!SESSION 2023-09-21 10:32:03.159 -----------------------------------------------
eclipse.buildId=4.14.1.202204250734
java.version=17.0.2
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.springframework.boot.ide.branding.sts4
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.springframework.boot.ide.branding.sts4

This is a continuation of log file D:\DaydropDEV\.metadata\.bak_8.log
Created Time: 2023-09-21 15:33:55.621

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-09-21 15:33:55.623
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-09-21 15:33:55.625
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-21 15:33:56.416
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.xyram.daydrop.serviceimpl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.transaction.Transactional;

import org.apache.commons.collections4.map.HashedMap;
import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.server.ResponseStatusException;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.xyram.daydrop.admin.model.CurrentUser;
import com.xyram.daydrop.basemodel.Base64Wrapper;
import com.xyram.daydrop.basemodel.MerchantTransactionIdGenerator;
import com.xyram.daydrop.basemodel.PhonepeSerializer;
import com.xyram.daydrop.dao.ApartmentDao;
import com.xyram.daydrop.dao.CustomerDetailsDao;
import com.xyram.daydrop.dao.CustomerOrderDao;
import com.xyram.daydrop.dao.CustomerOrderReplicaDoa;
import com.xyram.daydrop.dao.SheduleDao;
import com.xyram.daydrop.enumtypes.UserStatus;
import com.xyram.daydrop.model.Apartments;
import com.xyram.daydrop.model.CustomerOrder;
import com.xyram.daydrop.model.CustomerOrderReplica;
import com.xyram.daydrop.model.Customers;
import com.xyram.daydrop.model.Schedule;
import com.xyram.daydrop.modelMapper.PaymentInstrument;
import com.xyram.daydrop.modelMapper.PhonePePayModel;
import com.xyram.daydrop.request.CustomerOrderReplicaRequest;
import com.xyram.daydrop.response.RazorPayRequest;
import com.xyram.daydrop.service.CustomerOrderPriceService;
import com.xyram.daydrop.service.CustomerOrderReplicaService;
import com.xyram.daydrop.util.HashEncoder;
import com.xyram.daydrop.util.RazorPay;
import com.xyram.daydrop.service.ConsumerService;

@Transactional
@Service
public class CustomerOrderReplicaServiceImpl implements CustomerOrderReplicaService {

	@Autowired
	CustomerOrderReplicaDoa customerOrderReplicaDoa;

	@Autowired
	ApartmentDao apartmentDao;

	@Autowired
	SheduleDao scheduleDao;

	@Autowired
	CustomerDetailsDao customerDetailsDao;

	@Autowired
	ConsumerService consumerService;

	@Autowired
	CurrentUser currentUser;

	@Autowired
	PhonepeServiceImpl phonepeServiceImpl;

	@Value("${merchant_id}")
	private String merchantId;

	@Value("${salt_key}")
	private String saltKey;

	@Value("${salt_index}")
	private String saltIndex;

	@Override
	public Map createCustomerOrderReplicaService(CustomerOrderReplicaRequest customerOrderReplicaRequest,
			String contactNumber, Integer aparmentId)

	{

		Map response = new HashedMap<>();

		response.put("message", "success");
		CustomerOrderReplica customerOrderReplica = null;

		if (customerOrderReplicaRequest.getCartId() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "cartId is mandatory ");
		}
		long razorPayCount = 0;
		if (customerOrderReplicaRequest.getOrderId() != null) {

			razorPayCount = customerOrderReplicaDoa.getRazorPayExistByCartId(customerOrderReplicaRequest.getOrderId());
		}

		if (customerOrderReplicaRequest.getCustomerDetails() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Order Details  is mandatory ");
		}

		customerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(customerOrderReplicaRequest.getCartId(),
				contactNumber);

		if (customerOrderReplica != null) {
			customerOrderReplica.setCartId(customerOrderReplica.getCartId());

			if (customerOrderReplica.isOrdered()) {
				throw new ResponseStatusException(HttpStatus.CONFLICT, "Your Order is Placed With cart Details");
			}

//			if (razorPayCount >= 1 && !(customerOrderReplica.getRazorPayOrderId() != null
//					&& customerOrderReplica.getRazorPayOrderId().equals(customerOrderReplicaRequest.getOrderId()))) {
//				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
//			}

			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);

			customerOrderReplica.setAttempts(customerOrderReplica.getAttempts() + 1);
			customerOrderReplica.setUpdatedTime(new Date());

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		} else {

			customerOrderReplica = new CustomerOrderReplica();
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);
			customerOrderReplica.setCartId(customerOrderReplicaRequest.getCartId());
			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());

			if (razorPayCount > 0) {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
			}

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			Schedule schedule = scheduleDao.getlatestScheduleCustomers();

			if (schedule != null) {

				try {
					customerOrderReplica.setSchedule(schedule.getsId() != null ? schedule.getsId().toString() : null);
				} catch (Exception e) {
					e.printStackTrace();
				}
			} else {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
						"Sorry We Are Not Accepting Any Order Right now");

			}

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		}

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicas(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String schedule = null;

		Map filter = request.containsKey("filters") ? (Map) request.get("filters") : null;
		if (filter != null) {
			statusType = filter.containsKey("statusType") ? ((String) filter.get("statusType")).toLowerCase() : null;
			searchQuery = filter.containsKey("searchQuery") ? ((String) filter.get("searchQuery")).toLowerCase() : null;
			schedule = filter.containsKey("schedule") ? (String.valueOf(filter.get("schedule"))) : null;

		}

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplica(searchQuery, statusType, schedule);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");

				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setStreetName(
						customers.get("streetName") != null ? (String) customers.get("streetName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicasBySchedule(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String scheduleId = null;

		Schedule schedule = scheduleDao.getlatestScheduleCustomers();

		if (schedule != null) {

			try {
				scheduleId = schedule.getsId() != null ? schedule.getsId().toString() : null;
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

		statusType = request.containsKey("statusType") ? ((String) request.get("statusType")).toLowerCase() : "Success";

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplicaBySchdeule(statusType, scheduleId);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");
				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				System.out.println("customers" + customers.get("customerName"));

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public CustomerOrderReplica getCustomerOrderReplicaByCartId(String cartId) {

		CustomerOrderReplica CustomerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(cartId,
				currentUser.getContactNumber());

		ObjectMapper objectMapper = new ObjectMapper();
		try {

			// convert JSON string to Map
			Map<String, Object> customerOrderReplicaMap = objectMapper
					.readValue(CustomerOrderReplica.getCustomerOrderDetails(), Map.class);

			Object customerOrder = customerOrderReplicaMap.get("customerOrder");
			Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

			Object quanityList = items.get("quantity");
			Map customers = customerDetailsDao.getByContactNumberAndApartment(CustomerOrderReplica.getContactNumber(),
					CustomerOrderReplica.getApartmentId());

			System.out.println("customers" + customers.get("customerName"));

			// Apartments apartments =
			// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
			CustomerOrderReplica.setApartmentName(
					customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

			CustomerOrderReplica.setCustomerDetails(customers);

			CustomerOrderReplica.setCustomerOrder(customerOrder);
			CustomerOrderReplica.setQuatityList(quanityList);

		} catch (Exception e) {
			e.printStackTrace();
		}

		return CustomerOrderReplica;

	}

	@Override
	public Map createCustomerOrderReplica(CustomerOrderReplicaRequest customerOrderReplicaRequest, String contactNumber,
			Integer aparmentId) {

		if (customerOrderReplicaRequest.getRazorPayRequest() != null) {

//			Map razorPay = consumerService.createRazorPayOrder(customerOrderReplicaRequest.getRazorPayRequest());
//			customerOrderReplicaRequest.setOrderId(razorPay.get("order") != null ? (String)((RazorPay) razorPay.get("order")).getId() : null);	
//	
//			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);
//
//			razorPay.put("cartId", customerOrderReplicaRequest.getCartId());

			Map customerOrderReplicaMap = new HashMap<>();

			Map orderId = new HashMap<>();
			String transactionId = getMerchantTransactionId();
			orderId.put("id", transactionId);

			customerOrderReplicaMap.put("order", orderId);

			customerOrderReplicaRequest.setOrderId(transactionId);
			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);

			customerOrderReplicaMap.put("cartId", customerOrderReplicaRequest.getCartId());

			try {
				customerOrderReplicaMap.put("phonePeResponse",
						phonepeServiceImpl.initiatePhonepePayment(transactionId,
								Integer.valueOf(customerOrderReplicaRequest.getRazorPayRequest().getAmount()),
								contactNumber, customerOrderReplicaRequest.getRedirectUrl(), customerOrderReplicaRequest.getCallBackUrl()));

			} catch (Exception e) {
				e.printStackTrace();
				customerOrderReplicaMap.put("phonePeResponse", new HashedMap<>());
			}

			return customerOrderReplicaMap;

		} else {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
					"paymentDetails transcation Details are mandatory");
		}

	}

	private static String getMerchantTransactionId() {

		return "OD_" + MerchantTransactionIdGenerator.getRandomString();
	}


	@Override
	public List<CustomerOrderReplica> getCustomerOrderByMoblieNo(String contactNumber, Integer aid) {

	    Schedule latestSchedule = customerOrderReplicaDoa.getlatestschedule();

	    if (latestSchedule != null && latestSchedule.getCreationTimestamp() != null) {
	        if (latestSchedule.getStatus().equals(UserStatus.ACTIVE)) {
	            Customers customer = customerDetailsDao.getByContactNoAndApartment(contactNumber, aid);

	            if (customer != null) { // Ensure the customer exists
	                List<CustomerOrder> customerOrderList = customerOrderReplicaDoa.getListCustomerOrderByCustomerId(customer.getCtId());

	                double totalOrderAmount = 0.0;

	                if (customerOrderList != null && !customerOrderList.isEmpty()) {
	                    for (CustomerOrder customerOrder : customerOrderList) {
	                        Double orderAmount = customerOrder.getAmount();
	                        if (orderAmount != null) {
	                            totalOrderAmount += orderAmount;
	                            if(totalOrderAmount>200) {
	                            	totalOrderAmount+= customerOrder.getDelivaryCharges();
	                            }
	                            else(totalOrderAmount<200){
	                            	totalOrderAmount-= customerOrder.getDelivaryCharges();
	                            }
	                        }
	                    }

	                    // Define the minimum order amount for applying delivery charges
	                    double minimumOrderAmount = 200.0;

	                    if (totalOrderAmount < minimumOrderAmount) {
	                        System.out.println("Delivery Charges will be applicable");
	                    } else {
	                        // No delivery charges applicable
	                        System.out.println("No Delivery charges applicable");
	                    }

	                    List<CustomerOrderReplica> customerOrderReplicas = new ArrayList<>();
	                    return customerOrderReplicas;
	                } else {
	                    return Collections.emptyList();
	                }
	            } else {
	                return null; // or an appropriate value
	            }
	        } else {
	            // Handle the case when the latest schedule is not active
	            return null; // or an appropriate value
	        }
	    } else {
	        // Handle the case when there is no latest schedule or its creation timestamp is null
	        return null; // or an appropriate value
	    }
	}

}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1003)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:799)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:743)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:666)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:658)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.lambda$0(LSJavaHoverProvider.java:68)
	at java.base/java.util.concurrent.CompletableFuture$AsyncRun.run(CompletableFuture.java:1804)
	at java.base/java.util.concurrent.CompletableFuture$AsyncRun.exec(CompletableFuture.java:1796)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:373)
	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1182)
	at java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1655)
	at java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1622)
	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:165)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-09-21 15:33:56.418
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1003)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:799)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:743)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:666)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:658)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.lambda$0(LSJavaHoverProvider.java:68)
	at java.base/java.util.concurrent.CompletableFuture$AsyncRun.run(CompletableFuture.java:1804)
	at java.base/java.util.concurrent.CompletableFuture$AsyncRun.exec(CompletableFuture.java:1796)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:373)
	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1182)
	at java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1655)
	at java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1622)
	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:165)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-09-21 15:33:56.420
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1003)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:799)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:743)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:666)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:658)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.lambda$0(LSJavaHoverProvider.java:68)
	at java.base/java.util.concurrent.CompletableFuture$AsyncRun.run(CompletableFuture.java:1804)
	at java.base/java.util.concurrent.CompletableFuture$AsyncRun.exec(CompletableFuture.java:1796)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:373)
	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1182)
	at java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1655)
	at java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1622)
	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:165)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-21 15:33:56.510
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.xyram.daydrop.serviceimpl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.transaction.Transactional;

import org.apache.commons.collections4.map.HashedMap;
import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.server.ResponseStatusException;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.xyram.daydrop.admin.model.CurrentUser;
import com.xyram.daydrop.basemodel.Base64Wrapper;
import com.xyram.daydrop.basemodel.MerchantTransactionIdGenerator;
import com.xyram.daydrop.basemodel.PhonepeSerializer;
import com.xyram.daydrop.dao.ApartmentDao;
import com.xyram.daydrop.dao.CustomerDetailsDao;
import com.xyram.daydrop.dao.CustomerOrderDao;
import com.xyram.daydrop.dao.CustomerOrderReplicaDoa;
import com.xyram.daydrop.dao.SheduleDao;
import com.xyram.daydrop.enumtypes.UserStatus;
import com.xyram.daydrop.model.Apartments;
import com.xyram.daydrop.model.CustomerOrder;
import com.xyram.daydrop.model.CustomerOrderReplica;
import com.xyram.daydrop.model.Customers;
import com.xyram.daydrop.model.Schedule;
import com.xyram.daydrop.modelMapper.PaymentInstrument;
import com.xyram.daydrop.modelMapper.PhonePePayModel;
import com.xyram.daydrop.request.CustomerOrderReplicaRequest;
import com.xyram.daydrop.response.RazorPayRequest;
import com.xyram.daydrop.service.CustomerOrderPriceService;
import com.xyram.daydrop.service.CustomerOrderReplicaService;
import com.xyram.daydrop.util.HashEncoder;
import com.xyram.daydrop.util.RazorPay;
import com.xyram.daydrop.service.ConsumerService;

@Transactional
@Service
public class CustomerOrderReplicaServiceImpl implements CustomerOrderReplicaService {

	@Autowired
	CustomerOrderReplicaDoa customerOrderReplicaDoa;

	@Autowired
	ApartmentDao apartmentDao;

	@Autowired
	SheduleDao scheduleDao;

	@Autowired
	CustomerDetailsDao customerDetailsDao;

	@Autowired
	ConsumerService consumerService;

	@Autowired
	CurrentUser currentUser;

	@Autowired
	PhonepeServiceImpl phonepeServiceImpl;

	@Value("${merchant_id}")
	private String merchantId;

	@Value("${salt_key}")
	private String saltKey;

	@Value("${salt_index}")
	private String saltIndex;

	@Override
	public Map createCustomerOrderReplicaService(CustomerOrderReplicaRequest customerOrderReplicaRequest,
			String contactNumber, Integer aparmentId)

	{

		Map response = new HashedMap<>();

		response.put("message", "success");
		CustomerOrderReplica customerOrderReplica = null;

		if (customerOrderReplicaRequest.getCartId() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "cartId is mandatory ");
		}
		long razorPayCount = 0;
		if (customerOrderReplicaRequest.getOrderId() != null) {

			razorPayCount = customerOrderReplicaDoa.getRazorPayExistByCartId(customerOrderReplicaRequest.getOrderId());
		}

		if (customerOrderReplicaRequest.getCustomerDetails() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Order Details  is mandatory ");
		}

		customerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(customerOrderReplicaRequest.getCartId(),
				contactNumber);

		if (customerOrderReplica != null) {
			customerOrderReplica.setCartId(customerOrderReplica.getCartId());

			if (customerOrderReplica.isOrdered()) {
				throw new ResponseStatusException(HttpStatus.CONFLICT, "Your Order is Placed With cart Details");
			}

//			if (razorPayCount >= 1 && !(customerOrderReplica.getRazorPayOrderId() != null
//					&& customerOrderReplica.getRazorPayOrderId().equals(customerOrderReplicaRequest.getOrderId()))) {
//				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
//			}

			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);

			customerOrderReplica.setAttempts(customerOrderReplica.getAttempts() + 1);
			customerOrderReplica.setUpdatedTime(new Date());

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		} else {

			customerOrderReplica = new CustomerOrderReplica();
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);
			customerOrderReplica.setCartId(customerOrderReplicaRequest.getCartId());
			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());

			if (razorPayCount > 0) {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
			}

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			Schedule schedule = scheduleDao.getlatestScheduleCustomers();

			if (schedule != null) {

				try {
					customerOrderReplica.setSchedule(schedule.getsId() != null ? schedule.getsId().toString() : null);
				} catch (Exception e) {
					e.printStackTrace();
				}
			} else {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
						"Sorry We Are Not Accepting Any Order Right now");

			}

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		}

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicas(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String schedule = null;

		Map filter = request.containsKey("filters") ? (Map) request.get("filters") : null;
		if (filter != null) {
			statusType = filter.containsKey("statusType") ? ((String) filter.get("statusType")).toLowerCase() : null;
			searchQuery = filter.containsKey("searchQuery") ? ((String) filter.get("searchQuery")).toLowerCase() : null;
			schedule = filter.containsKey("schedule") ? (String.valueOf(filter.get("schedule"))) : null;

		}

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplica(searchQuery, statusType, schedule);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");

				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setStreetName(
						customers.get("streetName") != null ? (String) customers.get("streetName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicasBySchedule(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String scheduleId = null;

		Schedule schedule = scheduleDao.getlatestScheduleCustomers();

		if (schedule != null) {

			try {
				scheduleId = schedule.getsId() != null ? schedule.getsId().toString() : null;
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

		statusType = request.containsKey("statusType") ? ((String) request.get("statusType")).toLowerCase() : "Success";

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplicaBySchdeule(statusType, scheduleId);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");
				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				System.out.println("customers" + customers.get("customerName"));

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public CustomerOrderReplica getCustomerOrderReplicaByCartId(String cartId) {

		CustomerOrderReplica CustomerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(cartId,
				currentUser.getContactNumber());

		ObjectMapper objectMapper = new ObjectMapper();
		try {

			// convert JSON string to Map
			Map<String, Object> customerOrderReplicaMap = objectMapper
					.readValue(CustomerOrderReplica.getCustomerOrderDetails(), Map.class);

			Object customerOrder = customerOrderReplicaMap.get("customerOrder");
			Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

			Object quanityList = items.get("quantity");
			Map customers = customerDetailsDao.getByContactNumberAndApartment(CustomerOrderReplica.getContactNumber(),
					CustomerOrderReplica.getApartmentId());

			System.out.println("customers" + customers.get("customerName"));

			// Apartments apartments =
			// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
			CustomerOrderReplica.setApartmentName(
					customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

			CustomerOrderReplica.setCustomerDetails(customers);

			CustomerOrderReplica.setCustomerOrder(customerOrder);
			CustomerOrderReplica.setQuatityList(quanityList);

		} catch (Exception e) {
			e.printStackTrace();
		}

		return CustomerOrderReplica;

	}

	@Override
	public Map createCustomerOrderReplica(CustomerOrderReplicaRequest customerOrderReplicaRequest, String contactNumber,
			Integer aparmentId) {

		if (customerOrderReplicaRequest.getRazorPayRequest() != null) {

//			Map razorPay = consumerService.createRazorPayOrder(customerOrderReplicaRequest.getRazorPayRequest());
//			customerOrderReplicaRequest.setOrderId(razorPay.get("order") != null ? (String)((RazorPay) razorPay.get("order")).getId() : null);	
//	
//			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);
//
//			razorPay.put("cartId", customerOrderReplicaRequest.getCartId());

			Map customerOrderReplicaMap = new HashMap<>();

			Map orderId = new HashMap<>();
			String transactionId = getMerchantTransactionId();
			orderId.put("id", transactionId);

			customerOrderReplicaMap.put("order", orderId);

			customerOrderReplicaRequest.setOrderId(transactionId);
			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);

			customerOrderReplicaMap.put("cartId", customerOrderReplicaRequest.getCartId());

			try {
				customerOrderReplicaMap.put("phonePeResponse",
						phonepeServiceImpl.initiatePhonepePayment(transactionId,
								Integer.valueOf(customerOrderReplicaRequest.getRazorPayRequest().getAmount()),
								contactNumber, customerOrderReplicaRequest.getRedirectUrl(), customerOrderReplicaRequest.getCallBackUrl()));

			} catch (Exception e) {
				e.printStackTrace();
				customerOrderReplicaMap.put("phonePeResponse", new HashedMap<>());
			}

			return customerOrderReplicaMap;

		} else {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
					"paymentDetails transcation Details are mandatory");
		}

	}

	private static String getMerchantTransactionId() {

		return "OD_" + MerchantTransactionIdGenerator.getRandomString();
	}


	@Override
	public List<CustomerOrderReplica> getCustomerOrderByMoblieNo(String contactNumber, Integer aid) {

	    Schedule latestSchedule = customerOrderReplicaDoa.getlatestschedule();

	    if (latestSchedule != null && latestSchedule.getCreationTimestamp() != null) {
	        if (latestSchedule.getStatus().equals(UserStatus.ACTIVE)) {
	            Customers customer = customerDetailsDao.getByContactNoAndApartment(contactNumber, aid);

	            if (customer != null) { // Ensure the customer exists
	                List<CustomerOrder> customerOrderList = customerOrderReplicaDoa.getListCustomerOrderByCustomerId(customer.getCtId());

	                double totalOrderAmount = 0.0;

	                if (customerOrderList != null && !customerOrderList.isEmpty()) {
	                    for (CustomerOrder customerOrder : customerOrderList) {
	                        Double orderAmount = customerOrder.getAmount();
	                        if (orderAmount != null) {
	                            totalOrderAmount += orderAmount;
	                            if(totalOrderAmount>200) {
	                            	totalOrderAmount+= customerOrder.getDelivaryCharges();
	                            }
	                            else(totalOrderAmount<200){
	                            	totalOrderAmount-= customerOrder.getDelivaryCharges();
	                            }
	                        }
	                    }

	                    // Define the minimum order amount for applying delivery charges
	                    double minimumOrderAmount = 200.0;

	                    if (totalOrderAmount < minimumOrderAmount) {
	                        System.out.println("Delivery Charges will be applicable");
	                    } else {
	                        // No delivery charges applicable
	                        System.out.println("No Delivery charges applicable");
	                    }

	                    List<CustomerOrderReplica> customerOrderReplicas = new ArrayList<>();
	                    return customerOrderReplicas;
	                } else {
	                    return Collections.emptyList();
	                }
	            } else {
	                return null; // or an appropriate value
	            }
	        } else {
	            // Handle the case when the latest schedule is not active
	            return null; // or an appropriate value
	        }
	    } else {
	        // Handle the case when there is no latest schedule or its creation timestamp is null
	        return null; // or an appropriate value
	    }
	}

}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4035)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3635)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-09-21 15:33:56.512
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4035)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3635)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-09-21 15:33:56.513
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4035)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3635)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-21 15:33:56.568
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.xyram.daydrop.serviceimpl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.transaction.Transactional;

import org.apache.commons.collections4.map.HashedMap;
import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.server.ResponseStatusException;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.xyram.daydrop.admin.model.CurrentUser;
import com.xyram.daydrop.basemodel.Base64Wrapper;
import com.xyram.daydrop.basemodel.MerchantTransactionIdGenerator;
import com.xyram.daydrop.basemodel.PhonepeSerializer;
import com.xyram.daydrop.dao.ApartmentDao;
import com.xyram.daydrop.dao.CustomerDetailsDao;
import com.xyram.daydrop.dao.CustomerOrderDao;
import com.xyram.daydrop.dao.CustomerOrderReplicaDoa;
import com.xyram.daydrop.dao.SheduleDao;
import com.xyram.daydrop.enumtypes.UserStatus;
import com.xyram.daydrop.model.Apartments;
import com.xyram.daydrop.model.CustomerOrder;
import com.xyram.daydrop.model.CustomerOrderReplica;
import com.xyram.daydrop.model.Customers;
import com.xyram.daydrop.model.Schedule;
import com.xyram.daydrop.modelMapper.PaymentInstrument;
import com.xyram.daydrop.modelMapper.PhonePePayModel;
import com.xyram.daydrop.request.CustomerOrderReplicaRequest;
import com.xyram.daydrop.response.RazorPayRequest;
import com.xyram.daydrop.service.CustomerOrderPriceService;
import com.xyram.daydrop.service.CustomerOrderReplicaService;
import com.xyram.daydrop.util.HashEncoder;
import com.xyram.daydrop.util.RazorPay;
import com.xyram.daydrop.service.ConsumerService;

@Transactional
@Service
public class CustomerOrderReplicaServiceImpl implements CustomerOrderReplicaService {

	@Autowired
	CustomerOrderReplicaDoa customerOrderReplicaDoa;

	@Autowired
	ApartmentDao apartmentDao;

	@Autowired
	SheduleDao scheduleDao;

	@Autowired
	CustomerDetailsDao customerDetailsDao;

	@Autowired
	ConsumerService consumerService;

	@Autowired
	CurrentUser currentUser;

	@Autowired
	PhonepeServiceImpl phonepeServiceImpl;

	@Value("${merchant_id}")
	private String merchantId;

	@Value("${salt_key}")
	private String saltKey;

	@Value("${salt_index}")
	private String saltIndex;

	@Override
	public Map createCustomerOrderReplicaService(CustomerOrderReplicaRequest customerOrderReplicaRequest,
			String contactNumber, Integer aparmentId)

	{

		Map response = new HashedMap<>();

		response.put("message", "success");
		CustomerOrderReplica customerOrderReplica = null;

		if (customerOrderReplicaRequest.getCartId() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "cartId is mandatory ");
		}
		long razorPayCount = 0;
		if (customerOrderReplicaRequest.getOrderId() != null) {

			razorPayCount = customerOrderReplicaDoa.getRazorPayExistByCartId(customerOrderReplicaRequest.getOrderId());
		}

		if (customerOrderReplicaRequest.getCustomerDetails() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Order Details  is mandatory ");
		}

		customerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(customerOrderReplicaRequest.getCartId(),
				contactNumber);

		if (customerOrderReplica != null) {
			customerOrderReplica.setCartId(customerOrderReplica.getCartId());

			if (customerOrderReplica.isOrdered()) {
				throw new ResponseStatusException(HttpStatus.CONFLICT, "Your Order is Placed With cart Details");
			}

//			if (razorPayCount >= 1 && !(customerOrderReplica.getRazorPayOrderId() != null
//					&& customerOrderReplica.getRazorPayOrderId().equals(customerOrderReplicaRequest.getOrderId()))) {
//				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
//			}

			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);

			customerOrderReplica.setAttempts(customerOrderReplica.getAttempts() + 1);
			customerOrderReplica.setUpdatedTime(new Date());

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		} else {

			customerOrderReplica = new CustomerOrderReplica();
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);
			customerOrderReplica.setCartId(customerOrderReplicaRequest.getCartId());
			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());

			if (razorPayCount > 0) {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
			}

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			Schedule schedule = scheduleDao.getlatestScheduleCustomers();

			if (schedule != null) {

				try {
					customerOrderReplica.setSchedule(schedule.getsId() != null ? schedule.getsId().toString() : null);
				} catch (Exception e) {
					e.printStackTrace();
				}
			} else {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
						"Sorry We Are Not Accepting Any Order Right now");

			}

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		}

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicas(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String schedule = null;

		Map filter = request.containsKey("filters") ? (Map) request.get("filters") : null;
		if (filter != null) {
			statusType = filter.containsKey("statusType") ? ((String) filter.get("statusType")).toLowerCase() : null;
			searchQuery = filter.containsKey("searchQuery") ? ((String) filter.get("searchQuery")).toLowerCase() : null;
			schedule = filter.containsKey("schedule") ? (String.valueOf(filter.get("schedule"))) : null;

		}

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplica(searchQuery, statusType, schedule);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");

				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setStreetName(
						customers.get("streetName") != null ? (String) customers.get("streetName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicasBySchedule(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String scheduleId = null;

		Schedule schedule = scheduleDao.getlatestScheduleCustomers();

		if (schedule != null) {

			try {
				scheduleId = schedule.getsId() != null ? schedule.getsId().toString() : null;
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

		statusType = request.containsKey("statusType") ? ((String) request.get("statusType")).toLowerCase() : "Success";

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplicaBySchdeule(statusType, scheduleId);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");
				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				System.out.println("customers" + customers.get("customerName"));

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public CustomerOrderReplica getCustomerOrderReplicaByCartId(String cartId) {

		CustomerOrderReplica CustomerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(cartId,
				currentUser.getContactNumber());

		ObjectMapper objectMapper = new ObjectMapper();
		try {

			// convert JSON string to Map
			Map<String, Object> customerOrderReplicaMap = objectMapper
					.readValue(CustomerOrderReplica.getCustomerOrderDetails(), Map.class);

			Object customerOrder = customerOrderReplicaMap.get("customerOrder");
			Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

			Object quanityList = items.get("quantity");
			Map customers = customerDetailsDao.getByContactNumberAndApartment(CustomerOrderReplica.getContactNumber(),
					CustomerOrderReplica.getApartmentId());

			System.out.println("customers" + customers.get("customerName"));

			// Apartments apartments =
			// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
			CustomerOrderReplica.setApartmentName(
					customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

			CustomerOrderReplica.setCustomerDetails(customers);

			CustomerOrderReplica.setCustomerOrder(customerOrder);
			CustomerOrderReplica.setQuatityList(quanityList);

		} catch (Exception e) {
			e.printStackTrace();
		}

		return CustomerOrderReplica;

	}

	@Override
	public Map createCustomerOrderReplica(CustomerOrderReplicaRequest customerOrderReplicaRequest, String contactNumber,
			Integer aparmentId) {

		if (customerOrderReplicaRequest.getRazorPayRequest() != null) {

//			Map razorPay = consumerService.createRazorPayOrder(customerOrderReplicaRequest.getRazorPayRequest());
//			customerOrderReplicaRequest.setOrderId(razorPay.get("order") != null ? (String)((RazorPay) razorPay.get("order")).getId() : null);	
//	
//			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);
//
//			razorPay.put("cartId", customerOrderReplicaRequest.getCartId());

			Map customerOrderReplicaMap = new HashMap<>();

			Map orderId = new HashMap<>();
			String transactionId = getMerchantTransactionId();
			orderId.put("id", transactionId);

			customerOrderReplicaMap.put("order", orderId);

			customerOrderReplicaRequest.setOrderId(transactionId);
			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);

			customerOrderReplicaMap.put("cartId", customerOrderReplicaRequest.getCartId());

			try {
				customerOrderReplicaMap.put("phonePeResponse",
						phonepeServiceImpl.initiatePhonepePayment(transactionId,
								Integer.valueOf(customerOrderReplicaRequest.getRazorPayRequest().getAmount()),
								contactNumber, customerOrderReplicaRequest.getRedirectUrl(), customerOrderReplicaRequest.getCallBackUrl()));

			} catch (Exception e) {
				e.printStackTrace();
				customerOrderReplicaMap.put("phonePeResponse", new HashedMap<>());
			}

			return customerOrderReplicaMap;

		} else {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
					"paymentDetails transcation Details are mandatory");
		}

	}

	private static String getMerchantTransactionId() {

		return "OD_" + MerchantTransactionIdGenerator.getRandomString();
	}


	@Override
	public List<CustomerOrderReplica> getCustomerOrderByMoblieNo(String contactNumber, Integer aid) {

	    Schedule latestSchedule = customerOrderReplicaDoa.getlatestschedule();

	    if (latestSchedule != null && latestSchedule.getCreationTimestamp() != null) {
	        if (latestSchedule.getStatus().equals(UserStatus.ACTIVE)) {
	            Customers customer = customerDetailsDao.getByContactNoAndApartment(contactNumber, aid);

	            if (customer != null) { // Ensure the customer exists
	                List<CustomerOrder> customerOrderList = customerOrderReplicaDoa.getListCustomerOrderByCustomerId(customer.getCtId());

	                double totalOrderAmount = 0.0;

	                if (customerOrderList != null && !customerOrderList.isEmpty()) {
	                    for (CustomerOrder customerOrder : customerOrderList) {
	                        Double orderAmount = customerOrder.getAmount();
	                        if (orderAmount != null) {
	                            totalOrderAmount += orderAmount;
	                            if(totalOrderAmount>200) {
	                            	totalOrderAmount+= customerOrder.getDelivaryCharges();
	                            }
	                            else(totalOrderAmount<200){
	                            	totalOrderAmount-= customerOrder.getDelivaryCharges();
	                            }
	                        }
	                    }

	                    // Define the minimum order amount for applying delivery charges
	                    double minimumOrderAmount = 200.0;

	                    if (totalOrderAmount < minimumOrderAmount) {
	                        System.out.println("Delivery Charges will be applicable");
	                    } else {
	                        // No delivery charges applicable
	                        System.out.println("No Delivery charges applicable");
	                    }

	                    List<CustomerOrderReplica> customerOrderReplicas = new ArrayList<>();
	                    return customerOrderReplicas;
	                } else {
	                    return Collections.emptyList();
	                }
	            } else {
	                return null; // or an appropriate value
	            }
	        } else {
	            // Handle the case when the latest schedule is not active
	            return null; // or an appropriate value
	        }
	    } else {
	        // Handle the case when there is no latest schedule or its creation timestamp is null
	        return null; // or an appropriate value
	    }
	}

}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.internal.core.manipulation.dom.ASTResolving.createQuickFixAST(ASTResolving.java:1052)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:131)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4035)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3635)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.ui 4 0 2023-09-21 15:33:56.570
!MESSAGE Unhandled event loop exception
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.internal.core.manipulation.dom.ASTResolving.createQuickFixAST(ASTResolving.java:1052)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:131)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4035)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3635)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-21 15:33:58.877
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.xyram.daydrop.serviceimpl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.transaction.Transactional;

import org.apache.commons.collections4.map.HashedMap;
import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.server.ResponseStatusException;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.xyram.daydrop.admin.model.CurrentUser;
import com.xyram.daydrop.basemodel.Base64Wrapper;
import com.xyram.daydrop.basemodel.MerchantTransactionIdGenerator;
import com.xyram.daydrop.basemodel.PhonepeSerializer;
import com.xyram.daydrop.dao.ApartmentDao;
import com.xyram.daydrop.dao.CustomerDetailsDao;
import com.xyram.daydrop.dao.CustomerOrderDao;
import com.xyram.daydrop.dao.CustomerOrderReplicaDoa;
import com.xyram.daydrop.dao.SheduleDao;
import com.xyram.daydrop.enumtypes.UserStatus;
import com.xyram.daydrop.model.Apartments;
import com.xyram.daydrop.model.CustomerOrder;
import com.xyram.daydrop.model.CustomerOrderReplica;
import com.xyram.daydrop.model.Customers;
import com.xyram.daydrop.model.Schedule;
import com.xyram.daydrop.modelMapper.PaymentInstrument;
import com.xyram.daydrop.modelMapper.PhonePePayModel;
import com.xyram.daydrop.request.CustomerOrderReplicaRequest;
import com.xyram.daydrop.response.RazorPayRequest;
import com.xyram.daydrop.service.CustomerOrderPriceService;
import com.xyram.daydrop.service.CustomerOrderReplicaService;
import com.xyram.daydrop.util.HashEncoder;
import com.xyram.daydrop.util.RazorPay;
import com.xyram.daydrop.service.ConsumerService;

@Transactional
@Service
public class CustomerOrderReplicaServiceImpl implements CustomerOrderReplicaService {

	@Autowired
	CustomerOrderReplicaDoa customerOrderReplicaDoa;

	@Autowired
	ApartmentDao apartmentDao;

	@Autowired
	SheduleDao scheduleDao;

	@Autowired
	CustomerDetailsDao customerDetailsDao;

	@Autowired
	ConsumerService consumerService;

	@Autowired
	CurrentUser currentUser;

	@Autowired
	PhonepeServiceImpl phonepeServiceImpl;

	@Value("${merchant_id}")
	private String merchantId;

	@Value("${salt_key}")
	private String saltKey;

	@Value("${salt_index}")
	private String saltIndex;

	@Override
	public Map createCustomerOrderReplicaService(CustomerOrderReplicaRequest customerOrderReplicaRequest,
			String contactNumber, Integer aparmentId)

	{

		Map response = new HashedMap<>();

		response.put("message", "success");
		CustomerOrderReplica customerOrderReplica = null;

		if (customerOrderReplicaRequest.getCartId() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "cartId is mandatory ");
		}
		long razorPayCount = 0;
		if (customerOrderReplicaRequest.getOrderId() != null) {

			razorPayCount = customerOrderReplicaDoa.getRazorPayExistByCartId(customerOrderReplicaRequest.getOrderId());
		}

		if (customerOrderReplicaRequest.getCustomerDetails() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Order Details  is mandatory ");
		}

		customerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(customerOrderReplicaRequest.getCartId(),
				contactNumber);

		if (customerOrderReplica != null) {
			customerOrderReplica.setCartId(customerOrderReplica.getCartId());

			if (customerOrderReplica.isOrdered()) {
				throw new ResponseStatusException(HttpStatus.CONFLICT, "Your Order is Placed With cart Details");
			}

//			if (razorPayCount >= 1 && !(customerOrderReplica.getRazorPayOrderId() != null
//					&& customerOrderReplica.getRazorPayOrderId().equals(customerOrderReplicaRequest.getOrderId()))) {
//				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
//			}

			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);

			customerOrderReplica.setAttempts(customerOrderReplica.getAttempts() + 1);
			customerOrderReplica.setUpdatedTime(new Date());

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		} else {

			customerOrderReplica = new CustomerOrderReplica();
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);
			customerOrderReplica.setCartId(customerOrderReplicaRequest.getCartId());
			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());

			if (razorPayCount > 0) {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
			}

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			Schedule schedule = scheduleDao.getlatestScheduleCustomers();

			if (schedule != null) {

				try {
					customerOrderReplica.setSchedule(schedule.getsId() != null ? schedule.getsId().toString() : null);
				} catch (Exception e) {
					e.printStackTrace();
				}
			} else {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
						"Sorry We Are Not Accepting Any Order Right now");

			}

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		}

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicas(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String schedule = null;

		Map filter = request.containsKey("filters") ? (Map) request.get("filters") : null;
		if (filter != null) {
			statusType = filter.containsKey("statusType") ? ((String) filter.get("statusType")).toLowerCase() : null;
			searchQuery = filter.containsKey("searchQuery") ? ((String) filter.get("searchQuery")).toLowerCase() : null;
			schedule = filter.containsKey("schedule") ? (String.valueOf(filter.get("schedule"))) : null;

		}

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplica(searchQuery, statusType, schedule);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");

				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setStreetName(
						customers.get("streetName") != null ? (String) customers.get("streetName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicasBySchedule(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String scheduleId = null;

		Schedule schedule = scheduleDao.getlatestScheduleCustomers();

		if (schedule != null) {

			try {
				scheduleId = schedule.getsId() != null ? schedule.getsId().toString() : null;
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

		statusType = request.containsKey("statusType") ? ((String) request.get("statusType")).toLowerCase() : "Success";

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplicaBySchdeule(statusType, scheduleId);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");
				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				System.out.println("customers" + customers.get("customerName"));

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public CustomerOrderReplica getCustomerOrderReplicaByCartId(String cartId) {

		CustomerOrderReplica CustomerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(cartId,
				currentUser.getContactNumber());

		ObjectMapper objectMapper = new ObjectMapper();
		try {

			// convert JSON string to Map
			Map<String, Object> customerOrderReplicaMap = objectMapper
					.readValue(CustomerOrderReplica.getCustomerOrderDetails(), Map.class);

			Object customerOrder = customerOrderReplicaMap.get("customerOrder");
			Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

			Object quanityList = items.get("quantity");
			Map customers = customerDetailsDao.getByContactNumberAndApartment(CustomerOrderReplica.getContactNumber(),
					CustomerOrderReplica.getApartmentId());

			System.out.println("customers" + customers.get("customerName"));

			// Apartments apartments =
			// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
			CustomerOrderReplica.setApartmentName(
					customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

			CustomerOrderReplica.setCustomerDetails(customers);

			CustomerOrderReplica.setCustomerOrder(customerOrder);
			CustomerOrderReplica.setQuatityList(quanityList);

		} catch (Exception e) {
			e.printStackTrace();
		}

		return CustomerOrderReplica;

	}

	@Override
	public Map createCustomerOrderReplica(CustomerOrderReplicaRequest customerOrderReplicaRequest, String contactNumber,
			Integer aparmentId) {

		if (customerOrderReplicaRequest.getRazorPayRequest() != null) {

//			Map razorPay = consumerService.createRazorPayOrder(customerOrderReplicaRequest.getRazorPayRequest());
//			customerOrderReplicaRequest.setOrderId(razorPay.get("order") != null ? (String)((RazorPay) razorPay.get("order")).getId() : null);	
//	
//			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);
//
//			razorPay.put("cartId", customerOrderReplicaRequest.getCartId());

			Map customerOrderReplicaMap = new HashMap<>();

			Map orderId = new HashMap<>();
			String transactionId = getMerchantTransactionId();
			orderId.put("id", transactionId);

			customerOrderReplicaMap.put("order", orderId);

			customerOrderReplicaRequest.setOrderId(transactionId);
			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);

			customerOrderReplicaMap.put("cartId", customerOrderReplicaRequest.getCartId());

			try {
				customerOrderReplicaMap.put("phonePeResponse",
						phonepeServiceImpl.initiatePhonepePayment(transactionId,
								Integer.valueOf(customerOrderReplicaRequest.getRazorPayRequest().getAmount()),
								contactNumber, customerOrderReplicaRequest.getRedirectUrl(), customerOrderReplicaRequest.getCallBackUrl()));

			} catch (Exception e) {
				e.printStackTrace();
				customerOrderReplicaMap.put("phonePeResponse", new HashedMap<>());
			}

			return customerOrderReplicaMap;

		} else {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
					"paymentDetails transcation Details are mandatory");
		}

	}

	private static String getMerchantTransactionId() {

		return "OD_" + MerchantTransactionIdGenerator.getRandomString();
	}


	@Override
	public List<CustomerOrderReplica> getCustomerOrderByMoblieNo(String contactNumber, Integer aid) {

	    Schedule latestSchedule = customerOrderReplicaDoa.getlatestschedule();

	    if (latestSchedule != null && latestSchedule.getCreationTimestamp() != null) {
	        if (latestSchedule.getStatus().equals(UserStatus.ACTIVE)) {
	            Customers customer = customerDetailsDao.getByContactNoAndApartment(contactNumber, aid);

	            if (customer != null) { // Ensure the customer exists
	                List<CustomerOrder> customerOrderList = customerOrderReplicaDoa.getListCustomerOrderByCustomerId(customer.getCtId());

	                double totalOrderAmount = 0.0;

	                if (customerOrderList != null && !customerOrderList.isEmpty()) {
	                    for (CustomerOrder customerOrder : customerOrderList) {
	                        Double orderAmount = customerOrder.getAmount();
	                        if (orderAmount != null) {
	                            totalOrderAmount += orderAmount;
	                            if(totalOrderAmount>200) {
	                            	totalOrderAmount+= customerOrder.getDelivaryCharges();
	                            }
	                            else(totalOrderAmount<200){
	                            	totalOrderAmount-= customerOrder.getDelivaryCharges();
	                            
	                        }
	                    }

	                    // Define the minimum order amount for applying delivery charges
	                    double minimumOrderAmount = 200.0;

	                    if (totalOrderAmount < minimumOrderAmount) {
	                        System.out.println("Delivery Charges will be applicable");
	                    } else {
	                        // No delivery charges applicable
	                        System.out.println("No Delivery charges applicable");
	                    }

	                    List<CustomerOrderReplica> customerOrderReplicas = new ArrayList<>();
	                    return customerOrderReplicas;
	                } else {
	                    return Collections.emptyList();
	                }
	            } else {
	                return null; // or an appropriate value
	            }
	        } else {
	            // Handle the case when the latest schedule is not active
	            return null; // or an appropriate value
	        }
	    } else {
	        // Handle the case when there is no latest schedule or its creation timestamp is null
	        return null; // or an appropriate value
	    }
	}

}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-09-21 15:33:58.880
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-09-21 15:33:58.882
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-21 15:33:59.027
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.xyram.daydrop.serviceimpl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.transaction.Transactional;

import org.apache.commons.collections4.map.HashedMap;
import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.server.ResponseStatusException;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.xyram.daydrop.admin.model.CurrentUser;
import com.xyram.daydrop.basemodel.Base64Wrapper;
import com.xyram.daydrop.basemodel.MerchantTransactionIdGenerator;
import com.xyram.daydrop.basemodel.PhonepeSerializer;
import com.xyram.daydrop.dao.ApartmentDao;
import com.xyram.daydrop.dao.CustomerDetailsDao;
import com.xyram.daydrop.dao.CustomerOrderDao;
import com.xyram.daydrop.dao.CustomerOrderReplicaDoa;
import com.xyram.daydrop.dao.SheduleDao;
import com.xyram.daydrop.enumtypes.UserStatus;
import com.xyram.daydrop.model.Apartments;
import com.xyram.daydrop.model.CustomerOrder;
import com.xyram.daydrop.model.CustomerOrderReplica;
import com.xyram.daydrop.model.Customers;
import com.xyram.daydrop.model.Schedule;
import com.xyram.daydrop.modelMapper.PaymentInstrument;
import com.xyram.daydrop.modelMapper.PhonePePayModel;
import com.xyram.daydrop.request.CustomerOrderReplicaRequest;
import com.xyram.daydrop.response.RazorPayRequest;
import com.xyram.daydrop.service.CustomerOrderPriceService;
import com.xyram.daydrop.service.CustomerOrderReplicaService;
import com.xyram.daydrop.util.HashEncoder;
import com.xyram.daydrop.util.RazorPay;
import com.xyram.daydrop.service.ConsumerService;

@Transactional
@Service
public class CustomerOrderReplicaServiceImpl implements CustomerOrderReplicaService {

	@Autowired
	CustomerOrderReplicaDoa customerOrderReplicaDoa;

	@Autowired
	ApartmentDao apartmentDao;

	@Autowired
	SheduleDao scheduleDao;

	@Autowired
	CustomerDetailsDao customerDetailsDao;

	@Autowired
	ConsumerService consumerService;

	@Autowired
	CurrentUser currentUser;

	@Autowired
	PhonepeServiceImpl phonepeServiceImpl;

	@Value("${merchant_id}")
	private String merchantId;

	@Value("${salt_key}")
	private String saltKey;

	@Value("${salt_index}")
	private String saltIndex;

	@Override
	public Map createCustomerOrderReplicaService(CustomerOrderReplicaRequest customerOrderReplicaRequest,
			String contactNumber, Integer aparmentId)

	{

		Map response = new HashedMap<>();

		response.put("message", "success");
		CustomerOrderReplica customerOrderReplica = null;

		if (customerOrderReplicaRequest.getCartId() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "cartId is mandatory ");
		}
		long razorPayCount = 0;
		if (customerOrderReplicaRequest.getOrderId() != null) {

			razorPayCount = customerOrderReplicaDoa.getRazorPayExistByCartId(customerOrderReplicaRequest.getOrderId());
		}

		if (customerOrderReplicaRequest.getCustomerDetails() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Order Details  is mandatory ");
		}

		customerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(customerOrderReplicaRequest.getCartId(),
				contactNumber);

		if (customerOrderReplica != null) {
			customerOrderReplica.setCartId(customerOrderReplica.getCartId());

			if (customerOrderReplica.isOrdered()) {
				throw new ResponseStatusException(HttpStatus.CONFLICT, "Your Order is Placed With cart Details");
			}

//			if (razorPayCount >= 1 && !(customerOrderReplica.getRazorPayOrderId() != null
//					&& customerOrderReplica.getRazorPayOrderId().equals(customerOrderReplicaRequest.getOrderId()))) {
//				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
//			}

			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);

			customerOrderReplica.setAttempts(customerOrderReplica.getAttempts() + 1);
			customerOrderReplica.setUpdatedTime(new Date());

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		} else {

			customerOrderReplica = new CustomerOrderReplica();
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);
			customerOrderReplica.setCartId(customerOrderReplicaRequest.getCartId());
			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());

			if (razorPayCount > 0) {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
			}

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			Schedule schedule = scheduleDao.getlatestScheduleCustomers();

			if (schedule != null) {

				try {
					customerOrderReplica.setSchedule(schedule.getsId() != null ? schedule.getsId().toString() : null);
				} catch (Exception e) {
					e.printStackTrace();
				}
			} else {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
						"Sorry We Are Not Accepting Any Order Right now");

			}

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		}

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicas(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String schedule = null;

		Map filter = request.containsKey("filters") ? (Map) request.get("filters") : null;
		if (filter != null) {
			statusType = filter.containsKey("statusType") ? ((String) filter.get("statusType")).toLowerCase() : null;
			searchQuery = filter.containsKey("searchQuery") ? ((String) filter.get("searchQuery")).toLowerCase() : null;
			schedule = filter.containsKey("schedule") ? (String.valueOf(filter.get("schedule"))) : null;

		}

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplica(searchQuery, statusType, schedule);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");

				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setStreetName(
						customers.get("streetName") != null ? (String) customers.get("streetName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicasBySchedule(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String scheduleId = null;

		Schedule schedule = scheduleDao.getlatestScheduleCustomers();

		if (schedule != null) {

			try {
				scheduleId = schedule.getsId() != null ? schedule.getsId().toString() : null;
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

		statusType = request.containsKey("statusType") ? ((String) request.get("statusType")).toLowerCase() : "Success";

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplicaBySchdeule(statusType, scheduleId);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");
				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				System.out.println("customers" + customers.get("customerName"));

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public CustomerOrderReplica getCustomerOrderReplicaByCartId(String cartId) {

		CustomerOrderReplica CustomerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(cartId,
				currentUser.getContactNumber());

		ObjectMapper objectMapper = new ObjectMapper();
		try {

			// convert JSON string to Map
			Map<String, Object> customerOrderReplicaMap = objectMapper
					.readValue(CustomerOrderReplica.getCustomerOrderDetails(), Map.class);

			Object customerOrder = customerOrderReplicaMap.get("customerOrder");
			Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

			Object quanityList = items.get("quantity");
			Map customers = customerDetailsDao.getByContactNumberAndApartment(CustomerOrderReplica.getContactNumber(),
					CustomerOrderReplica.getApartmentId());

			System.out.println("customers" + customers.get("customerName"));

			// Apartments apartments =
			// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
			CustomerOrderReplica.setApartmentName(
					customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

			CustomerOrderReplica.setCustomerDetails(customers);

			CustomerOrderReplica.setCustomerOrder(customerOrder);
			CustomerOrderReplica.setQuatityList(quanityList);

		} catch (Exception e) {
			e.printStackTrace();
		}

		return CustomerOrderReplica;

	}

	@Override
	public Map createCustomerOrderReplica(CustomerOrderReplicaRequest customerOrderReplicaRequest, String contactNumber,
			Integer aparmentId) {

		if (customerOrderReplicaRequest.getRazorPayRequest() != null) {

//			Map razorPay = consumerService.createRazorPayOrder(customerOrderReplicaRequest.getRazorPayRequest());
//			customerOrderReplicaRequest.setOrderId(razorPay.get("order") != null ? (String)((RazorPay) razorPay.get("order")).getId() : null);	
//	
//			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);
//
//			razorPay.put("cartId", customerOrderReplicaRequest.getCartId());

			Map customerOrderReplicaMap = new HashMap<>();

			Map orderId = new HashMap<>();
			String transactionId = getMerchantTransactionId();
			orderId.put("id", transactionId);

			customerOrderReplicaMap.put("order", orderId);

			customerOrderReplicaRequest.setOrderId(transactionId);
			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);

			customerOrderReplicaMap.put("cartId", customerOrderReplicaRequest.getCartId());

			try {
				customerOrderReplicaMap.put("phonePeResponse",
						phonepeServiceImpl.initiatePhonepePayment(transactionId,
								Integer.valueOf(customerOrderReplicaRequest.getRazorPayRequest().getAmount()),
								contactNumber, customerOrderReplicaRequest.getRedirectUrl(), customerOrderReplicaRequest.getCallBackUrl()));

			} catch (Exception e) {
				e.printStackTrace();
				customerOrderReplicaMap.put("phonePeResponse", new HashedMap<>());
			}

			return customerOrderReplicaMap;

		} else {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
					"paymentDetails transcation Details are mandatory");
		}

	}

	private static String getMerchantTransactionId() {

		return "OD_" + MerchantTransactionIdGenerator.getRandomString();
	}


	@Override
	public List<CustomerOrderReplica> getCustomerOrderByMoblieNo(String contactNumber, Integer aid) {

	    Schedule latestSchedule = customerOrderReplicaDoa.getlatestschedule();

	    if (latestSchedule != null && latestSchedule.getCreationTimestamp() != null) {
	        if (latestSchedule.getStatus().equals(UserStatus.ACTIVE)) {
	            Customers customer = customerDetailsDao.getByContactNoAndApartment(contactNumber, aid);

	            if (customer != null) { // Ensure the customer exists
	                List<CustomerOrder> customerOrderList = customerOrderReplicaDoa.getListCustomerOrderByCustomerId(customer.getCtId());

	                double totalOrderAmount = 0.0;

	                if (customerOrderList != null && !customerOrderList.isEmpty()) {
	                    for (CustomerOrder customerOrder : customerOrderList) {
	                        Double orderAmount = customerOrder.getAmount();
	                        if (orderAmount != null) {
	                            totalOrderAmount += orderAmount;
	                            if(totalOrderAmount>200) {
	                            	totalOrderAmount+= customerOrder.getDelivaryCharges();
	                            }
	                            else(totalOrderAmount<200){
	                            	totalOrderAmount-= customerOrder.getDelivaryCharges();
	                            
	                        }
	                    }

	                    // Define the minimum order amount for applying delivery charges
	                    double minimumOrderAmount = 200.0;

	                    if (totalOrderAmount < minimumOrderAmount) {
	                        System.out.println("Delivery Charges will be applicable");
	                    } else {
	                        // No delivery charges applicable
	                        System.out.println("No Delivery charges applicable");
	                    }

	                    List<CustomerOrderReplica> customerOrderReplicas = new ArrayList<>();
	                    return customerOrderReplicas;
	                } else {
	                    return Collections.emptyList();
	                }
	            } else {
	                return null; // or an appropriate value
	            }
	        } else {
	            // Handle the case when the latest schedule is not active
	            return null; // or an appropriate value
	        }
	    } else {
	        // Handle the case when there is no latest schedule or its creation timestamp is null
	        return null; // or an appropriate value
	    }
	}

}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-09-21 15:33:59.030
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-09-21 15:33:59.033
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-21 15:34:00.979
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.xyram.daydrop.serviceimpl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.transaction.Transactional;

import org.apache.commons.collections4.map.HashedMap;
import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.server.ResponseStatusException;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.xyram.daydrop.admin.model.CurrentUser;
import com.xyram.daydrop.basemodel.Base64Wrapper;
import com.xyram.daydrop.basemodel.MerchantTransactionIdGenerator;
import com.xyram.daydrop.basemodel.PhonepeSerializer;
import com.xyram.daydrop.dao.ApartmentDao;
import com.xyram.daydrop.dao.CustomerDetailsDao;
import com.xyram.daydrop.dao.CustomerOrderDao;
import com.xyram.daydrop.dao.CustomerOrderReplicaDoa;
import com.xyram.daydrop.dao.SheduleDao;
import com.xyram.daydrop.enumtypes.UserStatus;
import com.xyram.daydrop.model.Apartments;
import com.xyram.daydrop.model.CustomerOrder;
import com.xyram.daydrop.model.CustomerOrderReplica;
import com.xyram.daydrop.model.Customers;
import com.xyram.daydrop.model.Schedule;
import com.xyram.daydrop.modelMapper.PaymentInstrument;
import com.xyram.daydrop.modelMapper.PhonePePayModel;
import com.xyram.daydrop.request.CustomerOrderReplicaRequest;
import com.xyram.daydrop.response.RazorPayRequest;
import com.xyram.daydrop.service.CustomerOrderPriceService;
import com.xyram.daydrop.service.CustomerOrderReplicaService;
import com.xyram.daydrop.util.HashEncoder;
import com.xyram.daydrop.util.RazorPay;
import com.xyram.daydrop.service.ConsumerService;

@Transactional
@Service
public class CustomerOrderReplicaServiceImpl implements CustomerOrderReplicaService {

	@Autowired
	CustomerOrderReplicaDoa customerOrderReplicaDoa;

	@Autowired
	ApartmentDao apartmentDao;

	@Autowired
	SheduleDao scheduleDao;

	@Autowired
	CustomerDetailsDao customerDetailsDao;

	@Autowired
	ConsumerService consumerService;

	@Autowired
	CurrentUser currentUser;

	@Autowired
	PhonepeServiceImpl phonepeServiceImpl;

	@Value("${merchant_id}")
	private String merchantId;

	@Value("${salt_key}")
	private String saltKey;

	@Value("${salt_index}")
	private String saltIndex;

	@Override
	public Map createCustomerOrderReplicaService(CustomerOrderReplicaRequest customerOrderReplicaRequest,
			String contactNumber, Integer aparmentId)

	{

		Map response = new HashedMap<>();

		response.put("message", "success");
		CustomerOrderReplica customerOrderReplica = null;

		if (customerOrderReplicaRequest.getCartId() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "cartId is mandatory ");
		}
		long razorPayCount = 0;
		if (customerOrderReplicaRequest.getOrderId() != null) {

			razorPayCount = customerOrderReplicaDoa.getRazorPayExistByCartId(customerOrderReplicaRequest.getOrderId());
		}

		if (customerOrderReplicaRequest.getCustomerDetails() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Order Details  is mandatory ");
		}

		customerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(customerOrderReplicaRequest.getCartId(),
				contactNumber);

		if (customerOrderReplica != null) {
			customerOrderReplica.setCartId(customerOrderReplica.getCartId());

			if (customerOrderReplica.isOrdered()) {
				throw new ResponseStatusException(HttpStatus.CONFLICT, "Your Order is Placed With cart Details");
			}

//			if (razorPayCount >= 1 && !(customerOrderReplica.getRazorPayOrderId() != null
//					&& customerOrderReplica.getRazorPayOrderId().equals(customerOrderReplicaRequest.getOrderId()))) {
//				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
//			}

			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);

			customerOrderReplica.setAttempts(customerOrderReplica.getAttempts() + 1);
			customerOrderReplica.setUpdatedTime(new Date());

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		} else {

			customerOrderReplica = new CustomerOrderReplica();
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);
			customerOrderReplica.setCartId(customerOrderReplicaRequest.getCartId());
			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());

			if (razorPayCount > 0) {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
			}

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			Schedule schedule = scheduleDao.getlatestScheduleCustomers();

			if (schedule != null) {

				try {
					customerOrderReplica.setSchedule(schedule.getsId() != null ? schedule.getsId().toString() : null);
				} catch (Exception e) {
					e.printStackTrace();
				}
			} else {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
						"Sorry We Are Not Accepting Any Order Right now");

			}

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		}

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicas(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String schedule = null;

		Map filter = request.containsKey("filters") ? (Map) request.get("filters") : null;
		if (filter != null) {
			statusType = filter.containsKey("statusType") ? ((String) filter.get("statusType")).toLowerCase() : null;
			searchQuery = filter.containsKey("searchQuery") ? ((String) filter.get("searchQuery")).toLowerCase() : null;
			schedule = filter.containsKey("schedule") ? (String.valueOf(filter.get("schedule"))) : null;

		}

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplica(searchQuery, statusType, schedule);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");

				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setStreetName(
						customers.get("streetName") != null ? (String) customers.get("streetName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicasBySchedule(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String scheduleId = null;

		Schedule schedule = scheduleDao.getlatestScheduleCustomers();

		if (schedule != null) {

			try {
				scheduleId = schedule.getsId() != null ? schedule.getsId().toString() : null;
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

		statusType = request.containsKey("statusType") ? ((String) request.get("statusType")).toLowerCase() : "Success";

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplicaBySchdeule(statusType, scheduleId);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");
				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				System.out.println("customers" + customers.get("customerName"));

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public CustomerOrderReplica getCustomerOrderReplicaByCartId(String cartId) {

		CustomerOrderReplica CustomerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(cartId,
				currentUser.getContactNumber());

		ObjectMapper objectMapper = new ObjectMapper();
		try {

			// convert JSON string to Map
			Map<String, Object> customerOrderReplicaMap = objectMapper
					.readValue(CustomerOrderReplica.getCustomerOrderDetails(), Map.class);

			Object customerOrder = customerOrderReplicaMap.get("customerOrder");
			Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

			Object quanityList = items.get("quantity");
			Map customers = customerDetailsDao.getByContactNumberAndApartment(CustomerOrderReplica.getContactNumber(),
					CustomerOrderReplica.getApartmentId());

			System.out.println("customers" + customers.get("customerName"));

			// Apartments apartments =
			// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
			CustomerOrderReplica.setApartmentName(
					customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

			CustomerOrderReplica.setCustomerDetails(customers);

			CustomerOrderReplica.setCustomerOrder(customerOrder);
			CustomerOrderReplica.setQuatityList(quanityList);

		} catch (Exception e) {
			e.printStackTrace();
		}

		return CustomerOrderReplica;

	}

	@Override
	public Map createCustomerOrderReplica(CustomerOrderReplicaRequest customerOrderReplicaRequest, String contactNumber,
			Integer aparmentId) {

		if (customerOrderReplicaRequest.getRazorPayRequest() != null) {

//			Map razorPay = consumerService.createRazorPayOrder(customerOrderReplicaRequest.getRazorPayRequest());
//			customerOrderReplicaRequest.setOrderId(razorPay.get("order") != null ? (String)((RazorPay) razorPay.get("order")).getId() : null);	
//	
//			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);
//
//			razorPay.put("cartId", customerOrderReplicaRequest.getCartId());

			Map customerOrderReplicaMap = new HashMap<>();

			Map orderId = new HashMap<>();
			String transactionId = getMerchantTransactionId();
			orderId.put("id", transactionId);

			customerOrderReplicaMap.put("order", orderId);

			customerOrderReplicaRequest.setOrderId(transactionId);
			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);

			customerOrderReplicaMap.put("cartId", customerOrderReplicaRequest.getCartId());

			try {
				customerOrderReplicaMap.put("phonePeResponse",
						phonepeServiceImpl.initiatePhonepePayment(transactionId,
								Integer.valueOf(customerOrderReplicaRequest.getRazorPayRequest().getAmount()),
								contactNumber, customerOrderReplicaRequest.getRedirectUrl(), customerOrderReplicaRequest.getCallBackUrl()));

			} catch (Exception e) {
				e.printStackTrace();
				customerOrderReplicaMap.put("phonePeResponse", new HashedMap<>());
			}

			return customerOrderReplicaMap;

		} else {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
					"paymentDetails transcation Details are mandatory");
		}

	}

	private static String getMerchantTransactionId() {

		return "OD_" + MerchantTransactionIdGenerator.getRandomString();
	}


	@Override
	public List<CustomerOrderReplica> getCustomerOrderByMoblieNo(String contactNumber, Integer aid) {

	    Schedule latestSchedule = customerOrderReplicaDoa.getlatestschedule();

	    if (latestSchedule != null && latestSchedule.getCreationTimestamp() != null) {
	        if (latestSchedule.getStatus().equals(UserStatus.ACTIVE)) {
	            Customers customer = customerDetailsDao.getByContactNoAndApartment(contactNumber, aid);

	            if (customer != null) { // Ensure the customer exists
	                List<CustomerOrder> customerOrderList = customerOrderReplicaDoa.getListCustomerOrderByCustomerId(customer.getCtId());

	                double totalOrderAmount = 0.0;

	                if (customerOrderList != null && !customerOrderList.isEmpty()) {
	                    for (CustomerOrder customerOrder : customerOrderList) {
	                        Double orderAmount = customerOrder.getAmount();
	                        if (orderAmount != null) {
	                            totalOrderAmount += orderAmount;
	                            if(totalOrderAmount>200) {
	                            	totalOrderAmount+= customerOrder.getDelivaryCharges();
	                            }
	                            else(totalOrderAmount<200){
	                            	totalOrderAmount-= customerOrder.getDelivaryCharges();
	                            }
	                        }
	                    }

	                    // Define the minimum order amount for applying delivery charges
	                    double minimumOrderAmount = 200.0;

	                    if (totalOrderAmount < minimumOrderAmount) {
	                        System.out.println("Delivery Charges will be applicable");
	                    } else {
	                        // No delivery charges applicable
	                        System.out.println("No Delivery charges applicable");
	                    }

	                    List<CustomerOrderReplica> customerOrderReplicas = new ArrayList<>();
	                    return customerOrderReplicas;
	                } else {
	                    return Collections.emptyList();
	                }
	            } else {
	                return null; // or an appropriate value
	            }
	        } else {
	            // Handle the case when the latest schedule is not active
	            return null; // or an appropriate value
	        }
	    } else {
	        // Handle the case when there is no latest schedule or its creation timestamp is null
	        return null; // or an appropriate value
	    }
	}

}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-09-21 15:34:00.981
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-09-21 15:34:00.982
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-21 15:34:01.141
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.xyram.daydrop.serviceimpl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.transaction.Transactional;

import org.apache.commons.collections4.map.HashedMap;
import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.server.ResponseStatusException;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.xyram.daydrop.admin.model.CurrentUser;
import com.xyram.daydrop.basemodel.Base64Wrapper;
import com.xyram.daydrop.basemodel.MerchantTransactionIdGenerator;
import com.xyram.daydrop.basemodel.PhonepeSerializer;
import com.xyram.daydrop.dao.ApartmentDao;
import com.xyram.daydrop.dao.CustomerDetailsDao;
import com.xyram.daydrop.dao.CustomerOrderDao;
import com.xyram.daydrop.dao.CustomerOrderReplicaDoa;
import com.xyram.daydrop.dao.SheduleDao;
import com.xyram.daydrop.enumtypes.UserStatus;
import com.xyram.daydrop.model.Apartments;
import com.xyram.daydrop.model.CustomerOrder;
import com.xyram.daydrop.model.CustomerOrderReplica;
import com.xyram.daydrop.model.Customers;
import com.xyram.daydrop.model.Schedule;
import com.xyram.daydrop.modelMapper.PaymentInstrument;
import com.xyram.daydrop.modelMapper.PhonePePayModel;
import com.xyram.daydrop.request.CustomerOrderReplicaRequest;
import com.xyram.daydrop.response.RazorPayRequest;
import com.xyram.daydrop.service.CustomerOrderPriceService;
import com.xyram.daydrop.service.CustomerOrderReplicaService;
import com.xyram.daydrop.util.HashEncoder;
import com.xyram.daydrop.util.RazorPay;
import com.xyram.daydrop.service.ConsumerService;

@Transactional
@Service
public class CustomerOrderReplicaServiceImpl implements CustomerOrderReplicaService {

	@Autowired
	CustomerOrderReplicaDoa customerOrderReplicaDoa;

	@Autowired
	ApartmentDao apartmentDao;

	@Autowired
	SheduleDao scheduleDao;

	@Autowired
	CustomerDetailsDao customerDetailsDao;

	@Autowired
	ConsumerService consumerService;

	@Autowired
	CurrentUser currentUser;

	@Autowired
	PhonepeServiceImpl phonepeServiceImpl;

	@Value("${merchant_id}")
	private String merchantId;

	@Value("${salt_key}")
	private String saltKey;

	@Value("${salt_index}")
	private String saltIndex;

	@Override
	public Map createCustomerOrderReplicaService(CustomerOrderReplicaRequest customerOrderReplicaRequest,
			String contactNumber, Integer aparmentId)

	{

		Map response = new HashedMap<>();

		response.put("message", "success");
		CustomerOrderReplica customerOrderReplica = null;

		if (customerOrderReplicaRequest.getCartId() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "cartId is mandatory ");
		}
		long razorPayCount = 0;
		if (customerOrderReplicaRequest.getOrderId() != null) {

			razorPayCount = customerOrderReplicaDoa.getRazorPayExistByCartId(customerOrderReplicaRequest.getOrderId());
		}

		if (customerOrderReplicaRequest.getCustomerDetails() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Order Details  is mandatory ");
		}

		customerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(customerOrderReplicaRequest.getCartId(),
				contactNumber);

		if (customerOrderReplica != null) {
			customerOrderReplica.setCartId(customerOrderReplica.getCartId());

			if (customerOrderReplica.isOrdered()) {
				throw new ResponseStatusException(HttpStatus.CONFLICT, "Your Order is Placed With cart Details");
			}

//			if (razorPayCount >= 1 && !(customerOrderReplica.getRazorPayOrderId() != null
//					&& customerOrderReplica.getRazorPayOrderId().equals(customerOrderReplicaRequest.getOrderId()))) {
//				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
//			}

			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);

			customerOrderReplica.setAttempts(customerOrderReplica.getAttempts() + 1);
			customerOrderReplica.setUpdatedTime(new Date());

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		} else {

			customerOrderReplica = new CustomerOrderReplica();
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);
			customerOrderReplica.setCartId(customerOrderReplicaRequest.getCartId());
			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());

			if (razorPayCount > 0) {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
			}

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			Schedule schedule = scheduleDao.getlatestScheduleCustomers();

			if (schedule != null) {

				try {
					customerOrderReplica.setSchedule(schedule.getsId() != null ? schedule.getsId().toString() : null);
				} catch (Exception e) {
					e.printStackTrace();
				}
			} else {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
						"Sorry We Are Not Accepting Any Order Right now");

			}

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		}

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicas(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String schedule = null;

		Map filter = request.containsKey("filters") ? (Map) request.get("filters") : null;
		if (filter != null) {
			statusType = filter.containsKey("statusType") ? ((String) filter.get("statusType")).toLowerCase() : null;
			searchQuery = filter.containsKey("searchQuery") ? ((String) filter.get("searchQuery")).toLowerCase() : null;
			schedule = filter.containsKey("schedule") ? (String.valueOf(filter.get("schedule"))) : null;

		}

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplica(searchQuery, statusType, schedule);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");

				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setStreetName(
						customers.get("streetName") != null ? (String) customers.get("streetName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicasBySchedule(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String scheduleId = null;

		Schedule schedule = scheduleDao.getlatestScheduleCustomers();

		if (schedule != null) {

			try {
				scheduleId = schedule.getsId() != null ? schedule.getsId().toString() : null;
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

		statusType = request.containsKey("statusType") ? ((String) request.get("statusType")).toLowerCase() : "Success";

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplicaBySchdeule(statusType, scheduleId);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");
				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				System.out.println("customers" + customers.get("customerName"));

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public CustomerOrderReplica getCustomerOrderReplicaByCartId(String cartId) {

		CustomerOrderReplica CustomerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(cartId,
				currentUser.getContactNumber());

		ObjectMapper objectMapper = new ObjectMapper();
		try {

			// convert JSON string to Map
			Map<String, Object> customerOrderReplicaMap = objectMapper
					.readValue(CustomerOrderReplica.getCustomerOrderDetails(), Map.class);

			Object customerOrder = customerOrderReplicaMap.get("customerOrder");
			Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

			Object quanityList = items.get("quantity");
			Map customers = customerDetailsDao.getByContactNumberAndApartment(CustomerOrderReplica.getContactNumber(),
					CustomerOrderReplica.getApartmentId());

			System.out.println("customers" + customers.get("customerName"));

			// Apartments apartments =
			// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
			CustomerOrderReplica.setApartmentName(
					customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

			CustomerOrderReplica.setCustomerDetails(customers);

			CustomerOrderReplica.setCustomerOrder(customerOrder);
			CustomerOrderReplica.setQuatityList(quanityList);

		} catch (Exception e) {
			e.printStackTrace();
		}

		return CustomerOrderReplica;

	}

	@Override
	public Map createCustomerOrderReplica(CustomerOrderReplicaRequest customerOrderReplicaRequest, String contactNumber,
			Integer aparmentId) {

		if (customerOrderReplicaRequest.getRazorPayRequest() != null) {

//			Map razorPay = consumerService.createRazorPayOrder(customerOrderReplicaRequest.getRazorPayRequest());
//			customerOrderReplicaRequest.setOrderId(razorPay.get("order") != null ? (String)((RazorPay) razorPay.get("order")).getId() : null);	
//	
//			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);
//
//			razorPay.put("cartId", customerOrderReplicaRequest.getCartId());

			Map customerOrderReplicaMap = new HashMap<>();

			Map orderId = new HashMap<>();
			String transactionId = getMerchantTransactionId();
			orderId.put("id", transactionId);

			customerOrderReplicaMap.put("order", orderId);

			customerOrderReplicaRequest.setOrderId(transactionId);
			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);

			customerOrderReplicaMap.put("cartId", customerOrderReplicaRequest.getCartId());

			try {
				customerOrderReplicaMap.put("phonePeResponse",
						phonepeServiceImpl.initiatePhonepePayment(transactionId,
								Integer.valueOf(customerOrderReplicaRequest.getRazorPayRequest().getAmount()),
								contactNumber, customerOrderReplicaRequest.getRedirectUrl(), customerOrderReplicaRequest.getCallBackUrl()));

			} catch (Exception e) {
				e.printStackTrace();
				customerOrderReplicaMap.put("phonePeResponse", new HashedMap<>());
			}

			return customerOrderReplicaMap;

		} else {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
					"paymentDetails transcation Details are mandatory");
		}

	}

	private static String getMerchantTransactionId() {

		return "OD_" + MerchantTransactionIdGenerator.getRandomString();
	}


	@Override
	public List<CustomerOrderReplica> getCustomerOrderByMoblieNo(String contactNumber, Integer aid) {

	    Schedule latestSchedule = customerOrderReplicaDoa.getlatestschedule();

	    if (latestSchedule != null && latestSchedule.getCreationTimestamp() != null) {
	        if (latestSchedule.getStatus().equals(UserStatus.ACTIVE)) {
	            Customers customer = customerDetailsDao.getByContactNoAndApartment(contactNumber, aid);

	            if (customer != null) { // Ensure the customer exists
	                List<CustomerOrder> customerOrderList = customerOrderReplicaDoa.getListCustomerOrderByCustomerId(customer.getCtId());

	                double totalOrderAmount = 0.0;

	                if (customerOrderList != null && !customerOrderList.isEmpty()) {
	                    for (CustomerOrder customerOrder : customerOrderList) {
	                        Double orderAmount = customerOrder.getAmount();
	                        if (orderAmount != null) {
	                            totalOrderAmount += orderAmount;
	                            if(totalOrderAmount>200) {
	                            	totalOrderAmount+= customerOrder.getDelivaryCharges();
	                            }
	                            else(totalOrderAmount<200){
	                            	totalOrderAmount-= customerOrder.getDelivaryCharges();
	                            }
	                        }
	                    }

	                    // Define the minimum order amount for applying delivery charges
	                    double minimumOrderAmount = 200.0;

	                    if (totalOrderAmount < minimumOrderAmount) {
	                        System.out.println("Delivery Charges will be applicable");
	                    } else {
	                        // No delivery charges applicable
	                        System.out.println("No Delivery charges applicable");
	                    }

	                    List<CustomerOrderReplica> customerOrderReplicas = new ArrayList<>();
	                    return customerOrderReplicas;
	                } else {
	                    return Collections.emptyList();
	                }
	            } else {
	                return null; // or an appropriate value
	            }
	        } else {
	            // Handle the case when the latest schedule is not active
	            return null; // or an appropriate value
	        }
	    } else {
	        // Handle the case when there is no latest schedule or its creation timestamp is null
	        return null; // or an appropriate value
	    }
	}

}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-09-21 15:34:01.144
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-09-21 15:34:01.146
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-21 15:34:02.526
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.xyram.daydrop.serviceimpl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.transaction.Transactional;

import org.apache.commons.collections4.map.HashedMap;
import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.server.ResponseStatusException;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.xyram.daydrop.admin.model.CurrentUser;
import com.xyram.daydrop.basemodel.Base64Wrapper;
import com.xyram.daydrop.basemodel.MerchantTransactionIdGenerator;
import com.xyram.daydrop.basemodel.PhonepeSerializer;
import com.xyram.daydrop.dao.ApartmentDao;
import com.xyram.daydrop.dao.CustomerDetailsDao;
import com.xyram.daydrop.dao.CustomerOrderDao;
import com.xyram.daydrop.dao.CustomerOrderReplicaDoa;
import com.xyram.daydrop.dao.SheduleDao;
import com.xyram.daydrop.enumtypes.UserStatus;
import com.xyram.daydrop.model.Apartments;
import com.xyram.daydrop.model.CustomerOrder;
import com.xyram.daydrop.model.CustomerOrderReplica;
import com.xyram.daydrop.model.Customers;
import com.xyram.daydrop.model.Schedule;
import com.xyram.daydrop.modelMapper.PaymentInstrument;
import com.xyram.daydrop.modelMapper.PhonePePayModel;
import com.xyram.daydrop.request.CustomerOrderReplicaRequest;
import com.xyram.daydrop.response.RazorPayRequest;
import com.xyram.daydrop.service.CustomerOrderPriceService;
import com.xyram.daydrop.service.CustomerOrderReplicaService;
import com.xyram.daydrop.util.HashEncoder;
import com.xyram.daydrop.util.RazorPay;
import com.xyram.daydrop.service.ConsumerService;

@Transactional
@Service
public class CustomerOrderReplicaServiceImpl implements CustomerOrderReplicaService {

	@Autowired
	CustomerOrderReplicaDoa customerOrderReplicaDoa;

	@Autowired
	ApartmentDao apartmentDao;

	@Autowired
	SheduleDao scheduleDao;

	@Autowired
	CustomerDetailsDao customerDetailsDao;

	@Autowired
	ConsumerService consumerService;

	@Autowired
	CurrentUser currentUser;

	@Autowired
	PhonepeServiceImpl phonepeServiceImpl;

	@Value("${merchant_id}")
	private String merchantId;

	@Value("${salt_key}")
	private String saltKey;

	@Value("${salt_index}")
	private String saltIndex;

	@Override
	public Map createCustomerOrderReplicaService(CustomerOrderReplicaRequest customerOrderReplicaRequest,
			String contactNumber, Integer aparmentId)

	{

		Map response = new HashedMap<>();

		response.put("message", "success");
		CustomerOrderReplica customerOrderReplica = null;

		if (customerOrderReplicaRequest.getCartId() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "cartId is mandatory ");
		}
		long razorPayCount = 0;
		if (customerOrderReplicaRequest.getOrderId() != null) {

			razorPayCount = customerOrderReplicaDoa.getRazorPayExistByCartId(customerOrderReplicaRequest.getOrderId());
		}

		if (customerOrderReplicaRequest.getCustomerDetails() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Order Details  is mandatory ");
		}

		customerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(customerOrderReplicaRequest.getCartId(),
				contactNumber);

		if (customerOrderReplica != null) {
			customerOrderReplica.setCartId(customerOrderReplica.getCartId());

			if (customerOrderReplica.isOrdered()) {
				throw new ResponseStatusException(HttpStatus.CONFLICT, "Your Order is Placed With cart Details");
			}

//			if (razorPayCount >= 1 && !(customerOrderReplica.getRazorPayOrderId() != null
//					&& customerOrderReplica.getRazorPayOrderId().equals(customerOrderReplicaRequest.getOrderId()))) {
//				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
//			}

			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);

			customerOrderReplica.setAttempts(customerOrderReplica.getAttempts() + 1);
			customerOrderReplica.setUpdatedTime(new Date());

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		} else {

			customerOrderReplica = new CustomerOrderReplica();
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);
			customerOrderReplica.setCartId(customerOrderReplicaRequest.getCartId());
			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());

			if (razorPayCount > 0) {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
			}

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			Schedule schedule = scheduleDao.getlatestScheduleCustomers();

			if (schedule != null) {

				try {
					customerOrderReplica.setSchedule(schedule.getsId() != null ? schedule.getsId().toString() : null);
				} catch (Exception e) {
					e.printStackTrace();
				}
			} else {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
						"Sorry We Are Not Accepting Any Order Right now");

			}

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		}

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicas(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String schedule = null;

		Map filter = request.containsKey("filters") ? (Map) request.get("filters") : null;
		if (filter != null) {
			statusType = filter.containsKey("statusType") ? ((String) filter.get("statusType")).toLowerCase() : null;
			searchQuery = filter.containsKey("searchQuery") ? ((String) filter.get("searchQuery")).toLowerCase() : null;
			schedule = filter.containsKey("schedule") ? (String.valueOf(filter.get("schedule"))) : null;

		}

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplica(searchQuery, statusType, schedule);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");

				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setStreetName(
						customers.get("streetName") != null ? (String) customers.get("streetName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicasBySchedule(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String scheduleId = null;

		Schedule schedule = scheduleDao.getlatestScheduleCustomers();

		if (schedule != null) {

			try {
				scheduleId = schedule.getsId() != null ? schedule.getsId().toString() : null;
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

		statusType = request.containsKey("statusType") ? ((String) request.get("statusType")).toLowerCase() : "Success";

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplicaBySchdeule(statusType, scheduleId);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");
				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				System.out.println("customers" + customers.get("customerName"));

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public CustomerOrderReplica getCustomerOrderReplicaByCartId(String cartId) {

		CustomerOrderReplica CustomerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(cartId,
				currentUser.getContactNumber());

		ObjectMapper objectMapper = new ObjectMapper();
		try {

			// convert JSON string to Map
			Map<String, Object> customerOrderReplicaMap = objectMapper
					.readValue(CustomerOrderReplica.getCustomerOrderDetails(), Map.class);

			Object customerOrder = customerOrderReplicaMap.get("customerOrder");
			Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

			Object quanityList = items.get("quantity");
			Map customers = customerDetailsDao.getByContactNumberAndApartment(CustomerOrderReplica.getContactNumber(),
					CustomerOrderReplica.getApartmentId());

			System.out.println("customers" + customers.get("customerName"));

			// Apartments apartments =
			// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
			CustomerOrderReplica.setApartmentName(
					customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

			CustomerOrderReplica.setCustomerDetails(customers);

			CustomerOrderReplica.setCustomerOrder(customerOrder);
			CustomerOrderReplica.setQuatityList(quanityList);

		} catch (Exception e) {
			e.printStackTrace();
		}

		return CustomerOrderReplica;

	}

	@Override
	public Map createCustomerOrderReplica(CustomerOrderReplicaRequest customerOrderReplicaRequest, String contactNumber,
			Integer aparmentId) {

		if (customerOrderReplicaRequest.getRazorPayRequest() != null) {

//			Map razorPay = consumerService.createRazorPayOrder(customerOrderReplicaRequest.getRazorPayRequest());
//			customerOrderReplicaRequest.setOrderId(razorPay.get("order") != null ? (String)((RazorPay) razorPay.get("order")).getId() : null);	
//	
//			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);
//
//			razorPay.put("cartId", customerOrderReplicaRequest.getCartId());

			Map customerOrderReplicaMap = new HashMap<>();

			Map orderId = new HashMap<>();
			String transactionId = getMerchantTransactionId();
			orderId.put("id", transactionId);

			customerOrderReplicaMap.put("order", orderId);

			customerOrderReplicaRequest.setOrderId(transactionId);
			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);

			customerOrderReplicaMap.put("cartId", customerOrderReplicaRequest.getCartId());

			try {
				customerOrderReplicaMap.put("phonePeResponse",
						phonepeServiceImpl.initiatePhonepePayment(transactionId,
								Integer.valueOf(customerOrderReplicaRequest.getRazorPayRequest().getAmount()),
								contactNumber, customerOrderReplicaRequest.getRedirectUrl(), customerOrderReplicaRequest.getCallBackUrl()));

			} catch (Exception e) {
				e.printStackTrace();
				customerOrderReplicaMap.put("phonePeResponse", new HashedMap<>());
			}

			return customerOrderReplicaMap;

		} else {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
					"paymentDetails transcation Details are mandatory");
		}

	}

	private static String getMerchantTransactionId() {

		return "OD_" + MerchantTransactionIdGenerator.getRandomString();
	}


	@Override
	public List<CustomerOrderReplica> getCustomerOrderByMoblieNo(String contactNumber, Integer aid) {

	    Schedule latestSchedule = customerOrderReplicaDoa.getlatestschedule();

	    if (latestSchedule != null && latestSchedule.getCreationTimestamp() != null) {
	        if (latestSchedule.getStatus().equals(UserStatus.ACTIVE)) {
	            Customers customer = customerDetailsDao.getByContactNoAndApartment(contactNumber, aid);

	            if (customer != null) { // Ensure the customer exists
	                List<CustomerOrder> customerOrderList = customerOrderReplicaDoa.getListCustomerOrderByCustomerId(customer.getCtId());

	                double totalOrderAmount = 0.0;

	                if (customerOrderList != null && !customerOrderList.isEmpty()) {
	                    for (CustomerOrder customerOrder : customerOrderList) {
	                        Double orderAmount = customerOrder.getAmount();
	                        if (orderAmount != null) {
	                            totalOrderAmount += orderAmount;
	                            if(totalOrderAmount>200) {
	                            	totalOrderAmount+= customerOrder.getDelivaryCharges();
	                            }
	                            else(totalOrderAmount<200){
	                            	totalOrderAmount-= customerOrder.getDelivaryCharges();
	                            }
	                        }
	                    }

	                    // Define the minimum order amount for applying delivery charges
	                    double minimumOrderAmount = 200.0;

	                    if (totalOrderAmount < minimumOrderAmount) {
	                        System.out.println("Delivery Charges will be applicable");
	                    } else {
	                        // No delivery charges applicable
	                        System.out.println("No Delivery charges applicable");
	                    }

	                    List<CustomerOrderReplica> customerOrderReplicas = new ArrayList<>();
	                    return customerOrderReplicas;
	                } else {
	                    return Collections.emptyList();
	                }
	            } else {
	                return null; // or an appropriate value
	            }
	        } else {
	            // Handle the case when the latest schedule is not active
	            return null; // or an appropriate value
	        }
	    } else {
	        // Handle the case when there is no latest schedule or its creation timestamp is null
	        return null; // or an appropriate value
	    }
	}

}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4035)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3635)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-09-21 15:34:02.528
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4035)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3635)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-09-21 15:34:02.530
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4035)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3635)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-21 15:34:02.585
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.xyram.daydrop.serviceimpl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.transaction.Transactional;

import org.apache.commons.collections4.map.HashedMap;
import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.server.ResponseStatusException;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.xyram.daydrop.admin.model.CurrentUser;
import com.xyram.daydrop.basemodel.Base64Wrapper;
import com.xyram.daydrop.basemodel.MerchantTransactionIdGenerator;
import com.xyram.daydrop.basemodel.PhonepeSerializer;
import com.xyram.daydrop.dao.ApartmentDao;
import com.xyram.daydrop.dao.CustomerDetailsDao;
import com.xyram.daydrop.dao.CustomerOrderDao;
import com.xyram.daydrop.dao.CustomerOrderReplicaDoa;
import com.xyram.daydrop.dao.SheduleDao;
import com.xyram.daydrop.enumtypes.UserStatus;
import com.xyram.daydrop.model.Apartments;
import com.xyram.daydrop.model.CustomerOrder;
import com.xyram.daydrop.model.CustomerOrderReplica;
import com.xyram.daydrop.model.Customers;
import com.xyram.daydrop.model.Schedule;
import com.xyram.daydrop.modelMapper.PaymentInstrument;
import com.xyram.daydrop.modelMapper.PhonePePayModel;
import com.xyram.daydrop.request.CustomerOrderReplicaRequest;
import com.xyram.daydrop.response.RazorPayRequest;
import com.xyram.daydrop.service.CustomerOrderPriceService;
import com.xyram.daydrop.service.CustomerOrderReplicaService;
import com.xyram.daydrop.util.HashEncoder;
import com.xyram.daydrop.util.RazorPay;
import com.xyram.daydrop.service.ConsumerService;

@Transactional
@Service
public class CustomerOrderReplicaServiceImpl implements CustomerOrderReplicaService {

	@Autowired
	CustomerOrderReplicaDoa customerOrderReplicaDoa;

	@Autowired
	ApartmentDao apartmentDao;

	@Autowired
	SheduleDao scheduleDao;

	@Autowired
	CustomerDetailsDao customerDetailsDao;

	@Autowired
	ConsumerService consumerService;

	@Autowired
	CurrentUser currentUser;

	@Autowired
	PhonepeServiceImpl phonepeServiceImpl;

	@Value("${merchant_id}")
	private String merchantId;

	@Value("${salt_key}")
	private String saltKey;

	@Value("${salt_index}")
	private String saltIndex;

	@Override
	public Map createCustomerOrderReplicaService(CustomerOrderReplicaRequest customerOrderReplicaRequest,
			String contactNumber, Integer aparmentId)

	{

		Map response = new HashedMap<>();

		response.put("message", "success");
		CustomerOrderReplica customerOrderReplica = null;

		if (customerOrderReplicaRequest.getCartId() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "cartId is mandatory ");
		}
		long razorPayCount = 0;
		if (customerOrderReplicaRequest.getOrderId() != null) {

			razorPayCount = customerOrderReplicaDoa.getRazorPayExistByCartId(customerOrderReplicaRequest.getOrderId());
		}

		if (customerOrderReplicaRequest.getCustomerDetails() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Order Details  is mandatory ");
		}

		customerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(customerOrderReplicaRequest.getCartId(),
				contactNumber);

		if (customerOrderReplica != null) {
			customerOrderReplica.setCartId(customerOrderReplica.getCartId());

			if (customerOrderReplica.isOrdered()) {
				throw new ResponseStatusException(HttpStatus.CONFLICT, "Your Order is Placed With cart Details");
			}

//			if (razorPayCount >= 1 && !(customerOrderReplica.getRazorPayOrderId() != null
//					&& customerOrderReplica.getRazorPayOrderId().equals(customerOrderReplicaRequest.getOrderId()))) {
//				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
//			}

			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);

			customerOrderReplica.setAttempts(customerOrderReplica.getAttempts() + 1);
			customerOrderReplica.setUpdatedTime(new Date());

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		} else {

			customerOrderReplica = new CustomerOrderReplica();
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);
			customerOrderReplica.setCartId(customerOrderReplicaRequest.getCartId());
			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());

			if (razorPayCount > 0) {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
			}

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			Schedule schedule = scheduleDao.getlatestScheduleCustomers();

			if (schedule != null) {

				try {
					customerOrderReplica.setSchedule(schedule.getsId() != null ? schedule.getsId().toString() : null);
				} catch (Exception e) {
					e.printStackTrace();
				}
			} else {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
						"Sorry We Are Not Accepting Any Order Right now");

			}

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		}

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicas(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String schedule = null;

		Map filter = request.containsKey("filters") ? (Map) request.get("filters") : null;
		if (filter != null) {
			statusType = filter.containsKey("statusType") ? ((String) filter.get("statusType")).toLowerCase() : null;
			searchQuery = filter.containsKey("searchQuery") ? ((String) filter.get("searchQuery")).toLowerCase() : null;
			schedule = filter.containsKey("schedule") ? (String.valueOf(filter.get("schedule"))) : null;

		}

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplica(searchQuery, statusType, schedule);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");

				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setStreetName(
						customers.get("streetName") != null ? (String) customers.get("streetName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicasBySchedule(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String scheduleId = null;

		Schedule schedule = scheduleDao.getlatestScheduleCustomers();

		if (schedule != null) {

			try {
				scheduleId = schedule.getsId() != null ? schedule.getsId().toString() : null;
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

		statusType = request.containsKey("statusType") ? ((String) request.get("statusType")).toLowerCase() : "Success";

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplicaBySchdeule(statusType, scheduleId);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");
				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				System.out.println("customers" + customers.get("customerName"));

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public CustomerOrderReplica getCustomerOrderReplicaByCartId(String cartId) {

		CustomerOrderReplica CustomerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(cartId,
				currentUser.getContactNumber());

		ObjectMapper objectMapper = new ObjectMapper();
		try {

			// convert JSON string to Map
			Map<String, Object> customerOrderReplicaMap = objectMapper
					.readValue(CustomerOrderReplica.getCustomerOrderDetails(), Map.class);

			Object customerOrder = customerOrderReplicaMap.get("customerOrder");
			Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

			Object quanityList = items.get("quantity");
			Map customers = customerDetailsDao.getByContactNumberAndApartment(CustomerOrderReplica.getContactNumber(),
					CustomerOrderReplica.getApartmentId());

			System.out.println("customers" + customers.get("customerName"));

			// Apartments apartments =
			// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
			CustomerOrderReplica.setApartmentName(
					customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

			CustomerOrderReplica.setCustomerDetails(customers);

			CustomerOrderReplica.setCustomerOrder(customerOrder);
			CustomerOrderReplica.setQuatityList(quanityList);

		} catch (Exception e) {
			e.printStackTrace();
		}

		return CustomerOrderReplica;

	}

	@Override
	public Map createCustomerOrderReplica(CustomerOrderReplicaRequest customerOrderReplicaRequest, String contactNumber,
			Integer aparmentId) {

		if (customerOrderReplicaRequest.getRazorPayRequest() != null) {

//			Map razorPay = consumerService.createRazorPayOrder(customerOrderReplicaRequest.getRazorPayRequest());
//			customerOrderReplicaRequest.setOrderId(razorPay.get("order") != null ? (String)((RazorPay) razorPay.get("order")).getId() : null);	
//	
//			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);
//
//			razorPay.put("cartId", customerOrderReplicaRequest.getCartId());

			Map customerOrderReplicaMap = new HashMap<>();

			Map orderId = new HashMap<>();
			String transactionId = getMerchantTransactionId();
			orderId.put("id", transactionId);

			customerOrderReplicaMap.put("order", orderId);

			customerOrderReplicaRequest.setOrderId(transactionId);
			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);

			customerOrderReplicaMap.put("cartId", customerOrderReplicaRequest.getCartId());

			try {
				customerOrderReplicaMap.put("phonePeResponse",
						phonepeServiceImpl.initiatePhonepePayment(transactionId,
								Integer.valueOf(customerOrderReplicaRequest.getRazorPayRequest().getAmount()),
								contactNumber, customerOrderReplicaRequest.getRedirectUrl(), customerOrderReplicaRequest.getCallBackUrl()));

			} catch (Exception e) {
				e.printStackTrace();
				customerOrderReplicaMap.put("phonePeResponse", new HashedMap<>());
			}

			return customerOrderReplicaMap;

		} else {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
					"paymentDetails transcation Details are mandatory");
		}

	}

	private static String getMerchantTransactionId() {

		return "OD_" + MerchantTransactionIdGenerator.getRandomString();
	}


	@Override
	public List<CustomerOrderReplica> getCustomerOrderByMoblieNo(String contactNumber, Integer aid) {

	    Schedule latestSchedule = customerOrderReplicaDoa.getlatestschedule();

	    if (latestSchedule != null && latestSchedule.getCreationTimestamp() != null) {
	        if (latestSchedule.getStatus().equals(UserStatus.ACTIVE)) {
	            Customers customer = customerDetailsDao.getByContactNoAndApartment(contactNumber, aid);

	            if (customer != null) { // Ensure the customer exists
	                List<CustomerOrder> customerOrderList = customerOrderReplicaDoa.getListCustomerOrderByCustomerId(customer.getCtId());

	                double totalOrderAmount = 0.0;

	                if (customerOrderList != null && !customerOrderList.isEmpty()) {
	                    for (CustomerOrder customerOrder : customerOrderList) {
	                        Double orderAmount = customerOrder.getAmount();
	                        if (orderAmount != null) {
	                            totalOrderAmount += orderAmount;
	                            if(totalOrderAmount>200) {
	                            	totalOrderAmount+= customerOrder.getDelivaryCharges();
	                            }
	                            else(totalOrderAmount<200){
	                            	totalOrderAmount-= customerOrder.getDelivaryCharges();
	                            }
	                        }
	                    }

	                    // Define the minimum order amount for applying delivery charges
	                    double minimumOrderAmount = 200.0;

	                    if (totalOrderAmount < minimumOrderAmount) {
	                        System.out.println("Delivery Charges will be applicable");
	                    } else {
	                        // No delivery charges applicable
	                        System.out.println("No Delivery charges applicable");
	                    }

	                    List<CustomerOrderReplica> customerOrderReplicas = new ArrayList<>();
	                    return customerOrderReplicas;
	                } else {
	                    return Collections.emptyList();
	                }
	            } else {
	                return null; // or an appropriate value
	            }
	        } else {
	            // Handle the case when the latest schedule is not active
	            return null; // or an appropriate value
	        }
	    } else {
	        // Handle the case when there is no latest schedule or its creation timestamp is null
	        return null; // or an appropriate value
	    }
	}

}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.internal.core.manipulation.dom.ASTResolving.createQuickFixAST(ASTResolving.java:1052)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:131)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4035)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3635)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.ui 4 0 2023-09-21 15:34:02.586
!MESSAGE Unhandled event loop exception
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.internal.core.manipulation.dom.ASTResolving.createQuickFixAST(ASTResolving.java:1052)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:131)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4035)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3635)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-21 15:34:03.143
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.xyram.daydrop.serviceimpl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.transaction.Transactional;

import org.apache.commons.collections4.map.HashedMap;
import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.server.ResponseStatusException;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.xyram.daydrop.admin.model.CurrentUser;
import com.xyram.daydrop.basemodel.Base64Wrapper;
import com.xyram.daydrop.basemodel.MerchantTransactionIdGenerator;
import com.xyram.daydrop.basemodel.PhonepeSerializer;
import com.xyram.daydrop.dao.ApartmentDao;
import com.xyram.daydrop.dao.CustomerDetailsDao;
import com.xyram.daydrop.dao.CustomerOrderDao;
import com.xyram.daydrop.dao.CustomerOrderReplicaDoa;
import com.xyram.daydrop.dao.SheduleDao;
import com.xyram.daydrop.enumtypes.UserStatus;
import com.xyram.daydrop.model.Apartments;
import com.xyram.daydrop.model.CustomerOrder;
import com.xyram.daydrop.model.CustomerOrderReplica;
import com.xyram.daydrop.model.Customers;
import com.xyram.daydrop.model.Schedule;
import com.xyram.daydrop.modelMapper.PaymentInstrument;
import com.xyram.daydrop.modelMapper.PhonePePayModel;
import com.xyram.daydrop.request.CustomerOrderReplicaRequest;
import com.xyram.daydrop.response.RazorPayRequest;
import com.xyram.daydrop.service.CustomerOrderPriceService;
import com.xyram.daydrop.service.CustomerOrderReplicaService;
import com.xyram.daydrop.util.HashEncoder;
import com.xyram.daydrop.util.RazorPay;
import com.xyram.daydrop.service.ConsumerService;

@Transactional
@Service
public class CustomerOrderReplicaServiceImpl implements CustomerOrderReplicaService {

	@Autowired
	CustomerOrderReplicaDoa customerOrderReplicaDoa;

	@Autowired
	ApartmentDao apartmentDao;

	@Autowired
	SheduleDao scheduleDao;

	@Autowired
	CustomerDetailsDao customerDetailsDao;

	@Autowired
	ConsumerService consumerService;

	@Autowired
	CurrentUser currentUser;

	@Autowired
	PhonepeServiceImpl phonepeServiceImpl;

	@Value("${merchant_id}")
	private String merchantId;

	@Value("${salt_key}")
	private String saltKey;

	@Value("${salt_index}")
	private String saltIndex;

	@Override
	public Map createCustomerOrderReplicaService(CustomerOrderReplicaRequest customerOrderReplicaRequest,
			String contactNumber, Integer aparmentId)

	{

		Map response = new HashedMap<>();

		response.put("message", "success");
		CustomerOrderReplica customerOrderReplica = null;

		if (customerOrderReplicaRequest.getCartId() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "cartId is mandatory ");
		}
		long razorPayCount = 0;
		if (customerOrderReplicaRequest.getOrderId() != null) {

			razorPayCount = customerOrderReplicaDoa.getRazorPayExistByCartId(customerOrderReplicaRequest.getOrderId());
		}

		if (customerOrderReplicaRequest.getCustomerDetails() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Order Details  is mandatory ");
		}

		customerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(customerOrderReplicaRequest.getCartId(),
				contactNumber);

		if (customerOrderReplica != null) {
			customerOrderReplica.setCartId(customerOrderReplica.getCartId());

			if (customerOrderReplica.isOrdered()) {
				throw new ResponseStatusException(HttpStatus.CONFLICT, "Your Order is Placed With cart Details");
			}

//			if (razorPayCount >= 1 && !(customerOrderReplica.getRazorPayOrderId() != null
//					&& customerOrderReplica.getRazorPayOrderId().equals(customerOrderReplicaRequest.getOrderId()))) {
//				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
//			}

			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);

			customerOrderReplica.setAttempts(customerOrderReplica.getAttempts() + 1);
			customerOrderReplica.setUpdatedTime(new Date());

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		} else {

			customerOrderReplica = new CustomerOrderReplica();
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);
			customerOrderReplica.setCartId(customerOrderReplicaRequest.getCartId());
			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());

			if (razorPayCount > 0) {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
			}

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			Schedule schedule = scheduleDao.getlatestScheduleCustomers();

			if (schedule != null) {

				try {
					customerOrderReplica.setSchedule(schedule.getsId() != null ? schedule.getsId().toString() : null);
				} catch (Exception e) {
					e.printStackTrace();
				}
			} else {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
						"Sorry We Are Not Accepting Any Order Right now");

			}

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		}

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicas(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String schedule = null;

		Map filter = request.containsKey("filters") ? (Map) request.get("filters") : null;
		if (filter != null) {
			statusType = filter.containsKey("statusType") ? ((String) filter.get("statusType")).toLowerCase() : null;
			searchQuery = filter.containsKey("searchQuery") ? ((String) filter.get("searchQuery")).toLowerCase() : null;
			schedule = filter.containsKey("schedule") ? (String.valueOf(filter.get("schedule"))) : null;

		}

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplica(searchQuery, statusType, schedule);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");

				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setStreetName(
						customers.get("streetName") != null ? (String) customers.get("streetName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicasBySchedule(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String scheduleId = null;

		Schedule schedule = scheduleDao.getlatestScheduleCustomers();

		if (schedule != null) {

			try {
				scheduleId = schedule.getsId() != null ? schedule.getsId().toString() : null;
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

		statusType = request.containsKey("statusType") ? ((String) request.get("statusType")).toLowerCase() : "Success";

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplicaBySchdeule(statusType, scheduleId);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");
				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				System.out.println("customers" + customers.get("customerName"));

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public CustomerOrderReplica getCustomerOrderReplicaByCartId(String cartId) {

		CustomerOrderReplica CustomerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(cartId,
				currentUser.getContactNumber());

		ObjectMapper objectMapper = new ObjectMapper();
		try {

			// convert JSON string to Map
			Map<String, Object> customerOrderReplicaMap = objectMapper
					.readValue(CustomerOrderReplica.getCustomerOrderDetails(), Map.class);

			Object customerOrder = customerOrderReplicaMap.get("customerOrder");
			Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

			Object quanityList = items.get("quantity");
			Map customers = customerDetailsDao.getByContactNumberAndApartment(CustomerOrderReplica.getContactNumber(),
					CustomerOrderReplica.getApartmentId());

			System.out.println("customers" + customers.get("customerName"));

			// Apartments apartments =
			// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
			CustomerOrderReplica.setApartmentName(
					customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

			CustomerOrderReplica.setCustomerDetails(customers);

			CustomerOrderReplica.setCustomerOrder(customerOrder);
			CustomerOrderReplica.setQuatityList(quanityList);

		} catch (Exception e) {
			e.printStackTrace();
		}

		return CustomerOrderReplica;

	}

	@Override
	public Map createCustomerOrderReplica(CustomerOrderReplicaRequest customerOrderReplicaRequest, String contactNumber,
			Integer aparmentId) {

		if (customerOrderReplicaRequest.getRazorPayRequest() != null) {

//			Map razorPay = consumerService.createRazorPayOrder(customerOrderReplicaRequest.getRazorPayRequest());
//			customerOrderReplicaRequest.setOrderId(razorPay.get("order") != null ? (String)((RazorPay) razorPay.get("order")).getId() : null);	
//	
//			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);
//
//			razorPay.put("cartId", customerOrderReplicaRequest.getCartId());

			Map customerOrderReplicaMap = new HashMap<>();

			Map orderId = new HashMap<>();
			String transactionId = getMerchantTransactionId();
			orderId.put("id", transactionId);

			customerOrderReplicaMap.put("order", orderId);

			customerOrderReplicaRequest.setOrderId(transactionId);
			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);

			customerOrderReplicaMap.put("cartId", customerOrderReplicaRequest.getCartId());

			try {
				customerOrderReplicaMap.put("phonePeResponse",
						phonepeServiceImpl.initiatePhonepePayment(transactionId,
								Integer.valueOf(customerOrderReplicaRequest.getRazorPayRequest().getAmount()),
								contactNumber, customerOrderReplicaRequest.getRedirectUrl(), customerOrderReplicaRequest.getCallBackUrl()));

			} catch (Exception e) {
				e.printStackTrace();
				customerOrderReplicaMap.put("phonePeResponse", new HashedMap<>());
			}

			return customerOrderReplicaMap;

		} else {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
					"paymentDetails transcation Details are mandatory");
		}

	}

	private static String getMerchantTransactionId() {

		return "OD_" + MerchantTransactionIdGenerator.getRandomString();
	}


	@Override
	public List<CustomerOrderReplica> getCustomerOrderByMoblieNo(String contactNumber, Integer aid) {

	    Schedule latestSchedule = customerOrderReplicaDoa.getlatestschedule();

	    if (latestSchedule != null && latestSchedule.getCreationTimestamp() != null) {
	        if (latestSchedule.getStatus().equals(UserStatus.ACTIVE)) {
	            Customers customer = customerDetailsDao.getByContactNoAndApartment(contactNumber, aid);

	            if (customer != null) { // Ensure the customer exists
	                List<CustomerOrder> customerOrderList = customerOrderReplicaDoa.getListCustomerOrderByCustomerId(customer.getCtId());

	                double totalOrderAmount = 0.0;

	                if (customerOrderList != null && !customerOrderList.isEmpty()) {
	                    for (CustomerOrder customerOrder : customerOrderList) {
	                        Double orderAmount = customerOrder.getAmount();
	                        if (orderAmount != null) {
	                            totalOrderAmount += orderAmount;
	                            if(totalOrderAmount>200) {
	                            	totalOrderAmount+= customerOrder.getDelivaryCharges();
	                            }
	                            else(totalOrderAmount<200){
	                            	totalOrderAmount-= customerOrder.getDelivaryCharges();
	                            }
	                        }
	                    }

	                    // Define the minimum order amount for applying delivery charges
	                    double minimumOrderAmount = 200.0;

	                    if (totalOrderAmount < minimumOrderAmount) {
	                        System.out.println("Delivery Charges will be applicable");
	                    } else {
	                        // No delivery charges applicable
	                        System.out.println("No Delivery charges applicable");
	                    }

	                    List<CustomerOrderReplica> customerOrderReplicas = new ArrayList<>();
	                    return customerOrderReplicas;
	                } else {
	                    return Collections.emptyList();
	                }
	            } else {
	                return null; // or an appropriate value
	            }
	        } else {
	            // Handle the case when the latest schedule is not active
	            return null; // or an appropriate value
	        }
	    } else {
	        // Handle the case when there is no latest schedule or its creation timestamp is null
	        return null; // or an appropriate value
	    }
	}

}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-09-21 15:34:03.146
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-09-21 15:34:03.148
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-21 15:34:03.589
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.xyram.daydrop.serviceimpl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.transaction.Transactional;

import org.apache.commons.collections4.map.HashedMap;
import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.server.ResponseStatusException;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.xyram.daydrop.admin.model.CurrentUser;
import com.xyram.daydrop.basemodel.Base64Wrapper;
import com.xyram.daydrop.basemodel.MerchantTransactionIdGenerator;
import com.xyram.daydrop.basemodel.PhonepeSerializer;
import com.xyram.daydrop.dao.ApartmentDao;
import com.xyram.daydrop.dao.CustomerDetailsDao;
import com.xyram.daydrop.dao.CustomerOrderDao;
import com.xyram.daydrop.dao.CustomerOrderReplicaDoa;
import com.xyram.daydrop.dao.SheduleDao;
import com.xyram.daydrop.enumtypes.UserStatus;
import com.xyram.daydrop.model.Apartments;
import com.xyram.daydrop.model.CustomerOrder;
import com.xyram.daydrop.model.CustomerOrderReplica;
import com.xyram.daydrop.model.Customers;
import com.xyram.daydrop.model.Schedule;
import com.xyram.daydrop.modelMapper.PaymentInstrument;
import com.xyram.daydrop.modelMapper.PhonePePayModel;
import com.xyram.daydrop.request.CustomerOrderReplicaRequest;
import com.xyram.daydrop.response.RazorPayRequest;
import com.xyram.daydrop.service.CustomerOrderPriceService;
import com.xyram.daydrop.service.CustomerOrderReplicaService;
import com.xyram.daydrop.util.HashEncoder;
import com.xyram.daydrop.util.RazorPay;
import com.xyram.daydrop.service.ConsumerService;

@Transactional
@Service
public class CustomerOrderReplicaServiceImpl implements CustomerOrderReplicaService {

	@Autowired
	CustomerOrderReplicaDoa customerOrderReplicaDoa;

	@Autowired
	ApartmentDao apartmentDao;

	@Autowired
	SheduleDao scheduleDao;

	@Autowired
	CustomerDetailsDao customerDetailsDao;

	@Autowired
	ConsumerService consumerService;

	@Autowired
	CurrentUser currentUser;

	@Autowired
	PhonepeServiceImpl phonepeServiceImpl;

	@Value("${merchant_id}")
	private String merchantId;

	@Value("${salt_key}")
	private String saltKey;

	@Value("${salt_index}")
	private String saltIndex;

	@Override
	public Map createCustomerOrderReplicaService(CustomerOrderReplicaRequest customerOrderReplicaRequest,
			String contactNumber, Integer aparmentId)

	{

		Map response = new HashedMap<>();

		response.put("message", "success");
		CustomerOrderReplica customerOrderReplica = null;

		if (customerOrderReplicaRequest.getCartId() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "cartId is mandatory ");
		}
		long razorPayCount = 0;
		if (customerOrderReplicaRequest.getOrderId() != null) {

			razorPayCount = customerOrderReplicaDoa.getRazorPayExistByCartId(customerOrderReplicaRequest.getOrderId());
		}

		if (customerOrderReplicaRequest.getCustomerDetails() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Order Details  is mandatory ");
		}

		customerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(customerOrderReplicaRequest.getCartId(),
				contactNumber);

		if (customerOrderReplica != null) {
			customerOrderReplica.setCartId(customerOrderReplica.getCartId());

			if (customerOrderReplica.isOrdered()) {
				throw new ResponseStatusException(HttpStatus.CONFLICT, "Your Order is Placed With cart Details");
			}

//			if (razorPayCount >= 1 && !(customerOrderReplica.getRazorPayOrderId() != null
//					&& customerOrderReplica.getRazorPayOrderId().equals(customerOrderReplicaRequest.getOrderId()))) {
//				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
//			}

			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);

			customerOrderReplica.setAttempts(customerOrderReplica.getAttempts() + 1);
			customerOrderReplica.setUpdatedTime(new Date());

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		} else {

			customerOrderReplica = new CustomerOrderReplica();
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);
			customerOrderReplica.setCartId(customerOrderReplicaRequest.getCartId());
			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());

			if (razorPayCount > 0) {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
			}

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			Schedule schedule = scheduleDao.getlatestScheduleCustomers();

			if (schedule != null) {

				try {
					customerOrderReplica.setSchedule(schedule.getsId() != null ? schedule.getsId().toString() : null);
				} catch (Exception e) {
					e.printStackTrace();
				}
			} else {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
						"Sorry We Are Not Accepting Any Order Right now");

			}

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		}

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicas(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String schedule = null;

		Map filter = request.containsKey("filters") ? (Map) request.get("filters") : null;
		if (filter != null) {
			statusType = filter.containsKey("statusType") ? ((String) filter.get("statusType")).toLowerCase() : null;
			searchQuery = filter.containsKey("searchQuery") ? ((String) filter.get("searchQuery")).toLowerCase() : null;
			schedule = filter.containsKey("schedule") ? (String.valueOf(filter.get("schedule"))) : null;

		}

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplica(searchQuery, statusType, schedule);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");

				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setStreetName(
						customers.get("streetName") != null ? (String) customers.get("streetName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicasBySchedule(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String scheduleId = null;

		Schedule schedule = scheduleDao.getlatestScheduleCustomers();

		if (schedule != null) {

			try {
				scheduleId = schedule.getsId() != null ? schedule.getsId().toString() : null;
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

		statusType = request.containsKey("statusType") ? ((String) request.get("statusType")).toLowerCase() : "Success";

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplicaBySchdeule(statusType, scheduleId);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");
				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				System.out.println("customers" + customers.get("customerName"));

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public CustomerOrderReplica getCustomerOrderReplicaByCartId(String cartId) {

		CustomerOrderReplica CustomerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(cartId,
				currentUser.getContactNumber());

		ObjectMapper objectMapper = new ObjectMapper();
		try {

			// convert JSON string to Map
			Map<String, Object> customerOrderReplicaMap = objectMapper
					.readValue(CustomerOrderReplica.getCustomerOrderDetails(), Map.class);

			Object customerOrder = customerOrderReplicaMap.get("customerOrder");
			Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

			Object quanityList = items.get("quantity");
			Map customers = customerDetailsDao.getByContactNumberAndApartment(CustomerOrderReplica.getContactNumber(),
					CustomerOrderReplica.getApartmentId());

			System.out.println("customers" + customers.get("customerName"));

			// Apartments apartments =
			// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
			CustomerOrderReplica.setApartmentName(
					customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

			CustomerOrderReplica.setCustomerDetails(customers);

			CustomerOrderReplica.setCustomerOrder(customerOrder);
			CustomerOrderReplica.setQuatityList(quanityList);

		} catch (Exception e) {
			e.printStackTrace();
		}

		return CustomerOrderReplica;

	}

	@Override
	public Map createCustomerOrderReplica(CustomerOrderReplicaRequest customerOrderReplicaRequest, String contactNumber,
			Integer aparmentId) {

		if (customerOrderReplicaRequest.getRazorPayRequest() != null) {

//			Map razorPay = consumerService.createRazorPayOrder(customerOrderReplicaRequest.getRazorPayRequest());
//			customerOrderReplicaRequest.setOrderId(razorPay.get("order") != null ? (String)((RazorPay) razorPay.get("order")).getId() : null);	
//	
//			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);
//
//			razorPay.put("cartId", customerOrderReplicaRequest.getCartId());

			Map customerOrderReplicaMap = new HashMap<>();

			Map orderId = new HashMap<>();
			String transactionId = getMerchantTransactionId();
			orderId.put("id", transactionId);

			customerOrderReplicaMap.put("order", orderId);

			customerOrderReplicaRequest.setOrderId(transactionId);
			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);

			customerOrderReplicaMap.put("cartId", customerOrderReplicaRequest.getCartId());

			try {
				customerOrderReplicaMap.put("phonePeResponse",
						phonepeServiceImpl.initiatePhonepePayment(transactionId,
								Integer.valueOf(customerOrderReplicaRequest.getRazorPayRequest().getAmount()),
								contactNumber, customerOrderReplicaRequest.getRedirectUrl(), customerOrderReplicaRequest.getCallBackUrl()));

			} catch (Exception e) {
				e.printStackTrace();
				customerOrderReplicaMap.put("phonePeResponse", new HashedMap<>());
			}

			return customerOrderReplicaMap;

		} else {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
					"paymentDetails transcation Details are mandatory");
		}

	}

	private static String getMerchantTransactionId() {

		return "OD_" + MerchantTransactionIdGenerator.getRandomString();
	}


	@Override
	public List<CustomerOrderReplica> getCustomerOrderByMoblieNo(String contactNumber, Integer aid) {

	    Schedule latestSchedule = customerOrderReplicaDoa.getlatestschedule();

	    if (latestSchedule != null && latestSchedule.getCreationTimestamp() != null) {
	        if (latestSchedule.getStatus().equals(UserStatus.ACTIVE)) {
	            Customers customer = customerDetailsDao.getByContactNoAndApartment(contactNumber, aid);

	            if (customer != null) { // Ensure the customer exists
	                List<CustomerOrder> customerOrderList = customerOrderReplicaDoa.getListCustomerOrderByCustomerId(customer.getCtId());

	                double totalOrderAmount = 0.0;

	                if (customerOrderList != null && !customerOrderList.isEmpty()) {
	                    for (CustomerOrder customerOrder : customerOrderList) {
	                        Double orderAmount = customerOrder.getAmount();
	                        if (orderAmount != null) {
	                            totalOrderAmount += orderAmount;
	                            if(totalOrderAmount>200) {
	                            	totalOrderAmount+= customerOrder.getDelivaryCharges();
	                            }
	                            else(totalOrderAmount<200){
	                            	totalOrderAmount-= customerOrder.getDelivaryCharges();
	                            }
	                        }
	                    }

	                    // Define the minimum order amount for applying delivery charges
	                    double minimumOrderAmount = 200.0;

	                    if (totalOrderAmount < minimumOrderAmount) {
	                        System.out.println("Delivery Charges will be applicable");
	                    } else {
	                        // No delivery charges applicable
	                        System.out.println("No Delivery charges applicable");
	                    }

	                    List<CustomerOrderReplica> customerOrderReplicas = new ArrayList<>();
	                    return customerOrderReplicas;
	                } else {
	                    return Collections.emptyList();
	                }
	            } else {
	                return null; // or an appropriate value
	            }
	        } else {
	            // Handle the case when the latest schedule is not active
	            return null; // or an appropriate value
	        }
	    } else {
	        // Handle the case when there is no latest schedule or its creation timestamp is null
	        return null; // or an appropriate value
	    }
	}

}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1003)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:799)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:743)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:666)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:658)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.lambda$0(LSJavaHoverProvider.java:68)
	at java.base/java.util.concurrent.CompletableFuture$AsyncRun.run(CompletableFuture.java:1804)
	at java.base/java.util.concurrent.CompletableFuture$AsyncRun.exec(CompletableFuture.java:1796)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:373)
	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1182)
	at java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1655)
	at java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1622)
	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:165)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-09-21 15:34:03.591
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1003)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:799)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:743)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:666)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:658)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.lambda$0(LSJavaHoverProvider.java:68)
	at java.base/java.util.concurrent.CompletableFuture$AsyncRun.run(CompletableFuture.java:1804)
	at java.base/java.util.concurrent.CompletableFuture$AsyncRun.exec(CompletableFuture.java:1796)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:373)
	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1182)
	at java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1655)
	at java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1622)
	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:165)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-09-21 15:34:03.593
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1003)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:799)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:743)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:666)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:658)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.lambda$0(LSJavaHoverProvider.java:68)
	at java.base/java.util.concurrent.CompletableFuture$AsyncRun.run(CompletableFuture.java:1804)
	at java.base/java.util.concurrent.CompletableFuture$AsyncRun.exec(CompletableFuture.java:1796)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:373)
	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1182)
	at java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1655)
	at java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1622)
	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:165)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-21 15:34:03.687
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.xyram.daydrop.serviceimpl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.transaction.Transactional;

import org.apache.commons.collections4.map.HashedMap;
import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.server.ResponseStatusException;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.xyram.daydrop.admin.model.CurrentUser;
import com.xyram.daydrop.basemodel.Base64Wrapper;
import com.xyram.daydrop.basemodel.MerchantTransactionIdGenerator;
import com.xyram.daydrop.basemodel.PhonepeSerializer;
import com.xyram.daydrop.dao.ApartmentDao;
import com.xyram.daydrop.dao.CustomerDetailsDao;
import com.xyram.daydrop.dao.CustomerOrderDao;
import com.xyram.daydrop.dao.CustomerOrderReplicaDoa;
import com.xyram.daydrop.dao.SheduleDao;
import com.xyram.daydrop.enumtypes.UserStatus;
import com.xyram.daydrop.model.Apartments;
import com.xyram.daydrop.model.CustomerOrder;
import com.xyram.daydrop.model.CustomerOrderReplica;
import com.xyram.daydrop.model.Customers;
import com.xyram.daydrop.model.Schedule;
import com.xyram.daydrop.modelMapper.PaymentInstrument;
import com.xyram.daydrop.modelMapper.PhonePePayModel;
import com.xyram.daydrop.request.CustomerOrderReplicaRequest;
import com.xyram.daydrop.response.RazorPayRequest;
import com.xyram.daydrop.service.CustomerOrderPriceService;
import com.xyram.daydrop.service.CustomerOrderReplicaService;
import com.xyram.daydrop.util.HashEncoder;
import com.xyram.daydrop.util.RazorPay;
import com.xyram.daydrop.service.ConsumerService;

@Transactional
@Service
public class CustomerOrderReplicaServiceImpl implements CustomerOrderReplicaService {

	@Autowired
	CustomerOrderReplicaDoa customerOrderReplicaDoa;

	@Autowired
	ApartmentDao apartmentDao;

	@Autowired
	SheduleDao scheduleDao;

	@Autowired
	CustomerDetailsDao customerDetailsDao;

	@Autowired
	ConsumerService consumerService;

	@Autowired
	CurrentUser currentUser;

	@Autowired
	PhonepeServiceImpl phonepeServiceImpl;

	@Value("${merchant_id}")
	private String merchantId;

	@Value("${salt_key}")
	private String saltKey;

	@Value("${salt_index}")
	private String saltIndex;

	@Override
	public Map createCustomerOrderReplicaService(CustomerOrderReplicaRequest customerOrderReplicaRequest,
			String contactNumber, Integer aparmentId)

	{

		Map response = new HashedMap<>();

		response.put("message", "success");
		CustomerOrderReplica customerOrderReplica = null;

		if (customerOrderReplicaRequest.getCartId() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "cartId is mandatory ");
		}
		long razorPayCount = 0;
		if (customerOrderReplicaRequest.getOrderId() != null) {

			razorPayCount = customerOrderReplicaDoa.getRazorPayExistByCartId(customerOrderReplicaRequest.getOrderId());
		}

		if (customerOrderReplicaRequest.getCustomerDetails() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Order Details  is mandatory ");
		}

		customerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(customerOrderReplicaRequest.getCartId(),
				contactNumber);

		if (customerOrderReplica != null) {
			customerOrderReplica.setCartId(customerOrderReplica.getCartId());

			if (customerOrderReplica.isOrdered()) {
				throw new ResponseStatusException(HttpStatus.CONFLICT, "Your Order is Placed With cart Details");
			}

//			if (razorPayCount >= 1 && !(customerOrderReplica.getRazorPayOrderId() != null
//					&& customerOrderReplica.getRazorPayOrderId().equals(customerOrderReplicaRequest.getOrderId()))) {
//				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
//			}

			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);

			customerOrderReplica.setAttempts(customerOrderReplica.getAttempts() + 1);
			customerOrderReplica.setUpdatedTime(new Date());

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		} else {

			customerOrderReplica = new CustomerOrderReplica();
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);
			customerOrderReplica.setCartId(customerOrderReplicaRequest.getCartId());
			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());

			if (razorPayCount > 0) {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
			}

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			Schedule schedule = scheduleDao.getlatestScheduleCustomers();

			if (schedule != null) {

				try {
					customerOrderReplica.setSchedule(schedule.getsId() != null ? schedule.getsId().toString() : null);
				} catch (Exception e) {
					e.printStackTrace();
				}
			} else {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
						"Sorry We Are Not Accepting Any Order Right now");

			}

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		}

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicas(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String schedule = null;

		Map filter = request.containsKey("filters") ? (Map) request.get("filters") : null;
		if (filter != null) {
			statusType = filter.containsKey("statusType") ? ((String) filter.get("statusType")).toLowerCase() : null;
			searchQuery = filter.containsKey("searchQuery") ? ((String) filter.get("searchQuery")).toLowerCase() : null;
			schedule = filter.containsKey("schedule") ? (String.valueOf(filter.get("schedule"))) : null;

		}

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplica(searchQuery, statusType, schedule);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");

				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setStreetName(
						customers.get("streetName") != null ? (String) customers.get("streetName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicasBySchedule(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String scheduleId = null;

		Schedule schedule = scheduleDao.getlatestScheduleCustomers();

		if (schedule != null) {

			try {
				scheduleId = schedule.getsId() != null ? schedule.getsId().toString() : null;
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

		statusType = request.containsKey("statusType") ? ((String) request.get("statusType")).toLowerCase() : "Success";

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplicaBySchdeule(statusType, scheduleId);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");
				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				System.out.println("customers" + customers.get("customerName"));

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public CustomerOrderReplica getCustomerOrderReplicaByCartId(String cartId) {

		CustomerOrderReplica CustomerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(cartId,
				currentUser.getContactNumber());

		ObjectMapper objectMapper = new ObjectMapper();
		try {

			// convert JSON string to Map
			Map<String, Object> customerOrderReplicaMap = objectMapper
					.readValue(CustomerOrderReplica.getCustomerOrderDetails(), Map.class);

			Object customerOrder = customerOrderReplicaMap.get("customerOrder");
			Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

			Object quanityList = items.get("quantity");
			Map customers = customerDetailsDao.getByContactNumberAndApartment(CustomerOrderReplica.getContactNumber(),
					CustomerOrderReplica.getApartmentId());

			System.out.println("customers" + customers.get("customerName"));

			// Apartments apartments =
			// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
			CustomerOrderReplica.setApartmentName(
					customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

			CustomerOrderReplica.setCustomerDetails(customers);

			CustomerOrderReplica.setCustomerOrder(customerOrder);
			CustomerOrderReplica.setQuatityList(quanityList);

		} catch (Exception e) {
			e.printStackTrace();
		}

		return CustomerOrderReplica;

	}

	@Override
	public Map createCustomerOrderReplica(CustomerOrderReplicaRequest customerOrderReplicaRequest, String contactNumber,
			Integer aparmentId) {

		if (customerOrderReplicaRequest.getRazorPayRequest() != null) {

//			Map razorPay = consumerService.createRazorPayOrder(customerOrderReplicaRequest.getRazorPayRequest());
//			customerOrderReplicaRequest.setOrderId(razorPay.get("order") != null ? (String)((RazorPay) razorPay.get("order")).getId() : null);	
//	
//			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);
//
//			razorPay.put("cartId", customerOrderReplicaRequest.getCartId());

			Map customerOrderReplicaMap = new HashMap<>();

			Map orderId = new HashMap<>();
			String transactionId = getMerchantTransactionId();
			orderId.put("id", transactionId);

			customerOrderReplicaMap.put("order", orderId);

			customerOrderReplicaRequest.setOrderId(transactionId);
			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);

			customerOrderReplicaMap.put("cartId", customerOrderReplicaRequest.getCartId());

			try {
				customerOrderReplicaMap.put("phonePeResponse",
						phonepeServiceImpl.initiatePhonepePayment(transactionId,
								Integer.valueOf(customerOrderReplicaRequest.getRazorPayRequest().getAmount()),
								contactNumber, customerOrderReplicaRequest.getRedirectUrl(), customerOrderReplicaRequest.getCallBackUrl()));

			} catch (Exception e) {
				e.printStackTrace();
				customerOrderReplicaMap.put("phonePeResponse", new HashedMap<>());
			}

			return customerOrderReplicaMap;

		} else {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
					"paymentDetails transcation Details are mandatory");
		}

	}

	private static String getMerchantTransactionId() {

		return "OD_" + MerchantTransactionIdGenerator.getRandomString();
	}


	@Override
	public List<CustomerOrderReplica> getCustomerOrderByMoblieNo(String contactNumber, Integer aid) {

	    Schedule latestSchedule = customerOrderReplicaDoa.getlatestschedule();

	    if (latestSchedule != null && latestSchedule.getCreationTimestamp() != null) {
	        if (latestSchedule.getStatus().equals(UserStatus.ACTIVE)) {
	            Customers customer = customerDetailsDao.getByContactNoAndApartment(contactNumber, aid);

	            if (customer != null) { // Ensure the customer exists
	                List<CustomerOrder> customerOrderList = customerOrderReplicaDoa.getListCustomerOrderByCustomerId(customer.getCtId());

	                double totalOrderAmount = 0.0;

	                if (customerOrderList != null && !customerOrderList.isEmpty()) {
	                    for (CustomerOrder customerOrder : customerOrderList) {
	                        Double orderAmount = customerOrder.getAmount();
	                        if (orderAmount != null) {
	                            totalOrderAmount += orderAmount;
	                            if(totalOrderAmount>200) {
	                            	totalOrderAmount+= customerOrder.getDelivaryCharges();
	                            }
	                            else(totalOrderAmount<200){
	                            	totalOrderAmount-= customerOrder.getDelivaryCharges();
	                            }
	                        }
	                    }

	                    // Define the minimum order amount for applying delivery charges
	                    double minimumOrderAmount = 200.0;

	                    if (totalOrderAmount < minimumOrderAmount) {
	                        System.out.println("Delivery Charges will be applicable");
	                    } else {
	                        // No delivery charges applicable
	                        System.out.println("No Delivery charges applicable");
	                    }

	                    List<CustomerOrderReplica> customerOrderReplicas = new ArrayList<>();
	                    return customerOrderReplicas;
	                } else {
	                    return Collections.emptyList();
	                }
	            } else {
	                return null; // or an appropriate value
	            }
	        } else {
	            // Handle the case when the latest schedule is not active
	            return null; // or an appropriate value
	        }
	    } else {
	        // Handle the case when there is no latest schedule or its creation timestamp is null
	        return null; // or an appropriate value
	    }
	}

}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4035)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3635)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-09-21 15:34:03.690
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4035)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3635)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-09-21 15:34:03.692
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4035)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3635)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-21 15:34:03.751
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.xyram.daydrop.serviceimpl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.transaction.Transactional;

import org.apache.commons.collections4.map.HashedMap;
import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.server.ResponseStatusException;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.xyram.daydrop.admin.model.CurrentUser;
import com.xyram.daydrop.basemodel.Base64Wrapper;
import com.xyram.daydrop.basemodel.MerchantTransactionIdGenerator;
import com.xyram.daydrop.basemodel.PhonepeSerializer;
import com.xyram.daydrop.dao.ApartmentDao;
import com.xyram.daydrop.dao.CustomerDetailsDao;
import com.xyram.daydrop.dao.CustomerOrderDao;
import com.xyram.daydrop.dao.CustomerOrderReplicaDoa;
import com.xyram.daydrop.dao.SheduleDao;
import com.xyram.daydrop.enumtypes.UserStatus;
import com.xyram.daydrop.model.Apartments;
import com.xyram.daydrop.model.CustomerOrder;
import com.xyram.daydrop.model.CustomerOrderReplica;
import com.xyram.daydrop.model.Customers;
import com.xyram.daydrop.model.Schedule;
import com.xyram.daydrop.modelMapper.PaymentInstrument;
import com.xyram.daydrop.modelMapper.PhonePePayModel;
import com.xyram.daydrop.request.CustomerOrderReplicaRequest;
import com.xyram.daydrop.response.RazorPayRequest;
import com.xyram.daydrop.service.CustomerOrderPriceService;
import com.xyram.daydrop.service.CustomerOrderReplicaService;
import com.xyram.daydrop.util.HashEncoder;
import com.xyram.daydrop.util.RazorPay;
import com.xyram.daydrop.service.ConsumerService;

@Transactional
@Service
public class CustomerOrderReplicaServiceImpl implements CustomerOrderReplicaService {

	@Autowired
	CustomerOrderReplicaDoa customerOrderReplicaDoa;

	@Autowired
	ApartmentDao apartmentDao;

	@Autowired
	SheduleDao scheduleDao;

	@Autowired
	CustomerDetailsDao customerDetailsDao;

	@Autowired
	ConsumerService consumerService;

	@Autowired
	CurrentUser currentUser;

	@Autowired
	PhonepeServiceImpl phonepeServiceImpl;

	@Value("${merchant_id}")
	private String merchantId;

	@Value("${salt_key}")
	private String saltKey;

	@Value("${salt_index}")
	private String saltIndex;

	@Override
	public Map createCustomerOrderReplicaService(CustomerOrderReplicaRequest customerOrderReplicaRequest,
			String contactNumber, Integer aparmentId)

	{

		Map response = new HashedMap<>();

		response.put("message", "success");
		CustomerOrderReplica customerOrderReplica = null;

		if (customerOrderReplicaRequest.getCartId() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "cartId is mandatory ");
		}
		long razorPayCount = 0;
		if (customerOrderReplicaRequest.getOrderId() != null) {

			razorPayCount = customerOrderReplicaDoa.getRazorPayExistByCartId(customerOrderReplicaRequest.getOrderId());
		}

		if (customerOrderReplicaRequest.getCustomerDetails() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Order Details  is mandatory ");
		}

		customerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(customerOrderReplicaRequest.getCartId(),
				contactNumber);

		if (customerOrderReplica != null) {
			customerOrderReplica.setCartId(customerOrderReplica.getCartId());

			if (customerOrderReplica.isOrdered()) {
				throw new ResponseStatusException(HttpStatus.CONFLICT, "Your Order is Placed With cart Details");
			}

//			if (razorPayCount >= 1 && !(customerOrderReplica.getRazorPayOrderId() != null
//					&& customerOrderReplica.getRazorPayOrderId().equals(customerOrderReplicaRequest.getOrderId()))) {
//				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
//			}

			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);

			customerOrderReplica.setAttempts(customerOrderReplica.getAttempts() + 1);
			customerOrderReplica.setUpdatedTime(new Date());

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		} else {

			customerOrderReplica = new CustomerOrderReplica();
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);
			customerOrderReplica.setCartId(customerOrderReplicaRequest.getCartId());
			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());

			if (razorPayCount > 0) {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
			}

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			Schedule schedule = scheduleDao.getlatestScheduleCustomers();

			if (schedule != null) {

				try {
					customerOrderReplica.setSchedule(schedule.getsId() != null ? schedule.getsId().toString() : null);
				} catch (Exception e) {
					e.printStackTrace();
				}
			} else {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
						"Sorry We Are Not Accepting Any Order Right now");

			}

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		}

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicas(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String schedule = null;

		Map filter = request.containsKey("filters") ? (Map) request.get("filters") : null;
		if (filter != null) {
			statusType = filter.containsKey("statusType") ? ((String) filter.get("statusType")).toLowerCase() : null;
			searchQuery = filter.containsKey("searchQuery") ? ((String) filter.get("searchQuery")).toLowerCase() : null;
			schedule = filter.containsKey("schedule") ? (String.valueOf(filter.get("schedule"))) : null;

		}

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplica(searchQuery, statusType, schedule);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");

				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setStreetName(
						customers.get("streetName") != null ? (String) customers.get("streetName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicasBySchedule(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String scheduleId = null;

		Schedule schedule = scheduleDao.getlatestScheduleCustomers();

		if (schedule != null) {

			try {
				scheduleId = schedule.getsId() != null ? schedule.getsId().toString() : null;
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

		statusType = request.containsKey("statusType") ? ((String) request.get("statusType")).toLowerCase() : "Success";

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplicaBySchdeule(statusType, scheduleId);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");
				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				System.out.println("customers" + customers.get("customerName"));

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public CustomerOrderReplica getCustomerOrderReplicaByCartId(String cartId) {

		CustomerOrderReplica CustomerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(cartId,
				currentUser.getContactNumber());

		ObjectMapper objectMapper = new ObjectMapper();
		try {

			// convert JSON string to Map
			Map<String, Object> customerOrderReplicaMap = objectMapper
					.readValue(CustomerOrderReplica.getCustomerOrderDetails(), Map.class);

			Object customerOrder = customerOrderReplicaMap.get("customerOrder");
			Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

			Object quanityList = items.get("quantity");
			Map customers = customerDetailsDao.getByContactNumberAndApartment(CustomerOrderReplica.getContactNumber(),
					CustomerOrderReplica.getApartmentId());

			System.out.println("customers" + customers.get("customerName"));

			// Apartments apartments =
			// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
			CustomerOrderReplica.setApartmentName(
					customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

			CustomerOrderReplica.setCustomerDetails(customers);

			CustomerOrderReplica.setCustomerOrder(customerOrder);
			CustomerOrderReplica.setQuatityList(quanityList);

		} catch (Exception e) {
			e.printStackTrace();
		}

		return CustomerOrderReplica;

	}

	@Override
	public Map createCustomerOrderReplica(CustomerOrderReplicaRequest customerOrderReplicaRequest, String contactNumber,
			Integer aparmentId) {

		if (customerOrderReplicaRequest.getRazorPayRequest() != null) {

//			Map razorPay = consumerService.createRazorPayOrder(customerOrderReplicaRequest.getRazorPayRequest());
//			customerOrderReplicaRequest.setOrderId(razorPay.get("order") != null ? (String)((RazorPay) razorPay.get("order")).getId() : null);	
//	
//			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);
//
//			razorPay.put("cartId", customerOrderReplicaRequest.getCartId());

			Map customerOrderReplicaMap = new HashMap<>();

			Map orderId = new HashMap<>();
			String transactionId = getMerchantTransactionId();
			orderId.put("id", transactionId);

			customerOrderReplicaMap.put("order", orderId);

			customerOrderReplicaRequest.setOrderId(transactionId);
			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);

			customerOrderReplicaMap.put("cartId", customerOrderReplicaRequest.getCartId());

			try {
				customerOrderReplicaMap.put("phonePeResponse",
						phonepeServiceImpl.initiatePhonepePayment(transactionId,
								Integer.valueOf(customerOrderReplicaRequest.getRazorPayRequest().getAmount()),
								contactNumber, customerOrderReplicaRequest.getRedirectUrl(), customerOrderReplicaRequest.getCallBackUrl()));

			} catch (Exception e) {
				e.printStackTrace();
				customerOrderReplicaMap.put("phonePeResponse", new HashedMap<>());
			}

			return customerOrderReplicaMap;

		} else {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
					"paymentDetails transcation Details are mandatory");
		}

	}

	private static String getMerchantTransactionId() {

		return "OD_" + MerchantTransactionIdGenerator.getRandomString();
	}


	@Override
	public List<CustomerOrderReplica> getCustomerOrderByMoblieNo(String contactNumber, Integer aid) {

	    Schedule latestSchedule = customerOrderReplicaDoa.getlatestschedule();

	    if (latestSchedule != null && latestSchedule.getCreationTimestamp() != null) {
	        if (latestSchedule.getStatus().equals(UserStatus.ACTIVE)) {
	            Customers customer = customerDetailsDao.getByContactNoAndApartment(contactNumber, aid);

	            if (customer != null) { // Ensure the customer exists
	                List<CustomerOrder> customerOrderList = customerOrderReplicaDoa.getListCustomerOrderByCustomerId(customer.getCtId());

	                double totalOrderAmount = 0.0;

	                if (customerOrderList != null && !customerOrderList.isEmpty()) {
	                    for (CustomerOrder customerOrder : customerOrderList) {
	                        Double orderAmount = customerOrder.getAmount();
	                        if (orderAmount != null) {
	                            totalOrderAmount += orderAmount;
	                            if(totalOrderAmount>200) {
	                            	totalOrderAmount+= customerOrder.getDelivaryCharges();
	                            }
	                            else(totalOrderAmount<200){
	                            	totalOrderAmount-= customerOrder.getDelivaryCharges();
	                            }
	                        }
	                    }

	                    // Define the minimum order amount for applying delivery charges
	                    double minimumOrderAmount = 200.0;

	                    if (totalOrderAmount < minimumOrderAmount) {
	                        System.out.println("Delivery Charges will be applicable");
	                    } else {
	                        // No delivery charges applicable
	                        System.out.println("No Delivery charges applicable");
	                    }

	                    List<CustomerOrderReplica> customerOrderReplicas = new ArrayList<>();
	                    return customerOrderReplicas;
	                } else {
	                    return Collections.emptyList();
	                }
	            } else {
	                return null; // or an appropriate value
	            }
	        } else {
	            // Handle the case when the latest schedule is not active
	            return null; // or an appropriate value
	        }
	    } else {
	        // Handle the case when there is no latest schedule or its creation timestamp is null
	        return null; // or an appropriate value
	    }
	}

}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.internal.core.manipulation.dom.ASTResolving.createQuickFixAST(ASTResolving.java:1052)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:131)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4035)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3635)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.ui 4 0 2023-09-21 15:34:03.754
!MESSAGE Unhandled event loop exception
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.internal.core.manipulation.dom.ASTResolving.createQuickFixAST(ASTResolving.java:1052)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:131)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4035)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3635)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-21 15:34:05.347
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.xyram.daydrop.serviceimpl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.transaction.Transactional;

import org.apache.commons.collections4.map.HashedMap;
import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.server.ResponseStatusException;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.xyram.daydrop.admin.model.CurrentUser;
import com.xyram.daydrop.basemodel.Base64Wrapper;
import com.xyram.daydrop.basemodel.MerchantTransactionIdGenerator;
import com.xyram.daydrop.basemodel.PhonepeSerializer;
import com.xyram.daydrop.dao.ApartmentDao;
import com.xyram.daydrop.dao.CustomerDetailsDao;
import com.xyram.daydrop.dao.CustomerOrderDao;
import com.xyram.daydrop.dao.CustomerOrderReplicaDoa;
import com.xyram.daydrop.dao.SheduleDao;
import com.xyram.daydrop.enumtypes.UserStatus;
import com.xyram.daydrop.model.Apartments;
import com.xyram.daydrop.model.CustomerOrder;
import com.xyram.daydrop.model.CustomerOrderReplica;
import com.xyram.daydrop.model.Customers;
import com.xyram.daydrop.model.Schedule;
import com.xyram.daydrop.modelMapper.PaymentInstrument;
import com.xyram.daydrop.modelMapper.PhonePePayModel;
import com.xyram.daydrop.request.CustomerOrderReplicaRequest;
import com.xyram.daydrop.response.RazorPayRequest;
import com.xyram.daydrop.service.CustomerOrderPriceService;
import com.xyram.daydrop.service.CustomerOrderReplicaService;
import com.xyram.daydrop.util.HashEncoder;
import com.xyram.daydrop.util.RazorPay;
import com.xyram.daydrop.service.ConsumerService;

@Transactional
@Service
public class CustomerOrderReplicaServiceImpl implements CustomerOrderReplicaService {

	@Autowired
	CustomerOrderReplicaDoa customerOrderReplicaDoa;

	@Autowired
	ApartmentDao apartmentDao;

	@Autowired
	SheduleDao scheduleDao;

	@Autowired
	CustomerDetailsDao customerDetailsDao;

	@Autowired
	ConsumerService consumerService;

	@Autowired
	CurrentUser currentUser;

	@Autowired
	PhonepeServiceImpl phonepeServiceImpl;

	@Value("${merchant_id}")
	private String merchantId;

	@Value("${salt_key}")
	private String saltKey;

	@Value("${salt_index}")
	private String saltIndex;

	@Override
	public Map createCustomerOrderReplicaService(CustomerOrderReplicaRequest customerOrderReplicaRequest,
			String contactNumber, Integer aparmentId)

	{

		Map response = new HashedMap<>();

		response.put("message", "success");
		CustomerOrderReplica customerOrderReplica = null;

		if (customerOrderReplicaRequest.getCartId() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "cartId is mandatory ");
		}
		long razorPayCount = 0;
		if (customerOrderReplicaRequest.getOrderId() != null) {

			razorPayCount = customerOrderReplicaDoa.getRazorPayExistByCartId(customerOrderReplicaRequest.getOrderId());
		}

		if (customerOrderReplicaRequest.getCustomerDetails() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Order Details  is mandatory ");
		}

		customerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(customerOrderReplicaRequest.getCartId(),
				contactNumber);

		if (customerOrderReplica != null) {
			customerOrderReplica.setCartId(customerOrderReplica.getCartId());

			if (customerOrderReplica.isOrdered()) {
				throw new ResponseStatusException(HttpStatus.CONFLICT, "Your Order is Placed With cart Details");
			}

//			if (razorPayCount >= 1 && !(customerOrderReplica.getRazorPayOrderId() != null
//					&& customerOrderReplica.getRazorPayOrderId().equals(customerOrderReplicaRequest.getOrderId()))) {
//				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
//			}

			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);

			customerOrderReplica.setAttempts(customerOrderReplica.getAttempts() + 1);
			customerOrderReplica.setUpdatedTime(new Date());

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		} else {

			customerOrderReplica = new CustomerOrderReplica();
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);
			customerOrderReplica.setCartId(customerOrderReplicaRequest.getCartId());
			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());

			if (razorPayCount > 0) {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
			}

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			Schedule schedule = scheduleDao.getlatestScheduleCustomers();

			if (schedule != null) {

				try {
					customerOrderReplica.setSchedule(schedule.getsId() != null ? schedule.getsId().toString() : null);
				} catch (Exception e) {
					e.printStackTrace();
				}
			} else {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
						"Sorry We Are Not Accepting Any Order Right now");

			}

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		}

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicas(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String schedule = null;

		Map filter = request.containsKey("filters") ? (Map) request.get("filters") : null;
		if (filter != null) {
			statusType = filter.containsKey("statusType") ? ((String) filter.get("statusType")).toLowerCase() : null;
			searchQuery = filter.containsKey("searchQuery") ? ((String) filter.get("searchQuery")).toLowerCase() : null;
			schedule = filter.containsKey("schedule") ? (String.valueOf(filter.get("schedule"))) : null;

		}

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplica(searchQuery, statusType, schedule);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");

				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setStreetName(
						customers.get("streetName") != null ? (String) customers.get("streetName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicasBySchedule(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String scheduleId = null;

		Schedule schedule = scheduleDao.getlatestScheduleCustomers();

		if (schedule != null) {

			try {
				scheduleId = schedule.getsId() != null ? schedule.getsId().toString() : null;
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

		statusType = request.containsKey("statusType") ? ((String) request.get("statusType")).toLowerCase() : "Success";

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplicaBySchdeule(statusType, scheduleId);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");
				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				System.out.println("customers" + customers.get("customerName"));

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public CustomerOrderReplica getCustomerOrderReplicaByCartId(String cartId) {

		CustomerOrderReplica CustomerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(cartId,
				currentUser.getContactNumber());

		ObjectMapper objectMapper = new ObjectMapper();
		try {

			// convert JSON string to Map
			Map<String, Object> customerOrderReplicaMap = objectMapper
					.readValue(CustomerOrderReplica.getCustomerOrderDetails(), Map.class);

			Object customerOrder = customerOrderReplicaMap.get("customerOrder");
			Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

			Object quanityList = items.get("quantity");
			Map customers = customerDetailsDao.getByContactNumberAndApartment(CustomerOrderReplica.getContactNumber(),
					CustomerOrderReplica.getApartmentId());

			System.out.println("customers" + customers.get("customerName"));

			// Apartments apartments =
			// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
			CustomerOrderReplica.setApartmentName(
					customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

			CustomerOrderReplica.setCustomerDetails(customers);

			CustomerOrderReplica.setCustomerOrder(customerOrder);
			CustomerOrderReplica.setQuatityList(quanityList);

		} catch (Exception e) {
			e.printStackTrace();
		}

		return CustomerOrderReplica;

	}

	@Override
	public Map createCustomerOrderReplica(CustomerOrderReplicaRequest customerOrderReplicaRequest, String contactNumber,
			Integer aparmentId) {

		if (customerOrderReplicaRequest.getRazorPayRequest() != null) {

//			Map razorPay = consumerService.createRazorPayOrder(customerOrderReplicaRequest.getRazorPayRequest());
//			customerOrderReplicaRequest.setOrderId(razorPay.get("order") != null ? (String)((RazorPay) razorPay.get("order")).getId() : null);	
//	
//			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);
//
//			razorPay.put("cartId", customerOrderReplicaRequest.getCartId());

			Map customerOrderReplicaMap = new HashMap<>();

			Map orderId = new HashMap<>();
			String transactionId = getMerchantTransactionId();
			orderId.put("id", transactionId);

			customerOrderReplicaMap.put("order", orderId);

			customerOrderReplicaRequest.setOrderId(transactionId);
			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);

			customerOrderReplicaMap.put("cartId", customerOrderReplicaRequest.getCartId());

			try {
				customerOrderReplicaMap.put("phonePeResponse",
						phonepeServiceImpl.initiatePhonepePayment(transactionId,
								Integer.valueOf(customerOrderReplicaRequest.getRazorPayRequest().getAmount()),
								contactNumber, customerOrderReplicaRequest.getRedirectUrl(), customerOrderReplicaRequest.getCallBackUrl()));

			} catch (Exception e) {
				e.printStackTrace();
				customerOrderReplicaMap.put("phonePeResponse", new HashedMap<>());
			}

			return customerOrderReplicaMap;

		} else {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
					"paymentDetails transcation Details are mandatory");
		}

	}

	private static String getMerchantTransactionId() {

		return "OD_" + MerchantTransactionIdGenerator.getRandomString();
	}


	@Override
	public List<CustomerOrderReplica> getCustomerOrderByMoblieNo(String contactNumber, Integer aid) {

	    Schedule latestSchedule = customerOrderReplicaDoa.getlatestschedule();

	    if (latestSchedule != null && latestSchedule.getCreationTimestamp() != null) {
	        if (latestSchedule.getStatus().equals(UserStatus.ACTIVE)) {
	            Customers customer = customerDetailsDao.getByContactNoAndApartment(contactNumber, aid);

	            if (customer != null) { // Ensure the customer exists
	                List<CustomerOrder> customerOrderList = customerOrderReplicaDoa.getListCustomerOrderByCustomerId(customer.getCtId());

	                double totalOrderAmount = 0.0;

	                if (customerOrderList != null && !customerOrderList.isEmpty()) {
	                    for (CustomerOrder customerOrder : customerOrderList) {
	                        Double orderAmount = customerOrder.getAmount();
	                        if (orderAmount != null) {
	                            totalOrderAmount += orderAmount;
	                            if(totalOrderAmount>200) {
	                            	totalOrderAmount+= customerOrder.getDelivaryCharges();
	                            }
	                            else(totalOrderAmount<200){
	                            	totalOrderAmount-= customerOrder.getDelivaryCharges();
	                            }
	                        }
	                    }

	                    // Define the minimum order amount for applying delivery charges
	                    double minimumOrderAmount = 200.0;

	                    if (totalOrderAmount < minimumOrderAmount) {
	                        System.out.println("Delivery Charges will be applicable");
	                    } else {
	                        // No delivery charges applicable
	                        System.out.println("No Delivery charges applicable");
	                    }

	                    List<CustomerOrderReplica> customerOrderReplicas = new ArrayList<>();
	                    return customerOrderReplicas;
	                } else {
	                    return Collections.emptyList();
	                }
	            } else {
	                return null; // or an appropriate value
	            }
	        } else {
	            // Handle the case when the latest schedule is not active
	            return null; // or an appropriate value
	        }
	    } else {
	        // Handle the case when there is no latest schedule or its creation timestamp is null
	        return null; // or an appropriate value
	    }
	}

}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4035)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3635)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-09-21 15:34:05.349
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4035)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3635)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-09-21 15:34:05.351
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4035)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3635)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-21 15:34:05.409
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.xyram.daydrop.serviceimpl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.transaction.Transactional;

import org.apache.commons.collections4.map.HashedMap;
import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.server.ResponseStatusException;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.xyram.daydrop.admin.model.CurrentUser;
import com.xyram.daydrop.basemodel.Base64Wrapper;
import com.xyram.daydrop.basemodel.MerchantTransactionIdGenerator;
import com.xyram.daydrop.basemodel.PhonepeSerializer;
import com.xyram.daydrop.dao.ApartmentDao;
import com.xyram.daydrop.dao.CustomerDetailsDao;
import com.xyram.daydrop.dao.CustomerOrderDao;
import com.xyram.daydrop.dao.CustomerOrderReplicaDoa;
import com.xyram.daydrop.dao.SheduleDao;
import com.xyram.daydrop.enumtypes.UserStatus;
import com.xyram.daydrop.model.Apartments;
import com.xyram.daydrop.model.CustomerOrder;
import com.xyram.daydrop.model.CustomerOrderReplica;
import com.xyram.daydrop.model.Customers;
import com.xyram.daydrop.model.Schedule;
import com.xyram.daydrop.modelMapper.PaymentInstrument;
import com.xyram.daydrop.modelMapper.PhonePePayModel;
import com.xyram.daydrop.request.CustomerOrderReplicaRequest;
import com.xyram.daydrop.response.RazorPayRequest;
import com.xyram.daydrop.service.CustomerOrderPriceService;
import com.xyram.daydrop.service.CustomerOrderReplicaService;
import com.xyram.daydrop.util.HashEncoder;
import com.xyram.daydrop.util.RazorPay;
import com.xyram.daydrop.service.ConsumerService;

@Transactional
@Service
public class CustomerOrderReplicaServiceImpl implements CustomerOrderReplicaService {

	@Autowired
	CustomerOrderReplicaDoa customerOrderReplicaDoa;

	@Autowired
	ApartmentDao apartmentDao;

	@Autowired
	SheduleDao scheduleDao;

	@Autowired
	CustomerDetailsDao customerDetailsDao;

	@Autowired
	ConsumerService consumerService;

	@Autowired
	CurrentUser currentUser;

	@Autowired
	PhonepeServiceImpl phonepeServiceImpl;

	@Value("${merchant_id}")
	private String merchantId;

	@Value("${salt_key}")
	private String saltKey;

	@Value("${salt_index}")
	private String saltIndex;

	@Override
	public Map createCustomerOrderReplicaService(CustomerOrderReplicaRequest customerOrderReplicaRequest,
			String contactNumber, Integer aparmentId)

	{

		Map response = new HashedMap<>();

		response.put("message", "success");
		CustomerOrderReplica customerOrderReplica = null;

		if (customerOrderReplicaRequest.getCartId() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "cartId is mandatory ");
		}
		long razorPayCount = 0;
		if (customerOrderReplicaRequest.getOrderId() != null) {

			razorPayCount = customerOrderReplicaDoa.getRazorPayExistByCartId(customerOrderReplicaRequest.getOrderId());
		}

		if (customerOrderReplicaRequest.getCustomerDetails() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Order Details  is mandatory ");
		}

		customerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(customerOrderReplicaRequest.getCartId(),
				contactNumber);

		if (customerOrderReplica != null) {
			customerOrderReplica.setCartId(customerOrderReplica.getCartId());

			if (customerOrderReplica.isOrdered()) {
				throw new ResponseStatusException(HttpStatus.CONFLICT, "Your Order is Placed With cart Details");
			}

//			if (razorPayCount >= 1 && !(customerOrderReplica.getRazorPayOrderId() != null
//					&& customerOrderReplica.getRazorPayOrderId().equals(customerOrderReplicaRequest.getOrderId()))) {
//				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
//			}

			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);

			customerOrderReplica.setAttempts(customerOrderReplica.getAttempts() + 1);
			customerOrderReplica.setUpdatedTime(new Date());

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		} else {

			customerOrderReplica = new CustomerOrderReplica();
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);
			customerOrderReplica.setCartId(customerOrderReplicaRequest.getCartId());
			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());

			if (razorPayCount > 0) {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
			}

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			Schedule schedule = scheduleDao.getlatestScheduleCustomers();

			if (schedule != null) {

				try {
					customerOrderReplica.setSchedule(schedule.getsId() != null ? schedule.getsId().toString() : null);
				} catch (Exception e) {
					e.printStackTrace();
				}
			} else {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
						"Sorry We Are Not Accepting Any Order Right now");

			}

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		}

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicas(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String schedule = null;

		Map filter = request.containsKey("filters") ? (Map) request.get("filters") : null;
		if (filter != null) {
			statusType = filter.containsKey("statusType") ? ((String) filter.get("statusType")).toLowerCase() : null;
			searchQuery = filter.containsKey("searchQuery") ? ((String) filter.get("searchQuery")).toLowerCase() : null;
			schedule = filter.containsKey("schedule") ? (String.valueOf(filter.get("schedule"))) : null;

		}

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplica(searchQuery, statusType, schedule);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");

				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setStreetName(
						customers.get("streetName") != null ? (String) customers.get("streetName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicasBySchedule(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String scheduleId = null;

		Schedule schedule = scheduleDao.getlatestScheduleCustomers();

		if (schedule != null) {

			try {
				scheduleId = schedule.getsId() != null ? schedule.getsId().toString() : null;
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

		statusType = request.containsKey("statusType") ? ((String) request.get("statusType")).toLowerCase() : "Success";

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplicaBySchdeule(statusType, scheduleId);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");
				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				System.out.println("customers" + customers.get("customerName"));

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public CustomerOrderReplica getCustomerOrderReplicaByCartId(String cartId) {

		CustomerOrderReplica CustomerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(cartId,
				currentUser.getContactNumber());

		ObjectMapper objectMapper = new ObjectMapper();
		try {

			// convert JSON string to Map
			Map<String, Object> customerOrderReplicaMap = objectMapper
					.readValue(CustomerOrderReplica.getCustomerOrderDetails(), Map.class);

			Object customerOrder = customerOrderReplicaMap.get("customerOrder");
			Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

			Object quanityList = items.get("quantity");
			Map customers = customerDetailsDao.getByContactNumberAndApartment(CustomerOrderReplica.getContactNumber(),
					CustomerOrderReplica.getApartmentId());

			System.out.println("customers" + customers.get("customerName"));

			// Apartments apartments =
			// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
			CustomerOrderReplica.setApartmentName(
					customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

			CustomerOrderReplica.setCustomerDetails(customers);

			CustomerOrderReplica.setCustomerOrder(customerOrder);
			CustomerOrderReplica.setQuatityList(quanityList);

		} catch (Exception e) {
			e.printStackTrace();
		}

		return CustomerOrderReplica;

	}

	@Override
	public Map createCustomerOrderReplica(CustomerOrderReplicaRequest customerOrderReplicaRequest, String contactNumber,
			Integer aparmentId) {

		if (customerOrderReplicaRequest.getRazorPayRequest() != null) {

//			Map razorPay = consumerService.createRazorPayOrder(customerOrderReplicaRequest.getRazorPayRequest());
//			customerOrderReplicaRequest.setOrderId(razorPay.get("order") != null ? (String)((RazorPay) razorPay.get("order")).getId() : null);	
//	
//			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);
//
//			razorPay.put("cartId", customerOrderReplicaRequest.getCartId());

			Map customerOrderReplicaMap = new HashMap<>();

			Map orderId = new HashMap<>();
			String transactionId = getMerchantTransactionId();
			orderId.put("id", transactionId);

			customerOrderReplicaMap.put("order", orderId);

			customerOrderReplicaRequest.setOrderId(transactionId);
			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);

			customerOrderReplicaMap.put("cartId", customerOrderReplicaRequest.getCartId());

			try {
				customerOrderReplicaMap.put("phonePeResponse",
						phonepeServiceImpl.initiatePhonepePayment(transactionId,
								Integer.valueOf(customerOrderReplicaRequest.getRazorPayRequest().getAmount()),
								contactNumber, customerOrderReplicaRequest.getRedirectUrl(), customerOrderReplicaRequest.getCallBackUrl()));

			} catch (Exception e) {
				e.printStackTrace();
				customerOrderReplicaMap.put("phonePeResponse", new HashedMap<>());
			}

			return customerOrderReplicaMap;

		} else {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
					"paymentDetails transcation Details are mandatory");
		}

	}

	private static String getMerchantTransactionId() {

		return "OD_" + MerchantTransactionIdGenerator.getRandomString();
	}


	@Override
	public List<CustomerOrderReplica> getCustomerOrderByMoblieNo(String contactNumber, Integer aid) {

	    Schedule latestSchedule = customerOrderReplicaDoa.getlatestschedule();

	    if (latestSchedule != null && latestSchedule.getCreationTimestamp() != null) {
	        if (latestSchedule.getStatus().equals(UserStatus.ACTIVE)) {
	            Customers customer = customerDetailsDao.getByContactNoAndApartment(contactNumber, aid);

	            if (customer != null) { // Ensure the customer exists
	                List<CustomerOrder> customerOrderList = customerOrderReplicaDoa.getListCustomerOrderByCustomerId(customer.getCtId());

	                double totalOrderAmount = 0.0;

	                if (customerOrderList != null && !customerOrderList.isEmpty()) {
	                    for (CustomerOrder customerOrder : customerOrderList) {
	                        Double orderAmount = customerOrder.getAmount();
	                        if (orderAmount != null) {
	                            totalOrderAmount += orderAmount;
	                            if(totalOrderAmount>200) {
	                            	totalOrderAmount+= customerOrder.getDelivaryCharges();
	                            }
	                            else(totalOrderAmount<200){
	                            	totalOrderAmount-= customerOrder.getDelivaryCharges();
	                            }
	                        }
	                    }

	                    // Define the minimum order amount for applying delivery charges
	                    double minimumOrderAmount = 200.0;

	                    if (totalOrderAmount < minimumOrderAmount) {
	                        System.out.println("Delivery Charges will be applicable");
	                    } else {
	                        // No delivery charges applicable
	                        System.out.println("No Delivery charges applicable");
	                    }

	                    List<CustomerOrderReplica> customerOrderReplicas = new ArrayList<>();
	                    return customerOrderReplicas;
	                } else {
	                    return Collections.emptyList();
	                }
	            } else {
	                return null; // or an appropriate value
	            }
	        } else {
	            // Handle the case when the latest schedule is not active
	            return null; // or an appropriate value
	        }
	    } else {
	        // Handle the case when there is no latest schedule or its creation timestamp is null
	        return null; // or an appropriate value
	    }
	}

}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.internal.core.manipulation.dom.ASTResolving.createQuickFixAST(ASTResolving.java:1052)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:131)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4035)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3635)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.ui 4 0 2023-09-21 15:34:05.412
!MESSAGE Unhandled event loop exception
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.internal.core.manipulation.dom.ASTResolving.createQuickFixAST(ASTResolving.java:1052)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:131)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4035)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3635)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-21 15:34:08.768
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.xyram.daydrop.serviceimpl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.transaction.Transactional;

import org.apache.commons.collections4.map.HashedMap;
import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.server.ResponseStatusException;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.xyram.daydrop.admin.model.CurrentUser;
import com.xyram.daydrop.basemodel.Base64Wrapper;
import com.xyram.daydrop.basemodel.MerchantTransactionIdGenerator;
import com.xyram.daydrop.basemodel.PhonepeSerializer;
import com.xyram.daydrop.dao.ApartmentDao;
import com.xyram.daydrop.dao.CustomerDetailsDao;
import com.xyram.daydrop.dao.CustomerOrderDao;
import com.xyram.daydrop.dao.CustomerOrderReplicaDoa;
import com.xyram.daydrop.dao.SheduleDao;
import com.xyram.daydrop.enumtypes.UserStatus;
import com.xyram.daydrop.model.Apartments;
import com.xyram.daydrop.model.CustomerOrder;
import com.xyram.daydrop.model.CustomerOrderReplica;
import com.xyram.daydrop.model.Customers;
import com.xyram.daydrop.model.Schedule;
import com.xyram.daydrop.modelMapper.PaymentInstrument;
import com.xyram.daydrop.modelMapper.PhonePePayModel;
import com.xyram.daydrop.request.CustomerOrderReplicaRequest;
import com.xyram.daydrop.response.RazorPayRequest;
import com.xyram.daydrop.service.CustomerOrderPriceService;
import com.xyram.daydrop.service.CustomerOrderReplicaService;
import com.xyram.daydrop.util.HashEncoder;
import com.xyram.daydrop.util.RazorPay;
import com.xyram.daydrop.service.ConsumerService;

@Transactional
@Service
public class CustomerOrderReplicaServiceImpl implements CustomerOrderReplicaService {

	@Autowired
	CustomerOrderReplicaDoa customerOrderReplicaDoa;

	@Autowired
	ApartmentDao apartmentDao;

	@Autowired
	SheduleDao scheduleDao;

	@Autowired
	CustomerDetailsDao customerDetailsDao;

	@Autowired
	ConsumerService consumerService;

	@Autowired
	CurrentUser currentUser;

	@Autowired
	PhonepeServiceImpl phonepeServiceImpl;

	@Value("${merchant_id}")
	private String merchantId;

	@Value("${salt_key}")
	private String saltKey;

	@Value("${salt_index}")
	private String saltIndex;

	@Override
	public Map createCustomerOrderReplicaService(CustomerOrderReplicaRequest customerOrderReplicaRequest,
			String contactNumber, Integer aparmentId)

	{

		Map response = new HashedMap<>();

		response.put("message", "success");
		CustomerOrderReplica customerOrderReplica = null;

		if (customerOrderReplicaRequest.getCartId() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "cartId is mandatory ");
		}
		long razorPayCount = 0;
		if (customerOrderReplicaRequest.getOrderId() != null) {

			razorPayCount = customerOrderReplicaDoa.getRazorPayExistByCartId(customerOrderReplicaRequest.getOrderId());
		}

		if (customerOrderReplicaRequest.getCustomerDetails() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Order Details  is mandatory ");
		}

		customerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(customerOrderReplicaRequest.getCartId(),
				contactNumber);

		if (customerOrderReplica != null) {
			customerOrderReplica.setCartId(customerOrderReplica.getCartId());

			if (customerOrderReplica.isOrdered()) {
				throw new ResponseStatusException(HttpStatus.CONFLICT, "Your Order is Placed With cart Details");
			}

//			if (razorPayCount >= 1 && !(customerOrderReplica.getRazorPayOrderId() != null
//					&& customerOrderReplica.getRazorPayOrderId().equals(customerOrderReplicaRequest.getOrderId()))) {
//				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
//			}

			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);

			customerOrderReplica.setAttempts(customerOrderReplica.getAttempts() + 1);
			customerOrderReplica.setUpdatedTime(new Date());

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		} else {

			customerOrderReplica = new CustomerOrderReplica();
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);
			customerOrderReplica.setCartId(customerOrderReplicaRequest.getCartId());
			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());

			if (razorPayCount > 0) {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
			}

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			Schedule schedule = scheduleDao.getlatestScheduleCustomers();

			if (schedule != null) {

				try {
					customerOrderReplica.setSchedule(schedule.getsId() != null ? schedule.getsId().toString() : null);
				} catch (Exception e) {
					e.printStackTrace();
				}
			} else {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
						"Sorry We Are Not Accepting Any Order Right now");

			}

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		}

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicas(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String schedule = null;

		Map filter = request.containsKey("filters") ? (Map) request.get("filters") : null;
		if (filter != null) {
			statusType = filter.containsKey("statusType") ? ((String) filter.get("statusType")).toLowerCase() : null;
			searchQuery = filter.containsKey("searchQuery") ? ((String) filter.get("searchQuery")).toLowerCase() : null;
			schedule = filter.containsKey("schedule") ? (String.valueOf(filter.get("schedule"))) : null;

		}

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplica(searchQuery, statusType, schedule);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");

				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setStreetName(
						customers.get("streetName") != null ? (String) customers.get("streetName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicasBySchedule(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String scheduleId = null;

		Schedule schedule = scheduleDao.getlatestScheduleCustomers();

		if (schedule != null) {

			try {
				scheduleId = schedule.getsId() != null ? schedule.getsId().toString() : null;
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

		statusType = request.containsKey("statusType") ? ((String) request.get("statusType")).toLowerCase() : "Success";

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplicaBySchdeule(statusType, scheduleId);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");
				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				System.out.println("customers" + customers.get("customerName"));

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public CustomerOrderReplica getCustomerOrderReplicaByCartId(String cartId) {

		CustomerOrderReplica CustomerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(cartId,
				currentUser.getContactNumber());

		ObjectMapper objectMapper = new ObjectMapper();
		try {

			// convert JSON string to Map
			Map<String, Object> customerOrderReplicaMap = objectMapper
					.readValue(CustomerOrderReplica.getCustomerOrderDetails(), Map.class);

			Object customerOrder = customerOrderReplicaMap.get("customerOrder");
			Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

			Object quanityList = items.get("quantity");
			Map customers = customerDetailsDao.getByContactNumberAndApartment(CustomerOrderReplica.getContactNumber(),
					CustomerOrderReplica.getApartmentId());

			System.out.println("customers" + customers.get("customerName"));

			// Apartments apartments =
			// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
			CustomerOrderReplica.setApartmentName(
					customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

			CustomerOrderReplica.setCustomerDetails(customers);

			CustomerOrderReplica.setCustomerOrder(customerOrder);
			CustomerOrderReplica.setQuatityList(quanityList);

		} catch (Exception e) {
			e.printStackTrace();
		}

		return CustomerOrderReplica;

	}

	@Override
	public Map createCustomerOrderReplica(CustomerOrderReplicaRequest customerOrderReplicaRequest, String contactNumber,
			Integer aparmentId) {

		if (customerOrderReplicaRequest.getRazorPayRequest() != null) {

//			Map razorPay = consumerService.createRazorPayOrder(customerOrderReplicaRequest.getRazorPayRequest());
//			customerOrderReplicaRequest.setOrderId(razorPay.get("order") != null ? (String)((RazorPay) razorPay.get("order")).getId() : null);	
//	
//			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);
//
//			razorPay.put("cartId", customerOrderReplicaRequest.getCartId());

			Map customerOrderReplicaMap = new HashMap<>();

			Map orderId = new HashMap<>();
			String transactionId = getMerchantTransactionId();
			orderId.put("id", transactionId);

			customerOrderReplicaMap.put("order", orderId);

			customerOrderReplicaRequest.setOrderId(transactionId);
			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);

			customerOrderReplicaMap.put("cartId", customerOrderReplicaRequest.getCartId());

			try {
				customerOrderReplicaMap.put("phonePeResponse",
						phonepeServiceImpl.initiatePhonepePayment(transactionId,
								Integer.valueOf(customerOrderReplicaRequest.getRazorPayRequest().getAmount()),
								contactNumber, customerOrderReplicaRequest.getRedirectUrl(), customerOrderReplicaRequest.getCallBackUrl()));

			} catch (Exception e) {
				e.printStackTrace();
				customerOrderReplicaMap.put("phonePeResponse", new HashedMap<>());
			}

			return customerOrderReplicaMap;

		} else {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
					"paymentDetails transcation Details are mandatory");
		}

	}

	private static String getMerchantTransactionId() {

		return "OD_" + MerchantTransactionIdGenerator.getRandomString();
	}


	@Override
	public List<CustomerOrderReplica> getCustomerOrderByMoblieNo(String contactNumber, Integer aid) {

	    Schedule latestSchedule = customerOrderReplicaDoa.getlatestschedule();

	    if (latestSchedule != null && latestSchedule.getCreationTimestamp() != null) {
	        if (latestSchedule.getStatus().equals(UserStatus.ACTIVE)) {
	            Customers customer = customerDetailsDao.getByContactNoAndApartment(contactNumber, aid);

	            if (customer != null) { // Ensure the customer exists
	                List<CustomerOrder> customerOrderList = customerOrderReplicaDoa.getListCustomerOrderByCustomerId(customer.getCtId());

	                double totalOrderAmount = 0.0;

	                if (customerOrderList != null && !customerOrderList.isEmpty()) {
	                    for (CustomerOrder customerOrder : customerOrderList) {
	                        Double orderAmount = customerOrder.getAmount();
	                        if (orderAmount != null) {
	                            totalOrderAmount += orderAmount;
	                            if(totalOrderAmount>200) {
	                            	totalOrderAmount+= customerOrder.getDelivaryCharges();
	                            }
	                            else(totalOrderAmount<200){
	                            	totalOrderAmount-= customerOrder.getDelivaryCharges();
	                            }
	                        }
	                    }

	                    // Define the minimum order amount for applying delivery charges
	                    double minimumOrderAmount = 200.0;

	                    if (totalOrderAmount < minimumOrderAmount) {
	                        System.out.println("Delivery Charges will be applicable");
	                    } else {
	                        // No delivery charges applicable
	                        System.out.println("No Delivery charges applicable");
	                    }

	                    List<CustomerOrderReplica> customerOrderReplicas = new ArrayList<>();
	                    return customerOrderReplicas;
	                } else {
	                    return Collections.emptyList();
	                }
	            } else {
	                return null; // or an appropriate value
	            }
	        } else {
	            // Handle the case when the latest schedule is not active
	            return null; // or an appropriate value
	        }
	    } else {
	        // Handle the case when there is no latest schedule or its creation timestamp is null
	        return null; // or an appropriate value
	    }
	}

}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-09-21 15:34:08.770
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-09-21 15:34:08.771
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-21 15:34:14.349
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.xyram.daydrop.serviceimpl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.transaction.Transactional;

import org.apache.commons.collections4.map.HashedMap;
import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.server.ResponseStatusException;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.xyram.daydrop.admin.model.CurrentUser;
import com.xyram.daydrop.basemodel.Base64Wrapper;
import com.xyram.daydrop.basemodel.MerchantTransactionIdGenerator;
import com.xyram.daydrop.basemodel.PhonepeSerializer;
import com.xyram.daydrop.dao.ApartmentDao;
import com.xyram.daydrop.dao.CustomerDetailsDao;
import com.xyram.daydrop.dao.CustomerOrderDao;
import com.xyram.daydrop.dao.CustomerOrderReplicaDoa;
import com.xyram.daydrop.dao.SheduleDao;
import com.xyram.daydrop.enumtypes.UserStatus;
import com.xyram.daydrop.model.Apartments;
import com.xyram.daydrop.model.CustomerOrder;
import com.xyram.daydrop.model.CustomerOrderReplica;
import com.xyram.daydrop.model.Customers;
import com.xyram.daydrop.model.Schedule;
import com.xyram.daydrop.modelMapper.PaymentInstrument;
import com.xyram.daydrop.modelMapper.PhonePePayModel;
import com.xyram.daydrop.request.CustomerOrderReplicaRequest;
import com.xyram.daydrop.response.RazorPayRequest;
import com.xyram.daydrop.service.CustomerOrderPriceService;
import com.xyram.daydrop.service.CustomerOrderReplicaService;
import com.xyram.daydrop.util.HashEncoder;
import com.xyram.daydrop.util.RazorPay;
import com.xyram.daydrop.service.ConsumerService;

@Transactional
@Service
public class CustomerOrderReplicaServiceImpl implements CustomerOrderReplicaService {

	@Autowired
	CustomerOrderReplicaDoa customerOrderReplicaDoa;

	@Autowired
	ApartmentDao apartmentDao;

	@Autowired
	SheduleDao scheduleDao;

	@Autowired
	CustomerDetailsDao customerDetailsDao;

	@Autowired
	ConsumerService consumerService;

	@Autowired
	CurrentUser currentUser;

	@Autowired
	PhonepeServiceImpl phonepeServiceImpl;

	@Value("${merchant_id}")
	private String merchantId;

	@Value("${salt_key}")
	private String saltKey;

	@Value("${salt_index}")
	private String saltIndex;

	@Override
	public Map createCustomerOrderReplicaService(CustomerOrderReplicaRequest customerOrderReplicaRequest,
			String contactNumber, Integer aparmentId)

	{

		Map response = new HashedMap<>();

		response.put("message", "success");
		CustomerOrderReplica customerOrderReplica = null;

		if (customerOrderReplicaRequest.getCartId() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "cartId is mandatory ");
		}
		long razorPayCount = 0;
		if (customerOrderReplicaRequest.getOrderId() != null) {

			razorPayCount = customerOrderReplicaDoa.getRazorPayExistByCartId(customerOrderReplicaRequest.getOrderId());
		}

		if (customerOrderReplicaRequest.getCustomerDetails() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Order Details  is mandatory ");
		}

		customerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(customerOrderReplicaRequest.getCartId(),
				contactNumber);

		if (customerOrderReplica != null) {
			customerOrderReplica.setCartId(customerOrderReplica.getCartId());

			if (customerOrderReplica.isOrdered()) {
				throw new ResponseStatusException(HttpStatus.CONFLICT, "Your Order is Placed With cart Details");
			}

//			if (razorPayCount >= 1 && !(customerOrderReplica.getRazorPayOrderId() != null
//					&& customerOrderReplica.getRazorPayOrderId().equals(customerOrderReplicaRequest.getOrderId()))) {
//				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
//			}

			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);

			customerOrderReplica.setAttempts(customerOrderReplica.getAttempts() + 1);
			customerOrderReplica.setUpdatedTime(new Date());

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		} else {

			customerOrderReplica = new CustomerOrderReplica();
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);
			customerOrderReplica.setCartId(customerOrderReplicaRequest.getCartId());
			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());

			if (razorPayCount > 0) {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
			}

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			Schedule schedule = scheduleDao.getlatestScheduleCustomers();

			if (schedule != null) {

				try {
					customerOrderReplica.setSchedule(schedule.getsId() != null ? schedule.getsId().toString() : null);
				} catch (Exception e) {
					e.printStackTrace();
				}
			} else {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
						"Sorry We Are Not Accepting Any Order Right now");

			}

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		}

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicas(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String schedule = null;

		Map filter = request.containsKey("filters") ? (Map) request.get("filters") : null;
		if (filter != null) {
			statusType = filter.containsKey("statusType") ? ((String) filter.get("statusType")).toLowerCase() : null;
			searchQuery = filter.containsKey("searchQuery") ? ((String) filter.get("searchQuery")).toLowerCase() : null;
			schedule = filter.containsKey("schedule") ? (String.valueOf(filter.get("schedule"))) : null;

		}

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplica(searchQuery, statusType, schedule);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");

				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setStreetName(
						customers.get("streetName") != null ? (String) customers.get("streetName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicasBySchedule(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String scheduleId = null;

		Schedule schedule = scheduleDao.getlatestScheduleCustomers();

		if (schedule != null) {

			try {
				scheduleId = schedule.getsId() != null ? schedule.getsId().toString() : null;
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

		statusType = request.containsKey("statusType") ? ((String) request.get("statusType")).toLowerCase() : "Success";

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplicaBySchdeule(statusType, scheduleId);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");
				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				System.out.println("customers" + customers.get("customerName"));

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public CustomerOrderReplica getCustomerOrderReplicaByCartId(String cartId) {

		CustomerOrderReplica CustomerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(cartId,
				currentUser.getContactNumber());

		ObjectMapper objectMapper = new ObjectMapper();
		try {

			// convert JSON string to Map
			Map<String, Object> customerOrderReplicaMap = objectMapper
					.readValue(CustomerOrderReplica.getCustomerOrderDetails(), Map.class);

			Object customerOrder = customerOrderReplicaMap.get("customerOrder");
			Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

			Object quanityList = items.get("quantity");
			Map customers = customerDetailsDao.getByContactNumberAndApartment(CustomerOrderReplica.getContactNumber(),
					CustomerOrderReplica.getApartmentId());

			System.out.println("customers" + customers.get("customerName"));

			// Apartments apartments =
			// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
			CustomerOrderReplica.setApartmentName(
					customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

			CustomerOrderReplica.setCustomerDetails(customers);

			CustomerOrderReplica.setCustomerOrder(customerOrder);
			CustomerOrderReplica.setQuatityList(quanityList);

		} catch (Exception e) {
			e.printStackTrace();
		}

		return CustomerOrderReplica;

	}

	@Override
	public Map createCustomerOrderReplica(CustomerOrderReplicaRequest customerOrderReplicaRequest, String contactNumber,
			Integer aparmentId) {

		if (customerOrderReplicaRequest.getRazorPayRequest() != null) {

//			Map razorPay = consumerService.createRazorPayOrder(customerOrderReplicaRequest.getRazorPayRequest());
//			customerOrderReplicaRequest.setOrderId(razorPay.get("order") != null ? (String)((RazorPay) razorPay.get("order")).getId() : null);	
//	
//			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);
//
//			razorPay.put("cartId", customerOrderReplicaRequest.getCartId());

			Map customerOrderReplicaMap = new HashMap<>();

			Map orderId = new HashMap<>();
			String transactionId = getMerchantTransactionId();
			orderId.put("id", transactionId);

			customerOrderReplicaMap.put("order", orderId);

			customerOrderReplicaRequest.setOrderId(transactionId);
			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);

			customerOrderReplicaMap.put("cartId", customerOrderReplicaRequest.getCartId());

			try {
				customerOrderReplicaMap.put("phonePeResponse",
						phonepeServiceImpl.initiatePhonepePayment(transactionId,
								Integer.valueOf(customerOrderReplicaRequest.getRazorPayRequest().getAmount()),
								contactNumber, customerOrderReplicaRequest.getRedirectUrl(), customerOrderReplicaRequest.getCallBackUrl()));

			} catch (Exception e) {
				e.printStackTrace();
				customerOrderReplicaMap.put("phonePeResponse", new HashedMap<>());
			}

			return customerOrderReplicaMap;

		} else {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
					"paymentDetails transcation Details are mandatory");
		}

	}

	private static String getMerchantTransactionId() {

		return "OD_" + MerchantTransactionIdGenerator.getRandomString();
	}


	@Override
	public List<CustomerOrderReplica> getCustomerOrderByMoblieNo(String contactNumber, Integer aid) {

	    Schedule latestSchedule = customerOrderReplicaDoa.getlatestschedule();

	    if (latestSchedule != null && latestSchedule.getCreationTimestamp() != null) {
	        if (latestSchedule.getStatus().equals(UserStatus.ACTIVE)) {
	            Customers customer = customerDetailsDao.getByContactNoAndApartment(contactNumber, aid);

	            if (customer != null) { // Ensure the customer exists
	                List<CustomerOrder> customerOrderList = customerOrderReplicaDoa.getListCustomerOrderByCustomerId(customer.getCtId());

	                double totalOrderAmount = 0.0;

	                if (customerOrderList != null && !customerOrderList.isEmpty()) {
	                    for (CustomerOrder customerOrder : customerOrderList) {
	                        Double orderAmount = customerOrder.getAmount();
	                        if (orderAmount != null) {
	                            totalOrderAmount += orderAmount;
	                            if(totalOrderAmount>200) {
	                            	totalOrderAmount+= customerOrder.getDelivaryCharges();
	                            }
	                            else (totalOrderAmount<200){
	                            	totalOrderAmount-= customerOrder.getDelivaryCharges();
	                            }
	                        }
	                    }

	                    // Define the minimum order amount for applying delivery charges
	                    double minimumOrderAmount = 200.0;

	                    if (totalOrderAmount < minimumOrderAmount) {
	                        System.out.println("Delivery Charges will be applicable");
	                    } else {
	                        // No delivery charges applicable
	                        System.out.println("No Delivery charges applicable");
	                    }

	                    List<CustomerOrderReplica> customerOrderReplicas = new ArrayList<>();
	                    return customerOrderReplicas;
	                } else {
	                    return Collections.emptyList();
	                }
	            } else {
	                return null; // or an appropriate value
	            }
	        } else {
	            // Handle the case when the latest schedule is not active
	            return null; // or an appropriate value
	        }
	    } else {
	        // Handle the case when there is no latest schedule or its creation timestamp is null
	        return null; // or an appropriate value
	    }
	}

}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-09-21 15:34:14.351
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-09-21 15:34:14.352
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-21 15:34:14.426
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.xyram.daydrop.serviceimpl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.transaction.Transactional;

import org.apache.commons.collections4.map.HashedMap;
import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.server.ResponseStatusException;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.xyram.daydrop.admin.model.CurrentUser;
import com.xyram.daydrop.basemodel.Base64Wrapper;
import com.xyram.daydrop.basemodel.MerchantTransactionIdGenerator;
import com.xyram.daydrop.basemodel.PhonepeSerializer;
import com.xyram.daydrop.dao.ApartmentDao;
import com.xyram.daydrop.dao.CustomerDetailsDao;
import com.xyram.daydrop.dao.CustomerOrderDao;
import com.xyram.daydrop.dao.CustomerOrderReplicaDoa;
import com.xyram.daydrop.dao.SheduleDao;
import com.xyram.daydrop.enumtypes.UserStatus;
import com.xyram.daydrop.model.Apartments;
import com.xyram.daydrop.model.CustomerOrder;
import com.xyram.daydrop.model.CustomerOrderReplica;
import com.xyram.daydrop.model.Customers;
import com.xyram.daydrop.model.Schedule;
import com.xyram.daydrop.modelMapper.PaymentInstrument;
import com.xyram.daydrop.modelMapper.PhonePePayModel;
import com.xyram.daydrop.request.CustomerOrderReplicaRequest;
import com.xyram.daydrop.response.RazorPayRequest;
import com.xyram.daydrop.service.CustomerOrderPriceService;
import com.xyram.daydrop.service.CustomerOrderReplicaService;
import com.xyram.daydrop.util.HashEncoder;
import com.xyram.daydrop.util.RazorPay;
import com.xyram.daydrop.service.ConsumerService;

@Transactional
@Service
public class CustomerOrderReplicaServiceImpl implements CustomerOrderReplicaService {

	@Autowired
	CustomerOrderReplicaDoa customerOrderReplicaDoa;

	@Autowired
	ApartmentDao apartmentDao;

	@Autowired
	SheduleDao scheduleDao;

	@Autowired
	CustomerDetailsDao customerDetailsDao;

	@Autowired
	ConsumerService consumerService;

	@Autowired
	CurrentUser currentUser;

	@Autowired
	PhonepeServiceImpl phonepeServiceImpl;

	@Value("${merchant_id}")
	private String merchantId;

	@Value("${salt_key}")
	private String saltKey;

	@Value("${salt_index}")
	private String saltIndex;

	@Override
	public Map createCustomerOrderReplicaService(CustomerOrderReplicaRequest customerOrderReplicaRequest,
			String contactNumber, Integer aparmentId)

	{

		Map response = new HashedMap<>();

		response.put("message", "success");
		CustomerOrderReplica customerOrderReplica = null;

		if (customerOrderReplicaRequest.getCartId() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "cartId is mandatory ");
		}
		long razorPayCount = 0;
		if (customerOrderReplicaRequest.getOrderId() != null) {

			razorPayCount = customerOrderReplicaDoa.getRazorPayExistByCartId(customerOrderReplicaRequest.getOrderId());
		}

		if (customerOrderReplicaRequest.getCustomerDetails() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Order Details  is mandatory ");
		}

		customerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(customerOrderReplicaRequest.getCartId(),
				contactNumber);

		if (customerOrderReplica != null) {
			customerOrderReplica.setCartId(customerOrderReplica.getCartId());

			if (customerOrderReplica.isOrdered()) {
				throw new ResponseStatusException(HttpStatus.CONFLICT, "Your Order is Placed With cart Details");
			}

//			if (razorPayCount >= 1 && !(customerOrderReplica.getRazorPayOrderId() != null
//					&& customerOrderReplica.getRazorPayOrderId().equals(customerOrderReplicaRequest.getOrderId()))) {
//				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
//			}

			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);

			customerOrderReplica.setAttempts(customerOrderReplica.getAttempts() + 1);
			customerOrderReplica.setUpdatedTime(new Date());

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		} else {

			customerOrderReplica = new CustomerOrderReplica();
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);
			customerOrderReplica.setCartId(customerOrderReplicaRequest.getCartId());
			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());

			if (razorPayCount > 0) {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
			}

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			Schedule schedule = scheduleDao.getlatestScheduleCustomers();

			if (schedule != null) {

				try {
					customerOrderReplica.setSchedule(schedule.getsId() != null ? schedule.getsId().toString() : null);
				} catch (Exception e) {
					e.printStackTrace();
				}
			} else {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
						"Sorry We Are Not Accepting Any Order Right now");

			}

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		}

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicas(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String schedule = null;

		Map filter = request.containsKey("filters") ? (Map) request.get("filters") : null;
		if (filter != null) {
			statusType = filter.containsKey("statusType") ? ((String) filter.get("statusType")).toLowerCase() : null;
			searchQuery = filter.containsKey("searchQuery") ? ((String) filter.get("searchQuery")).toLowerCase() : null;
			schedule = filter.containsKey("schedule") ? (String.valueOf(filter.get("schedule"))) : null;

		}

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplica(searchQuery, statusType, schedule);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");

				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setStreetName(
						customers.get("streetName") != null ? (String) customers.get("streetName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicasBySchedule(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String scheduleId = null;

		Schedule schedule = scheduleDao.getlatestScheduleCustomers();

		if (schedule != null) {

			try {
				scheduleId = schedule.getsId() != null ? schedule.getsId().toString() : null;
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

		statusType = request.containsKey("statusType") ? ((String) request.get("statusType")).toLowerCase() : "Success";

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplicaBySchdeule(statusType, scheduleId);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");
				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				System.out.println("customers" + customers.get("customerName"));

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public CustomerOrderReplica getCustomerOrderReplicaByCartId(String cartId) {

		CustomerOrderReplica CustomerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(cartId,
				currentUser.getContactNumber());

		ObjectMapper objectMapper = new ObjectMapper();
		try {

			// convert JSON string to Map
			Map<String, Object> customerOrderReplicaMap = objectMapper
					.readValue(CustomerOrderReplica.getCustomerOrderDetails(), Map.class);

			Object customerOrder = customerOrderReplicaMap.get("customerOrder");
			Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

			Object quanityList = items.get("quantity");
			Map customers = customerDetailsDao.getByContactNumberAndApartment(CustomerOrderReplica.getContactNumber(),
					CustomerOrderReplica.getApartmentId());

			System.out.println("customers" + customers.get("customerName"));

			// Apartments apartments =
			// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
			CustomerOrderReplica.setApartmentName(
					customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

			CustomerOrderReplica.setCustomerDetails(customers);

			CustomerOrderReplica.setCustomerOrder(customerOrder);
			CustomerOrderReplica.setQuatityList(quanityList);

		} catch (Exception e) {
			e.printStackTrace();
		}

		return CustomerOrderReplica;

	}

	@Override
	public Map createCustomerOrderReplica(CustomerOrderReplicaRequest customerOrderReplicaRequest, String contactNumber,
			Integer aparmentId) {

		if (customerOrderReplicaRequest.getRazorPayRequest() != null) {

//			Map razorPay = consumerService.createRazorPayOrder(customerOrderReplicaRequest.getRazorPayRequest());
//			customerOrderReplicaRequest.setOrderId(razorPay.get("order") != null ? (String)((RazorPay) razorPay.get("order")).getId() : null);	
//	
//			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);
//
//			razorPay.put("cartId", customerOrderReplicaRequest.getCartId());

			Map customerOrderReplicaMap = new HashMap<>();

			Map orderId = new HashMap<>();
			String transactionId = getMerchantTransactionId();
			orderId.put("id", transactionId);

			customerOrderReplicaMap.put("order", orderId);

			customerOrderReplicaRequest.setOrderId(transactionId);
			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);

			customerOrderReplicaMap.put("cartId", customerOrderReplicaRequest.getCartId());

			try {
				customerOrderReplicaMap.put("phonePeResponse",
						phonepeServiceImpl.initiatePhonepePayment(transactionId,
								Integer.valueOf(customerOrderReplicaRequest.getRazorPayRequest().getAmount()),
								contactNumber, customerOrderReplicaRequest.getRedirectUrl(), customerOrderReplicaRequest.getCallBackUrl()));

			} catch (Exception e) {
				e.printStackTrace();
				customerOrderReplicaMap.put("phonePeResponse", new HashedMap<>());
			}

			return customerOrderReplicaMap;

		} else {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
					"paymentDetails transcation Details are mandatory");
		}

	}

	private static String getMerchantTransactionId() {

		return "OD_" + MerchantTransactionIdGenerator.getRandomString();
	}


	@Override
	public List<CustomerOrderReplica> getCustomerOrderByMoblieNo(String contactNumber, Integer aid) {

	    Schedule latestSchedule = customerOrderReplicaDoa.getlatestschedule();

	    if (latestSchedule != null && latestSchedule.getCreationTimestamp() != null) {
	        if (latestSchedule.getStatus().equals(UserStatus.ACTIVE)) {
	            Customers customer = customerDetailsDao.getByContactNoAndApartment(contactNumber, aid);

	            if (customer != null) { // Ensure the customer exists
	                List<CustomerOrder> customerOrderList = customerOrderReplicaDoa.getListCustomerOrderByCustomerId(customer.getCtId());

	                double totalOrderAmount = 0.0;

	                if (customerOrderList != null && !customerOrderList.isEmpty()) {
	                    for (CustomerOrder customerOrder : customerOrderList) {
	                        Double orderAmount = customerOrder.getAmount();
	                        if (orderAmount != null) {
	                            totalOrderAmount += orderAmount;
	                            if(totalOrderAmount>200) {
	                            	totalOrderAmount+= customerOrder.getDelivaryCharges();
	                            }
	                            else (totalOrderAmount<200){
	                            	totalOrderAmount-= customerOrder.getDelivaryCharges();
	                            }
	                        }
	                    }

	                    // Define the minimum order amount for applying delivery charges
	                    double minimumOrderAmount = 200.0;

	                    if (totalOrderAmount < minimumOrderAmount) {
	                        System.out.println("Delivery Charges will be applicable");
	                    } else {
	                        // No delivery charges applicable
	                        System.out.println("No Delivery charges applicable");
	                    }

	                    List<CustomerOrderReplica> customerOrderReplicas = new ArrayList<>();
	                    return customerOrderReplicas;
	                } else {
	                    return Collections.emptyList();
	                }
	            } else {
	                return null; // or an appropriate value
	            }
	        } else {
	            // Handle the case when the latest schedule is not active
	            return null; // or an appropriate value
	        }
	    } else {
	        // Handle the case when there is no latest schedule or its creation timestamp is null
	        return null; // or an appropriate value
	    }
	}

}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-09-21 15:34:14.429
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-09-21 15:34:14.431
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.lsp4e 2 0 2023-09-21 15:34:20.479
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:386)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2096)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-21 15:34:20.520
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.xyram.daydrop.serviceimpl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.transaction.Transactional;

import org.apache.commons.collections4.map.HashedMap;
import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.server.ResponseStatusException;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.xyram.daydrop.admin.model.CurrentUser;
import com.xyram.daydrop.basemodel.Base64Wrapper;
import com.xyram.daydrop.basemodel.MerchantTransactionIdGenerator;
import com.xyram.daydrop.basemodel.PhonepeSerializer;
import com.xyram.daydrop.dao.ApartmentDao;
import com.xyram.daydrop.dao.CustomerDetailsDao;
import com.xyram.daydrop.dao.CustomerOrderDao;
import com.xyram.daydrop.dao.CustomerOrderReplicaDoa;
import com.xyram.daydrop.dao.SheduleDao;
import com.xyram.daydrop.enumtypes.UserStatus;
import com.xyram.daydrop.model.Apartments;
import com.xyram.daydrop.model.CustomerOrder;
import com.xyram.daydrop.model.CustomerOrderReplica;
import com.xyram.daydrop.model.Customers;
import com.xyram.daydrop.model.Schedule;
import com.xyram.daydrop.modelMapper.PaymentInstrument;
import com.xyram.daydrop.modelMapper.PhonePePayModel;
import com.xyram.daydrop.request.CustomerOrderReplicaRequest;
import com.xyram.daydrop.response.RazorPayRequest;
import com.xyram.daydrop.service.CustomerOrderPriceService;
import com.xyram.daydrop.service.CustomerOrderReplicaService;
import com.xyram.daydrop.util.HashEncoder;
import com.xyram.daydrop.util.RazorPay;
import com.xyram.daydrop.service.ConsumerService;

@Transactional
@Service
public class CustomerOrderReplicaServiceImpl implements CustomerOrderReplicaService {

	@Autowired
	CustomerOrderReplicaDoa customerOrderReplicaDoa;

	@Autowired
	ApartmentDao apartmentDao;

	@Autowired
	SheduleDao scheduleDao;

	@Autowired
	CustomerDetailsDao customerDetailsDao;

	@Autowired
	ConsumerService consumerService;

	@Autowired
	CurrentUser currentUser;

	@Autowired
	PhonepeServiceImpl phonepeServiceImpl;

	@Value("${merchant_id}")
	private String merchantId;

	@Value("${salt_key}")
	private String saltKey;

	@Value("${salt_index}")
	private String saltIndex;

	@Override
	public Map createCustomerOrderReplicaService(CustomerOrderReplicaRequest customerOrderReplicaRequest,
			String contactNumber, Integer aparmentId)

	{

		Map response = new HashedMap<>();

		response.put("message", "success");
		CustomerOrderReplica customerOrderReplica = null;

		if (customerOrderReplicaRequest.getCartId() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "cartId is mandatory ");
		}
		long razorPayCount = 0;
		if (customerOrderReplicaRequest.getOrderId() != null) {

			razorPayCount = customerOrderReplicaDoa.getRazorPayExistByCartId(customerOrderReplicaRequest.getOrderId());
		}

		if (customerOrderReplicaRequest.getCustomerDetails() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Order Details  is mandatory ");
		}

		customerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(customerOrderReplicaRequest.getCartId(),
				contactNumber);

		if (customerOrderReplica != null) {
			customerOrderReplica.setCartId(customerOrderReplica.getCartId());

			if (customerOrderReplica.isOrdered()) {
				throw new ResponseStatusException(HttpStatus.CONFLICT, "Your Order is Placed With cart Details");
			}

//			if (razorPayCount >= 1 && !(customerOrderReplica.getRazorPayOrderId() != null
//					&& customerOrderReplica.getRazorPayOrderId().equals(customerOrderReplicaRequest.getOrderId()))) {
//				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
//			}

			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);

			customerOrderReplica.setAttempts(customerOrderReplica.getAttempts() + 1);
			customerOrderReplica.setUpdatedTime(new Date());

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		} else {

			customerOrderReplica = new CustomerOrderReplica();
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);
			customerOrderReplica.setCartId(customerOrderReplicaRequest.getCartId());
			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());

			if (razorPayCount > 0) {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
			}

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			Schedule schedule = scheduleDao.getlatestScheduleCustomers();

			if (schedule != null) {

				try {
					customerOrderReplica.setSchedule(schedule.getsId() != null ? schedule.getsId().toString() : null);
				} catch (Exception e) {
					e.printStackTrace();
				}
			} else {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
						"Sorry We Are Not Accepting Any Order Right now");

			}

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		}

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicas(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String schedule = null;

		Map filter = request.containsKey("filters") ? (Map) request.get("filters") : null;
		if (filter != null) {
			statusType = filter.containsKey("statusType") ? ((String) filter.get("statusType")).toLowerCase() : null;
			searchQuery = filter.containsKey("searchQuery") ? ((String) filter.get("searchQuery")).toLowerCase() : null;
			schedule = filter.containsKey("schedule") ? (String.valueOf(filter.get("schedule"))) : null;

		}

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplica(searchQuery, statusType, schedule);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");

				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setStreetName(
						customers.get("streetName") != null ? (String) customers.get("streetName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicasBySchedule(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String scheduleId = null;

		Schedule schedule = scheduleDao.getlatestScheduleCustomers();

		if (schedule != null) {

			try {
				scheduleId = schedule.getsId() != null ? schedule.getsId().toString() : null;
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

		statusType = request.containsKey("statusType") ? ((String) request.get("statusType")).toLowerCase() : "Success";

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplicaBySchdeule(statusType, scheduleId);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");
				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				System.out.println("customers" + customers.get("customerName"));

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public CustomerOrderReplica getCustomerOrderReplicaByCartId(String cartId) {

		CustomerOrderReplica CustomerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(cartId,
				currentUser.getContactNumber());

		ObjectMapper objectMapper = new ObjectMapper();
		try {

			// convert JSON string to Map
			Map<String, Object> customerOrderReplicaMap = objectMapper
					.readValue(CustomerOrderReplica.getCustomerOrderDetails(), Map.class);

			Object customerOrder = customerOrderReplicaMap.get("customerOrder");
			Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

			Object quanityList = items.get("quantity");
			Map customers = customerDetailsDao.getByContactNumberAndApartment(CustomerOrderReplica.getContactNumber(),
					CustomerOrderReplica.getApartmentId());

			System.out.println("customers" + customers.get("customerName"));

			// Apartments apartments =
			// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
			CustomerOrderReplica.setApartmentName(
					customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

			CustomerOrderReplica.setCustomerDetails(customers);

			CustomerOrderReplica.setCustomerOrder(customerOrder);
			CustomerOrderReplica.setQuatityList(quanityList);

		} catch (Exception e) {
			e.printStackTrace();
		}

		return CustomerOrderReplica;

	}

	@Override
	public Map createCustomerOrderReplica(CustomerOrderReplicaRequest customerOrderReplicaRequest, String contactNumber,
			Integer aparmentId) {

		if (customerOrderReplicaRequest.getRazorPayRequest() != null) {

//			Map razorPay = consumerService.createRazorPayOrder(customerOrderReplicaRequest.getRazorPayRequest());
//			customerOrderReplicaRequest.setOrderId(razorPay.get("order") != null ? (String)((RazorPay) razorPay.get("order")).getId() : null);	
//	
//			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);
//
//			razorPay.put("cartId", customerOrderReplicaRequest.getCartId());

			Map customerOrderReplicaMap = new HashMap<>();

			Map orderId = new HashMap<>();
			String transactionId = getMerchantTransactionId();
			orderId.put("id", transactionId);

			customerOrderReplicaMap.put("order", orderId);

			customerOrderReplicaRequest.setOrderId(transactionId);
			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);

			customerOrderReplicaMap.put("cartId", customerOrderReplicaRequest.getCartId());

			try {
				customerOrderReplicaMap.put("phonePeResponse",
						phonepeServiceImpl.initiatePhonepePayment(transactionId,
								Integer.valueOf(customerOrderReplicaRequest.getRazorPayRequest().getAmount()),
								contactNumber, customerOrderReplicaRequest.getRedirectUrl(), customerOrderReplicaRequest.getCallBackUrl()));

			} catch (Exception e) {
				e.printStackTrace();
				customerOrderReplicaMap.put("phonePeResponse", new HashedMap<>());
			}

			return customerOrderReplicaMap;

		} else {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
					"paymentDetails transcation Details are mandatory");
		}

	}

	private static String getMerchantTransactionId() {

		return "OD_" + MerchantTransactionIdGenerator.getRandomString();
	}


	@Override
	public List<CustomerOrderReplica> getCustomerOrderByMoblieNo(String contactNumber, Integer aid) {

	    Schedule latestSchedule = customerOrderReplicaDoa.getlatestschedule();

	    if (latestSchedule != null && latestSchedule.getCreationTimestamp() != null) {
	        if (latestSchedule.getStatus().equals(UserStatus.ACTIVE)) {
	            Customers customer = customerDetailsDao.getByContactNoAndApartment(contactNumber, aid);

	            if (customer != null) { // Ensure the customer exists
	                List<CustomerOrder> customerOrderList = customerOrderReplicaDoa.getListCustomerOrderByCustomerId(customer.getCtId());

	                double totalOrderAmount = 0.0;

	                if (customerOrderList != null && !customerOrderList.isEmpty()) {
	                    for (CustomerOrder customerOrder : customerOrderList) {
	                        Double orderAmount = customerOrder.getAmount();
	                        if (orderAmount != null) {
	                            totalOrderAmount += orderAmount;
	                            if(totalOrderAmount>200) {
	                            	totalOrderAmount+= customerOrder.getDelivaryCharges();
	                            }
	                            else (totalOrderAmount<200){
	                            	totalOrderAmount-= customerOrder.getDelivaryCharges();
	                            }
	                        }
	                    }

	                    // Define the minimum order amount for applying delivery charges
	                    double minimumOrderAmount = 200.0;

	                    if (totalOrderAmount < minimumOrderAmount) {
	                        System.out.println("Delivery Charges will be applicable");
	                    } else {
	                        // No delivery charges applicable
	                        System.out.println("No Delivery charges applicable");
	                    }

	                    List<CustomerOrderReplica> customerOrderReplicas = new ArrayList<>();
	                    return customerOrderReplicas;
	                } else {
	                    return Collections.emptyList();
	                }
	            } else {
	                return null; // or an appropriate value
	            }
	        } else {
	            // Handle the case when the latest schedule is not active
	            return null; // or an appropriate value
	        }
	    } else {
	        // Handle the case when there is no latest schedule or its creation timestamp is null
	        return null; // or an appropriate value
	    }
	}

}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-09-21 15:34:20.522
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-09-21 15:34:20.525
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-21 15:34:20.559
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.xyram.daydrop.serviceimpl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.transaction.Transactional;

import org.apache.commons.collections4.map.HashedMap;
import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.server.ResponseStatusException;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.xyram.daydrop.admin.model.CurrentUser;
import com.xyram.daydrop.basemodel.Base64Wrapper;
import com.xyram.daydrop.basemodel.MerchantTransactionIdGenerator;
import com.xyram.daydrop.basemodel.PhonepeSerializer;
import com.xyram.daydrop.dao.ApartmentDao;
import com.xyram.daydrop.dao.CustomerDetailsDao;
import com.xyram.daydrop.dao.CustomerOrderDao;
import com.xyram.daydrop.dao.CustomerOrderReplicaDoa;
import com.xyram.daydrop.dao.SheduleDao;
import com.xyram.daydrop.enumtypes.UserStatus;
import com.xyram.daydrop.model.Apartments;
import com.xyram.daydrop.model.CustomerOrder;
import com.xyram.daydrop.model.CustomerOrderReplica;
import com.xyram.daydrop.model.Customers;
import com.xyram.daydrop.model.Schedule;
import com.xyram.daydrop.modelMapper.PaymentInstrument;
import com.xyram.daydrop.modelMapper.PhonePePayModel;
import com.xyram.daydrop.request.CustomerOrderReplicaRequest;
import com.xyram.daydrop.response.RazorPayRequest;
import com.xyram.daydrop.service.CustomerOrderPriceService;
import com.xyram.daydrop.service.CustomerOrderReplicaService;
import com.xyram.daydrop.util.HashEncoder;
import com.xyram.daydrop.util.RazorPay;
import com.xyram.daydrop.service.ConsumerService;

@Transactional
@Service
public class CustomerOrderReplicaServiceImpl implements CustomerOrderReplicaService {

	@Autowired
	CustomerOrderReplicaDoa customerOrderReplicaDoa;

	@Autowired
	ApartmentDao apartmentDao;

	@Autowired
	SheduleDao scheduleDao;

	@Autowired
	CustomerDetailsDao customerDetailsDao;

	@Autowired
	ConsumerService consumerService;

	@Autowired
	CurrentUser currentUser;

	@Autowired
	PhonepeServiceImpl phonepeServiceImpl;

	@Value("${merchant_id}")
	private String merchantId;

	@Value("${salt_key}")
	private String saltKey;

	@Value("${salt_index}")
	private String saltIndex;

	@Override
	public Map createCustomerOrderReplicaService(CustomerOrderReplicaRequest customerOrderReplicaRequest,
			String contactNumber, Integer aparmentId)

	{

		Map response = new HashedMap<>();

		response.put("message", "success");
		CustomerOrderReplica customerOrderReplica = null;

		if (customerOrderReplicaRequest.getCartId() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "cartId is mandatory ");
		}
		long razorPayCount = 0;
		if (customerOrderReplicaRequest.getOrderId() != null) {

			razorPayCount = customerOrderReplicaDoa.getRazorPayExistByCartId(customerOrderReplicaRequest.getOrderId());
		}

		if (customerOrderReplicaRequest.getCustomerDetails() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Order Details  is mandatory ");
		}

		customerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(customerOrderReplicaRequest.getCartId(),
				contactNumber);

		if (customerOrderReplica != null) {
			customerOrderReplica.setCartId(customerOrderReplica.getCartId());

			if (customerOrderReplica.isOrdered()) {
				throw new ResponseStatusException(HttpStatus.CONFLICT, "Your Order is Placed With cart Details");
			}

//			if (razorPayCount >= 1 && !(customerOrderReplica.getRazorPayOrderId() != null
//					&& customerOrderReplica.getRazorPayOrderId().equals(customerOrderReplicaRequest.getOrderId()))) {
//				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
//			}

			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);

			customerOrderReplica.setAttempts(customerOrderReplica.getAttempts() + 1);
			customerOrderReplica.setUpdatedTime(new Date());

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		} else {

			customerOrderReplica = new CustomerOrderReplica();
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);
			customerOrderReplica.setCartId(customerOrderReplicaRequest.getCartId());
			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());

			if (razorPayCount > 0) {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
			}

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			Schedule schedule = scheduleDao.getlatestScheduleCustomers();

			if (schedule != null) {

				try {
					customerOrderReplica.setSchedule(schedule.getsId() != null ? schedule.getsId().toString() : null);
				} catch (Exception e) {
					e.printStackTrace();
				}
			} else {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
						"Sorry We Are Not Accepting Any Order Right now");

			}

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		}

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicas(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String schedule = null;

		Map filter = request.containsKey("filters") ? (Map) request.get("filters") : null;
		if (filter != null) {
			statusType = filter.containsKey("statusType") ? ((String) filter.get("statusType")).toLowerCase() : null;
			searchQuery = filter.containsKey("searchQuery") ? ((String) filter.get("searchQuery")).toLowerCase() : null;
			schedule = filter.containsKey("schedule") ? (String.valueOf(filter.get("schedule"))) : null;

		}

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplica(searchQuery, statusType, schedule);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");

				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setStreetName(
						customers.get("streetName") != null ? (String) customers.get("streetName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicasBySchedule(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String scheduleId = null;

		Schedule schedule = scheduleDao.getlatestScheduleCustomers();

		if (schedule != null) {

			try {
				scheduleId = schedule.getsId() != null ? schedule.getsId().toString() : null;
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

		statusType = request.containsKey("statusType") ? ((String) request.get("statusType")).toLowerCase() : "Success";

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplicaBySchdeule(statusType, scheduleId);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");
				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				System.out.println("customers" + customers.get("customerName"));

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public CustomerOrderReplica getCustomerOrderReplicaByCartId(String cartId) {

		CustomerOrderReplica CustomerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(cartId,
				currentUser.getContactNumber());

		ObjectMapper objectMapper = new ObjectMapper();
		try {

			// convert JSON string to Map
			Map<String, Object> customerOrderReplicaMap = objectMapper
					.readValue(CustomerOrderReplica.getCustomerOrderDetails(), Map.class);

			Object customerOrder = customerOrderReplicaMap.get("customerOrder");
			Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

			Object quanityList = items.get("quantity");
			Map customers = customerDetailsDao.getByContactNumberAndApartment(CustomerOrderReplica.getContactNumber(),
					CustomerOrderReplica.getApartmentId());

			System.out.println("customers" + customers.get("customerName"));

			// Apartments apartments =
			// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
			CustomerOrderReplica.setApartmentName(
					customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

			CustomerOrderReplica.setCustomerDetails(customers);

			CustomerOrderReplica.setCustomerOrder(customerOrder);
			CustomerOrderReplica.setQuatityList(quanityList);

		} catch (Exception e) {
			e.printStackTrace();
		}

		return CustomerOrderReplica;

	}

	@Override
	public Map createCustomerOrderReplica(CustomerOrderReplicaRequest customerOrderReplicaRequest, String contactNumber,
			Integer aparmentId) {

		if (customerOrderReplicaRequest.getRazorPayRequest() != null) {

//			Map razorPay = consumerService.createRazorPayOrder(customerOrderReplicaRequest.getRazorPayRequest());
//			customerOrderReplicaRequest.setOrderId(razorPay.get("order") != null ? (String)((RazorPay) razorPay.get("order")).getId() : null);	
//	
//			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);
//
//			razorPay.put("cartId", customerOrderReplicaRequest.getCartId());

			Map customerOrderReplicaMap = new HashMap<>();

			Map orderId = new HashMap<>();
			String transactionId = getMerchantTransactionId();
			orderId.put("id", transactionId);

			customerOrderReplicaMap.put("order", orderId);

			customerOrderReplicaRequest.setOrderId(transactionId);
			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);

			customerOrderReplicaMap.put("cartId", customerOrderReplicaRequest.getCartId());

			try {
				customerOrderReplicaMap.put("phonePeResponse",
						phonepeServiceImpl.initiatePhonepePayment(transactionId,
								Integer.valueOf(customerOrderReplicaRequest.getRazorPayRequest().getAmount()),
								contactNumber, customerOrderReplicaRequest.getRedirectUrl(), customerOrderReplicaRequest.getCallBackUrl()));

			} catch (Exception e) {
				e.printStackTrace();
				customerOrderReplicaMap.put("phonePeResponse", new HashedMap<>());
			}

			return customerOrderReplicaMap;

		} else {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
					"paymentDetails transcation Details are mandatory");
		}

	}

	private static String getMerchantTransactionId() {

		return "OD_" + MerchantTransactionIdGenerator.getRandomString();
	}


	@Override
	public List<CustomerOrderReplica> getCustomerOrderByMoblieNo(String contactNumber, Integer aid) {

	    Schedule latestSchedule = customerOrderReplicaDoa.getlatestschedule();

	    if (latestSchedule != null && latestSchedule.getCreationTimestamp() != null) {
	        if (latestSchedule.getStatus().equals(UserStatus.ACTIVE)) {
	            Customers customer = customerDetailsDao.getByContactNoAndApartment(contactNumber, aid);

	            if (customer != null) { // Ensure the customer exists
	                List<CustomerOrder> customerOrderList = customerOrderReplicaDoa.getListCustomerOrderByCustomerId(customer.getCtId());

	                double totalOrderAmount = 0.0;

	                if (customerOrderList != null && !customerOrderList.isEmpty()) {
	                    for (CustomerOrder customerOrder : customerOrderList) {
	                        Double orderAmount = customerOrder.getAmount();
	                        if (orderAmount != null) {
	                            totalOrderAmount += orderAmount;
	                            if(totalOrderAmount>200) {
	                            	totalOrderAmount+= customerOrder.getDelivaryCharges();
	                            }
	                            else (totalOrderAmount<200){
	                            	totalOrderAmount-= customerOrder.getDelivaryCharges();
	                            }
	                        }
	                    }

	                    // Define the minimum order amount for applying delivery charges
	                    double minimumOrderAmount = 200.0;

	                    if (totalOrderAmount < minimumOrderAmount) {
	                        System.out.println("Delivery Charges will be applicable");
	                    } else {
	                        // No delivery charges applicable
	                        System.out.println("No Delivery charges applicable");
	                    }

	                    List<CustomerOrderReplica> customerOrderReplicas = new ArrayList<>();
	                    return customerOrderReplicas;
	                } else {
	                    return Collections.emptyList();
	                }
	            } else {
	                return null; // or an appropriate value
	            }
	        } else {
	            // Handle the case when the latest schedule is not active
	            return null; // or an appropriate value
	        }
	    } else {
	        // Handle the case when there is no latest schedule or its creation timestamp is null
	        return null; // or an appropriate value
	    }
	}

}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1003)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:799)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:743)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:666)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:658)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.lambda$0(LSJavaHoverProvider.java:68)
	at java.base/java.util.concurrent.CompletableFuture$AsyncRun.run(CompletableFuture.java:1804)
	at java.base/java.util.concurrent.CompletableFuture$AsyncRun.exec(CompletableFuture.java:1796)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:373)
	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1182)
	at java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1655)
	at java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1622)
	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:165)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-09-21 15:34:20.561
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1003)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:799)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:743)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:666)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:658)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.lambda$0(LSJavaHoverProvider.java:68)
	at java.base/java.util.concurrent.CompletableFuture$AsyncRun.run(CompletableFuture.java:1804)
	at java.base/java.util.concurrent.CompletableFuture$AsyncRun.exec(CompletableFuture.java:1796)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:373)
	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1182)
	at java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1655)
	at java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1622)
	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:165)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-09-21 15:34:20.564
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1003)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:799)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:743)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:666)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:658)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.lambda$0(LSJavaHoverProvider.java:68)
	at java.base/java.util.concurrent.CompletableFuture$AsyncRun.run(CompletableFuture.java:1804)
	at java.base/java.util.concurrent.CompletableFuture$AsyncRun.exec(CompletableFuture.java:1796)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:373)
	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1182)
	at java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1655)
	at java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1622)
	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:165)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-21 15:34:20.626
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.xyram.daydrop.serviceimpl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.transaction.Transactional;

import org.apache.commons.collections4.map.HashedMap;
import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.server.ResponseStatusException;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.xyram.daydrop.admin.model.CurrentUser;
import com.xyram.daydrop.basemodel.Base64Wrapper;
import com.xyram.daydrop.basemodel.MerchantTransactionIdGenerator;
import com.xyram.daydrop.basemodel.PhonepeSerializer;
import com.xyram.daydrop.dao.ApartmentDao;
import com.xyram.daydrop.dao.CustomerDetailsDao;
import com.xyram.daydrop.dao.CustomerOrderDao;
import com.xyram.daydrop.dao.CustomerOrderReplicaDoa;
import com.xyram.daydrop.dao.SheduleDao;
import com.xyram.daydrop.enumtypes.UserStatus;
import com.xyram.daydrop.model.Apartments;
import com.xyram.daydrop.model.CustomerOrder;
import com.xyram.daydrop.model.CustomerOrderReplica;
import com.xyram.daydrop.model.Customers;
import com.xyram.daydrop.model.Schedule;
import com.xyram.daydrop.modelMapper.PaymentInstrument;
import com.xyram.daydrop.modelMapper.PhonePePayModel;
import com.xyram.daydrop.request.CustomerOrderReplicaRequest;
import com.xyram.daydrop.response.RazorPayRequest;
import com.xyram.daydrop.service.CustomerOrderPriceService;
import com.xyram.daydrop.service.CustomerOrderReplicaService;
import com.xyram.daydrop.util.HashEncoder;
import com.xyram.daydrop.util.RazorPay;
import com.xyram.daydrop.service.ConsumerService;

@Transactional
@Service
public class CustomerOrderReplicaServiceImpl implements CustomerOrderReplicaService {

	@Autowired
	CustomerOrderReplicaDoa customerOrderReplicaDoa;

	@Autowired
	ApartmentDao apartmentDao;

	@Autowired
	SheduleDao scheduleDao;

	@Autowired
	CustomerDetailsDao customerDetailsDao;

	@Autowired
	ConsumerService consumerService;

	@Autowired
	CurrentUser currentUser;

	@Autowired
	PhonepeServiceImpl phonepeServiceImpl;

	@Value("${merchant_id}")
	private String merchantId;

	@Value("${salt_key}")
	private String saltKey;

	@Value("${salt_index}")
	private String saltIndex;

	@Override
	public Map createCustomerOrderReplicaService(CustomerOrderReplicaRequest customerOrderReplicaRequest,
			String contactNumber, Integer aparmentId)

	{

		Map response = new HashedMap<>();

		response.put("message", "success");
		CustomerOrderReplica customerOrderReplica = null;

		if (customerOrderReplicaRequest.getCartId() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "cartId is mandatory ");
		}
		long razorPayCount = 0;
		if (customerOrderReplicaRequest.getOrderId() != null) {

			razorPayCount = customerOrderReplicaDoa.getRazorPayExistByCartId(customerOrderReplicaRequest.getOrderId());
		}

		if (customerOrderReplicaRequest.getCustomerDetails() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Order Details  is mandatory ");
		}

		customerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(customerOrderReplicaRequest.getCartId(),
				contactNumber);

		if (customerOrderReplica != null) {
			customerOrderReplica.setCartId(customerOrderReplica.getCartId());

			if (customerOrderReplica.isOrdered()) {
				throw new ResponseStatusException(HttpStatus.CONFLICT, "Your Order is Placed With cart Details");
			}

//			if (razorPayCount >= 1 && !(customerOrderReplica.getRazorPayOrderId() != null
//					&& customerOrderReplica.getRazorPayOrderId().equals(customerOrderReplicaRequest.getOrderId()))) {
//				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
//			}

			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);

			customerOrderReplica.setAttempts(customerOrderReplica.getAttempts() + 1);
			customerOrderReplica.setUpdatedTime(new Date());

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		} else {

			customerOrderReplica = new CustomerOrderReplica();
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);
			customerOrderReplica.setCartId(customerOrderReplicaRequest.getCartId());
			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());

			if (razorPayCount > 0) {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
			}

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			Schedule schedule = scheduleDao.getlatestScheduleCustomers();

			if (schedule != null) {

				try {
					customerOrderReplica.setSchedule(schedule.getsId() != null ? schedule.getsId().toString() : null);
				} catch (Exception e) {
					e.printStackTrace();
				}
			} else {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
						"Sorry We Are Not Accepting Any Order Right now");

			}

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		}

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicas(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String schedule = null;

		Map filter = request.containsKey("filters") ? (Map) request.get("filters") : null;
		if (filter != null) {
			statusType = filter.containsKey("statusType") ? ((String) filter.get("statusType")).toLowerCase() : null;
			searchQuery = filter.containsKey("searchQuery") ? ((String) filter.get("searchQuery")).toLowerCase() : null;
			schedule = filter.containsKey("schedule") ? (String.valueOf(filter.get("schedule"))) : null;

		}

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplica(searchQuery, statusType, schedule);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");

				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setStreetName(
						customers.get("streetName") != null ? (String) customers.get("streetName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicasBySchedule(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String scheduleId = null;

		Schedule schedule = scheduleDao.getlatestScheduleCustomers();

		if (schedule != null) {

			try {
				scheduleId = schedule.getsId() != null ? schedule.getsId().toString() : null;
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

		statusType = request.containsKey("statusType") ? ((String) request.get("statusType")).toLowerCase() : "Success";

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplicaBySchdeule(statusType, scheduleId);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");
				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				System.out.println("customers" + customers.get("customerName"));

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public CustomerOrderReplica getCustomerOrderReplicaByCartId(String cartId) {

		CustomerOrderReplica CustomerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(cartId,
				currentUser.getContactNumber());

		ObjectMapper objectMapper = new ObjectMapper();
		try {

			// convert JSON string to Map
			Map<String, Object> customerOrderReplicaMap = objectMapper
					.readValue(CustomerOrderReplica.getCustomerOrderDetails(), Map.class);

			Object customerOrder = customerOrderReplicaMap.get("customerOrder");
			Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

			Object quanityList = items.get("quantity");
			Map customers = customerDetailsDao.getByContactNumberAndApartment(CustomerOrderReplica.getContactNumber(),
					CustomerOrderReplica.getApartmentId());

			System.out.println("customers" + customers.get("customerName"));

			// Apartments apartments =
			// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
			CustomerOrderReplica.setApartmentName(
					customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

			CustomerOrderReplica.setCustomerDetails(customers);

			CustomerOrderReplica.setCustomerOrder(customerOrder);
			CustomerOrderReplica.setQuatityList(quanityList);

		} catch (Exception e) {
			e.printStackTrace();
		}

		return CustomerOrderReplica;

	}

	@Override
	public Map createCustomerOrderReplica(CustomerOrderReplicaRequest customerOrderReplicaRequest, String contactNumber,
			Integer aparmentId) {

		if (customerOrderReplicaRequest.getRazorPayRequest() != null) {

//			Map razorPay = consumerService.createRazorPayOrder(customerOrderReplicaRequest.getRazorPayRequest());
//			customerOrderReplicaRequest.setOrderId(razorPay.get("order") != null ? (String)((RazorPay) razorPay.get("order")).getId() : null);	
//	
//			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);
//
//			razorPay.put("cartId", customerOrderReplicaRequest.getCartId());

			Map customerOrderReplicaMap = new HashMap<>();

			Map orderId = new HashMap<>();
			String transactionId = getMerchantTransactionId();
			orderId.put("id", transactionId);

			customerOrderReplicaMap.put("order", orderId);

			customerOrderReplicaRequest.setOrderId(transactionId);
			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);

			customerOrderReplicaMap.put("cartId", customerOrderReplicaRequest.getCartId());

			try {
				customerOrderReplicaMap.put("phonePeResponse",
						phonepeServiceImpl.initiatePhonepePayment(transactionId,
								Integer.valueOf(customerOrderReplicaRequest.getRazorPayRequest().getAmount()),
								contactNumber, customerOrderReplicaRequest.getRedirectUrl(), customerOrderReplicaRequest.getCallBackUrl()));

			} catch (Exception e) {
				e.printStackTrace();
				customerOrderReplicaMap.put("phonePeResponse", new HashedMap<>());
			}

			return customerOrderReplicaMap;

		} else {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
					"paymentDetails transcation Details are mandatory");
		}

	}

	private static String getMerchantTransactionId() {

		return "OD_" + MerchantTransactionIdGenerator.getRandomString();
	}


	@Override
	public List<CustomerOrderReplica> getCustomerOrderByMoblieNo(String contactNumber, Integer aid) {

	    Schedule latestSchedule = customerOrderReplicaDoa.getlatestschedule();

	    if (latestSchedule != null && latestSchedule.getCreationTimestamp() != null) {
	        if (latestSchedule.getStatus().equals(UserStatus.ACTIVE)) {
	            Customers customer = customerDetailsDao.getByContactNoAndApartment(contactNumber, aid);

	            if (customer != null) { // Ensure the customer exists
	                List<CustomerOrder> customerOrderList = customerOrderReplicaDoa.getListCustomerOrderByCustomerId(customer.getCtId());

	                double totalOrderAmount = 0.0;

	                if (customerOrderList != null && !customerOrderList.isEmpty()) {
	                    for (CustomerOrder customerOrder : customerOrderList) {
	                        Double orderAmount = customerOrder.getAmount();
	                        if (orderAmount != null) {
	                            totalOrderAmount += orderAmount;
	                            if(totalOrderAmount>200) {
	                            	totalOrderAmount+= customerOrder.getDelivaryCharges();
	                            }
	                            else (totalOrderAmount<200){
	                            	totalOrderAmount-= customerOrder.getDelivaryCharges();
	                            }
	                        }
	                    }

	                    // Define the minimum order amount for applying delivery charges
	                    double minimumOrderAmount = 200.0;

	                    if (totalOrderAmount < minimumOrderAmount) {
	                        System.out.println("Delivery Charges will be applicable");
	                    } else {
	                        // No delivery charges applicable
	                        System.out.println("No Delivery charges applicable");
	                    }

	                    List<CustomerOrderReplica> customerOrderReplicas = new ArrayList<>();
	                    return customerOrderReplicas;
	                } else {
	                    return Collections.emptyList();
	                }
	            } else {
	                return null; // or an appropriate value
	            }
	        } else {
	            // Handle the case when the latest schedule is not active
	            return null; // or an appropriate value
	        }
	    } else {
	        // Handle the case when there is no latest schedule or its creation timestamp is null
	        return null; // or an appropriate value
	    }
	}

}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4035)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3635)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-09-21 15:34:20.628
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4035)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3635)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-09-21 15:34:20.630
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4035)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3635)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-21 15:34:20.676
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.xyram.daydrop.serviceimpl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.transaction.Transactional;

import org.apache.commons.collections4.map.HashedMap;
import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.server.ResponseStatusException;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.xyram.daydrop.admin.model.CurrentUser;
import com.xyram.daydrop.basemodel.Base64Wrapper;
import com.xyram.daydrop.basemodel.MerchantTransactionIdGenerator;
import com.xyram.daydrop.basemodel.PhonepeSerializer;
import com.xyram.daydrop.dao.ApartmentDao;
import com.xyram.daydrop.dao.CustomerDetailsDao;
import com.xyram.daydrop.dao.CustomerOrderDao;
import com.xyram.daydrop.dao.CustomerOrderReplicaDoa;
import com.xyram.daydrop.dao.SheduleDao;
import com.xyram.daydrop.enumtypes.UserStatus;
import com.xyram.daydrop.model.Apartments;
import com.xyram.daydrop.model.CustomerOrder;
import com.xyram.daydrop.model.CustomerOrderReplica;
import com.xyram.daydrop.model.Customers;
import com.xyram.daydrop.model.Schedule;
import com.xyram.daydrop.modelMapper.PaymentInstrument;
import com.xyram.daydrop.modelMapper.PhonePePayModel;
import com.xyram.daydrop.request.CustomerOrderReplicaRequest;
import com.xyram.daydrop.response.RazorPayRequest;
import com.xyram.daydrop.service.CustomerOrderPriceService;
import com.xyram.daydrop.service.CustomerOrderReplicaService;
import com.xyram.daydrop.util.HashEncoder;
import com.xyram.daydrop.util.RazorPay;
import com.xyram.daydrop.service.ConsumerService;

@Transactional
@Service
public class CustomerOrderReplicaServiceImpl implements CustomerOrderReplicaService {

	@Autowired
	CustomerOrderReplicaDoa customerOrderReplicaDoa;

	@Autowired
	ApartmentDao apartmentDao;

	@Autowired
	SheduleDao scheduleDao;

	@Autowired
	CustomerDetailsDao customerDetailsDao;

	@Autowired
	ConsumerService consumerService;

	@Autowired
	CurrentUser currentUser;

	@Autowired
	PhonepeServiceImpl phonepeServiceImpl;

	@Value("${merchant_id}")
	private String merchantId;

	@Value("${salt_key}")
	private String saltKey;

	@Value("${salt_index}")
	private String saltIndex;

	@Override
	public Map createCustomerOrderReplicaService(CustomerOrderReplicaRequest customerOrderReplicaRequest,
			String contactNumber, Integer aparmentId)

	{

		Map response = new HashedMap<>();

		response.put("message", "success");
		CustomerOrderReplica customerOrderReplica = null;

		if (customerOrderReplicaRequest.getCartId() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "cartId is mandatory ");
		}
		long razorPayCount = 0;
		if (customerOrderReplicaRequest.getOrderId() != null) {

			razorPayCount = customerOrderReplicaDoa.getRazorPayExistByCartId(customerOrderReplicaRequest.getOrderId());
		}

		if (customerOrderReplicaRequest.getCustomerDetails() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Order Details  is mandatory ");
		}

		customerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(customerOrderReplicaRequest.getCartId(),
				contactNumber);

		if (customerOrderReplica != null) {
			customerOrderReplica.setCartId(customerOrderReplica.getCartId());

			if (customerOrderReplica.isOrdered()) {
				throw new ResponseStatusException(HttpStatus.CONFLICT, "Your Order is Placed With cart Details");
			}

//			if (razorPayCount >= 1 && !(customerOrderReplica.getRazorPayOrderId() != null
//					&& customerOrderReplica.getRazorPayOrderId().equals(customerOrderReplicaRequest.getOrderId()))) {
//				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
//			}

			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);

			customerOrderReplica.setAttempts(customerOrderReplica.getAttempts() + 1);
			customerOrderReplica.setUpdatedTime(new Date());

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		} else {

			customerOrderReplica = new CustomerOrderReplica();
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);
			customerOrderReplica.setCartId(customerOrderReplicaRequest.getCartId());
			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());

			if (razorPayCount > 0) {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
			}

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			Schedule schedule = scheduleDao.getlatestScheduleCustomers();

			if (schedule != null) {

				try {
					customerOrderReplica.setSchedule(schedule.getsId() != null ? schedule.getsId().toString() : null);
				} catch (Exception e) {
					e.printStackTrace();
				}
			} else {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
						"Sorry We Are Not Accepting Any Order Right now");

			}

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		}

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicas(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String schedule = null;

		Map filter = request.containsKey("filters") ? (Map) request.get("filters") : null;
		if (filter != null) {
			statusType = filter.containsKey("statusType") ? ((String) filter.get("statusType")).toLowerCase() : null;
			searchQuery = filter.containsKey("searchQuery") ? ((String) filter.get("searchQuery")).toLowerCase() : null;
			schedule = filter.containsKey("schedule") ? (String.valueOf(filter.get("schedule"))) : null;

		}

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplica(searchQuery, statusType, schedule);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");

				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setStreetName(
						customers.get("streetName") != null ? (String) customers.get("streetName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicasBySchedule(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String scheduleId = null;

		Schedule schedule = scheduleDao.getlatestScheduleCustomers();

		if (schedule != null) {

			try {
				scheduleId = schedule.getsId() != null ? schedule.getsId().toString() : null;
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

		statusType = request.containsKey("statusType") ? ((String) request.get("statusType")).toLowerCase() : "Success";

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplicaBySchdeule(statusType, scheduleId);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");
				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				System.out.println("customers" + customers.get("customerName"));

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public CustomerOrderReplica getCustomerOrderReplicaByCartId(String cartId) {

		CustomerOrderReplica CustomerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(cartId,
				currentUser.getContactNumber());

		ObjectMapper objectMapper = new ObjectMapper();
		try {

			// convert JSON string to Map
			Map<String, Object> customerOrderReplicaMap = objectMapper
					.readValue(CustomerOrderReplica.getCustomerOrderDetails(), Map.class);

			Object customerOrder = customerOrderReplicaMap.get("customerOrder");
			Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

			Object quanityList = items.get("quantity");
			Map customers = customerDetailsDao.getByContactNumberAndApartment(CustomerOrderReplica.getContactNumber(),
					CustomerOrderReplica.getApartmentId());

			System.out.println("customers" + customers.get("customerName"));

			// Apartments apartments =
			// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
			CustomerOrderReplica.setApartmentName(
					customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

			CustomerOrderReplica.setCustomerDetails(customers);

			CustomerOrderReplica.setCustomerOrder(customerOrder);
			CustomerOrderReplica.setQuatityList(quanityList);

		} catch (Exception e) {
			e.printStackTrace();
		}

		return CustomerOrderReplica;

	}

	@Override
	public Map createCustomerOrderReplica(CustomerOrderReplicaRequest customerOrderReplicaRequest, String contactNumber,
			Integer aparmentId) {

		if (customerOrderReplicaRequest.getRazorPayRequest() != null) {

//			Map razorPay = consumerService.createRazorPayOrder(customerOrderReplicaRequest.getRazorPayRequest());
//			customerOrderReplicaRequest.setOrderId(razorPay.get("order") != null ? (String)((RazorPay) razorPay.get("order")).getId() : null);	
//	
//			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);
//
//			razorPay.put("cartId", customerOrderReplicaRequest.getCartId());

			Map customerOrderReplicaMap = new HashMap<>();

			Map orderId = new HashMap<>();
			String transactionId = getMerchantTransactionId();
			orderId.put("id", transactionId);

			customerOrderReplicaMap.put("order", orderId);

			customerOrderReplicaRequest.setOrderId(transactionId);
			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);

			customerOrderReplicaMap.put("cartId", customerOrderReplicaRequest.getCartId());

			try {
				customerOrderReplicaMap.put("phonePeResponse",
						phonepeServiceImpl.initiatePhonepePayment(transactionId,
								Integer.valueOf(customerOrderReplicaRequest.getRazorPayRequest().getAmount()),
								contactNumber, customerOrderReplicaRequest.getRedirectUrl(), customerOrderReplicaRequest.getCallBackUrl()));

			} catch (Exception e) {
				e.printStackTrace();
				customerOrderReplicaMap.put("phonePeResponse", new HashedMap<>());
			}

			return customerOrderReplicaMap;

		} else {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
					"paymentDetails transcation Details are mandatory");
		}

	}

	private static String getMerchantTransactionId() {

		return "OD_" + MerchantTransactionIdGenerator.getRandomString();
	}


	@Override
	public List<CustomerOrderReplica> getCustomerOrderByMoblieNo(String contactNumber, Integer aid) {

	    Schedule latestSchedule = customerOrderReplicaDoa.getlatestschedule();

	    if (latestSchedule != null && latestSchedule.getCreationTimestamp() != null) {
	        if (latestSchedule.getStatus().equals(UserStatus.ACTIVE)) {
	            Customers customer = customerDetailsDao.getByContactNoAndApartment(contactNumber, aid);

	            if (customer != null) { // Ensure the customer exists
	                List<CustomerOrder> customerOrderList = customerOrderReplicaDoa.getListCustomerOrderByCustomerId(customer.getCtId());

	                double totalOrderAmount = 0.0;

	                if (customerOrderList != null && !customerOrderList.isEmpty()) {
	                    for (CustomerOrder customerOrder : customerOrderList) {
	                        Double orderAmount = customerOrder.getAmount();
	                        if (orderAmount != null) {
	                            totalOrderAmount += orderAmount;
	                            if(totalOrderAmount>200) {
	                            	totalOrderAmount+= customerOrder.getDelivaryCharges();
	                            }
	                            else (totalOrderAmount<200){
	                            	totalOrderAmount-= customerOrder.getDelivaryCharges();
	                            }
	                        }
	                    }

	                    // Define the minimum order amount for applying delivery charges
	                    double minimumOrderAmount = 200.0;

	                    if (totalOrderAmount < minimumOrderAmount) {
	                        System.out.println("Delivery Charges will be applicable");
	                    } else {
	                        // No delivery charges applicable
	                        System.out.println("No Delivery charges applicable");
	                    }

	                    List<CustomerOrderReplica> customerOrderReplicas = new ArrayList<>();
	                    return customerOrderReplicas;
	                } else {
	                    return Collections.emptyList();
	                }
	            } else {
	                return null; // or an appropriate value
	            }
	        } else {
	            // Handle the case when the latest schedule is not active
	            return null; // or an appropriate value
	        }
	    } else {
	        // Handle the case when there is no latest schedule or its creation timestamp is null
	        return null; // or an appropriate value
	    }
	}

}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.internal.core.manipulation.dom.ASTResolving.createQuickFixAST(ASTResolving.java:1052)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:131)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4035)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3635)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.ui 4 0 2023-09-21 15:34:20.677
!MESSAGE Unhandled event loop exception
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.internal.core.manipulation.dom.ASTResolving.createQuickFixAST(ASTResolving.java:1052)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:131)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4035)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3635)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-21 15:34:21.247
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.xyram.daydrop.serviceimpl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.transaction.Transactional;

import org.apache.commons.collections4.map.HashedMap;
import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.server.ResponseStatusException;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.xyram.daydrop.admin.model.CurrentUser;
import com.xyram.daydrop.basemodel.Base64Wrapper;
import com.xyram.daydrop.basemodel.MerchantTransactionIdGenerator;
import com.xyram.daydrop.basemodel.PhonepeSerializer;
import com.xyram.daydrop.dao.ApartmentDao;
import com.xyram.daydrop.dao.CustomerDetailsDao;
import com.xyram.daydrop.dao.CustomerOrderDao;
import com.xyram.daydrop.dao.CustomerOrderReplicaDoa;
import com.xyram.daydrop.dao.SheduleDao;
import com.xyram.daydrop.enumtypes.UserStatus;
import com.xyram.daydrop.model.Apartments;
import com.xyram.daydrop.model.CustomerOrder;
import com.xyram.daydrop.model.CustomerOrderReplica;
import com.xyram.daydrop.model.Customers;
import com.xyram.daydrop.model.Schedule;
import com.xyram.daydrop.modelMapper.PaymentInstrument;
import com.xyram.daydrop.modelMapper.PhonePePayModel;
import com.xyram.daydrop.request.CustomerOrderReplicaRequest;
import com.xyram.daydrop.response.RazorPayRequest;
import com.xyram.daydrop.service.CustomerOrderPriceService;
import com.xyram.daydrop.service.CustomerOrderReplicaService;
import com.xyram.daydrop.util.HashEncoder;
import com.xyram.daydrop.util.RazorPay;
import com.xyram.daydrop.service.ConsumerService;

@Transactional
@Service
public class CustomerOrderReplicaServiceImpl implements CustomerOrderReplicaService {

	@Autowired
	CustomerOrderReplicaDoa customerOrderReplicaDoa;

	@Autowired
	ApartmentDao apartmentDao;

	@Autowired
	SheduleDao scheduleDao;

	@Autowired
	CustomerDetailsDao customerDetailsDao;

	@Autowired
	ConsumerService consumerService;

	@Autowired
	CurrentUser currentUser;

	@Autowired
	PhonepeServiceImpl phonepeServiceImpl;

	@Value("${merchant_id}")
	private String merchantId;

	@Value("${salt_key}")
	private String saltKey;

	@Value("${salt_index}")
	private String saltIndex;

	@Override
	public Map createCustomerOrderReplicaService(CustomerOrderReplicaRequest customerOrderReplicaRequest,
			String contactNumber, Integer aparmentId)

	{

		Map response = new HashedMap<>();

		response.put("message", "success");
		CustomerOrderReplica customerOrderReplica = null;

		if (customerOrderReplicaRequest.getCartId() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "cartId is mandatory ");
		}
		long razorPayCount = 0;
		if (customerOrderReplicaRequest.getOrderId() != null) {

			razorPayCount = customerOrderReplicaDoa.getRazorPayExistByCartId(customerOrderReplicaRequest.getOrderId());
		}

		if (customerOrderReplicaRequest.getCustomerDetails() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Order Details  is mandatory ");
		}

		customerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(customerOrderReplicaRequest.getCartId(),
				contactNumber);

		if (customerOrderReplica != null) {
			customerOrderReplica.setCartId(customerOrderReplica.getCartId());

			if (customerOrderReplica.isOrdered()) {
				throw new ResponseStatusException(HttpStatus.CONFLICT, "Your Order is Placed With cart Details");
			}

//			if (razorPayCount >= 1 && !(customerOrderReplica.getRazorPayOrderId() != null
//					&& customerOrderReplica.getRazorPayOrderId().equals(customerOrderReplicaRequest.getOrderId()))) {
//				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
//			}

			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);

			customerOrderReplica.setAttempts(customerOrderReplica.getAttempts() + 1);
			customerOrderReplica.setUpdatedTime(new Date());

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		} else {

			customerOrderReplica = new CustomerOrderReplica();
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);
			customerOrderReplica.setCartId(customerOrderReplicaRequest.getCartId());
			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());

			if (razorPayCount > 0) {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
			}

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			Schedule schedule = scheduleDao.getlatestScheduleCustomers();

			if (schedule != null) {

				try {
					customerOrderReplica.setSchedule(schedule.getsId() != null ? schedule.getsId().toString() : null);
				} catch (Exception e) {
					e.printStackTrace();
				}
			} else {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
						"Sorry We Are Not Accepting Any Order Right now");

			}

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		}

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicas(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String schedule = null;

		Map filter = request.containsKey("filters") ? (Map) request.get("filters") : null;
		if (filter != null) {
			statusType = filter.containsKey("statusType") ? ((String) filter.get("statusType")).toLowerCase() : null;
			searchQuery = filter.containsKey("searchQuery") ? ((String) filter.get("searchQuery")).toLowerCase() : null;
			schedule = filter.containsKey("schedule") ? (String.valueOf(filter.get("schedule"))) : null;

		}

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplica(searchQuery, statusType, schedule);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");

				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setStreetName(
						customers.get("streetName") != null ? (String) customers.get("streetName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicasBySchedule(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String scheduleId = null;

		Schedule schedule = scheduleDao.getlatestScheduleCustomers();

		if (schedule != null) {

			try {
				scheduleId = schedule.getsId() != null ? schedule.getsId().toString() : null;
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

		statusType = request.containsKey("statusType") ? ((String) request.get("statusType")).toLowerCase() : "Success";

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplicaBySchdeule(statusType, scheduleId);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");
				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				System.out.println("customers" + customers.get("customerName"));

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public CustomerOrderReplica getCustomerOrderReplicaByCartId(String cartId) {

		CustomerOrderReplica CustomerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(cartId,
				currentUser.getContactNumber());

		ObjectMapper objectMapper = new ObjectMapper();
		try {

			// convert JSON string to Map
			Map<String, Object> customerOrderReplicaMap = objectMapper
					.readValue(CustomerOrderReplica.getCustomerOrderDetails(), Map.class);

			Object customerOrder = customerOrderReplicaMap.get("customerOrder");
			Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

			Object quanityList = items.get("quantity");
			Map customers = customerDetailsDao.getByContactNumberAndApartment(CustomerOrderReplica.getContactNumber(),
					CustomerOrderReplica.getApartmentId());

			System.out.println("customers" + customers.get("customerName"));

			// Apartments apartments =
			// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
			CustomerOrderReplica.setApartmentName(
					customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

			CustomerOrderReplica.setCustomerDetails(customers);

			CustomerOrderReplica.setCustomerOrder(customerOrder);
			CustomerOrderReplica.setQuatityList(quanityList);

		} catch (Exception e) {
			e.printStackTrace();
		}

		return CustomerOrderReplica;

	}

	@Override
	public Map createCustomerOrderReplica(CustomerOrderReplicaRequest customerOrderReplicaRequest, String contactNumber,
			Integer aparmentId) {

		if (customerOrderReplicaRequest.getRazorPayRequest() != null) {

//			Map razorPay = consumerService.createRazorPayOrder(customerOrderReplicaRequest.getRazorPayRequest());
//			customerOrderReplicaRequest.setOrderId(razorPay.get("order") != null ? (String)((RazorPay) razorPay.get("order")).getId() : null);	
//	
//			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);
//
//			razorPay.put("cartId", customerOrderReplicaRequest.getCartId());

			Map customerOrderReplicaMap = new HashMap<>();

			Map orderId = new HashMap<>();
			String transactionId = getMerchantTransactionId();
			orderId.put("id", transactionId);

			customerOrderReplicaMap.put("order", orderId);

			customerOrderReplicaRequest.setOrderId(transactionId);
			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);

			customerOrderReplicaMap.put("cartId", customerOrderReplicaRequest.getCartId());

			try {
				customerOrderReplicaMap.put("phonePeResponse",
						phonepeServiceImpl.initiatePhonepePayment(transactionId,
								Integer.valueOf(customerOrderReplicaRequest.getRazorPayRequest().getAmount()),
								contactNumber, customerOrderReplicaRequest.getRedirectUrl(), customerOrderReplicaRequest.getCallBackUrl()));

			} catch (Exception e) {
				e.printStackTrace();
				customerOrderReplicaMap.put("phonePeResponse", new HashedMap<>());
			}

			return customerOrderReplicaMap;

		} else {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
					"paymentDetails transcation Details are mandatory");
		}

	}

	private static String getMerchantTransactionId() {

		return "OD_" + MerchantTransactionIdGenerator.getRandomString();
	}


	@Override
	public List<CustomerOrderReplica> getCustomerOrderByMoblieNo(String contactNumber, Integer aid) {

	    Schedule latestSchedule = customerOrderReplicaDoa.getlatestschedule();

	    if (latestSchedule != null && latestSchedule.getCreationTimestamp() != null) {
	        if (latestSchedule.getStatus().equals(UserStatus.ACTIVE)) {
	            Customers customer = customerDetailsDao.getByContactNoAndApartment(contactNumber, aid);

	            if (customer != null) { // Ensure the customer exists
	                List<CustomerOrder> customerOrderList = customerOrderReplicaDoa.getListCustomerOrderByCustomerId(customer.getCtId());

	                double totalOrderAmount = 0.0;

	                if (customerOrderList != null && !customerOrderList.isEmpty()) {
	                    for (CustomerOrder customerOrder : customerOrderList) {
	                        Double orderAmount = customerOrder.getAmount();
	                        if (orderAmount != null) {
	                            totalOrderAmount += orderAmount;
	                            if(totalOrderAmount>200) {
	                            	totalOrderAmount+= customerOrder.getDelivaryCharges();
	                            }
	                            else (totalOrderAmount<200){
	                            	totalOrderAmount-= customerOrder.getDelivaryCharges();
	                            }
	                        }
	                    }

	                    // Define the minimum order amount for applying delivery charges
	                    double minimumOrderAmount = 200.0;

	                    if (totalOrderAmount < minimumOrderAmount) {
	                        System.out.println("Delivery Charges will be applicable");
	                    } else {
	                        // No delivery charges applicable
	                        System.out.println("No Delivery charges applicable");
	                    }

	                    List<CustomerOrderReplica> customerOrderReplicas = new ArrayList<>();
	                    return customerOrderReplicas;
	                } else {
	                    return Collections.emptyList();
	                }
	            } else {
	                return null; // or an appropriate value
	            }
	        } else {
	            // Handle the case when the latest schedule is not active
	            return null; // or an appropriate value
	        }
	    } else {
	        // Handle the case when there is no latest schedule or its creation timestamp is null
	        return null; // or an appropriate value
	    }
	}

}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-09-21 15:34:21.250
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-09-21 15:34:21.251
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-21 15:34:21.924
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.xyram.daydrop.serviceimpl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.transaction.Transactional;

import org.apache.commons.collections4.map.HashedMap;
import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.server.ResponseStatusException;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.xyram.daydrop.admin.model.CurrentUser;
import com.xyram.daydrop.basemodel.Base64Wrapper;
import com.xyram.daydrop.basemodel.MerchantTransactionIdGenerator;
import com.xyram.daydrop.basemodel.PhonepeSerializer;
import com.xyram.daydrop.dao.ApartmentDao;
import com.xyram.daydrop.dao.CustomerDetailsDao;
import com.xyram.daydrop.dao.CustomerOrderDao;
import com.xyram.daydrop.dao.CustomerOrderReplicaDoa;
import com.xyram.daydrop.dao.SheduleDao;
import com.xyram.daydrop.enumtypes.UserStatus;
import com.xyram.daydrop.model.Apartments;
import com.xyram.daydrop.model.CustomerOrder;
import com.xyram.daydrop.model.CustomerOrderReplica;
import com.xyram.daydrop.model.Customers;
import com.xyram.daydrop.model.Schedule;
import com.xyram.daydrop.modelMapper.PaymentInstrument;
import com.xyram.daydrop.modelMapper.PhonePePayModel;
import com.xyram.daydrop.request.CustomerOrderReplicaRequest;
import com.xyram.daydrop.response.RazorPayRequest;
import com.xyram.daydrop.service.CustomerOrderPriceService;
import com.xyram.daydrop.service.CustomerOrderReplicaService;
import com.xyram.daydrop.util.HashEncoder;
import com.xyram.daydrop.util.RazorPay;
import com.xyram.daydrop.service.ConsumerService;

@Transactional
@Service
public class CustomerOrderReplicaServiceImpl implements CustomerOrderReplicaService {

	@Autowired
	CustomerOrderReplicaDoa customerOrderReplicaDoa;

	@Autowired
	ApartmentDao apartmentDao;

	@Autowired
	SheduleDao scheduleDao;

	@Autowired
	CustomerDetailsDao customerDetailsDao;

	@Autowired
	ConsumerService consumerService;

	@Autowired
	CurrentUser currentUser;

	@Autowired
	PhonepeServiceImpl phonepeServiceImpl;

	@Value("${merchant_id}")
	private String merchantId;

	@Value("${salt_key}")
	private String saltKey;

	@Value("${salt_index}")
	private String saltIndex;

	@Override
	public Map createCustomerOrderReplicaService(CustomerOrderReplicaRequest customerOrderReplicaRequest,
			String contactNumber, Integer aparmentId)

	{

		Map response = new HashedMap<>();

		response.put("message", "success");
		CustomerOrderReplica customerOrderReplica = null;

		if (customerOrderReplicaRequest.getCartId() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "cartId is mandatory ");
		}
		long razorPayCount = 0;
		if (customerOrderReplicaRequest.getOrderId() != null) {

			razorPayCount = customerOrderReplicaDoa.getRazorPayExistByCartId(customerOrderReplicaRequest.getOrderId());
		}

		if (customerOrderReplicaRequest.getCustomerDetails() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Order Details  is mandatory ");
		}

		customerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(customerOrderReplicaRequest.getCartId(),
				contactNumber);

		if (customerOrderReplica != null) {
			customerOrderReplica.setCartId(customerOrderReplica.getCartId());

			if (customerOrderReplica.isOrdered()) {
				throw new ResponseStatusException(HttpStatus.CONFLICT, "Your Order is Placed With cart Details");
			}

//			if (razorPayCount >= 1 && !(customerOrderReplica.getRazorPayOrderId() != null
//					&& customerOrderReplica.getRazorPayOrderId().equals(customerOrderReplicaRequest.getOrderId()))) {
//				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
//			}

			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);

			customerOrderReplica.setAttempts(customerOrderReplica.getAttempts() + 1);
			customerOrderReplica.setUpdatedTime(new Date());

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		} else {

			customerOrderReplica = new CustomerOrderReplica();
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);
			customerOrderReplica.setCartId(customerOrderReplicaRequest.getCartId());
			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());

			if (razorPayCount > 0) {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
			}

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			Schedule schedule = scheduleDao.getlatestScheduleCustomers();

			if (schedule != null) {

				try {
					customerOrderReplica.setSchedule(schedule.getsId() != null ? schedule.getsId().toString() : null);
				} catch (Exception e) {
					e.printStackTrace();
				}
			} else {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
						"Sorry We Are Not Accepting Any Order Right now");

			}

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		}

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicas(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String schedule = null;

		Map filter = request.containsKey("filters") ? (Map) request.get("filters") : null;
		if (filter != null) {
			statusType = filter.containsKey("statusType") ? ((String) filter.get("statusType")).toLowerCase() : null;
			searchQuery = filter.containsKey("searchQuery") ? ((String) filter.get("searchQuery")).toLowerCase() : null;
			schedule = filter.containsKey("schedule") ? (String.valueOf(filter.get("schedule"))) : null;

		}

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplica(searchQuery, statusType, schedule);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");

				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setStreetName(
						customers.get("streetName") != null ? (String) customers.get("streetName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicasBySchedule(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String scheduleId = null;

		Schedule schedule = scheduleDao.getlatestScheduleCustomers();

		if (schedule != null) {

			try {
				scheduleId = schedule.getsId() != null ? schedule.getsId().toString() : null;
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

		statusType = request.containsKey("statusType") ? ((String) request.get("statusType")).toLowerCase() : "Success";

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplicaBySchdeule(statusType, scheduleId);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");
				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				System.out.println("customers" + customers.get("customerName"));

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public CustomerOrderReplica getCustomerOrderReplicaByCartId(String cartId) {

		CustomerOrderReplica CustomerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(cartId,
				currentUser.getContactNumber());

		ObjectMapper objectMapper = new ObjectMapper();
		try {

			// convert JSON string to Map
			Map<String, Object> customerOrderReplicaMap = objectMapper
					.readValue(CustomerOrderReplica.getCustomerOrderDetails(), Map.class);

			Object customerOrder = customerOrderReplicaMap.get("customerOrder");
			Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

			Object quanityList = items.get("quantity");
			Map customers = customerDetailsDao.getByContactNumberAndApartment(CustomerOrderReplica.getContactNumber(),
					CustomerOrderReplica.getApartmentId());

			System.out.println("customers" + customers.get("customerName"));

			// Apartments apartments =
			// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
			CustomerOrderReplica.setApartmentName(
					customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

			CustomerOrderReplica.setCustomerDetails(customers);

			CustomerOrderReplica.setCustomerOrder(customerOrder);
			CustomerOrderReplica.setQuatityList(quanityList);

		} catch (Exception e) {
			e.printStackTrace();
		}

		return CustomerOrderReplica;

	}

	@Override
	public Map createCustomerOrderReplica(CustomerOrderReplicaRequest customerOrderReplicaRequest, String contactNumber,
			Integer aparmentId) {

		if (customerOrderReplicaRequest.getRazorPayRequest() != null) {

//			Map razorPay = consumerService.createRazorPayOrder(customerOrderReplicaRequest.getRazorPayRequest());
//			customerOrderReplicaRequest.setOrderId(razorPay.get("order") != null ? (String)((RazorPay) razorPay.get("order")).getId() : null);	
//	
//			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);
//
//			razorPay.put("cartId", customerOrderReplicaRequest.getCartId());

			Map customerOrderReplicaMap = new HashMap<>();

			Map orderId = new HashMap<>();
			String transactionId = getMerchantTransactionId();
			orderId.put("id", transactionId);

			customerOrderReplicaMap.put("order", orderId);

			customerOrderReplicaRequest.setOrderId(transactionId);
			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);

			customerOrderReplicaMap.put("cartId", customerOrderReplicaRequest.getCartId());

			try {
				customerOrderReplicaMap.put("phonePeResponse",
						phonepeServiceImpl.initiatePhonepePayment(transactionId,
								Integer.valueOf(customerOrderReplicaRequest.getRazorPayRequest().getAmount()),
								contactNumber, customerOrderReplicaRequest.getRedirectUrl(), customerOrderReplicaRequest.getCallBackUrl()));

			} catch (Exception e) {
				e.printStackTrace();
				customerOrderReplicaMap.put("phonePeResponse", new HashedMap<>());
			}

			return customerOrderReplicaMap;

		} else {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
					"paymentDetails transcation Details are mandatory");
		}

	}

	private static String getMerchantTransactionId() {

		return "OD_" + MerchantTransactionIdGenerator.getRandomString();
	}


	@Override
	public List<CustomerOrderReplica> getCustomerOrderByMoblieNo(String contactNumber, Integer aid) {

	    Schedule latestSchedule = customerOrderReplicaDoa.getlatestschedule();

	    if (latestSchedule != null && latestSchedule.getCreationTimestamp() != null) {
	        if (latestSchedule.getStatus().equals(UserStatus.ACTIVE)) {
	            Customers customer = customerDetailsDao.getByContactNoAndApartment(contactNumber, aid);

	            if (customer != null) { // Ensure the customer exists
	                List<CustomerOrder> customerOrderList = customerOrderReplicaDoa.getListCustomerOrderByCustomerId(customer.getCtId());

	                double totalOrderAmount = 0.0;

	                if (customerOrderList != null && !customerOrderList.isEmpty()) {
	                    for (CustomerOrder customerOrder : customerOrderList) {
	                        Double orderAmount = customerOrder.getAmount();
	                        if (orderAmount != null) {
	                            totalOrderAmount += orderAmount;
	                            if(totalOrderAmount>200) {
	                            	totalOrderAmount+= customerOrder.getDelivaryCharges();
	                            }
	                            else(totalOrderAmount<200){
	                            	totalOrderAmount-= customerOrder.getDelivaryCharges();
	                            }
	                        }
	                    }

	                    // Define the minimum order amount for applying delivery charges
	                    double minimumOrderAmount = 200.0;

	                    if (totalOrderAmount < minimumOrderAmount) {
	                        System.out.println("Delivery Charges will be applicable");
	                    } else {
	                        // No delivery charges applicable
	                        System.out.println("No Delivery charges applicable");
	                    }

	                    List<CustomerOrderReplica> customerOrderReplicas = new ArrayList<>();
	                    return customerOrderReplicas;
	                } else {
	                    return Collections.emptyList();
	                }
	            } else {
	                return null; // or an appropriate value
	            }
	        } else {
	            // Handle the case when the latest schedule is not active
	            return null; // or an appropriate value
	        }
	    } else {
	        // Handle the case when there is no latest schedule or its creation timestamp is null
	        return null; // or an appropriate value
	    }
	}

}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-09-21 15:34:21.926
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-09-21 15:34:21.928
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-21 15:34:22.048
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.xyram.daydrop.serviceimpl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.transaction.Transactional;

import org.apache.commons.collections4.map.HashedMap;
import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.server.ResponseStatusException;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.xyram.daydrop.admin.model.CurrentUser;
import com.xyram.daydrop.basemodel.Base64Wrapper;
import com.xyram.daydrop.basemodel.MerchantTransactionIdGenerator;
import com.xyram.daydrop.basemodel.PhonepeSerializer;
import com.xyram.daydrop.dao.ApartmentDao;
import com.xyram.daydrop.dao.CustomerDetailsDao;
import com.xyram.daydrop.dao.CustomerOrderDao;
import com.xyram.daydrop.dao.CustomerOrderReplicaDoa;
import com.xyram.daydrop.dao.SheduleDao;
import com.xyram.daydrop.enumtypes.UserStatus;
import com.xyram.daydrop.model.Apartments;
import com.xyram.daydrop.model.CustomerOrder;
import com.xyram.daydrop.model.CustomerOrderReplica;
import com.xyram.daydrop.model.Customers;
import com.xyram.daydrop.model.Schedule;
import com.xyram.daydrop.modelMapper.PaymentInstrument;
import com.xyram.daydrop.modelMapper.PhonePePayModel;
import com.xyram.daydrop.request.CustomerOrderReplicaRequest;
import com.xyram.daydrop.response.RazorPayRequest;
import com.xyram.daydrop.service.CustomerOrderPriceService;
import com.xyram.daydrop.service.CustomerOrderReplicaService;
import com.xyram.daydrop.util.HashEncoder;
import com.xyram.daydrop.util.RazorPay;
import com.xyram.daydrop.service.ConsumerService;

@Transactional
@Service
public class CustomerOrderReplicaServiceImpl implements CustomerOrderReplicaService {

	@Autowired
	CustomerOrderReplicaDoa customerOrderReplicaDoa;

	@Autowired
	ApartmentDao apartmentDao;

	@Autowired
	SheduleDao scheduleDao;

	@Autowired
	CustomerDetailsDao customerDetailsDao;

	@Autowired
	ConsumerService consumerService;

	@Autowired
	CurrentUser currentUser;

	@Autowired
	PhonepeServiceImpl phonepeServiceImpl;

	@Value("${merchant_id}")
	private String merchantId;

	@Value("${salt_key}")
	private String saltKey;

	@Value("${salt_index}")
	private String saltIndex;

	@Override
	public Map createCustomerOrderReplicaService(CustomerOrderReplicaRequest customerOrderReplicaRequest,
			String contactNumber, Integer aparmentId)

	{

		Map response = new HashedMap<>();

		response.put("message", "success");
		CustomerOrderReplica customerOrderReplica = null;

		if (customerOrderReplicaRequest.getCartId() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "cartId is mandatory ");
		}
		long razorPayCount = 0;
		if (customerOrderReplicaRequest.getOrderId() != null) {

			razorPayCount = customerOrderReplicaDoa.getRazorPayExistByCartId(customerOrderReplicaRequest.getOrderId());
		}

		if (customerOrderReplicaRequest.getCustomerDetails() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Order Details  is mandatory ");
		}

		customerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(customerOrderReplicaRequest.getCartId(),
				contactNumber);

		if (customerOrderReplica != null) {
			customerOrderReplica.setCartId(customerOrderReplica.getCartId());

			if (customerOrderReplica.isOrdered()) {
				throw new ResponseStatusException(HttpStatus.CONFLICT, "Your Order is Placed With cart Details");
			}

//			if (razorPayCount >= 1 && !(customerOrderReplica.getRazorPayOrderId() != null
//					&& customerOrderReplica.getRazorPayOrderId().equals(customerOrderReplicaRequest.getOrderId()))) {
//				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
//			}

			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);

			customerOrderReplica.setAttempts(customerOrderReplica.getAttempts() + 1);
			customerOrderReplica.setUpdatedTime(new Date());

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		} else {

			customerOrderReplica = new CustomerOrderReplica();
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);
			customerOrderReplica.setCartId(customerOrderReplicaRequest.getCartId());
			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());

			if (razorPayCount > 0) {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
			}

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			Schedule schedule = scheduleDao.getlatestScheduleCustomers();

			if (schedule != null) {

				try {
					customerOrderReplica.setSchedule(schedule.getsId() != null ? schedule.getsId().toString() : null);
				} catch (Exception e) {
					e.printStackTrace();
				}
			} else {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
						"Sorry We Are Not Accepting Any Order Right now");

			}

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		}

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicas(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String schedule = null;

		Map filter = request.containsKey("filters") ? (Map) request.get("filters") : null;
		if (filter != null) {
			statusType = filter.containsKey("statusType") ? ((String) filter.get("statusType")).toLowerCase() : null;
			searchQuery = filter.containsKey("searchQuery") ? ((String) filter.get("searchQuery")).toLowerCase() : null;
			schedule = filter.containsKey("schedule") ? (String.valueOf(filter.get("schedule"))) : null;

		}

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplica(searchQuery, statusType, schedule);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");

				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setStreetName(
						customers.get("streetName") != null ? (String) customers.get("streetName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicasBySchedule(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String scheduleId = null;

		Schedule schedule = scheduleDao.getlatestScheduleCustomers();

		if (schedule != null) {

			try {
				scheduleId = schedule.getsId() != null ? schedule.getsId().toString() : null;
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

		statusType = request.containsKey("statusType") ? ((String) request.get("statusType")).toLowerCase() : "Success";

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplicaBySchdeule(statusType, scheduleId);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");
				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				System.out.println("customers" + customers.get("customerName"));

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public CustomerOrderReplica getCustomerOrderReplicaByCartId(String cartId) {

		CustomerOrderReplica CustomerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(cartId,
				currentUser.getContactNumber());

		ObjectMapper objectMapper = new ObjectMapper();
		try {

			// convert JSON string to Map
			Map<String, Object> customerOrderReplicaMap = objectMapper
					.readValue(CustomerOrderReplica.getCustomerOrderDetails(), Map.class);

			Object customerOrder = customerOrderReplicaMap.get("customerOrder");
			Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

			Object quanityList = items.get("quantity");
			Map customers = customerDetailsDao.getByContactNumberAndApartment(CustomerOrderReplica.getContactNumber(),
					CustomerOrderReplica.getApartmentId());

			System.out.println("customers" + customers.get("customerName"));

			// Apartments apartments =
			// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
			CustomerOrderReplica.setApartmentName(
					customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

			CustomerOrderReplica.setCustomerDetails(customers);

			CustomerOrderReplica.setCustomerOrder(customerOrder);
			CustomerOrderReplica.setQuatityList(quanityList);

		} catch (Exception e) {
			e.printStackTrace();
		}

		return CustomerOrderReplica;

	}

	@Override
	public Map createCustomerOrderReplica(CustomerOrderReplicaRequest customerOrderReplicaRequest, String contactNumber,
			Integer aparmentId) {

		if (customerOrderReplicaRequest.getRazorPayRequest() != null) {

//			Map razorPay = consumerService.createRazorPayOrder(customerOrderReplicaRequest.getRazorPayRequest());
//			customerOrderReplicaRequest.setOrderId(razorPay.get("order") != null ? (String)((RazorPay) razorPay.get("order")).getId() : null);	
//	
//			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);
//
//			razorPay.put("cartId", customerOrderReplicaRequest.getCartId());

			Map customerOrderReplicaMap = new HashMap<>();

			Map orderId = new HashMap<>();
			String transactionId = getMerchantTransactionId();
			orderId.put("id", transactionId);

			customerOrderReplicaMap.put("order", orderId);

			customerOrderReplicaRequest.setOrderId(transactionId);
			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);

			customerOrderReplicaMap.put("cartId", customerOrderReplicaRequest.getCartId());

			try {
				customerOrderReplicaMap.put("phonePeResponse",
						phonepeServiceImpl.initiatePhonepePayment(transactionId,
								Integer.valueOf(customerOrderReplicaRequest.getRazorPayRequest().getAmount()),
								contactNumber, customerOrderReplicaRequest.getRedirectUrl(), customerOrderReplicaRequest.getCallBackUrl()));

			} catch (Exception e) {
				e.printStackTrace();
				customerOrderReplicaMap.put("phonePeResponse", new HashedMap<>());
			}

			return customerOrderReplicaMap;

		} else {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
					"paymentDetails transcation Details are mandatory");
		}

	}

	private static String getMerchantTransactionId() {

		return "OD_" + MerchantTransactionIdGenerator.getRandomString();
	}


	@Override
	public List<CustomerOrderReplica> getCustomerOrderByMoblieNo(String contactNumber, Integer aid) {

	    Schedule latestSchedule = customerOrderReplicaDoa.getlatestschedule();

	    if (latestSchedule != null && latestSchedule.getCreationTimestamp() != null) {
	        if (latestSchedule.getStatus().equals(UserStatus.ACTIVE)) {
	            Customers customer = customerDetailsDao.getByContactNoAndApartment(contactNumber, aid);

	            if (customer != null) { // Ensure the customer exists
	                List<CustomerOrder> customerOrderList = customerOrderReplicaDoa.getListCustomerOrderByCustomerId(customer.getCtId());

	                double totalOrderAmount = 0.0;

	                if (customerOrderList != null && !customerOrderList.isEmpty()) {
	                    for (CustomerOrder customerOrder : customerOrderList) {
	                        Double orderAmount = customerOrder.getAmount();
	                        if (orderAmount != null) {
	                            totalOrderAmount += orderAmount;
	                            if(totalOrderAmount>200) {
	                            	totalOrderAmount+= customerOrder.getDelivaryCharges();
	                            }
	                            else(totalOrderAmount<200){
	                            	totalOrderAmount-= customerOrder.getDelivaryCharges();
	                            }
	                        }
	                    }

	                    // Define the minimum order amount for applying delivery charges
	                    double minimumOrderAmount = 200.0;

	                    if (totalOrderAmount < minimumOrderAmount) {
	                        System.out.println("Delivery Charges will be applicable");
	                    } else {
	                        // No delivery charges applicable
	                        System.out.println("No Delivery charges applicable");
	                    }

	                    List<CustomerOrderReplica> customerOrderReplicas = new ArrayList<>();
	                    return customerOrderReplicas;
	                } else {
	                    return Collections.emptyList();
	                }
	            } else {
	                return null; // or an appropriate value
	            }
	        } else {
	            // Handle the case when the latest schedule is not active
	            return null; // or an appropriate value
	        }
	    } else {
	        // Handle the case when there is no latest schedule or its creation timestamp is null
	        return null; // or an appropriate value
	    }
	}

}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-09-21 15:34:22.050
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-09-21 15:34:22.052
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-21 15:34:24.208
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.xyram.daydrop.serviceimpl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.transaction.Transactional;

import org.apache.commons.collections4.map.HashedMap;
import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.server.ResponseStatusException;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.xyram.daydrop.admin.model.CurrentUser;
import com.xyram.daydrop.basemodel.Base64Wrapper;
import com.xyram.daydrop.basemodel.MerchantTransactionIdGenerator;
import com.xyram.daydrop.basemodel.PhonepeSerializer;
import com.xyram.daydrop.dao.ApartmentDao;
import com.xyram.daydrop.dao.CustomerDetailsDao;
import com.xyram.daydrop.dao.CustomerOrderDao;
import com.xyram.daydrop.dao.CustomerOrderReplicaDoa;
import com.xyram.daydrop.dao.SheduleDao;
import com.xyram.daydrop.enumtypes.UserStatus;
import com.xyram.daydrop.model.Apartments;
import com.xyram.daydrop.model.CustomerOrder;
import com.xyram.daydrop.model.CustomerOrderReplica;
import com.xyram.daydrop.model.Customers;
import com.xyram.daydrop.model.Schedule;
import com.xyram.daydrop.modelMapper.PaymentInstrument;
import com.xyram.daydrop.modelMapper.PhonePePayModel;
import com.xyram.daydrop.request.CustomerOrderReplicaRequest;
import com.xyram.daydrop.response.RazorPayRequest;
import com.xyram.daydrop.service.CustomerOrderPriceService;
import com.xyram.daydrop.service.CustomerOrderReplicaService;
import com.xyram.daydrop.util.HashEncoder;
import com.xyram.daydrop.util.RazorPay;
import com.xyram.daydrop.service.ConsumerService;

@Transactional
@Service
public class CustomerOrderReplicaServiceImpl implements CustomerOrderReplicaService {

	@Autowired
	CustomerOrderReplicaDoa customerOrderReplicaDoa;

	@Autowired
	ApartmentDao apartmentDao;

	@Autowired
	SheduleDao scheduleDao;

	@Autowired
	CustomerDetailsDao customerDetailsDao;

	@Autowired
	ConsumerService consumerService;

	@Autowired
	CurrentUser currentUser;

	@Autowired
	PhonepeServiceImpl phonepeServiceImpl;

	@Value("${merchant_id}")
	private String merchantId;

	@Value("${salt_key}")
	private String saltKey;

	@Value("${salt_index}")
	private String saltIndex;

	@Override
	public Map createCustomerOrderReplicaService(CustomerOrderReplicaRequest customerOrderReplicaRequest,
			String contactNumber, Integer aparmentId)

	{

		Map response = new HashedMap<>();

		response.put("message", "success");
		CustomerOrderReplica customerOrderReplica = null;

		if (customerOrderReplicaRequest.getCartId() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "cartId is mandatory ");
		}
		long razorPayCount = 0;
		if (customerOrderReplicaRequest.getOrderId() != null) {

			razorPayCount = customerOrderReplicaDoa.getRazorPayExistByCartId(customerOrderReplicaRequest.getOrderId());
		}

		if (customerOrderReplicaRequest.getCustomerDetails() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Order Details  is mandatory ");
		}

		customerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(customerOrderReplicaRequest.getCartId(),
				contactNumber);

		if (customerOrderReplica != null) {
			customerOrderReplica.setCartId(customerOrderReplica.getCartId());

			if (customerOrderReplica.isOrdered()) {
				throw new ResponseStatusException(HttpStatus.CONFLICT, "Your Order is Placed With cart Details");
			}

//			if (razorPayCount >= 1 && !(customerOrderReplica.getRazorPayOrderId() != null
//					&& customerOrderReplica.getRazorPayOrderId().equals(customerOrderReplicaRequest.getOrderId()))) {
//				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
//			}

			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);

			customerOrderReplica.setAttempts(customerOrderReplica.getAttempts() + 1);
			customerOrderReplica.setUpdatedTime(new Date());

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		} else {

			customerOrderReplica = new CustomerOrderReplica();
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);
			customerOrderReplica.setCartId(customerOrderReplicaRequest.getCartId());
			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());

			if (razorPayCount > 0) {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
			}

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			Schedule schedule = scheduleDao.getlatestScheduleCustomers();

			if (schedule != null) {

				try {
					customerOrderReplica.setSchedule(schedule.getsId() != null ? schedule.getsId().toString() : null);
				} catch (Exception e) {
					e.printStackTrace();
				}
			} else {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
						"Sorry We Are Not Accepting Any Order Right now");

			}

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		}

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicas(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String schedule = null;

		Map filter = request.containsKey("filters") ? (Map) request.get("filters") : null;
		if (filter != null) {
			statusType = filter.containsKey("statusType") ? ((String) filter.get("statusType")).toLowerCase() : null;
			searchQuery = filter.containsKey("searchQuery") ? ((String) filter.get("searchQuery")).toLowerCase() : null;
			schedule = filter.containsKey("schedule") ? (String.valueOf(filter.get("schedule"))) : null;

		}

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplica(searchQuery, statusType, schedule);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");

				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setStreetName(
						customers.get("streetName") != null ? (String) customers.get("streetName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicasBySchedule(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String scheduleId = null;

		Schedule schedule = scheduleDao.getlatestScheduleCustomers();

		if (schedule != null) {

			try {
				scheduleId = schedule.getsId() != null ? schedule.getsId().toString() : null;
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

		statusType = request.containsKey("statusType") ? ((String) request.get("statusType")).toLowerCase() : "Success";

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplicaBySchdeule(statusType, scheduleId);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");
				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				System.out.println("customers" + customers.get("customerName"));

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public CustomerOrderReplica getCustomerOrderReplicaByCartId(String cartId) {

		CustomerOrderReplica CustomerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(cartId,
				currentUser.getContactNumber());

		ObjectMapper objectMapper = new ObjectMapper();
		try {

			// convert JSON string to Map
			Map<String, Object> customerOrderReplicaMap = objectMapper
					.readValue(CustomerOrderReplica.getCustomerOrderDetails(), Map.class);

			Object customerOrder = customerOrderReplicaMap.get("customerOrder");
			Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

			Object quanityList = items.get("quantity");
			Map customers = customerDetailsDao.getByContactNumberAndApartment(CustomerOrderReplica.getContactNumber(),
					CustomerOrderReplica.getApartmentId());

			System.out.println("customers" + customers.get("customerName"));

			// Apartments apartments =
			// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
			CustomerOrderReplica.setApartmentName(
					customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

			CustomerOrderReplica.setCustomerDetails(customers);

			CustomerOrderReplica.setCustomerOrder(customerOrder);
			CustomerOrderReplica.setQuatityList(quanityList);

		} catch (Exception e) {
			e.printStackTrace();
		}

		return CustomerOrderReplica;

	}

	@Override
	public Map createCustomerOrderReplica(CustomerOrderReplicaRequest customerOrderReplicaRequest, String contactNumber,
			Integer aparmentId) {

		if (customerOrderReplicaRequest.getRazorPayRequest() != null) {

//			Map razorPay = consumerService.createRazorPayOrder(customerOrderReplicaRequest.getRazorPayRequest());
//			customerOrderReplicaRequest.setOrderId(razorPay.get("order") != null ? (String)((RazorPay) razorPay.get("order")).getId() : null);	
//	
//			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);
//
//			razorPay.put("cartId", customerOrderReplicaRequest.getCartId());

			Map customerOrderReplicaMap = new HashMap<>();

			Map orderId = new HashMap<>();
			String transactionId = getMerchantTransactionId();
			orderId.put("id", transactionId);

			customerOrderReplicaMap.put("order", orderId);

			customerOrderReplicaRequest.setOrderId(transactionId);
			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);

			customerOrderReplicaMap.put("cartId", customerOrderReplicaRequest.getCartId());

			try {
				customerOrderReplicaMap.put("phonePeResponse",
						phonepeServiceImpl.initiatePhonepePayment(transactionId,
								Integer.valueOf(customerOrderReplicaRequest.getRazorPayRequest().getAmount()),
								contactNumber, customerOrderReplicaRequest.getRedirectUrl(), customerOrderReplicaRequest.getCallBackUrl()));

			} catch (Exception e) {
				e.printStackTrace();
				customerOrderReplicaMap.put("phonePeResponse", new HashedMap<>());
			}

			return customerOrderReplicaMap;

		} else {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
					"paymentDetails transcation Details are mandatory");
		}

	}

	private static String getMerchantTransactionId() {

		return "OD_" + MerchantTransactionIdGenerator.getRandomString();
	}


	@Override
	public List<CustomerOrderReplica> getCustomerOrderByMoblieNo(String contactNumber, Integer aid) {

	    Schedule latestSchedule = customerOrderReplicaDoa.getlatestschedule();

	    if (latestSchedule != null && latestSchedule.getCreationTimestamp() != null) {
	        if (latestSchedule.getStatus().equals(UserStatus.ACTIVE)) {
	            Customers customer = customerDetailsDao.getByContactNoAndApartment(contactNumber, aid);

	            if (customer != null) { // Ensure the customer exists
	                List<CustomerOrder> customerOrderList = customerOrderReplicaDoa.getListCustomerOrderByCustomerId(customer.getCtId());

	                double totalOrderAmount = 0.0;

	                if (customerOrderList != null && !customerOrderList.isEmpty()) {
	                    for (CustomerOrder customerOrder : customerOrderList) {
	                        Double orderAmount = customerOrder.getAmount();
	                        if (orderAmount != null) {
	                            totalOrderAmount += orderAmount;
	                            if(totalOrderAmount>200) {
	                            	totalOrderAmount+= customerOrder.getDelivaryCharges();
	                            }
	                            else(totalOrderAmount<200){
	                            	totalOrderAmount-= customerOrder.getDelivaryCharges();
	                            }
	                        }
	                    }

	                    // Define the minimum order amount for applying delivery charges
	                    double minimumOrderAmount = 200.0;

	                    if (totalOrderAmount < minimumOrderAmount) {
	                        System.out.println("Delivery Charges will be applicable");
	                    } else {
	                        // No delivery charges applicable
	                        System.out.println("No Delivery charges applicable");
	                    }

	                    List<CustomerOrderReplica> customerOrderReplicas = new ArrayList<>();
	                    return customerOrderReplicas;
	                } else {
	                    return Collections.emptyList();
	                }
	            } else {
	                return null; // or an appropriate value
	            }
	        } else {
	            // Handle the case when the latest schedule is not active
	            return null; // or an appropriate value
	        }
	    } else {
	        // Handle the case when there is no latest schedule or its creation timestamp is null
	        return null; // or an appropriate value
	    }
	}

}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-09-21 15:34:24.210
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-09-21 15:34:24.215
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-21 15:34:24.806
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.xyram.daydrop.serviceimpl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.transaction.Transactional;

import org.apache.commons.collections4.map.HashedMap;
import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.server.ResponseStatusException;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.xyram.daydrop.admin.model.CurrentUser;
import com.xyram.daydrop.basemodel.Base64Wrapper;
import com.xyram.daydrop.basemodel.MerchantTransactionIdGenerator;
import com.xyram.daydrop.basemodel.PhonepeSerializer;
import com.xyram.daydrop.dao.ApartmentDao;
import com.xyram.daydrop.dao.CustomerDetailsDao;
import com.xyram.daydrop.dao.CustomerOrderDao;
import com.xyram.daydrop.dao.CustomerOrderReplicaDoa;
import com.xyram.daydrop.dao.SheduleDao;
import com.xyram.daydrop.enumtypes.UserStatus;
import com.xyram.daydrop.model.Apartments;
import com.xyram.daydrop.model.CustomerOrder;
import com.xyram.daydrop.model.CustomerOrderReplica;
import com.xyram.daydrop.model.Customers;
import com.xyram.daydrop.model.Schedule;
import com.xyram.daydrop.modelMapper.PaymentInstrument;
import com.xyram.daydrop.modelMapper.PhonePePayModel;
import com.xyram.daydrop.request.CustomerOrderReplicaRequest;
import com.xyram.daydrop.response.RazorPayRequest;
import com.xyram.daydrop.service.CustomerOrderPriceService;
import com.xyram.daydrop.service.CustomerOrderReplicaService;
import com.xyram.daydrop.util.HashEncoder;
import com.xyram.daydrop.util.RazorPay;
import com.xyram.daydrop.service.ConsumerService;

@Transactional
@Service
public class CustomerOrderReplicaServiceImpl implements CustomerOrderReplicaService {

	@Autowired
	CustomerOrderReplicaDoa customerOrderReplicaDoa;

	@Autowired
	ApartmentDao apartmentDao;

	@Autowired
	SheduleDao scheduleDao;

	@Autowired
	CustomerDetailsDao customerDetailsDao;

	@Autowired
	ConsumerService consumerService;

	@Autowired
	CurrentUser currentUser;

	@Autowired
	PhonepeServiceImpl phonepeServiceImpl;

	@Value("${merchant_id}")
	private String merchantId;

	@Value("${salt_key}")
	private String saltKey;

	@Value("${salt_index}")
	private String saltIndex;

	@Override
	public Map createCustomerOrderReplicaService(CustomerOrderReplicaRequest customerOrderReplicaRequest,
			String contactNumber, Integer aparmentId)

	{

		Map response = new HashedMap<>();

		response.put("message", "success");
		CustomerOrderReplica customerOrderReplica = null;

		if (customerOrderReplicaRequest.getCartId() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "cartId is mandatory ");
		}
		long razorPayCount = 0;
		if (customerOrderReplicaRequest.getOrderId() != null) {

			razorPayCount = customerOrderReplicaDoa.getRazorPayExistByCartId(customerOrderReplicaRequest.getOrderId());
		}

		if (customerOrderReplicaRequest.getCustomerDetails() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Order Details  is mandatory ");
		}

		customerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(customerOrderReplicaRequest.getCartId(),
				contactNumber);

		if (customerOrderReplica != null) {
			customerOrderReplica.setCartId(customerOrderReplica.getCartId());

			if (customerOrderReplica.isOrdered()) {
				throw new ResponseStatusException(HttpStatus.CONFLICT, "Your Order is Placed With cart Details");
			}

//			if (razorPayCount >= 1 && !(customerOrderReplica.getRazorPayOrderId() != null
//					&& customerOrderReplica.getRazorPayOrderId().equals(customerOrderReplicaRequest.getOrderId()))) {
//				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
//			}

			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);

			customerOrderReplica.setAttempts(customerOrderReplica.getAttempts() + 1);
			customerOrderReplica.setUpdatedTime(new Date());

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		} else {

			customerOrderReplica = new CustomerOrderReplica();
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);
			customerOrderReplica.setCartId(customerOrderReplicaRequest.getCartId());
			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());

			if (razorPayCount > 0) {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
			}

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			Schedule schedule = scheduleDao.getlatestScheduleCustomers();

			if (schedule != null) {

				try {
					customerOrderReplica.setSchedule(schedule.getsId() != null ? schedule.getsId().toString() : null);
				} catch (Exception e) {
					e.printStackTrace();
				}
			} else {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
						"Sorry We Are Not Accepting Any Order Right now");

			}

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		}

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicas(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String schedule = null;

		Map filter = request.containsKey("filters") ? (Map) request.get("filters") : null;
		if (filter != null) {
			statusType = filter.containsKey("statusType") ? ((String) filter.get("statusType")).toLowerCase() : null;
			searchQuery = filter.containsKey("searchQuery") ? ((String) filter.get("searchQuery")).toLowerCase() : null;
			schedule = filter.containsKey("schedule") ? (String.valueOf(filter.get("schedule"))) : null;

		}

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplica(searchQuery, statusType, schedule);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");

				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setStreetName(
						customers.get("streetName") != null ? (String) customers.get("streetName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicasBySchedule(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String scheduleId = null;

		Schedule schedule = scheduleDao.getlatestScheduleCustomers();

		if (schedule != null) {

			try {
				scheduleId = schedule.getsId() != null ? schedule.getsId().toString() : null;
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

		statusType = request.containsKey("statusType") ? ((String) request.get("statusType")).toLowerCase() : "Success";

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplicaBySchdeule(statusType, scheduleId);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");
				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				System.out.println("customers" + customers.get("customerName"));

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public CustomerOrderReplica getCustomerOrderReplicaByCartId(String cartId) {

		CustomerOrderReplica CustomerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(cartId,
				currentUser.getContactNumber());

		ObjectMapper objectMapper = new ObjectMapper();
		try {

			// convert JSON string to Map
			Map<String, Object> customerOrderReplicaMap = objectMapper
					.readValue(CustomerOrderReplica.getCustomerOrderDetails(), Map.class);

			Object customerOrder = customerOrderReplicaMap.get("customerOrder");
			Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

			Object quanityList = items.get("quantity");
			Map customers = customerDetailsDao.getByContactNumberAndApartment(CustomerOrderReplica.getContactNumber(),
					CustomerOrderReplica.getApartmentId());

			System.out.println("customers" + customers.get("customerName"));

			// Apartments apartments =
			// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
			CustomerOrderReplica.setApartmentName(
					customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

			CustomerOrderReplica.setCustomerDetails(customers);

			CustomerOrderReplica.setCustomerOrder(customerOrder);
			CustomerOrderReplica.setQuatityList(quanityList);

		} catch (Exception e) {
			e.printStackTrace();
		}

		return CustomerOrderReplica;

	}

	@Override
	public Map createCustomerOrderReplica(CustomerOrderReplicaRequest customerOrderReplicaRequest, String contactNumber,
			Integer aparmentId) {

		if (customerOrderReplicaRequest.getRazorPayRequest() != null) {

//			Map razorPay = consumerService.createRazorPayOrder(customerOrderReplicaRequest.getRazorPayRequest());
//			customerOrderReplicaRequest.setOrderId(razorPay.get("order") != null ? (String)((RazorPay) razorPay.get("order")).getId() : null);	
//	
//			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);
//
//			razorPay.put("cartId", customerOrderReplicaRequest.getCartId());

			Map customerOrderReplicaMap = new HashMap<>();

			Map orderId = new HashMap<>();
			String transactionId = getMerchantTransactionId();
			orderId.put("id", transactionId);

			customerOrderReplicaMap.put("order", orderId);

			customerOrderReplicaRequest.setOrderId(transactionId);
			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);

			customerOrderReplicaMap.put("cartId", customerOrderReplicaRequest.getCartId());

			try {
				customerOrderReplicaMap.put("phonePeResponse",
						phonepeServiceImpl.initiatePhonepePayment(transactionId,
								Integer.valueOf(customerOrderReplicaRequest.getRazorPayRequest().getAmount()),
								contactNumber, customerOrderReplicaRequest.getRedirectUrl(), customerOrderReplicaRequest.getCallBackUrl()));

			} catch (Exception e) {
				e.printStackTrace();
				customerOrderReplicaMap.put("phonePeResponse", new HashedMap<>());
			}

			return customerOrderReplicaMap;

		} else {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
					"paymentDetails transcation Details are mandatory");
		}

	}

	private static String getMerchantTransactionId() {

		return "OD_" + MerchantTransactionIdGenerator.getRandomString();
	}


	@Override
	public List<CustomerOrderReplica> getCustomerOrderByMoblieNo(String contactNumber, Integer aid) {

	    Schedule latestSchedule = customerOrderReplicaDoa.getlatestschedule();

	    if (latestSchedule != null && latestSchedule.getCreationTimestamp() != null) {
	        if (latestSchedule.getStatus().equals(UserStatus.ACTIVE)) {
	            Customers customer = customerDetailsDao.getByContactNoAndApartment(contactNumber, aid);

	            if (customer != null) { // Ensure the customer exists
	                List<CustomerOrder> customerOrderList = customerOrderReplicaDoa.getListCustomerOrderByCustomerId(customer.getCtId());

	                double totalOrderAmount = 0.0;

	                if (customerOrderList != null && !customerOrderList.isEmpty()) {
	                    for (CustomerOrder customerOrder : customerOrderList) {
	                        Double orderAmount = customerOrder.getAmount();
	                        if (orderAmount != null) {
	                            totalOrderAmount += orderAmount;
	                            if(totalOrderAmount>200) {
	                            	totalOrderAmount+= customerOrder.getDelivaryCharges();
	                            }
	                            else(totalOrderAmount<200){
	                            	totalOrderAmount-= customerOrder.getDelivaryCharges();
	                            }
	                        }
	                    }

	                    // Define the minimum order amount for applying delivery charges
	                    double minimumOrderAmount = 200.0;

	                    if (totalOrderAmount < minimumOrderAmount) {
	                        System.out.println("Delivery Charges will be applicable");
	                    } else {
	                        // No delivery charges applicable
	                        System.out.println("No Delivery charges applicable");
	                    }

	                    List<CustomerOrderReplica> customerOrderReplicas = new ArrayList<>();
	                    return customerOrderReplicas;
	                } else {
	                    return Collections.emptyList();
	                }
	            } else {
	                return null; // or an appropriate value
	            }
	        } else {
	            // Handle the case when the latest schedule is not active
	            return null; // or an appropriate value
	        }
	    } else {
	        // Handle the case when there is no latest schedule or its creation timestamp is null
	        return null; // or an appropriate value
	    }
	}

}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-09-21 15:34:24.813
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-09-21 15:34:24.817
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-21 15:34:25.690
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.xyram.daydrop.serviceimpl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.transaction.Transactional;

import org.apache.commons.collections4.map.HashedMap;
import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.server.ResponseStatusException;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.xyram.daydrop.admin.model.CurrentUser;
import com.xyram.daydrop.basemodel.Base64Wrapper;
import com.xyram.daydrop.basemodel.MerchantTransactionIdGenerator;
import com.xyram.daydrop.basemodel.PhonepeSerializer;
import com.xyram.daydrop.dao.ApartmentDao;
import com.xyram.daydrop.dao.CustomerDetailsDao;
import com.xyram.daydrop.dao.CustomerOrderDao;
import com.xyram.daydrop.dao.CustomerOrderReplicaDoa;
import com.xyram.daydrop.dao.SheduleDao;
import com.xyram.daydrop.enumtypes.UserStatus;
import com.xyram.daydrop.model.Apartments;
import com.xyram.daydrop.model.CustomerOrder;
import com.xyram.daydrop.model.CustomerOrderReplica;
import com.xyram.daydrop.model.Customers;
import com.xyram.daydrop.model.Schedule;
import com.xyram.daydrop.modelMapper.PaymentInstrument;
import com.xyram.daydrop.modelMapper.PhonePePayModel;
import com.xyram.daydrop.request.CustomerOrderReplicaRequest;
import com.xyram.daydrop.response.RazorPayRequest;
import com.xyram.daydrop.service.CustomerOrderPriceService;
import com.xyram.daydrop.service.CustomerOrderReplicaService;
import com.xyram.daydrop.util.HashEncoder;
import com.xyram.daydrop.util.RazorPay;
import com.xyram.daydrop.service.ConsumerService;

@Transactional
@Service
public class CustomerOrderReplicaServiceImpl implements CustomerOrderReplicaService {

	@Autowired
	CustomerOrderReplicaDoa customerOrderReplicaDoa;

	@Autowired
	ApartmentDao apartmentDao;

	@Autowired
	SheduleDao scheduleDao;

	@Autowired
	CustomerDetailsDao customerDetailsDao;

	@Autowired
	ConsumerService consumerService;

	@Autowired
	CurrentUser currentUser;

	@Autowired
	PhonepeServiceImpl phonepeServiceImpl;

	@Value("${merchant_id}")
	private String merchantId;

	@Value("${salt_key}")
	private String saltKey;

	@Value("${salt_index}")
	private String saltIndex;

	@Override
	public Map createCustomerOrderReplicaService(CustomerOrderReplicaRequest customerOrderReplicaRequest,
			String contactNumber, Integer aparmentId)

	{

		Map response = new HashedMap<>();

		response.put("message", "success");
		CustomerOrderReplica customerOrderReplica = null;

		if (customerOrderReplicaRequest.getCartId() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "cartId is mandatory ");
		}
		long razorPayCount = 0;
		if (customerOrderReplicaRequest.getOrderId() != null) {

			razorPayCount = customerOrderReplicaDoa.getRazorPayExistByCartId(customerOrderReplicaRequest.getOrderId());
		}

		if (customerOrderReplicaRequest.getCustomerDetails() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Order Details  is mandatory ");
		}

		customerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(customerOrderReplicaRequest.getCartId(),
				contactNumber);

		if (customerOrderReplica != null) {
			customerOrderReplica.setCartId(customerOrderReplica.getCartId());

			if (customerOrderReplica.isOrdered()) {
				throw new ResponseStatusException(HttpStatus.CONFLICT, "Your Order is Placed With cart Details");
			}

//			if (razorPayCount >= 1 && !(customerOrderReplica.getRazorPayOrderId() != null
//					&& customerOrderReplica.getRazorPayOrderId().equals(customerOrderReplicaRequest.getOrderId()))) {
//				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
//			}

			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);

			customerOrderReplica.setAttempts(customerOrderReplica.getAttempts() + 1);
			customerOrderReplica.setUpdatedTime(new Date());

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		} else {

			customerOrderReplica = new CustomerOrderReplica();
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);
			customerOrderReplica.setCartId(customerOrderReplicaRequest.getCartId());
			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());

			if (razorPayCount > 0) {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
			}

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			Schedule schedule = scheduleDao.getlatestScheduleCustomers();

			if (schedule != null) {

				try {
					customerOrderReplica.setSchedule(schedule.getsId() != null ? schedule.getsId().toString() : null);
				} catch (Exception e) {
					e.printStackTrace();
				}
			} else {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
						"Sorry We Are Not Accepting Any Order Right now");

			}

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		}

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicas(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String schedule = null;

		Map filter = request.containsKey("filters") ? (Map) request.get("filters") : null;
		if (filter != null) {
			statusType = filter.containsKey("statusType") ? ((String) filter.get("statusType")).toLowerCase() : null;
			searchQuery = filter.containsKey("searchQuery") ? ((String) filter.get("searchQuery")).toLowerCase() : null;
			schedule = filter.containsKey("schedule") ? (String.valueOf(filter.get("schedule"))) : null;

		}

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplica(searchQuery, statusType, schedule);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");

				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setStreetName(
						customers.get("streetName") != null ? (String) customers.get("streetName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicasBySchedule(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String scheduleId = null;

		Schedule schedule = scheduleDao.getlatestScheduleCustomers();

		if (schedule != null) {

			try {
				scheduleId = schedule.getsId() != null ? schedule.getsId().toString() : null;
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

		statusType = request.containsKey("statusType") ? ((String) request.get("statusType")).toLowerCase() : "Success";

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplicaBySchdeule(statusType, scheduleId);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");
				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				System.out.println("customers" + customers.get("customerName"));

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public CustomerOrderReplica getCustomerOrderReplicaByCartId(String cartId) {

		CustomerOrderReplica CustomerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(cartId,
				currentUser.getContactNumber());

		ObjectMapper objectMapper = new ObjectMapper();
		try {

			// convert JSON string to Map
			Map<String, Object> customerOrderReplicaMap = objectMapper
					.readValue(CustomerOrderReplica.getCustomerOrderDetails(), Map.class);

			Object customerOrder = customerOrderReplicaMap.get("customerOrder");
			Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

			Object quanityList = items.get("quantity");
			Map customers = customerDetailsDao.getByContactNumberAndApartment(CustomerOrderReplica.getContactNumber(),
					CustomerOrderReplica.getApartmentId());

			System.out.println("customers" + customers.get("customerName"));

			// Apartments apartments =
			// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
			CustomerOrderReplica.setApartmentName(
					customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

			CustomerOrderReplica.setCustomerDetails(customers);

			CustomerOrderReplica.setCustomerOrder(customerOrder);
			CustomerOrderReplica.setQuatityList(quanityList);

		} catch (Exception e) {
			e.printStackTrace();
		}

		return CustomerOrderReplica;

	}

	@Override
	public Map createCustomerOrderReplica(CustomerOrderReplicaRequest customerOrderReplicaRequest, String contactNumber,
			Integer aparmentId) {

		if (customerOrderReplicaRequest.getRazorPayRequest() != null) {

//			Map razorPay = consumerService.createRazorPayOrder(customerOrderReplicaRequest.getRazorPayRequest());
//			customerOrderReplicaRequest.setOrderId(razorPay.get("order") != null ? (String)((RazorPay) razorPay.get("order")).getId() : null);	
//	
//			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);
//
//			razorPay.put("cartId", customerOrderReplicaRequest.getCartId());

			Map customerOrderReplicaMap = new HashMap<>();

			Map orderId = new HashMap<>();
			String transactionId = getMerchantTransactionId();
			orderId.put("id", transactionId);

			customerOrderReplicaMap.put("order", orderId);

			customerOrderReplicaRequest.setOrderId(transactionId);
			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);

			customerOrderReplicaMap.put("cartId", customerOrderReplicaRequest.getCartId());

			try {
				customerOrderReplicaMap.put("phonePeResponse",
						phonepeServiceImpl.initiatePhonepePayment(transactionId,
								Integer.valueOf(customerOrderReplicaRequest.getRazorPayRequest().getAmount()),
								contactNumber, customerOrderReplicaRequest.getRedirectUrl(), customerOrderReplicaRequest.getCallBackUrl()));

			} catch (Exception e) {
				e.printStackTrace();
				customerOrderReplicaMap.put("phonePeResponse", new HashedMap<>());
			}

			return customerOrderReplicaMap;

		} else {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
					"paymentDetails transcation Details are mandatory");
		}

	}

	private static String getMerchantTransactionId() {

		return "OD_" + MerchantTransactionIdGenerator.getRandomString();
	}


	@Override
	public List<CustomerOrderReplica> getCustomerOrderByMoblieNo(String contactNumber, Integer aid) {

	    Schedule latestSchedule = customerOrderReplicaDoa.getlatestschedule();

	    if (latestSchedule != null && latestSchedule.getCreationTimestamp() != null) {
	        if (latestSchedule.getStatus().equals(UserStatus.ACTIVE)) {
	            Customers customer = customerDetailsDao.getByContactNoAndApartment(contactNumber, aid);

	            if (customer != null) { // Ensure the customer exists
	                List<CustomerOrder> customerOrderList = customerOrderReplicaDoa.getListCustomerOrderByCustomerId(customer.getCtId());

	                double totalOrderAmount = 0.0;

	                if (customerOrderList != null && !customerOrderList.isEmpty()) {
	                    for (CustomerOrder customerOrder : customerOrderList) {
	                        Double orderAmount = customerOrder.getAmount();
	                        if (orderAmount != null) {
	                            totalOrderAmount += orderAmount;
	                            if(totalOrderAmount>200) {
	                            	totalOrderAmount+= customerOrder.getDelivaryCharges();
	                            }
	                            else(totalOrderAmount<200){
	                            	totalOrderAmount-= customerOrder.getDelivaryCharges();
	                            }
	                        }
	                    }

	                    // Define the minimum order amount for applying delivery charges
	                    double minimumOrderAmount = 200.0;

	                    if (totalOrderAmount < minimumOrderAmount) {
	                        System.out.println("Delivery Charges will be applicable");
	                    } else {
	                        // No delivery charges applicable
	                        System.out.println("No Delivery charges applicable");
	                    }

	                    List<CustomerOrderReplica> customerOrderReplicas = new ArrayList<>();
	                    return customerOrderReplicas;
	                } else {
	                    return Collections.emptyList();
	                }
	            } else {
	                return null; // or an appropriate value
	            }
	        } else {
	            // Handle the case when the latest schedule is not active
	            return null; // or an appropriate value
	        }
	    } else {
	        // Handle the case when there is no latest schedule or its creation timestamp is null
	        return null; // or an appropriate value
	    }
	}

}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-09-21 15:34:25.693
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-09-21 15:34:25.698
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-21 15:34:26.295
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.xyram.daydrop.serviceimpl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.transaction.Transactional;

import org.apache.commons.collections4.map.HashedMap;
import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.server.ResponseStatusException;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.xyram.daydrop.admin.model.CurrentUser;
import com.xyram.daydrop.basemodel.Base64Wrapper;
import com.xyram.daydrop.basemodel.MerchantTransactionIdGenerator;
import com.xyram.daydrop.basemodel.PhonepeSerializer;
import com.xyram.daydrop.dao.ApartmentDao;
import com.xyram.daydrop.dao.CustomerDetailsDao;
import com.xyram.daydrop.dao.CustomerOrderDao;
import com.xyram.daydrop.dao.CustomerOrderReplicaDoa;
import com.xyram.daydrop.dao.SheduleDao;
import com.xyram.daydrop.enumtypes.UserStatus;
import com.xyram.daydrop.model.Apartments;
import com.xyram.daydrop.model.CustomerOrder;
import com.xyram.daydrop.model.CustomerOrderReplica;
import com.xyram.daydrop.model.Customers;
import com.xyram.daydrop.model.Schedule;
import com.xyram.daydrop.modelMapper.PaymentInstrument;
import com.xyram.daydrop.modelMapper.PhonePePayModel;
import com.xyram.daydrop.request.CustomerOrderReplicaRequest;
import com.xyram.daydrop.response.RazorPayRequest;
import com.xyram.daydrop.service.CustomerOrderPriceService;
import com.xyram.daydrop.service.CustomerOrderReplicaService;
import com.xyram.daydrop.util.HashEncoder;
import com.xyram.daydrop.util.RazorPay;
import com.xyram.daydrop.service.ConsumerService;

@Transactional
@Service
public class CustomerOrderReplicaServiceImpl implements CustomerOrderReplicaService {

	@Autowired
	CustomerOrderReplicaDoa customerOrderReplicaDoa;

	@Autowired
	ApartmentDao apartmentDao;

	@Autowired
	SheduleDao scheduleDao;

	@Autowired
	CustomerDetailsDao customerDetailsDao;

	@Autowired
	ConsumerService consumerService;

	@Autowired
	CurrentUser currentUser;

	@Autowired
	PhonepeServiceImpl phonepeServiceImpl;

	@Value("${merchant_id}")
	private String merchantId;

	@Value("${salt_key}")
	private String saltKey;

	@Value("${salt_index}")
	private String saltIndex;

	@Override
	public Map createCustomerOrderReplicaService(CustomerOrderReplicaRequest customerOrderReplicaRequest,
			String contactNumber, Integer aparmentId)

	{

		Map response = new HashedMap<>();

		response.put("message", "success");
		CustomerOrderReplica customerOrderReplica = null;

		if (customerOrderReplicaRequest.getCartId() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "cartId is mandatory ");
		}
		long razorPayCount = 0;
		if (customerOrderReplicaRequest.getOrderId() != null) {

			razorPayCount = customerOrderReplicaDoa.getRazorPayExistByCartId(customerOrderReplicaRequest.getOrderId());
		}

		if (customerOrderReplicaRequest.getCustomerDetails() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Order Details  is mandatory ");
		}

		customerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(customerOrderReplicaRequest.getCartId(),
				contactNumber);

		if (customerOrderReplica != null) {
			customerOrderReplica.setCartId(customerOrderReplica.getCartId());

			if (customerOrderReplica.isOrdered()) {
				throw new ResponseStatusException(HttpStatus.CONFLICT, "Your Order is Placed With cart Details");
			}

//			if (razorPayCount >= 1 && !(customerOrderReplica.getRazorPayOrderId() != null
//					&& customerOrderReplica.getRazorPayOrderId().equals(customerOrderReplicaRequest.getOrderId()))) {
//				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
//			}

			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);

			customerOrderReplica.setAttempts(customerOrderReplica.getAttempts() + 1);
			customerOrderReplica.setUpdatedTime(new Date());

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		} else {

			customerOrderReplica = new CustomerOrderReplica();
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);
			customerOrderReplica.setCartId(customerOrderReplicaRequest.getCartId());
			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());

			if (razorPayCount > 0) {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
			}

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			Schedule schedule = scheduleDao.getlatestScheduleCustomers();

			if (schedule != null) {

				try {
					customerOrderReplica.setSchedule(schedule.getsId() != null ? schedule.getsId().toString() : null);
				} catch (Exception e) {
					e.printStackTrace();
				}
			} else {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
						"Sorry We Are Not Accepting Any Order Right now");

			}

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		}

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicas(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String schedule = null;

		Map filter = request.containsKey("filters") ? (Map) request.get("filters") : null;
		if (filter != null) {
			statusType = filter.containsKey("statusType") ? ((String) filter.get("statusType")).toLowerCase() : null;
			searchQuery = filter.containsKey("searchQuery") ? ((String) filter.get("searchQuery")).toLowerCase() : null;
			schedule = filter.containsKey("schedule") ? (String.valueOf(filter.get("schedule"))) : null;

		}

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplica(searchQuery, statusType, schedule);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");

				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setStreetName(
						customers.get("streetName") != null ? (String) customers.get("streetName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicasBySchedule(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String scheduleId = null;

		Schedule schedule = scheduleDao.getlatestScheduleCustomers();

		if (schedule != null) {

			try {
				scheduleId = schedule.getsId() != null ? schedule.getsId().toString() : null;
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

		statusType = request.containsKey("statusType") ? ((String) request.get("statusType")).toLowerCase() : "Success";

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplicaBySchdeule(statusType, scheduleId);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");
				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				System.out.println("customers" + customers.get("customerName"));

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public CustomerOrderReplica getCustomerOrderReplicaByCartId(String cartId) {

		CustomerOrderReplica CustomerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(cartId,
				currentUser.getContactNumber());

		ObjectMapper objectMapper = new ObjectMapper();
		try {

			// convert JSON string to Map
			Map<String, Object> customerOrderReplicaMap = objectMapper
					.readValue(CustomerOrderReplica.getCustomerOrderDetails(), Map.class);

			Object customerOrder = customerOrderReplicaMap.get("customerOrder");
			Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

			Object quanityList = items.get("quantity");
			Map customers = customerDetailsDao.getByContactNumberAndApartment(CustomerOrderReplica.getContactNumber(),
					CustomerOrderReplica.getApartmentId());

			System.out.println("customers" + customers.get("customerName"));

			// Apartments apartments =
			// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
			CustomerOrderReplica.setApartmentName(
					customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

			CustomerOrderReplica.setCustomerDetails(customers);

			CustomerOrderReplica.setCustomerOrder(customerOrder);
			CustomerOrderReplica.setQuatityList(quanityList);

		} catch (Exception e) {
			e.printStackTrace();
		}

		return CustomerOrderReplica;

	}

	@Override
	public Map createCustomerOrderReplica(CustomerOrderReplicaRequest customerOrderReplicaRequest, String contactNumber,
			Integer aparmentId) {

		if (customerOrderReplicaRequest.getRazorPayRequest() != null) {

//			Map razorPay = consumerService.createRazorPayOrder(customerOrderReplicaRequest.getRazorPayRequest());
//			customerOrderReplicaRequest.setOrderId(razorPay.get("order") != null ? (String)((RazorPay) razorPay.get("order")).getId() : null);	
//	
//			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);
//
//			razorPay.put("cartId", customerOrderReplicaRequest.getCartId());

			Map customerOrderReplicaMap = new HashMap<>();

			Map orderId = new HashMap<>();
			String transactionId = getMerchantTransactionId();
			orderId.put("id", transactionId);

			customerOrderReplicaMap.put("order", orderId);

			customerOrderReplicaRequest.setOrderId(transactionId);
			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);

			customerOrderReplicaMap.put("cartId", customerOrderReplicaRequest.getCartId());

			try {
				customerOrderReplicaMap.put("phonePeResponse",
						phonepeServiceImpl.initiatePhonepePayment(transactionId,
								Integer.valueOf(customerOrderReplicaRequest.getRazorPayRequest().getAmount()),
								contactNumber, customerOrderReplicaRequest.getRedirectUrl(), customerOrderReplicaRequest.getCallBackUrl()));

			} catch (Exception e) {
				e.printStackTrace();
				customerOrderReplicaMap.put("phonePeResponse", new HashedMap<>());
			}

			return customerOrderReplicaMap;

		} else {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
					"paymentDetails transcation Details are mandatory");
		}

	}

	private static String getMerchantTransactionId() {

		return "OD_" + MerchantTransactionIdGenerator.getRandomString();
	}


	@Override
	public List<CustomerOrderReplica> getCustomerOrderByMoblieNo(String contactNumber, Integer aid) {

	    Schedule latestSchedule = customerOrderReplicaDoa.getlatestschedule();

	    if (latestSchedule != null && latestSchedule.getCreationTimestamp() != null) {
	        if (latestSchedule.getStatus().equals(UserStatus.ACTIVE)) {
	            Customers customer = customerDetailsDao.getByContactNoAndApartment(contactNumber, aid);

	            if (customer != null) { // Ensure the customer exists
	                List<CustomerOrder> customerOrderList = customerOrderReplicaDoa.getListCustomerOrderByCustomerId(customer.getCtId());

	                double totalOrderAmount = 0.0;

	                if (customerOrderList != null && !customerOrderList.isEmpty()) {
	                    for (CustomerOrder customerOrder : customerOrderList) {
	                        Double orderAmount = customerOrder.getAmount();
	                        if (orderAmount != null) {
	                            totalOrderAmount += orderAmount;
	                            if(totalOrderAmount>200) {
	                            	totalOrderAmount+= customerOrder.getDelivaryCharges();
	                            }
	                            else(totalOrderAmount<200){
	                            	totalOrderAmount-= customerOrder.getDelivaryCharges();
	                            }
	                        }
	                    }

	                    // Define the minimum order amount for applying delivery charges
	                    double minimumOrderAmount = 200.0;

	                    if (totalOrderAmount < minimumOrderAmount) {
	                        System.out.println("Delivery Charges will be applicable");
	                    } else {
	                        // No delivery charges applicable
	                        System.out.println("No Delivery charges applicable");
	                    }

	                    List<CustomerOrderReplica> customerOrderReplicas = new ArrayList<>();
	                    return customerOrderReplicas;
	                } else {
	                    return Collections.emptyList();
	                }
	            } else {
	                return null; // or an appropriate value
	            }
	        } else {
	            // Handle the case when the latest schedule is not active
	            return null; // or an appropriate value
	        }
	    } else {
	        // Handle the case when there is no latest schedule or its creation timestamp is null
	        return null; // or an appropriate value
	    }
	}

}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1003)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:799)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:743)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:666)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:658)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.lambda$0(LSJavaHoverProvider.java:68)
	at java.base/java.util.concurrent.CompletableFuture$AsyncRun.run(CompletableFuture.java:1804)
	at java.base/java.util.concurrent.CompletableFuture$AsyncRun.exec(CompletableFuture.java:1796)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:373)
	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1182)
	at java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1655)
	at java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1622)
	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:165)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-09-21 15:34:26.300
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1003)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:799)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:743)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:666)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:658)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.lambda$0(LSJavaHoverProvider.java:68)
	at java.base/java.util.concurrent.CompletableFuture$AsyncRun.run(CompletableFuture.java:1804)
	at java.base/java.util.concurrent.CompletableFuture$AsyncRun.exec(CompletableFuture.java:1796)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:373)
	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1182)
	at java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1655)
	at java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1622)
	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:165)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-09-21 15:34:26.306
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1003)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:799)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:743)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:666)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:658)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.lambda$0(LSJavaHoverProvider.java:68)
	at java.base/java.util.concurrent.CompletableFuture$AsyncRun.run(CompletableFuture.java:1804)
	at java.base/java.util.concurrent.CompletableFuture$AsyncRun.exec(CompletableFuture.java:1796)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:373)
	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1182)
	at java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1655)
	at java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1622)
	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:165)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-21 15:34:26.514
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.xyram.daydrop.serviceimpl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.transaction.Transactional;

import org.apache.commons.collections4.map.HashedMap;
import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.server.ResponseStatusException;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.xyram.daydrop.admin.model.CurrentUser;
import com.xyram.daydrop.basemodel.Base64Wrapper;
import com.xyram.daydrop.basemodel.MerchantTransactionIdGenerator;
import com.xyram.daydrop.basemodel.PhonepeSerializer;
import com.xyram.daydrop.dao.ApartmentDao;
import com.xyram.daydrop.dao.CustomerDetailsDao;
import com.xyram.daydrop.dao.CustomerOrderDao;
import com.xyram.daydrop.dao.CustomerOrderReplicaDoa;
import com.xyram.daydrop.dao.SheduleDao;
import com.xyram.daydrop.enumtypes.UserStatus;
import com.xyram.daydrop.model.Apartments;
import com.xyram.daydrop.model.CustomerOrder;
import com.xyram.daydrop.model.CustomerOrderReplica;
import com.xyram.daydrop.model.Customers;
import com.xyram.daydrop.model.Schedule;
import com.xyram.daydrop.modelMapper.PaymentInstrument;
import com.xyram.daydrop.modelMapper.PhonePePayModel;
import com.xyram.daydrop.request.CustomerOrderReplicaRequest;
import com.xyram.daydrop.response.RazorPayRequest;
import com.xyram.daydrop.service.CustomerOrderPriceService;
import com.xyram.daydrop.service.CustomerOrderReplicaService;
import com.xyram.daydrop.util.HashEncoder;
import com.xyram.daydrop.util.RazorPay;
import com.xyram.daydrop.service.ConsumerService;

@Transactional
@Service
public class CustomerOrderReplicaServiceImpl implements CustomerOrderReplicaService {

	@Autowired
	CustomerOrderReplicaDoa customerOrderReplicaDoa;

	@Autowired
	ApartmentDao apartmentDao;

	@Autowired
	SheduleDao scheduleDao;

	@Autowired
	CustomerDetailsDao customerDetailsDao;

	@Autowired
	ConsumerService consumerService;

	@Autowired
	CurrentUser currentUser;

	@Autowired
	PhonepeServiceImpl phonepeServiceImpl;

	@Value("${merchant_id}")
	private String merchantId;

	@Value("${salt_key}")
	private String saltKey;

	@Value("${salt_index}")
	private String saltIndex;

	@Override
	public Map createCustomerOrderReplicaService(CustomerOrderReplicaRequest customerOrderReplicaRequest,
			String contactNumber, Integer aparmentId)

	{

		Map response = new HashedMap<>();

		response.put("message", "success");
		CustomerOrderReplica customerOrderReplica = null;

		if (customerOrderReplicaRequest.getCartId() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "cartId is mandatory ");
		}
		long razorPayCount = 0;
		if (customerOrderReplicaRequest.getOrderId() != null) {

			razorPayCount = customerOrderReplicaDoa.getRazorPayExistByCartId(customerOrderReplicaRequest.getOrderId());
		}

		if (customerOrderReplicaRequest.getCustomerDetails() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Order Details  is mandatory ");
		}

		customerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(customerOrderReplicaRequest.getCartId(),
				contactNumber);

		if (customerOrderReplica != null) {
			customerOrderReplica.setCartId(customerOrderReplica.getCartId());

			if (customerOrderReplica.isOrdered()) {
				throw new ResponseStatusException(HttpStatus.CONFLICT, "Your Order is Placed With cart Details");
			}

//			if (razorPayCount >= 1 && !(customerOrderReplica.getRazorPayOrderId() != null
//					&& customerOrderReplica.getRazorPayOrderId().equals(customerOrderReplicaRequest.getOrderId()))) {
//				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
//			}

			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);

			customerOrderReplica.setAttempts(customerOrderReplica.getAttempts() + 1);
			customerOrderReplica.setUpdatedTime(new Date());

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		} else {

			customerOrderReplica = new CustomerOrderReplica();
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);
			customerOrderReplica.setCartId(customerOrderReplicaRequest.getCartId());
			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());

			if (razorPayCount > 0) {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
			}

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			Schedule schedule = scheduleDao.getlatestScheduleCustomers();

			if (schedule != null) {

				try {
					customerOrderReplica.setSchedule(schedule.getsId() != null ? schedule.getsId().toString() : null);
				} catch (Exception e) {
					e.printStackTrace();
				}
			} else {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
						"Sorry We Are Not Accepting Any Order Right now");

			}

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		}

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicas(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String schedule = null;

		Map filter = request.containsKey("filters") ? (Map) request.get("filters") : null;
		if (filter != null) {
			statusType = filter.containsKey("statusType") ? ((String) filter.get("statusType")).toLowerCase() : null;
			searchQuery = filter.containsKey("searchQuery") ? ((String) filter.get("searchQuery")).toLowerCase() : null;
			schedule = filter.containsKey("schedule") ? (String.valueOf(filter.get("schedule"))) : null;

		}

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplica(searchQuery, statusType, schedule);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");

				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setStreetName(
						customers.get("streetName") != null ? (String) customers.get("streetName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicasBySchedule(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String scheduleId = null;

		Schedule schedule = scheduleDao.getlatestScheduleCustomers();

		if (schedule != null) {

			try {
				scheduleId = schedule.getsId() != null ? schedule.getsId().toString() : null;
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

		statusType = request.containsKey("statusType") ? ((String) request.get("statusType")).toLowerCase() : "Success";

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplicaBySchdeule(statusType, scheduleId);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");
				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				System.out.println("customers" + customers.get("customerName"));

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public CustomerOrderReplica getCustomerOrderReplicaByCartId(String cartId) {

		CustomerOrderReplica CustomerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(cartId,
				currentUser.getContactNumber());

		ObjectMapper objectMapper = new ObjectMapper();
		try {

			// convert JSON string to Map
			Map<String, Object> customerOrderReplicaMap = objectMapper
					.readValue(CustomerOrderReplica.getCustomerOrderDetails(), Map.class);

			Object customerOrder = customerOrderReplicaMap.get("customerOrder");
			Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

			Object quanityList = items.get("quantity");
			Map customers = customerDetailsDao.getByContactNumberAndApartment(CustomerOrderReplica.getContactNumber(),
					CustomerOrderReplica.getApartmentId());

			System.out.println("customers" + customers.get("customerName"));

			// Apartments apartments =
			// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
			CustomerOrderReplica.setApartmentName(
					customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

			CustomerOrderReplica.setCustomerDetails(customers);

			CustomerOrderReplica.setCustomerOrder(customerOrder);
			CustomerOrderReplica.setQuatityList(quanityList);

		} catch (Exception e) {
			e.printStackTrace();
		}

		return CustomerOrderReplica;

	}

	@Override
	public Map createCustomerOrderReplica(CustomerOrderReplicaRequest customerOrderReplicaRequest, String contactNumber,
			Integer aparmentId) {

		if (customerOrderReplicaRequest.getRazorPayRequest() != null) {

//			Map razorPay = consumerService.createRazorPayOrder(customerOrderReplicaRequest.getRazorPayRequest());
//			customerOrderReplicaRequest.setOrderId(razorPay.get("order") != null ? (String)((RazorPay) razorPay.get("order")).getId() : null);	
//	
//			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);
//
//			razorPay.put("cartId", customerOrderReplicaRequest.getCartId());

			Map customerOrderReplicaMap = new HashMap<>();

			Map orderId = new HashMap<>();
			String transactionId = getMerchantTransactionId();
			orderId.put("id", transactionId);

			customerOrderReplicaMap.put("order", orderId);

			customerOrderReplicaRequest.setOrderId(transactionId);
			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);

			customerOrderReplicaMap.put("cartId", customerOrderReplicaRequest.getCartId());

			try {
				customerOrderReplicaMap.put("phonePeResponse",
						phonepeServiceImpl.initiatePhonepePayment(transactionId,
								Integer.valueOf(customerOrderReplicaRequest.getRazorPayRequest().getAmount()),
								contactNumber, customerOrderReplicaRequest.getRedirectUrl(), customerOrderReplicaRequest.getCallBackUrl()));

			} catch (Exception e) {
				e.printStackTrace();
				customerOrderReplicaMap.put("phonePeResponse", new HashedMap<>());
			}

			return customerOrderReplicaMap;

		} else {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
					"paymentDetails transcation Details are mandatory");
		}

	}

	private static String getMerchantTransactionId() {

		return "OD_" + MerchantTransactionIdGenerator.getRandomString();
	}


	@Override
	public List<CustomerOrderReplica> getCustomerOrderByMoblieNo(String contactNumber, Integer aid) {

	    Schedule latestSchedule = customerOrderReplicaDoa.getlatestschedule();

	    if (latestSchedule != null && latestSchedule.getCreationTimestamp() != null) {
	        if (latestSchedule.getStatus().equals(UserStatus.ACTIVE)) {
	            Customers customer = customerDetailsDao.getByContactNoAndApartment(contactNumber, aid);

	            if (customer != null) { // Ensure the customer exists
	                List<CustomerOrder> customerOrderList = customerOrderReplicaDoa.getListCustomerOrderByCustomerId(customer.getCtId());

	                double totalOrderAmount = 0.0;

	                if (customerOrderList != null && !customerOrderList.isEmpty()) {
	                    for (CustomerOrder customerOrder : customerOrderList) {
	                        Double orderAmount = customerOrder.getAmount();
	                        if (orderAmount != null) {
	                            totalOrderAmount += orderAmount;
	                            if(totalOrderAmount>200) {
	                            	totalOrderAmount+= customerOrder.getDelivaryCharges();
	                            }
	                            else(totalOrderAmount<200){
	                            	totalOrderAmount-= customerOrder.getDelivaryCharges();
	                            }
	                        }
	                    }

	                    // Define the minimum order amount for applying delivery charges
	                    double minimumOrderAmount = 200.0;

	                    if (totalOrderAmount < minimumOrderAmount) {
	                        System.out.println("Delivery Charges will be applicable");
	                    } else {
	                        // No delivery charges applicable
	                        System.out.println("No Delivery charges applicable");
	                    }

	                    List<CustomerOrderReplica> customerOrderReplicas = new ArrayList<>();
	                    return customerOrderReplicas;
	                } else {
	                    return Collections.emptyList();
	                }
	            } else {
	                return null; // or an appropriate value
	            }
	        } else {
	            // Handle the case when the latest schedule is not active
	            return null; // or an appropriate value
	        }
	    } else {
	        // Handle the case when there is no latest schedule or its creation timestamp is null
	        return null; // or an appropriate value
	    }
	}

}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4035)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3635)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-09-21 15:34:26.517
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4035)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3635)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-09-21 15:34:26.520
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4035)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3635)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-21 15:34:26.586
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.xyram.daydrop.serviceimpl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.transaction.Transactional;

import org.apache.commons.collections4.map.HashedMap;
import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.server.ResponseStatusException;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.xyram.daydrop.admin.model.CurrentUser;
import com.xyram.daydrop.basemodel.Base64Wrapper;
import com.xyram.daydrop.basemodel.MerchantTransactionIdGenerator;
import com.xyram.daydrop.basemodel.PhonepeSerializer;
import com.xyram.daydrop.dao.ApartmentDao;
import com.xyram.daydrop.dao.CustomerDetailsDao;
import com.xyram.daydrop.dao.CustomerOrderDao;
import com.xyram.daydrop.dao.CustomerOrderReplicaDoa;
import com.xyram.daydrop.dao.SheduleDao;
import com.xyram.daydrop.enumtypes.UserStatus;
import com.xyram.daydrop.model.Apartments;
import com.xyram.daydrop.model.CustomerOrder;
import com.xyram.daydrop.model.CustomerOrderReplica;
import com.xyram.daydrop.model.Customers;
import com.xyram.daydrop.model.Schedule;
import com.xyram.daydrop.modelMapper.PaymentInstrument;
import com.xyram.daydrop.modelMapper.PhonePePayModel;
import com.xyram.daydrop.request.CustomerOrderReplicaRequest;
import com.xyram.daydrop.response.RazorPayRequest;
import com.xyram.daydrop.service.CustomerOrderPriceService;
import com.xyram.daydrop.service.CustomerOrderReplicaService;
import com.xyram.daydrop.util.HashEncoder;
import com.xyram.daydrop.util.RazorPay;
import com.xyram.daydrop.service.ConsumerService;

@Transactional
@Service
public class CustomerOrderReplicaServiceImpl implements CustomerOrderReplicaService {

	@Autowired
	CustomerOrderReplicaDoa customerOrderReplicaDoa;

	@Autowired
	ApartmentDao apartmentDao;

	@Autowired
	SheduleDao scheduleDao;

	@Autowired
	CustomerDetailsDao customerDetailsDao;

	@Autowired
	ConsumerService consumerService;

	@Autowired
	CurrentUser currentUser;

	@Autowired
	PhonepeServiceImpl phonepeServiceImpl;

	@Value("${merchant_id}")
	private String merchantId;

	@Value("${salt_key}")
	private String saltKey;

	@Value("${salt_index}")
	private String saltIndex;

	@Override
	public Map createCustomerOrderReplicaService(CustomerOrderReplicaRequest customerOrderReplicaRequest,
			String contactNumber, Integer aparmentId)

	{

		Map response = new HashedMap<>();

		response.put("message", "success");
		CustomerOrderReplica customerOrderReplica = null;

		if (customerOrderReplicaRequest.getCartId() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "cartId is mandatory ");
		}
		long razorPayCount = 0;
		if (customerOrderReplicaRequest.getOrderId() != null) {

			razorPayCount = customerOrderReplicaDoa.getRazorPayExistByCartId(customerOrderReplicaRequest.getOrderId());
		}

		if (customerOrderReplicaRequest.getCustomerDetails() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Order Details  is mandatory ");
		}

		customerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(customerOrderReplicaRequest.getCartId(),
				contactNumber);

		if (customerOrderReplica != null) {
			customerOrderReplica.setCartId(customerOrderReplica.getCartId());

			if (customerOrderReplica.isOrdered()) {
				throw new ResponseStatusException(HttpStatus.CONFLICT, "Your Order is Placed With cart Details");
			}

//			if (razorPayCount >= 1 && !(customerOrderReplica.getRazorPayOrderId() != null
//					&& customerOrderReplica.getRazorPayOrderId().equals(customerOrderReplicaRequest.getOrderId()))) {
//				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
//			}

			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);

			customerOrderReplica.setAttempts(customerOrderReplica.getAttempts() + 1);
			customerOrderReplica.setUpdatedTime(new Date());

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		} else {

			customerOrderReplica = new CustomerOrderReplica();
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);
			customerOrderReplica.setCartId(customerOrderReplicaRequest.getCartId());
			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());

			if (razorPayCount > 0) {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
			}

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			Schedule schedule = scheduleDao.getlatestScheduleCustomers();

			if (schedule != null) {

				try {
					customerOrderReplica.setSchedule(schedule.getsId() != null ? schedule.getsId().toString() : null);
				} catch (Exception e) {
					e.printStackTrace();
				}
			} else {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
						"Sorry We Are Not Accepting Any Order Right now");

			}

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		}

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicas(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String schedule = null;

		Map filter = request.containsKey("filters") ? (Map) request.get("filters") : null;
		if (filter != null) {
			statusType = filter.containsKey("statusType") ? ((String) filter.get("statusType")).toLowerCase() : null;
			searchQuery = filter.containsKey("searchQuery") ? ((String) filter.get("searchQuery")).toLowerCase() : null;
			schedule = filter.containsKey("schedule") ? (String.valueOf(filter.get("schedule"))) : null;

		}

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplica(searchQuery, statusType, schedule);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");

				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setStreetName(
						customers.get("streetName") != null ? (String) customers.get("streetName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicasBySchedule(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String scheduleId = null;

		Schedule schedule = scheduleDao.getlatestScheduleCustomers();

		if (schedule != null) {

			try {
				scheduleId = schedule.getsId() != null ? schedule.getsId().toString() : null;
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

		statusType = request.containsKey("statusType") ? ((String) request.get("statusType")).toLowerCase() : "Success";

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplicaBySchdeule(statusType, scheduleId);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");
				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				System.out.println("customers" + customers.get("customerName"));

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public CustomerOrderReplica getCustomerOrderReplicaByCartId(String cartId) {

		CustomerOrderReplica CustomerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(cartId,
				currentUser.getContactNumber());

		ObjectMapper objectMapper = new ObjectMapper();
		try {

			// convert JSON string to Map
			Map<String, Object> customerOrderReplicaMap = objectMapper
					.readValue(CustomerOrderReplica.getCustomerOrderDetails(), Map.class);

			Object customerOrder = customerOrderReplicaMap.get("customerOrder");
			Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

			Object quanityList = items.get("quantity");
			Map customers = customerDetailsDao.getByContactNumberAndApartment(CustomerOrderReplica.getContactNumber(),
					CustomerOrderReplica.getApartmentId());

			System.out.println("customers" + customers.get("customerName"));

			// Apartments apartments =
			// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
			CustomerOrderReplica.setApartmentName(
					customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

			CustomerOrderReplica.setCustomerDetails(customers);

			CustomerOrderReplica.setCustomerOrder(customerOrder);
			CustomerOrderReplica.setQuatityList(quanityList);

		} catch (Exception e) {
			e.printStackTrace();
		}

		return CustomerOrderReplica;

	}

	@Override
	public Map createCustomerOrderReplica(CustomerOrderReplicaRequest customerOrderReplicaRequest, String contactNumber,
			Integer aparmentId) {

		if (customerOrderReplicaRequest.getRazorPayRequest() != null) {

//			Map razorPay = consumerService.createRazorPayOrder(customerOrderReplicaRequest.getRazorPayRequest());
//			customerOrderReplicaRequest.setOrderId(razorPay.get("order") != null ? (String)((RazorPay) razorPay.get("order")).getId() : null);	
//	
//			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);
//
//			razorPay.put("cartId", customerOrderReplicaRequest.getCartId());

			Map customerOrderReplicaMap = new HashMap<>();

			Map orderId = new HashMap<>();
			String transactionId = getMerchantTransactionId();
			orderId.put("id", transactionId);

			customerOrderReplicaMap.put("order", orderId);

			customerOrderReplicaRequest.setOrderId(transactionId);
			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);

			customerOrderReplicaMap.put("cartId", customerOrderReplicaRequest.getCartId());

			try {
				customerOrderReplicaMap.put("phonePeResponse",
						phonepeServiceImpl.initiatePhonepePayment(transactionId,
								Integer.valueOf(customerOrderReplicaRequest.getRazorPayRequest().getAmount()),
								contactNumber, customerOrderReplicaRequest.getRedirectUrl(), customerOrderReplicaRequest.getCallBackUrl()));

			} catch (Exception e) {
				e.printStackTrace();
				customerOrderReplicaMap.put("phonePeResponse", new HashedMap<>());
			}

			return customerOrderReplicaMap;

		} else {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
					"paymentDetails transcation Details are mandatory");
		}

	}

	private static String getMerchantTransactionId() {

		return "OD_" + MerchantTransactionIdGenerator.getRandomString();
	}


	@Override
	public List<CustomerOrderReplica> getCustomerOrderByMoblieNo(String contactNumber, Integer aid) {

	    Schedule latestSchedule = customerOrderReplicaDoa.getlatestschedule();

	    if (latestSchedule != null && latestSchedule.getCreationTimestamp() != null) {
	        if (latestSchedule.getStatus().equals(UserStatus.ACTIVE)) {
	            Customers customer = customerDetailsDao.getByContactNoAndApartment(contactNumber, aid);

	            if (customer != null) { // Ensure the customer exists
	                List<CustomerOrder> customerOrderList = customerOrderReplicaDoa.getListCustomerOrderByCustomerId(customer.getCtId());

	                double totalOrderAmount = 0.0;

	                if (customerOrderList != null && !customerOrderList.isEmpty()) {
	                    for (CustomerOrder customerOrder : customerOrderList) {
	                        Double orderAmount = customerOrder.getAmount();
	                        if (orderAmount != null) {
	                            totalOrderAmount += orderAmount;
	                            if(totalOrderAmount>200) {
	                            	totalOrderAmount+= customerOrder.getDelivaryCharges();
	                            }
	                            else(totalOrderAmount<200){
	                            	totalOrderAmount-= customerOrder.getDelivaryCharges();
	                            }
	                        }
	                    }

	                    // Define the minimum order amount for applying delivery charges
	                    double minimumOrderAmount = 200.0;

	                    if (totalOrderAmount < minimumOrderAmount) {
	                        System.out.println("Delivery Charges will be applicable");
	                    } else {
	                        // No delivery charges applicable
	                        System.out.println("No Delivery charges applicable");
	                    }

	                    List<CustomerOrderReplica> customerOrderReplicas = new ArrayList<>();
	                    return customerOrderReplicas;
	                } else {
	                    return Collections.emptyList();
	                }
	            } else {
	                return null; // or an appropriate value
	            }
	        } else {
	            // Handle the case when the latest schedule is not active
	            return null; // or an appropriate value
	        }
	    } else {
	        // Handle the case when there is no latest schedule or its creation timestamp is null
	        return null; // or an appropriate value
	    }
	}

}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.internal.core.manipulation.dom.ASTResolving.createQuickFixAST(ASTResolving.java:1052)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:131)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4035)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3635)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.ui 4 0 2023-09-21 15:34:26.588
!MESSAGE Unhandled event loop exception
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.internal.core.manipulation.dom.ASTResolving.createQuickFixAST(ASTResolving.java:1052)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:131)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4035)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3635)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-21 15:34:28.514
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.xyram.daydrop.serviceimpl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.transaction.Transactional;

import org.apache.commons.collections4.map.HashedMap;
import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.server.ResponseStatusException;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.xyram.daydrop.admin.model.CurrentUser;
import com.xyram.daydrop.basemodel.Base64Wrapper;
import com.xyram.daydrop.basemodel.MerchantTransactionIdGenerator;
import com.xyram.daydrop.basemodel.PhonepeSerializer;
import com.xyram.daydrop.dao.ApartmentDao;
import com.xyram.daydrop.dao.CustomerDetailsDao;
import com.xyram.daydrop.dao.CustomerOrderDao;
import com.xyram.daydrop.dao.CustomerOrderReplicaDoa;
import com.xyram.daydrop.dao.SheduleDao;
import com.xyram.daydrop.enumtypes.UserStatus;
import com.xyram.daydrop.model.Apartments;
import com.xyram.daydrop.model.CustomerOrder;
import com.xyram.daydrop.model.CustomerOrderReplica;
import com.xyram.daydrop.model.Customers;
import com.xyram.daydrop.model.Schedule;
import com.xyram.daydrop.modelMapper.PaymentInstrument;
import com.xyram.daydrop.modelMapper.PhonePePayModel;
import com.xyram.daydrop.request.CustomerOrderReplicaRequest;
import com.xyram.daydrop.response.RazorPayRequest;
import com.xyram.daydrop.service.CustomerOrderPriceService;
import com.xyram.daydrop.service.CustomerOrderReplicaService;
import com.xyram.daydrop.util.HashEncoder;
import com.xyram.daydrop.util.RazorPay;
import com.xyram.daydrop.service.ConsumerService;

@Transactional
@Service
public class CustomerOrderReplicaServiceImpl implements CustomerOrderReplicaService {

	@Autowired
	CustomerOrderReplicaDoa customerOrderReplicaDoa;

	@Autowired
	ApartmentDao apartmentDao;

	@Autowired
	SheduleDao scheduleDao;

	@Autowired
	CustomerDetailsDao customerDetailsDao;

	@Autowired
	ConsumerService consumerService;

	@Autowired
	CurrentUser currentUser;

	@Autowired
	PhonepeServiceImpl phonepeServiceImpl;

	@Value("${merchant_id}")
	private String merchantId;

	@Value("${salt_key}")
	private String saltKey;

	@Value("${salt_index}")
	private String saltIndex;

	@Override
	public Map createCustomerOrderReplicaService(CustomerOrderReplicaRequest customerOrderReplicaRequest,
			String contactNumber, Integer aparmentId)

	{

		Map response = new HashedMap<>();

		response.put("message", "success");
		CustomerOrderReplica customerOrderReplica = null;

		if (customerOrderReplicaRequest.getCartId() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "cartId is mandatory ");
		}
		long razorPayCount = 0;
		if (customerOrderReplicaRequest.getOrderId() != null) {

			razorPayCount = customerOrderReplicaDoa.getRazorPayExistByCartId(customerOrderReplicaRequest.getOrderId());
		}

		if (customerOrderReplicaRequest.getCustomerDetails() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Order Details  is mandatory ");
		}

		customerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(customerOrderReplicaRequest.getCartId(),
				contactNumber);

		if (customerOrderReplica != null) {
			customerOrderReplica.setCartId(customerOrderReplica.getCartId());

			if (customerOrderReplica.isOrdered()) {
				throw new ResponseStatusException(HttpStatus.CONFLICT, "Your Order is Placed With cart Details");
			}

//			if (razorPayCount >= 1 && !(customerOrderReplica.getRazorPayOrderId() != null
//					&& customerOrderReplica.getRazorPayOrderId().equals(customerOrderReplicaRequest.getOrderId()))) {
//				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
//			}

			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);

			customerOrderReplica.setAttempts(customerOrderReplica.getAttempts() + 1);
			customerOrderReplica.setUpdatedTime(new Date());

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		} else {

			customerOrderReplica = new CustomerOrderReplica();
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);
			customerOrderReplica.setCartId(customerOrderReplicaRequest.getCartId());
			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());

			if (razorPayCount > 0) {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
			}

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			Schedule schedule = scheduleDao.getlatestScheduleCustomers();

			if (schedule != null) {

				try {
					customerOrderReplica.setSchedule(schedule.getsId() != null ? schedule.getsId().toString() : null);
				} catch (Exception e) {
					e.printStackTrace();
				}
			} else {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
						"Sorry We Are Not Accepting Any Order Right now");

			}

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		}

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicas(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String schedule = null;

		Map filter = request.containsKey("filters") ? (Map) request.get("filters") : null;
		if (filter != null) {
			statusType = filter.containsKey("statusType") ? ((String) filter.get("statusType")).toLowerCase() : null;
			searchQuery = filter.containsKey("searchQuery") ? ((String) filter.get("searchQuery")).toLowerCase() : null;
			schedule = filter.containsKey("schedule") ? (String.valueOf(filter.get("schedule"))) : null;

		}

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplica(searchQuery, statusType, schedule);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");

				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setStreetName(
						customers.get("streetName") != null ? (String) customers.get("streetName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicasBySchedule(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String scheduleId = null;

		Schedule schedule = scheduleDao.getlatestScheduleCustomers();

		if (schedule != null) {

			try {
				scheduleId = schedule.getsId() != null ? schedule.getsId().toString() : null;
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

		statusType = request.containsKey("statusType") ? ((String) request.get("statusType")).toLowerCase() : "Success";

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplicaBySchdeule(statusType, scheduleId);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");
				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				System.out.println("customers" + customers.get("customerName"));

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public CustomerOrderReplica getCustomerOrderReplicaByCartId(String cartId) {

		CustomerOrderReplica CustomerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(cartId,
				currentUser.getContactNumber());

		ObjectMapper objectMapper = new ObjectMapper();
		try {

			// convert JSON string to Map
			Map<String, Object> customerOrderReplicaMap = objectMapper
					.readValue(CustomerOrderReplica.getCustomerOrderDetails(), Map.class);

			Object customerOrder = customerOrderReplicaMap.get("customerOrder");
			Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

			Object quanityList = items.get("quantity");
			Map customers = customerDetailsDao.getByContactNumberAndApartment(CustomerOrderReplica.getContactNumber(),
					CustomerOrderReplica.getApartmentId());

			System.out.println("customers" + customers.get("customerName"));

			// Apartments apartments =
			// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
			CustomerOrderReplica.setApartmentName(
					customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

			CustomerOrderReplica.setCustomerDetails(customers);

			CustomerOrderReplica.setCustomerOrder(customerOrder);
			CustomerOrderReplica.setQuatityList(quanityList);

		} catch (Exception e) {
			e.printStackTrace();
		}

		return CustomerOrderReplica;

	}

	@Override
	public Map createCustomerOrderReplica(CustomerOrderReplicaRequest customerOrderReplicaRequest, String contactNumber,
			Integer aparmentId) {

		if (customerOrderReplicaRequest.getRazorPayRequest() != null) {

//			Map razorPay = consumerService.createRazorPayOrder(customerOrderReplicaRequest.getRazorPayRequest());
//			customerOrderReplicaRequest.setOrderId(razorPay.get("order") != null ? (String)((RazorPay) razorPay.get("order")).getId() : null);	
//	
//			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);
//
//			razorPay.put("cartId", customerOrderReplicaRequest.getCartId());

			Map customerOrderReplicaMap = new HashMap<>();

			Map orderId = new HashMap<>();
			String transactionId = getMerchantTransactionId();
			orderId.put("id", transactionId);

			customerOrderReplicaMap.put("order", orderId);

			customerOrderReplicaRequest.setOrderId(transactionId);
			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);

			customerOrderReplicaMap.put("cartId", customerOrderReplicaRequest.getCartId());

			try {
				customerOrderReplicaMap.put("phonePeResponse",
						phonepeServiceImpl.initiatePhonepePayment(transactionId,
								Integer.valueOf(customerOrderReplicaRequest.getRazorPayRequest().getAmount()),
								contactNumber, customerOrderReplicaRequest.getRedirectUrl(), customerOrderReplicaRequest.getCallBackUrl()));

			} catch (Exception e) {
				e.printStackTrace();
				customerOrderReplicaMap.put("phonePeResponse", new HashedMap<>());
			}

			return customerOrderReplicaMap;

		} else {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
					"paymentDetails transcation Details are mandatory");
		}

	}

	private static String getMerchantTransactionId() {

		return "OD_" + MerchantTransactionIdGenerator.getRandomString();
	}


	@Override
	public List<CustomerOrderReplica> getCustomerOrderByMoblieNo(String contactNumber, Integer aid) {

	    Schedule latestSchedule = customerOrderReplicaDoa.getlatestschedule();

	    if (latestSchedule != null && latestSchedule.getCreationTimestamp() != null) {
	        if (latestSchedule.getStatus().equals(UserStatus.ACTIVE)) {
	            Customers customer = customerDetailsDao.getByContactNoAndApartment(contactNumber, aid);

	            if (customer != null) { // Ensure the customer exists
	                List<CustomerOrder> customerOrderList = customerOrderReplicaDoa.getListCustomerOrderByCustomerId(customer.getCtId());

	                double totalOrderAmount = 0.0;

	                if (customerOrderList != null && !customerOrderList.isEmpty()) {
	                    for (CustomerOrder customerOrder : customerOrderList) {
	                        Double orderAmount = customerOrder.getAmount();
	                        if (orderAmount != null) {
	                            totalOrderAmount += orderAmount;
	                            if(totalOrderAmount>200) {
	                            	totalOrderAmount+= customerOrder.getDelivaryCharges();
	                            }
	                            else(totalOrderAmount<200){
	                            	totalOrderAmount-= customerOrder.getDelivaryCharges();
	                            }
	                        }
	                    }

	                    // Define the minimum order amount for applying delivery charges
	                    double minimumOrderAmount = 200.0;

	                    if (totalOrderAmount < minimumOrderAmount) {
	                        System.out.println("Delivery Charges will be applicable");
	                    } else {
	                        // No delivery charges applicable
	                        System.out.println("No Delivery charges applicable");
	                    }

	                    List<CustomerOrderReplica> customerOrderReplicas = new ArrayList<>();
	                    return customerOrderReplicas;
	                } else {
	                    return Collections.emptyList();
	                }
	            } else {
	                return null; // or an appropriate value
	            }
	        } else {
	            // Handle the case when the latest schedule is not active
	            return null; // or an appropriate value
	        }
	    } else {
	        // Handle the case when there is no latest schedule or its creation timestamp is null
	        return null; // or an appropriate value
	    }
	}

}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
