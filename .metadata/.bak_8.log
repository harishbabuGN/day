!SESSION 2023-09-21 10:32:03.159 -----------------------------------------------
eclipse.buildId=4.14.1.202204250734
java.version=17.0.2
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.springframework.boot.ide.branding.sts4
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.springframework.boot.ide.branding.sts4

This is a continuation of log file D:\DaydropDEV\.metadata\.bak_7.log
Created Time: 2023-09-21 15:07:37.684

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-09-21 15:07:37.686
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-09-21 15:07:37.687
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-21 15:07:38.682
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.xyram.daydrop.serviceimpl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.transaction.Transactional;

import org.apache.commons.collections4.map.HashedMap;
import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.server.ResponseStatusException;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.xyram.daydrop.admin.model.CurrentUser;
import com.xyram.daydrop.basemodel.Base64Wrapper;
import com.xyram.daydrop.basemodel.MerchantTransactionIdGenerator;
import com.xyram.daydrop.basemodel.PhonepeSerializer;
import com.xyram.daydrop.dao.ApartmentDao;
import com.xyram.daydrop.dao.CustomerDetailsDao;
import com.xyram.daydrop.dao.CustomerOrderDao;
import com.xyram.daydrop.dao.CustomerOrderReplicaDoa;
import com.xyram.daydrop.dao.SheduleDao;
import com.xyram.daydrop.enumtypes.UserStatus;
import com.xyram.daydrop.model.Apartments;
import com.xyram.daydrop.model.CustomerOrder;
import com.xyram.daydrop.model.CustomerOrderReplica;
import com.xyram.daydrop.model.Customers;
import com.xyram.daydrop.model.Schedule;
import com.xyram.daydrop.modelMapper.PaymentInstrument;
import com.xyram.daydrop.modelMapper.PhonePePayModel;
import com.xyram.daydrop.request.CustomerOrderReplicaRequest;
import com.xyram.daydrop.response.RazorPayRequest;
import com.xyram.daydrop.service.CustomerOrderPriceService;
import com.xyram.daydrop.service.CustomerOrderReplicaService;
import com.xyram.daydrop.util.HashEncoder;
import com.xyram.daydrop.util.RazorPay;
import com.xyram.daydrop.service.ConsumerService;

@Transactional
@Service
public class CustomerOrderReplicaServiceImpl implements CustomerOrderReplicaService {

	@Autowired
	CustomerOrderReplicaDoa customerOrderReplicaDoa;

	@Autowired
	ApartmentDao apartmentDao;

	@Autowired
	SheduleDao scheduleDao;

	@Autowired
	CustomerDetailsDao customerDetailsDao;

	@Autowired
	ConsumerService consumerService;

	@Autowired
	CurrentUser currentUser;

	@Autowired
	PhonepeServiceImpl phonepeServiceImpl;

	@Value("${merchant_id}")
	private String merchantId;

	@Value("${salt_key}")
	private String saltKey;

	@Value("${salt_index}")
	private String saltIndex;

	@Override
	public Map createCustomerOrderReplicaService(CustomerOrderReplicaRequest customerOrderReplicaRequest,
			String contactNumber, Integer aparmentId)

	{

		Map response = new HashedMap<>();

		response.put("message", "success");
		CustomerOrderReplica customerOrderReplica = null;

		if (customerOrderReplicaRequest.getCartId() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "cartId is mandatory ");
		}
		long razorPayCount = 0;
		if (customerOrderReplicaRequest.getOrderId() != null) {

			razorPayCount = customerOrderReplicaDoa.getRazorPayExistByCartId(customerOrderReplicaRequest.getOrderId());
		}

		if (customerOrderReplicaRequest.getCustomerDetails() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Order Details  is mandatory ");
		}

		customerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(customerOrderReplicaRequest.getCartId(),
				contactNumber);

		if (customerOrderReplica != null) {
			customerOrderReplica.setCartId(customerOrderReplica.getCartId());

			if (customerOrderReplica.isOrdered()) {
				throw new ResponseStatusException(HttpStatus.CONFLICT, "Your Order is Placed With cart Details");
			}

//			if (razorPayCount >= 1 && !(customerOrderReplica.getRazorPayOrderId() != null
//					&& customerOrderReplica.getRazorPayOrderId().equals(customerOrderReplicaRequest.getOrderId()))) {
//				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
//			}

			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);

			customerOrderReplica.setAttempts(customerOrderReplica.getAttempts() + 1);
			customerOrderReplica.setUpdatedTime(new Date());

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		} else {

			customerOrderReplica = new CustomerOrderReplica();
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);
			customerOrderReplica.setCartId(customerOrderReplicaRequest.getCartId());
			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());

			if (razorPayCount > 0) {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
			}

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			Schedule schedule = scheduleDao.getlatestScheduleCustomers();

			if (schedule != null) {

				try {
					customerOrderReplica.setSchedule(schedule.getsId() != null ? schedule.getsId().toString() : null);
				} catch (Exception e) {
					e.printStackTrace();
				}
			} else {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
						"Sorry We Are Not Accepting Any Order Right now");

			}

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		}

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicas(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String schedule = null;

		Map filter = request.containsKey("filters") ? (Map) request.get("filters") : null;
		if (filter != null) {
			statusType = filter.containsKey("statusType") ? ((String) filter.get("statusType")).toLowerCase() : null;
			searchQuery = filter.containsKey("searchQuery") ? ((String) filter.get("searchQuery")).toLowerCase() : null;
			schedule = filter.containsKey("schedule") ? (String.valueOf(filter.get("schedule"))) : null;

		}

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplica(searchQuery, statusType, schedule);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");

				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setStreetName(
						customers.get("streetName") != null ? (String) customers.get("streetName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicasBySchedule(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String scheduleId = null;

		Schedule schedule = scheduleDao.getlatestScheduleCustomers();

		if (schedule != null) {

			try {
				scheduleId = schedule.getsId() != null ? schedule.getsId().toString() : null;
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

		statusType = request.containsKey("statusType") ? ((String) request.get("statusType")).toLowerCase() : "Success";

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplicaBySchdeule(statusType, scheduleId);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");
				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				System.out.println("customers" + customers.get("customerName"));

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public CustomerOrderReplica getCustomerOrderReplicaByCartId(String cartId) {

		CustomerOrderReplica CustomerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(cartId,
				currentUser.getContactNumber());

		ObjectMapper objectMapper = new ObjectMapper();
		try {

			// convert JSON string to Map
			Map<String, Object> customerOrderReplicaMap = objectMapper
					.readValue(CustomerOrderReplica.getCustomerOrderDetails(), Map.class);

			Object customerOrder = customerOrderReplicaMap.get("customerOrder");
			Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

			Object quanityList = items.get("quantity");
			Map customers = customerDetailsDao.getByContactNumberAndApartment(CustomerOrderReplica.getContactNumber(),
					CustomerOrderReplica.getApartmentId());

			System.out.println("customers" + customers.get("customerName"));

			// Apartments apartments =
			// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
			CustomerOrderReplica.setApartmentName(
					customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

			CustomerOrderReplica.setCustomerDetails(customers);

			CustomerOrderReplica.setCustomerOrder(customerOrder);
			CustomerOrderReplica.setQuatityList(quanityList);

		} catch (Exception e) {
			e.printStackTrace();
		}

		return CustomerOrderReplica;

	}

	@Override
	public Map createCustomerOrderReplica(CustomerOrderReplicaRequest customerOrderReplicaRequest, String contactNumber,
			Integer aparmentId) {

		if (customerOrderReplicaRequest.getRazorPayRequest() != null) {

//			Map razorPay = consumerService.createRazorPayOrder(customerOrderReplicaRequest.getRazorPayRequest());
//			customerOrderReplicaRequest.setOrderId(razorPay.get("order") != null ? (String)((RazorPay) razorPay.get("order")).getId() : null);	
//	
//			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);
//
//			razorPay.put("cartId", customerOrderReplicaRequest.getCartId());

			Map customerOrderReplicaMap = new HashMap<>();

			Map orderId = new HashMap<>();
			String transactionId = getMerchantTransactionId();
			orderId.put("id", transactionId);

			customerOrderReplicaMap.put("order", orderId);

			customerOrderReplicaRequest.setOrderId(transactionId);
			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);

			customerOrderReplicaMap.put("cartId", customerOrderReplicaRequest.getCartId());

			try {
				customerOrderReplicaMap.put("phonePeResponse",
						phonepeServiceImpl.initiatePhonepePayment(transactionId,
								Integer.valueOf(customerOrderReplicaRequest.getRazorPayRequest().getAmount()),
								contactNumber, customerOrderReplicaRequest.getRedirectUrl(), customerOrderReplicaRequest.getCallBackUrl()));

			} catch (Exception e) {
				e.printStackTrace();
				customerOrderReplicaMap.put("phonePeResponse", new HashedMap<>());
			}

			return customerOrderReplicaMap;

		} else {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
					"paymentDetails transcation Details are mandatory");
		}

	}

	private static String getMerchantTransactionId() {

		return "OD_" + MerchantTransactionIdGenerator.getRandomString();
	}


	@Override
	public List<CustomerOrderReplica> getCustomerOrderByMoblieNo(String contactNumber,Integer aid) {
		
		Schedule latestschedule = customerOrderReplicaDoa.getlatestschedule();
		
		if (latestschedule != null && latestschedule.getCreationTimestamp()!=null) {
			
	        if (latestschedule.getStatus().equals(UserStatus.ACTIVE)) {
	        	
	        	Customers customer = customerDetailsDao.getByContactNoAndApartment(contactNumber, aid);
	        	if (customer != null) { // Ensure the customer exists
	        		List<CustomerOrder> customerOrderList = customerOrderReplicaDoa.getListCustomerOrderByCustomerId(customer.getCtid());
	        		
	                double totalOrderAmount = 0.0;
	       
                if (customerOrderList != null && !customerOrderList.isEmpty() && customerOrderList.add(customerOrder). {
                    for (CustomerOrder customerOrder : customerOrderList) {
                        Double orderAmount = customerOrder.getAmount();
                        if (orderAmount != null) {
                            totalOrderAmount += orderAmount;
                            if(totalOrderAmount>200) {
                            	totalOrderAmount+customerOrder
                            }
                        }
                    }
                    System.out.println("Total Order Amount: " + totalOrderAmount);
                    List<CustomerOrderReplica> customerOrderReplicas = new ArrayList<>();
                    return customerOrderReplicas;
                } else {
                    return Collections.emptyList(); // or return null or an appropriate value
                }
            } else {
              
                return null; // or an appropriate value
            }
        } else {
            // Handle the case when the latest schedule is not active
            return null; // or an appropriate value
        }
    } else {
        // Handle the case when there is no latest schedule or its creation timestamp is null
        return null; // or an appropriate value
    }
	}
}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-09-21 15:07:38.685
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-09-21 15:07:38.690
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.lsp4e 2 0 2023-09-21 15:10:05.744
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:386)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2096)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2023-09-21 15:25:17.425
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:386)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2096)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-21 15:33:30.191
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.xyram.daydrop.serviceimpl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.transaction.Transactional;

import org.apache.commons.collections4.map.HashedMap;
import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.server.ResponseStatusException;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.xyram.daydrop.admin.model.CurrentUser;
import com.xyram.daydrop.basemodel.Base64Wrapper;
import com.xyram.daydrop.basemodel.MerchantTransactionIdGenerator;
import com.xyram.daydrop.basemodel.PhonepeSerializer;
import com.xyram.daydrop.dao.ApartmentDao;
import com.xyram.daydrop.dao.CustomerDetailsDao;
import com.xyram.daydrop.dao.CustomerOrderDao;
import com.xyram.daydrop.dao.CustomerOrderReplicaDoa;
import com.xyram.daydrop.dao.SheduleDao;
import com.xyram.daydrop.enumtypes.UserStatus;
import com.xyram.daydrop.model.Apartments;
import com.xyram.daydrop.model.CustomerOrder;
import com.xyram.daydrop.model.CustomerOrderReplica;
import com.xyram.daydrop.model.Customers;
import com.xyram.daydrop.model.Schedule;
import com.xyram.daydrop.modelMapper.PaymentInstrument;
import com.xyram.daydrop.modelMapper.PhonePePayModel;
import com.xyram.daydrop.request.CustomerOrderReplicaRequest;
import com.xyram.daydrop.response.RazorPayRequest;
import com.xyram.daydrop.service.CustomerOrderPriceService;
import com.xyram.daydrop.service.CustomerOrderReplicaService;
import com.xyram.daydrop.util.HashEncoder;
import com.xyram.daydrop.util.RazorPay;
import com.xyram.daydrop.service.ConsumerService;

@Transactional
@Service
public class CustomerOrderReplicaServiceImpl implements CustomerOrderReplicaService {

	@Autowired
	CustomerOrderReplicaDoa customerOrderReplicaDoa;

	@Autowired
	ApartmentDao apartmentDao;

	@Autowired
	SheduleDao scheduleDao;

	@Autowired
	CustomerDetailsDao customerDetailsDao;

	@Autowired
	ConsumerService consumerService;

	@Autowired
	CurrentUser currentUser;

	@Autowired
	PhonepeServiceImpl phonepeServiceImpl;

	@Value("${merchant_id}")
	private String merchantId;

	@Value("${salt_key}")
	private String saltKey;

	@Value("${salt_index}")
	private String saltIndex;

	@Override
	public Map createCustomerOrderReplicaService(CustomerOrderReplicaRequest customerOrderReplicaRequest,
			String contactNumber, Integer aparmentId)

	{

		Map response = new HashedMap<>();

		response.put("message", "success");
		CustomerOrderReplica customerOrderReplica = null;

		if (customerOrderReplicaRequest.getCartId() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "cartId is mandatory ");
		}
		long razorPayCount = 0;
		if (customerOrderReplicaRequest.getOrderId() != null) {

			razorPayCount = customerOrderReplicaDoa.getRazorPayExistByCartId(customerOrderReplicaRequest.getOrderId());
		}

		if (customerOrderReplicaRequest.getCustomerDetails() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Order Details  is mandatory ");
		}

		customerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(customerOrderReplicaRequest.getCartId(),
				contactNumber);

		if (customerOrderReplica != null) {
			customerOrderReplica.setCartId(customerOrderReplica.getCartId());

			if (customerOrderReplica.isOrdered()) {
				throw new ResponseStatusException(HttpStatus.CONFLICT, "Your Order is Placed With cart Details");
			}

//			if (razorPayCount >= 1 && !(customerOrderReplica.getRazorPayOrderId() != null
//					&& customerOrderReplica.getRazorPayOrderId().equals(customerOrderReplicaRequest.getOrderId()))) {
//				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
//			}

			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);

			customerOrderReplica.setAttempts(customerOrderReplica.getAttempts() + 1);
			customerOrderReplica.setUpdatedTime(new Date());

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		} else {

			customerOrderReplica = new CustomerOrderReplica();
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);
			customerOrderReplica.setCartId(customerOrderReplicaRequest.getCartId());
			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());

			if (razorPayCount > 0) {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
			}

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			Schedule schedule = scheduleDao.getlatestScheduleCustomers();

			if (schedule != null) {

				try {
					customerOrderReplica.setSchedule(schedule.getsId() != null ? schedule.getsId().toString() : null);
				} catch (Exception e) {
					e.printStackTrace();
				}
			} else {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
						"Sorry We Are Not Accepting Any Order Right now");

			}

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		}

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicas(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String schedule = null;

		Map filter = request.containsKey("filters") ? (Map) request.get("filters") : null;
		if (filter != null) {
			statusType = filter.containsKey("statusType") ? ((String) filter.get("statusType")).toLowerCase() : null;
			searchQuery = filter.containsKey("searchQuery") ? ((String) filter.get("searchQuery")).toLowerCase() : null;
			schedule = filter.containsKey("schedule") ? (String.valueOf(filter.get("schedule"))) : null;

		}

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplica(searchQuery, statusType, schedule);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");

				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setStreetName(
						customers.get("streetName") != null ? (String) customers.get("streetName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicasBySchedule(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String scheduleId = null;

		Schedule schedule = scheduleDao.getlatestScheduleCustomers();

		if (schedule != null) {

			try {
				scheduleId = schedule.getsId() != null ? schedule.getsId().toString() : null;
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

		statusType = request.containsKey("statusType") ? ((String) request.get("statusType")).toLowerCase() : "Success";

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplicaBySchdeule(statusType, scheduleId);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");
				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				System.out.println("customers" + customers.get("customerName"));

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public CustomerOrderReplica getCustomerOrderReplicaByCartId(String cartId) {

		CustomerOrderReplica CustomerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(cartId,
				currentUser.getContactNumber());

		ObjectMapper objectMapper = new ObjectMapper();
		try {

			// convert JSON string to Map
			Map<String, Object> customerOrderReplicaMap = objectMapper
					.readValue(CustomerOrderReplica.getCustomerOrderDetails(), Map.class);

			Object customerOrder = customerOrderReplicaMap.get("customerOrder");
			Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

			Object quanityList = items.get("quantity");
			Map customers = customerDetailsDao.getByContactNumberAndApartment(CustomerOrderReplica.getContactNumber(),
					CustomerOrderReplica.getApartmentId());

			System.out.println("customers" + customers.get("customerName"));

			// Apartments apartments =
			// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
			CustomerOrderReplica.setApartmentName(
					customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

			CustomerOrderReplica.setCustomerDetails(customers);

			CustomerOrderReplica.setCustomerOrder(customerOrder);
			CustomerOrderReplica.setQuatityList(quanityList);

		} catch (Exception e) {
			e.printStackTrace();
		}

		return CustomerOrderReplica;

	}

	@Override
	public Map createCustomerOrderReplica(CustomerOrderReplicaRequest customerOrderReplicaRequest, String contactNumber,
			Integer aparmentId) {

		if (customerOrderReplicaRequest.getRazorPayRequest() != null) {

//			Map razorPay = consumerService.createRazorPayOrder(customerOrderReplicaRequest.getRazorPayRequest());
//			customerOrderReplicaRequest.setOrderId(razorPay.get("order") != null ? (String)((RazorPay) razorPay.get("order")).getId() : null);	
//	
//			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);
//
//			razorPay.put("cartId", customerOrderReplicaRequest.getCartId());

			Map customerOrderReplicaMap = new HashMap<>();

			Map orderId = new HashMap<>();
			String transactionId = getMerchantTransactionId();
			orderId.put("id", transactionId);

			customerOrderReplicaMap.put("order", orderId);

			customerOrderReplicaRequest.setOrderId(transactionId);
			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);

			customerOrderReplicaMap.put("cartId", customerOrderReplicaRequest.getCartId());

			try {
				customerOrderReplicaMap.put("phonePeResponse",
						phonepeServiceImpl.initiatePhonepePayment(transactionId,
								Integer.valueOf(customerOrderReplicaRequest.getRazorPayRequest().getAmount()),
								contactNumber, customerOrderReplicaRequest.getRedirectUrl(), customerOrderReplicaRequest.getCallBackUrl()));

			} catch (Exception e) {
				e.printStackTrace();
				customerOrderReplicaMap.put("phonePeResponse", new HashedMap<>());
			}

			return customerOrderReplicaMap;

		} else {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
					"paymentDetails transcation Details are mandatory");
		}

	}

	private static String getMerchantTransactionId() {

		return "OD_" + MerchantTransactionIdGenerator.getRandomString();
	}


	@Override
	public List<CustomerOrderReplica> getCustomerOrderByMoblieNo(String contactNumber, Integer aid) {

	    Schedule latestSchedule = customerOrderReplicaDoa.getlatestschedule();

	    if (latestSchedule != null && latestSchedule.getCreationTimestamp() != null) {
	        if (latestSchedule.getStatus().equals(UserStatus.ACTIVE)) {
	            Customers customer = customerDetailsDao.getByContactNoAndApartment(contactNumber, aid);

	            if (customer != null) { // Ensure the customer exists
	                List<CustomerOrder> customerOrderList = customerOrderReplicaDoa.getListCustomerOrderByCustomerId(customer.getCtId());

	                double totalOrderAmount = 0.0;

	                if (customerOrderList != null && !customerOrderList.isEmpty()) {
	                    for (CustomerOrder customerOrder : customerOrderList) {
	                        Double orderAmount = customerOrder.getAmount();
	                        if (orderAmount != null) {
	                            totalOrderAmount += orderAmount;
	                            if(totalOrderAmount>200) {
	                            	totalOrderAmount+= customerOrder.getDelivaryCharges();
	                            }
	                            else(totalOrderAmount<200)
	                        }
	                    }

	                    // Define the minimum order amount for applying delivery charges
	                    double minimumOrderAmount = 200.0;

	                    if (totalOrderAmount < minimumOrderAmount) {
	                        System.out.println("Delivery Charges will be applicable");
	                    } else {
	                        // No delivery charges applicable
	                        System.out.println("No Delivery charges applicable");
	                    }

	                    List<CustomerOrderReplica> customerOrderReplicas = new ArrayList<>();
	                    return customerOrderReplicas;
	                } else {
	                    return Collections.emptyList();
	                }
	            } else {
	                return null; // or an appropriate value
	            }
	        } else {
	            // Handle the case when the latest schedule is not active
	            return null; // or an appropriate value
	        }
	    } else {
	        // Handle the case when there is no latest schedule or its creation timestamp is null
	        return null; // or an appropriate value
	    }
	}

}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-09-21 15:33:30.193
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-09-21 15:33:30.195
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-21 15:33:30.323
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.xyram.daydrop.serviceimpl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.transaction.Transactional;

import org.apache.commons.collections4.map.HashedMap;
import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.server.ResponseStatusException;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.xyram.daydrop.admin.model.CurrentUser;
import com.xyram.daydrop.basemodel.Base64Wrapper;
import com.xyram.daydrop.basemodel.MerchantTransactionIdGenerator;
import com.xyram.daydrop.basemodel.PhonepeSerializer;
import com.xyram.daydrop.dao.ApartmentDao;
import com.xyram.daydrop.dao.CustomerDetailsDao;
import com.xyram.daydrop.dao.CustomerOrderDao;
import com.xyram.daydrop.dao.CustomerOrderReplicaDoa;
import com.xyram.daydrop.dao.SheduleDao;
import com.xyram.daydrop.enumtypes.UserStatus;
import com.xyram.daydrop.model.Apartments;
import com.xyram.daydrop.model.CustomerOrder;
import com.xyram.daydrop.model.CustomerOrderReplica;
import com.xyram.daydrop.model.Customers;
import com.xyram.daydrop.model.Schedule;
import com.xyram.daydrop.modelMapper.PaymentInstrument;
import com.xyram.daydrop.modelMapper.PhonePePayModel;
import com.xyram.daydrop.request.CustomerOrderReplicaRequest;
import com.xyram.daydrop.response.RazorPayRequest;
import com.xyram.daydrop.service.CustomerOrderPriceService;
import com.xyram.daydrop.service.CustomerOrderReplicaService;
import com.xyram.daydrop.util.HashEncoder;
import com.xyram.daydrop.util.RazorPay;
import com.xyram.daydrop.service.ConsumerService;

@Transactional
@Service
public class CustomerOrderReplicaServiceImpl implements CustomerOrderReplicaService {

	@Autowired
	CustomerOrderReplicaDoa customerOrderReplicaDoa;

	@Autowired
	ApartmentDao apartmentDao;

	@Autowired
	SheduleDao scheduleDao;

	@Autowired
	CustomerDetailsDao customerDetailsDao;

	@Autowired
	ConsumerService consumerService;

	@Autowired
	CurrentUser currentUser;

	@Autowired
	PhonepeServiceImpl phonepeServiceImpl;

	@Value("${merchant_id}")
	private String merchantId;

	@Value("${salt_key}")
	private String saltKey;

	@Value("${salt_index}")
	private String saltIndex;

	@Override
	public Map createCustomerOrderReplicaService(CustomerOrderReplicaRequest customerOrderReplicaRequest,
			String contactNumber, Integer aparmentId)

	{

		Map response = new HashedMap<>();

		response.put("message", "success");
		CustomerOrderReplica customerOrderReplica = null;

		if (customerOrderReplicaRequest.getCartId() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "cartId is mandatory ");
		}
		long razorPayCount = 0;
		if (customerOrderReplicaRequest.getOrderId() != null) {

			razorPayCount = customerOrderReplicaDoa.getRazorPayExistByCartId(customerOrderReplicaRequest.getOrderId());
		}

		if (customerOrderReplicaRequest.getCustomerDetails() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Order Details  is mandatory ");
		}

		customerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(customerOrderReplicaRequest.getCartId(),
				contactNumber);

		if (customerOrderReplica != null) {
			customerOrderReplica.setCartId(customerOrderReplica.getCartId());

			if (customerOrderReplica.isOrdered()) {
				throw new ResponseStatusException(HttpStatus.CONFLICT, "Your Order is Placed With cart Details");
			}

//			if (razorPayCount >= 1 && !(customerOrderReplica.getRazorPayOrderId() != null
//					&& customerOrderReplica.getRazorPayOrderId().equals(customerOrderReplicaRequest.getOrderId()))) {
//				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
//			}

			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);

			customerOrderReplica.setAttempts(customerOrderReplica.getAttempts() + 1);
			customerOrderReplica.setUpdatedTime(new Date());

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		} else {

			customerOrderReplica = new CustomerOrderReplica();
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);
			customerOrderReplica.setCartId(customerOrderReplicaRequest.getCartId());
			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());

			if (razorPayCount > 0) {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
			}

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			Schedule schedule = scheduleDao.getlatestScheduleCustomers();

			if (schedule != null) {

				try {
					customerOrderReplica.setSchedule(schedule.getsId() != null ? schedule.getsId().toString() : null);
				} catch (Exception e) {
					e.printStackTrace();
				}
			} else {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
						"Sorry We Are Not Accepting Any Order Right now");

			}

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		}

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicas(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String schedule = null;

		Map filter = request.containsKey("filters") ? (Map) request.get("filters") : null;
		if (filter != null) {
			statusType = filter.containsKey("statusType") ? ((String) filter.get("statusType")).toLowerCase() : null;
			searchQuery = filter.containsKey("searchQuery") ? ((String) filter.get("searchQuery")).toLowerCase() : null;
			schedule = filter.containsKey("schedule") ? (String.valueOf(filter.get("schedule"))) : null;

		}

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplica(searchQuery, statusType, schedule);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");

				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setStreetName(
						customers.get("streetName") != null ? (String) customers.get("streetName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicasBySchedule(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String scheduleId = null;

		Schedule schedule = scheduleDao.getlatestScheduleCustomers();

		if (schedule != null) {

			try {
				scheduleId = schedule.getsId() != null ? schedule.getsId().toString() : null;
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

		statusType = request.containsKey("statusType") ? ((String) request.get("statusType")).toLowerCase() : "Success";

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplicaBySchdeule(statusType, scheduleId);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");
				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				System.out.println("customers" + customers.get("customerName"));

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public CustomerOrderReplica getCustomerOrderReplicaByCartId(String cartId) {

		CustomerOrderReplica CustomerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(cartId,
				currentUser.getContactNumber());

		ObjectMapper objectMapper = new ObjectMapper();
		try {

			// convert JSON string to Map
			Map<String, Object> customerOrderReplicaMap = objectMapper
					.readValue(CustomerOrderReplica.getCustomerOrderDetails(), Map.class);

			Object customerOrder = customerOrderReplicaMap.get("customerOrder");
			Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

			Object quanityList = items.get("quantity");
			Map customers = customerDetailsDao.getByContactNumberAndApartment(CustomerOrderReplica.getContactNumber(),
					CustomerOrderReplica.getApartmentId());

			System.out.println("customers" + customers.get("customerName"));

			// Apartments apartments =
			// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
			CustomerOrderReplica.setApartmentName(
					customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

			CustomerOrderReplica.setCustomerDetails(customers);

			CustomerOrderReplica.setCustomerOrder(customerOrder);
			CustomerOrderReplica.setQuatityList(quanityList);

		} catch (Exception e) {
			e.printStackTrace();
		}

		return CustomerOrderReplica;

	}

	@Override
	public Map createCustomerOrderReplica(CustomerOrderReplicaRequest customerOrderReplicaRequest, String contactNumber,
			Integer aparmentId) {

		if (customerOrderReplicaRequest.getRazorPayRequest() != null) {

//			Map razorPay = consumerService.createRazorPayOrder(customerOrderReplicaRequest.getRazorPayRequest());
//			customerOrderReplicaRequest.setOrderId(razorPay.get("order") != null ? (String)((RazorPay) razorPay.get("order")).getId() : null);	
//	
//			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);
//
//			razorPay.put("cartId", customerOrderReplicaRequest.getCartId());

			Map customerOrderReplicaMap = new HashMap<>();

			Map orderId = new HashMap<>();
			String transactionId = getMerchantTransactionId();
			orderId.put("id", transactionId);

			customerOrderReplicaMap.put("order", orderId);

			customerOrderReplicaRequest.setOrderId(transactionId);
			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);

			customerOrderReplicaMap.put("cartId", customerOrderReplicaRequest.getCartId());

			try {
				customerOrderReplicaMap.put("phonePeResponse",
						phonepeServiceImpl.initiatePhonepePayment(transactionId,
								Integer.valueOf(customerOrderReplicaRequest.getRazorPayRequest().getAmount()),
								contactNumber, customerOrderReplicaRequest.getRedirectUrl(), customerOrderReplicaRequest.getCallBackUrl()));

			} catch (Exception e) {
				e.printStackTrace();
				customerOrderReplicaMap.put("phonePeResponse", new HashedMap<>());
			}

			return customerOrderReplicaMap;

		} else {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
					"paymentDetails transcation Details are mandatory");
		}

	}

	private static String getMerchantTransactionId() {

		return "OD_" + MerchantTransactionIdGenerator.getRandomString();
	}


	@Override
	public List<CustomerOrderReplica> getCustomerOrderByMoblieNo(String contactNumber, Integer aid) {

	    Schedule latestSchedule = customerOrderReplicaDoa.getlatestschedule();

	    if (latestSchedule != null && latestSchedule.getCreationTimestamp() != null) {
	        if (latestSchedule.getStatus().equals(UserStatus.ACTIVE)) {
	            Customers customer = customerDetailsDao.getByContactNoAndApartment(contactNumber, aid);

	            if (customer != null) { // Ensure the customer exists
	                List<CustomerOrder> customerOrderList = customerOrderReplicaDoa.getListCustomerOrderByCustomerId(customer.getCtId());

	                double totalOrderAmount = 0.0;

	                if (customerOrderList != null && !customerOrderList.isEmpty()) {
	                    for (CustomerOrder customerOrder : customerOrderList) {
	                        Double orderAmount = customerOrder.getAmount();
	                        if (orderAmount != null) {
	                            totalOrderAmount += orderAmount;
	                            if(totalOrderAmount>200) {
	                            	totalOrderAmount+= customerOrder.getDelivaryCharges();
	                            }
	                            else(totalOrderAmount<200)
	                        }
	                    }

	                    // Define the minimum order amount for applying delivery charges
	                    double minimumOrderAmount = 200.0;

	                    if (totalOrderAmount < minimumOrderAmount) {
	                        System.out.println("Delivery Charges will be applicable");
	                    } else {
	                        // No delivery charges applicable
	                        System.out.println("No Delivery charges applicable");
	                    }

	                    List<CustomerOrderReplica> customerOrderReplicas = new ArrayList<>();
	                    return customerOrderReplicas;
	                } else {
	                    return Collections.emptyList();
	                }
	            } else {
	                return null; // or an appropriate value
	            }
	        } else {
	            // Handle the case when the latest schedule is not active
	            return null; // or an appropriate value
	        }
	    } else {
	        // Handle the case when there is no latest schedule or its creation timestamp is null
	        return null; // or an appropriate value
	    }
	}

}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-09-21 15:33:30.325
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-09-21 15:33:30.327
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-21 15:33:31.771
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.xyram.daydrop.serviceimpl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.transaction.Transactional;

import org.apache.commons.collections4.map.HashedMap;
import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.server.ResponseStatusException;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.xyram.daydrop.admin.model.CurrentUser;
import com.xyram.daydrop.basemodel.Base64Wrapper;
import com.xyram.daydrop.basemodel.MerchantTransactionIdGenerator;
import com.xyram.daydrop.basemodel.PhonepeSerializer;
import com.xyram.daydrop.dao.ApartmentDao;
import com.xyram.daydrop.dao.CustomerDetailsDao;
import com.xyram.daydrop.dao.CustomerOrderDao;
import com.xyram.daydrop.dao.CustomerOrderReplicaDoa;
import com.xyram.daydrop.dao.SheduleDao;
import com.xyram.daydrop.enumtypes.UserStatus;
import com.xyram.daydrop.model.Apartments;
import com.xyram.daydrop.model.CustomerOrder;
import com.xyram.daydrop.model.CustomerOrderReplica;
import com.xyram.daydrop.model.Customers;
import com.xyram.daydrop.model.Schedule;
import com.xyram.daydrop.modelMapper.PaymentInstrument;
import com.xyram.daydrop.modelMapper.PhonePePayModel;
import com.xyram.daydrop.request.CustomerOrderReplicaRequest;
import com.xyram.daydrop.response.RazorPayRequest;
import com.xyram.daydrop.service.CustomerOrderPriceService;
import com.xyram.daydrop.service.CustomerOrderReplicaService;
import com.xyram.daydrop.util.HashEncoder;
import com.xyram.daydrop.util.RazorPay;
import com.xyram.daydrop.service.ConsumerService;

@Transactional
@Service
public class CustomerOrderReplicaServiceImpl implements CustomerOrderReplicaService {

	@Autowired
	CustomerOrderReplicaDoa customerOrderReplicaDoa;

	@Autowired
	ApartmentDao apartmentDao;

	@Autowired
	SheduleDao scheduleDao;

	@Autowired
	CustomerDetailsDao customerDetailsDao;

	@Autowired
	ConsumerService consumerService;

	@Autowired
	CurrentUser currentUser;

	@Autowired
	PhonepeServiceImpl phonepeServiceImpl;

	@Value("${merchant_id}")
	private String merchantId;

	@Value("${salt_key}")
	private String saltKey;

	@Value("${salt_index}")
	private String saltIndex;

	@Override
	public Map createCustomerOrderReplicaService(CustomerOrderReplicaRequest customerOrderReplicaRequest,
			String contactNumber, Integer aparmentId)

	{

		Map response = new HashedMap<>();

		response.put("message", "success");
		CustomerOrderReplica customerOrderReplica = null;

		if (customerOrderReplicaRequest.getCartId() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "cartId is mandatory ");
		}
		long razorPayCount = 0;
		if (customerOrderReplicaRequest.getOrderId() != null) {

			razorPayCount = customerOrderReplicaDoa.getRazorPayExistByCartId(customerOrderReplicaRequest.getOrderId());
		}

		if (customerOrderReplicaRequest.getCustomerDetails() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Order Details  is mandatory ");
		}

		customerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(customerOrderReplicaRequest.getCartId(),
				contactNumber);

		if (customerOrderReplica != null) {
			customerOrderReplica.setCartId(customerOrderReplica.getCartId());

			if (customerOrderReplica.isOrdered()) {
				throw new ResponseStatusException(HttpStatus.CONFLICT, "Your Order is Placed With cart Details");
			}

//			if (razorPayCount >= 1 && !(customerOrderReplica.getRazorPayOrderId() != null
//					&& customerOrderReplica.getRazorPayOrderId().equals(customerOrderReplicaRequest.getOrderId()))) {
//				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
//			}

			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);

			customerOrderReplica.setAttempts(customerOrderReplica.getAttempts() + 1);
			customerOrderReplica.setUpdatedTime(new Date());

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		} else {

			customerOrderReplica = new CustomerOrderReplica();
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);
			customerOrderReplica.setCartId(customerOrderReplicaRequest.getCartId());
			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());

			if (razorPayCount > 0) {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
			}

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			Schedule schedule = scheduleDao.getlatestScheduleCustomers();

			if (schedule != null) {

				try {
					customerOrderReplica.setSchedule(schedule.getsId() != null ? schedule.getsId().toString() : null);
				} catch (Exception e) {
					e.printStackTrace();
				}
			} else {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
						"Sorry We Are Not Accepting Any Order Right now");

			}

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		}

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicas(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String schedule = null;

		Map filter = request.containsKey("filters") ? (Map) request.get("filters") : null;
		if (filter != null) {
			statusType = filter.containsKey("statusType") ? ((String) filter.get("statusType")).toLowerCase() : null;
			searchQuery = filter.containsKey("searchQuery") ? ((String) filter.get("searchQuery")).toLowerCase() : null;
			schedule = filter.containsKey("schedule") ? (String.valueOf(filter.get("schedule"))) : null;

		}

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplica(searchQuery, statusType, schedule);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");

				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setStreetName(
						customers.get("streetName") != null ? (String) customers.get("streetName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicasBySchedule(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String scheduleId = null;

		Schedule schedule = scheduleDao.getlatestScheduleCustomers();

		if (schedule != null) {

			try {
				scheduleId = schedule.getsId() != null ? schedule.getsId().toString() : null;
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

		statusType = request.containsKey("statusType") ? ((String) request.get("statusType")).toLowerCase() : "Success";

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplicaBySchdeule(statusType, scheduleId);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");
				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				System.out.println("customers" + customers.get("customerName"));

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public CustomerOrderReplica getCustomerOrderReplicaByCartId(String cartId) {

		CustomerOrderReplica CustomerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(cartId,
				currentUser.getContactNumber());

		ObjectMapper objectMapper = new ObjectMapper();
		try {

			// convert JSON string to Map
			Map<String, Object> customerOrderReplicaMap = objectMapper
					.readValue(CustomerOrderReplica.getCustomerOrderDetails(), Map.class);

			Object customerOrder = customerOrderReplicaMap.get("customerOrder");
			Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

			Object quanityList = items.get("quantity");
			Map customers = customerDetailsDao.getByContactNumberAndApartment(CustomerOrderReplica.getContactNumber(),
					CustomerOrderReplica.getApartmentId());

			System.out.println("customers" + customers.get("customerName"));

			// Apartments apartments =
			// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
			CustomerOrderReplica.setApartmentName(
					customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

			CustomerOrderReplica.setCustomerDetails(customers);

			CustomerOrderReplica.setCustomerOrder(customerOrder);
			CustomerOrderReplica.setQuatityList(quanityList);

		} catch (Exception e) {
			e.printStackTrace();
		}

		return CustomerOrderReplica;

	}

	@Override
	public Map createCustomerOrderReplica(CustomerOrderReplicaRequest customerOrderReplicaRequest, String contactNumber,
			Integer aparmentId) {

		if (customerOrderReplicaRequest.getRazorPayRequest() != null) {

//			Map razorPay = consumerService.createRazorPayOrder(customerOrderReplicaRequest.getRazorPayRequest());
//			customerOrderReplicaRequest.setOrderId(razorPay.get("order") != null ? (String)((RazorPay) razorPay.get("order")).getId() : null);	
//	
//			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);
//
//			razorPay.put("cartId", customerOrderReplicaRequest.getCartId());

			Map customerOrderReplicaMap = new HashMap<>();

			Map orderId = new HashMap<>();
			String transactionId = getMerchantTransactionId();
			orderId.put("id", transactionId);

			customerOrderReplicaMap.put("order", orderId);

			customerOrderReplicaRequest.setOrderId(transactionId);
			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);

			customerOrderReplicaMap.put("cartId", customerOrderReplicaRequest.getCartId());

			try {
				customerOrderReplicaMap.put("phonePeResponse",
						phonepeServiceImpl.initiatePhonepePayment(transactionId,
								Integer.valueOf(customerOrderReplicaRequest.getRazorPayRequest().getAmount()),
								contactNumber, customerOrderReplicaRequest.getRedirectUrl(), customerOrderReplicaRequest.getCallBackUrl()));

			} catch (Exception e) {
				e.printStackTrace();
				customerOrderReplicaMap.put("phonePeResponse", new HashedMap<>());
			}

			return customerOrderReplicaMap;

		} else {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
					"paymentDetails transcation Details are mandatory");
		}

	}

	private static String getMerchantTransactionId() {

		return "OD_" + MerchantTransactionIdGenerator.getRandomString();
	}


	@Override
	public List<CustomerOrderReplica> getCustomerOrderByMoblieNo(String contactNumber, Integer aid) {

	    Schedule latestSchedule = customerOrderReplicaDoa.getlatestschedule();

	    if (latestSchedule != null && latestSchedule.getCreationTimestamp() != null) {
	        if (latestSchedule.getStatus().equals(UserStatus.ACTIVE)) {
	            Customers customer = customerDetailsDao.getByContactNoAndApartment(contactNumber, aid);

	            if (customer != null) { // Ensure the customer exists
	                List<CustomerOrder> customerOrderList = customerOrderReplicaDoa.getListCustomerOrderByCustomerId(customer.getCtId());

	                double totalOrderAmount = 0.0;

	                if (customerOrderList != null && !customerOrderList.isEmpty()) {
	                    for (CustomerOrder customerOrder : customerOrderList) {
	                        Double orderAmount = customerOrder.getAmount();
	                        if (orderAmount != null) {
	                            totalOrderAmount += orderAmount;
	                            if(totalOrderAmount>200) {
	                            	totalOrderAmount+= customerOrder.getDelivaryCharges();
	                            }
	                            else(totalOrderAmount<200)
	                        }
	                    }

	                    // Define the minimum order amount for applying delivery charges
	                    double minimumOrderAmount = 200.0;

	                    if (totalOrderAmount < minimumOrderAmount) {
	                        System.out.println("Delivery Charges will be applicable");
	                    } else {
	                        // No delivery charges applicable
	                        System.out.println("No Delivery charges applicable");
	                    }

	                    List<CustomerOrderReplica> customerOrderReplicas = new ArrayList<>();
	                    return customerOrderReplicas;
	                } else {
	                    return Collections.emptyList();
	                }
	            } else {
	                return null; // or an appropriate value
	            }
	        } else {
	            // Handle the case when the latest schedule is not active
	            return null; // or an appropriate value
	        }
	    } else {
	        // Handle the case when there is no latest schedule or its creation timestamp is null
	        return null; // or an appropriate value
	    }
	}

}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-09-21 15:33:31.773
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-09-21 15:33:31.774
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-21 15:33:34.797
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.xyram.daydrop.serviceimpl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.transaction.Transactional;

import org.apache.commons.collections4.map.HashedMap;
import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.server.ResponseStatusException;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.xyram.daydrop.admin.model.CurrentUser;
import com.xyram.daydrop.basemodel.Base64Wrapper;
import com.xyram.daydrop.basemodel.MerchantTransactionIdGenerator;
import com.xyram.daydrop.basemodel.PhonepeSerializer;
import com.xyram.daydrop.dao.ApartmentDao;
import com.xyram.daydrop.dao.CustomerDetailsDao;
import com.xyram.daydrop.dao.CustomerOrderDao;
import com.xyram.daydrop.dao.CustomerOrderReplicaDoa;
import com.xyram.daydrop.dao.SheduleDao;
import com.xyram.daydrop.enumtypes.UserStatus;
import com.xyram.daydrop.model.Apartments;
import com.xyram.daydrop.model.CustomerOrder;
import com.xyram.daydrop.model.CustomerOrderReplica;
import com.xyram.daydrop.model.Customers;
import com.xyram.daydrop.model.Schedule;
import com.xyram.daydrop.modelMapper.PaymentInstrument;
import com.xyram.daydrop.modelMapper.PhonePePayModel;
import com.xyram.daydrop.request.CustomerOrderReplicaRequest;
import com.xyram.daydrop.response.RazorPayRequest;
import com.xyram.daydrop.service.CustomerOrderPriceService;
import com.xyram.daydrop.service.CustomerOrderReplicaService;
import com.xyram.daydrop.util.HashEncoder;
import com.xyram.daydrop.util.RazorPay;
import com.xyram.daydrop.service.ConsumerService;

@Transactional
@Service
public class CustomerOrderReplicaServiceImpl implements CustomerOrderReplicaService {

	@Autowired
	CustomerOrderReplicaDoa customerOrderReplicaDoa;

	@Autowired
	ApartmentDao apartmentDao;

	@Autowired
	SheduleDao scheduleDao;

	@Autowired
	CustomerDetailsDao customerDetailsDao;

	@Autowired
	ConsumerService consumerService;

	@Autowired
	CurrentUser currentUser;

	@Autowired
	PhonepeServiceImpl phonepeServiceImpl;

	@Value("${merchant_id}")
	private String merchantId;

	@Value("${salt_key}")
	private String saltKey;

	@Value("${salt_index}")
	private String saltIndex;

	@Override
	public Map createCustomerOrderReplicaService(CustomerOrderReplicaRequest customerOrderReplicaRequest,
			String contactNumber, Integer aparmentId)

	{

		Map response = new HashedMap<>();

		response.put("message", "success");
		CustomerOrderReplica customerOrderReplica = null;

		if (customerOrderReplicaRequest.getCartId() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "cartId is mandatory ");
		}
		long razorPayCount = 0;
		if (customerOrderReplicaRequest.getOrderId() != null) {

			razorPayCount = customerOrderReplicaDoa.getRazorPayExistByCartId(customerOrderReplicaRequest.getOrderId());
		}

		if (customerOrderReplicaRequest.getCustomerDetails() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Order Details  is mandatory ");
		}

		customerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(customerOrderReplicaRequest.getCartId(),
				contactNumber);

		if (customerOrderReplica != null) {
			customerOrderReplica.setCartId(customerOrderReplica.getCartId());

			if (customerOrderReplica.isOrdered()) {
				throw new ResponseStatusException(HttpStatus.CONFLICT, "Your Order is Placed With cart Details");
			}

//			if (razorPayCount >= 1 && !(customerOrderReplica.getRazorPayOrderId() != null
//					&& customerOrderReplica.getRazorPayOrderId().equals(customerOrderReplicaRequest.getOrderId()))) {
//				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
//			}

			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);

			customerOrderReplica.setAttempts(customerOrderReplica.getAttempts() + 1);
			customerOrderReplica.setUpdatedTime(new Date());

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		} else {

			customerOrderReplica = new CustomerOrderReplica();
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);
			customerOrderReplica.setCartId(customerOrderReplicaRequest.getCartId());
			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());

			if (razorPayCount > 0) {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
			}

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			Schedule schedule = scheduleDao.getlatestScheduleCustomers();

			if (schedule != null) {

				try {
					customerOrderReplica.setSchedule(schedule.getsId() != null ? schedule.getsId().toString() : null);
				} catch (Exception e) {
					e.printStackTrace();
				}
			} else {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
						"Sorry We Are Not Accepting Any Order Right now");

			}

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		}

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicas(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String schedule = null;

		Map filter = request.containsKey("filters") ? (Map) request.get("filters") : null;
		if (filter != null) {
			statusType = filter.containsKey("statusType") ? ((String) filter.get("statusType")).toLowerCase() : null;
			searchQuery = filter.containsKey("searchQuery") ? ((String) filter.get("searchQuery")).toLowerCase() : null;
			schedule = filter.containsKey("schedule") ? (String.valueOf(filter.get("schedule"))) : null;

		}

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplica(searchQuery, statusType, schedule);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");

				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setStreetName(
						customers.get("streetName") != null ? (String) customers.get("streetName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicasBySchedule(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String scheduleId = null;

		Schedule schedule = scheduleDao.getlatestScheduleCustomers();

		if (schedule != null) {

			try {
				scheduleId = schedule.getsId() != null ? schedule.getsId().toString() : null;
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

		statusType = request.containsKey("statusType") ? ((String) request.get("statusType")).toLowerCase() : "Success";

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplicaBySchdeule(statusType, scheduleId);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");
				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				System.out.println("customers" + customers.get("customerName"));

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public CustomerOrderReplica getCustomerOrderReplicaByCartId(String cartId) {

		CustomerOrderReplica CustomerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(cartId,
				currentUser.getContactNumber());

		ObjectMapper objectMapper = new ObjectMapper();
		try {

			// convert JSON string to Map
			Map<String, Object> customerOrderReplicaMap = objectMapper
					.readValue(CustomerOrderReplica.getCustomerOrderDetails(), Map.class);

			Object customerOrder = customerOrderReplicaMap.get("customerOrder");
			Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

			Object quanityList = items.get("quantity");
			Map customers = customerDetailsDao.getByContactNumberAndApartment(CustomerOrderReplica.getContactNumber(),
					CustomerOrderReplica.getApartmentId());

			System.out.println("customers" + customers.get("customerName"));

			// Apartments apartments =
			// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
			CustomerOrderReplica.setApartmentName(
					customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

			CustomerOrderReplica.setCustomerDetails(customers);

			CustomerOrderReplica.setCustomerOrder(customerOrder);
			CustomerOrderReplica.setQuatityList(quanityList);

		} catch (Exception e) {
			e.printStackTrace();
		}

		return CustomerOrderReplica;

	}

	@Override
	public Map createCustomerOrderReplica(CustomerOrderReplicaRequest customerOrderReplicaRequest, String contactNumber,
			Integer aparmentId) {

		if (customerOrderReplicaRequest.getRazorPayRequest() != null) {

//			Map razorPay = consumerService.createRazorPayOrder(customerOrderReplicaRequest.getRazorPayRequest());
//			customerOrderReplicaRequest.setOrderId(razorPay.get("order") != null ? (String)((RazorPay) razorPay.get("order")).getId() : null);	
//	
//			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);
//
//			razorPay.put("cartId", customerOrderReplicaRequest.getCartId());

			Map customerOrderReplicaMap = new HashMap<>();

			Map orderId = new HashMap<>();
			String transactionId = getMerchantTransactionId();
			orderId.put("id", transactionId);

			customerOrderReplicaMap.put("order", orderId);

			customerOrderReplicaRequest.setOrderId(transactionId);
			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);

			customerOrderReplicaMap.put("cartId", customerOrderReplicaRequest.getCartId());

			try {
				customerOrderReplicaMap.put("phonePeResponse",
						phonepeServiceImpl.initiatePhonepePayment(transactionId,
								Integer.valueOf(customerOrderReplicaRequest.getRazorPayRequest().getAmount()),
								contactNumber, customerOrderReplicaRequest.getRedirectUrl(), customerOrderReplicaRequest.getCallBackUrl()));

			} catch (Exception e) {
				e.printStackTrace();
				customerOrderReplicaMap.put("phonePeResponse", new HashedMap<>());
			}

			return customerOrderReplicaMap;

		} else {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
					"paymentDetails transcation Details are mandatory");
		}

	}

	private static String getMerchantTransactionId() {

		return "OD_" + MerchantTransactionIdGenerator.getRandomString();
	}


	@Override
	public List<CustomerOrderReplica> getCustomerOrderByMoblieNo(String contactNumber, Integer aid) {

	    Schedule latestSchedule = customerOrderReplicaDoa.getlatestschedule();

	    if (latestSchedule != null && latestSchedule.getCreationTimestamp() != null) {
	        if (latestSchedule.getStatus().equals(UserStatus.ACTIVE)) {
	            Customers customer = customerDetailsDao.getByContactNoAndApartment(contactNumber, aid);

	            if (customer != null) { // Ensure the customer exists
	                List<CustomerOrder> customerOrderList = customerOrderReplicaDoa.getListCustomerOrderByCustomerId(customer.getCtId());

	                double totalOrderAmount = 0.0;

	                if (customerOrderList != null && !customerOrderList.isEmpty()) {
	                    for (CustomerOrder customerOrder : customerOrderList) {
	                        Double orderAmount = customerOrder.getAmount();
	                        if (orderAmount != null) {
	                            totalOrderAmount += orderAmount;
	                            if(totalOrderAmount>200) {
	                            	totalOrderAmount+= customerOrder.getDelivaryCharges();
	                            }
	                            else(totalOrderAmount<200){
	                        }
	                    }

	                    // Define the minimum order amount for applying delivery charges
	                    double minimumOrderAmount = 200.0;

	                    if (totalOrderAmount < minimumOrderAmount) {
	                        System.out.println("Delivery Charges will be applicable");
	                    } else {
	                        // No delivery charges applicable
	                        System.out.println("No Delivery charges applicable");
	                    }

	                    List<CustomerOrderReplica> customerOrderReplicas = new ArrayList<>();
	                    return customerOrderReplicas;
	                } else {
	                    return Collections.emptyList();
	                }
	            } else {
	                return null; // or an appropriate value
	            }
	        } else {
	            // Handle the case when the latest schedule is not active
	            return null; // or an appropriate value
	        }
	    } else {
	        // Handle the case when there is no latest schedule or its creation timestamp is null
	        return null; // or an appropriate value
	    }
	}

}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-09-21 15:33:34.799
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-09-21 15:33:34.801
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-21 15:33:34.882
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.xyram.daydrop.serviceimpl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.transaction.Transactional;

import org.apache.commons.collections4.map.HashedMap;
import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.server.ResponseStatusException;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.xyram.daydrop.admin.model.CurrentUser;
import com.xyram.daydrop.basemodel.Base64Wrapper;
import com.xyram.daydrop.basemodel.MerchantTransactionIdGenerator;
import com.xyram.daydrop.basemodel.PhonepeSerializer;
import com.xyram.daydrop.dao.ApartmentDao;
import com.xyram.daydrop.dao.CustomerDetailsDao;
import com.xyram.daydrop.dao.CustomerOrderDao;
import com.xyram.daydrop.dao.CustomerOrderReplicaDoa;
import com.xyram.daydrop.dao.SheduleDao;
import com.xyram.daydrop.enumtypes.UserStatus;
import com.xyram.daydrop.model.Apartments;
import com.xyram.daydrop.model.CustomerOrder;
import com.xyram.daydrop.model.CustomerOrderReplica;
import com.xyram.daydrop.model.Customers;
import com.xyram.daydrop.model.Schedule;
import com.xyram.daydrop.modelMapper.PaymentInstrument;
import com.xyram.daydrop.modelMapper.PhonePePayModel;
import com.xyram.daydrop.request.CustomerOrderReplicaRequest;
import com.xyram.daydrop.response.RazorPayRequest;
import com.xyram.daydrop.service.CustomerOrderPriceService;
import com.xyram.daydrop.service.CustomerOrderReplicaService;
import com.xyram.daydrop.util.HashEncoder;
import com.xyram.daydrop.util.RazorPay;
import com.xyram.daydrop.service.ConsumerService;

@Transactional
@Service
public class CustomerOrderReplicaServiceImpl implements CustomerOrderReplicaService {

	@Autowired
	CustomerOrderReplicaDoa customerOrderReplicaDoa;

	@Autowired
	ApartmentDao apartmentDao;

	@Autowired
	SheduleDao scheduleDao;

	@Autowired
	CustomerDetailsDao customerDetailsDao;

	@Autowired
	ConsumerService consumerService;

	@Autowired
	CurrentUser currentUser;

	@Autowired
	PhonepeServiceImpl phonepeServiceImpl;

	@Value("${merchant_id}")
	private String merchantId;

	@Value("${salt_key}")
	private String saltKey;

	@Value("${salt_index}")
	private String saltIndex;

	@Override
	public Map createCustomerOrderReplicaService(CustomerOrderReplicaRequest customerOrderReplicaRequest,
			String contactNumber, Integer aparmentId)

	{

		Map response = new HashedMap<>();

		response.put("message", "success");
		CustomerOrderReplica customerOrderReplica = null;

		if (customerOrderReplicaRequest.getCartId() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "cartId is mandatory ");
		}
		long razorPayCount = 0;
		if (customerOrderReplicaRequest.getOrderId() != null) {

			razorPayCount = customerOrderReplicaDoa.getRazorPayExistByCartId(customerOrderReplicaRequest.getOrderId());
		}

		if (customerOrderReplicaRequest.getCustomerDetails() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Order Details  is mandatory ");
		}

		customerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(customerOrderReplicaRequest.getCartId(),
				contactNumber);

		if (customerOrderReplica != null) {
			customerOrderReplica.setCartId(customerOrderReplica.getCartId());

			if (customerOrderReplica.isOrdered()) {
				throw new ResponseStatusException(HttpStatus.CONFLICT, "Your Order is Placed With cart Details");
			}

//			if (razorPayCount >= 1 && !(customerOrderReplica.getRazorPayOrderId() != null
//					&& customerOrderReplica.getRazorPayOrderId().equals(customerOrderReplicaRequest.getOrderId()))) {
//				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
//			}

			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);

			customerOrderReplica.setAttempts(customerOrderReplica.getAttempts() + 1);
			customerOrderReplica.setUpdatedTime(new Date());

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		} else {

			customerOrderReplica = new CustomerOrderReplica();
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);
			customerOrderReplica.setCartId(customerOrderReplicaRequest.getCartId());
			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());

			if (razorPayCount > 0) {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
			}

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			Schedule schedule = scheduleDao.getlatestScheduleCustomers();

			if (schedule != null) {

				try {
					customerOrderReplica.setSchedule(schedule.getsId() != null ? schedule.getsId().toString() : null);
				} catch (Exception e) {
					e.printStackTrace();
				}
			} else {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
						"Sorry We Are Not Accepting Any Order Right now");

			}

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		}

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicas(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String schedule = null;

		Map filter = request.containsKey("filters") ? (Map) request.get("filters") : null;
		if (filter != null) {
			statusType = filter.containsKey("statusType") ? ((String) filter.get("statusType")).toLowerCase() : null;
			searchQuery = filter.containsKey("searchQuery") ? ((String) filter.get("searchQuery")).toLowerCase() : null;
			schedule = filter.containsKey("schedule") ? (String.valueOf(filter.get("schedule"))) : null;

		}

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplica(searchQuery, statusType, schedule);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");

				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setStreetName(
						customers.get("streetName") != null ? (String) customers.get("streetName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicasBySchedule(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String scheduleId = null;

		Schedule schedule = scheduleDao.getlatestScheduleCustomers();

		if (schedule != null) {

			try {
				scheduleId = schedule.getsId() != null ? schedule.getsId().toString() : null;
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

		statusType = request.containsKey("statusType") ? ((String) request.get("statusType")).toLowerCase() : "Success";

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplicaBySchdeule(statusType, scheduleId);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");
				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				System.out.println("customers" + customers.get("customerName"));

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public CustomerOrderReplica getCustomerOrderReplicaByCartId(String cartId) {

		CustomerOrderReplica CustomerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(cartId,
				currentUser.getContactNumber());

		ObjectMapper objectMapper = new ObjectMapper();
		try {

			// convert JSON string to Map
			Map<String, Object> customerOrderReplicaMap = objectMapper
					.readValue(CustomerOrderReplica.getCustomerOrderDetails(), Map.class);

			Object customerOrder = customerOrderReplicaMap.get("customerOrder");
			Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

			Object quanityList = items.get("quantity");
			Map customers = customerDetailsDao.getByContactNumberAndApartment(CustomerOrderReplica.getContactNumber(),
					CustomerOrderReplica.getApartmentId());

			System.out.println("customers" + customers.get("customerName"));

			// Apartments apartments =
			// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
			CustomerOrderReplica.setApartmentName(
					customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

			CustomerOrderReplica.setCustomerDetails(customers);

			CustomerOrderReplica.setCustomerOrder(customerOrder);
			CustomerOrderReplica.setQuatityList(quanityList);

		} catch (Exception e) {
			e.printStackTrace();
		}

		return CustomerOrderReplica;

	}

	@Override
	public Map createCustomerOrderReplica(CustomerOrderReplicaRequest customerOrderReplicaRequest, String contactNumber,
			Integer aparmentId) {

		if (customerOrderReplicaRequest.getRazorPayRequest() != null) {

//			Map razorPay = consumerService.createRazorPayOrder(customerOrderReplicaRequest.getRazorPayRequest());
//			customerOrderReplicaRequest.setOrderId(razorPay.get("order") != null ? (String)((RazorPay) razorPay.get("order")).getId() : null);	
//	
//			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);
//
//			razorPay.put("cartId", customerOrderReplicaRequest.getCartId());

			Map customerOrderReplicaMap = new HashMap<>();

			Map orderId = new HashMap<>();
			String transactionId = getMerchantTransactionId();
			orderId.put("id", transactionId);

			customerOrderReplicaMap.put("order", orderId);

			customerOrderReplicaRequest.setOrderId(transactionId);
			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);

			customerOrderReplicaMap.put("cartId", customerOrderReplicaRequest.getCartId());

			try {
				customerOrderReplicaMap.put("phonePeResponse",
						phonepeServiceImpl.initiatePhonepePayment(transactionId,
								Integer.valueOf(customerOrderReplicaRequest.getRazorPayRequest().getAmount()),
								contactNumber, customerOrderReplicaRequest.getRedirectUrl(), customerOrderReplicaRequest.getCallBackUrl()));

			} catch (Exception e) {
				e.printStackTrace();
				customerOrderReplicaMap.put("phonePeResponse", new HashedMap<>());
			}

			return customerOrderReplicaMap;

		} else {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
					"paymentDetails transcation Details are mandatory");
		}

	}

	private static String getMerchantTransactionId() {

		return "OD_" + MerchantTransactionIdGenerator.getRandomString();
	}


	@Override
	public List<CustomerOrderReplica> getCustomerOrderByMoblieNo(String contactNumber, Integer aid) {

	    Schedule latestSchedule = customerOrderReplicaDoa.getlatestschedule();

	    if (latestSchedule != null && latestSchedule.getCreationTimestamp() != null) {
	        if (latestSchedule.getStatus().equals(UserStatus.ACTIVE)) {
	            Customers customer = customerDetailsDao.getByContactNoAndApartment(contactNumber, aid);

	            if (customer != null) { // Ensure the customer exists
	                List<CustomerOrder> customerOrderList = customerOrderReplicaDoa.getListCustomerOrderByCustomerId(customer.getCtId());

	                double totalOrderAmount = 0.0;

	                if (customerOrderList != null && !customerOrderList.isEmpty()) {
	                    for (CustomerOrder customerOrder : customerOrderList) {
	                        Double orderAmount = customerOrder.getAmount();
	                        if (orderAmount != null) {
	                            totalOrderAmount += orderAmount;
	                            if(totalOrderAmount>200) {
	                            	totalOrderAmount+= customerOrder.getDelivaryCharges();
	                            }
	                            else(totalOrderAmount<200){
	                        }
	                    }

	                    // Define the minimum order amount for applying delivery charges
	                    double minimumOrderAmount = 200.0;

	                    if (totalOrderAmount < minimumOrderAmount) {
	                        System.out.println("Delivery Charges will be applicable");
	                    } else {
	                        // No delivery charges applicable
	                        System.out.println("No Delivery charges applicable");
	                    }

	                    List<CustomerOrderReplica> customerOrderReplicas = new ArrayList<>();
	                    return customerOrderReplicas;
	                } else {
	                    return Collections.emptyList();
	                }
	            } else {
	                return null; // or an appropriate value
	            }
	        } else {
	            // Handle the case when the latest schedule is not active
	            return null; // or an appropriate value
	        }
	    } else {
	        // Handle the case when there is no latest schedule or its creation timestamp is null
	        return null; // or an appropriate value
	    }
	}

}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-09-21 15:33:34.885
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-09-21 15:33:34.886
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-21 15:33:35.422
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.xyram.daydrop.serviceimpl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.transaction.Transactional;

import org.apache.commons.collections4.map.HashedMap;
import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.server.ResponseStatusException;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.xyram.daydrop.admin.model.CurrentUser;
import com.xyram.daydrop.basemodel.Base64Wrapper;
import com.xyram.daydrop.basemodel.MerchantTransactionIdGenerator;
import com.xyram.daydrop.basemodel.PhonepeSerializer;
import com.xyram.daydrop.dao.ApartmentDao;
import com.xyram.daydrop.dao.CustomerDetailsDao;
import com.xyram.daydrop.dao.CustomerOrderDao;
import com.xyram.daydrop.dao.CustomerOrderReplicaDoa;
import com.xyram.daydrop.dao.SheduleDao;
import com.xyram.daydrop.enumtypes.UserStatus;
import com.xyram.daydrop.model.Apartments;
import com.xyram.daydrop.model.CustomerOrder;
import com.xyram.daydrop.model.CustomerOrderReplica;
import com.xyram.daydrop.model.Customers;
import com.xyram.daydrop.model.Schedule;
import com.xyram.daydrop.modelMapper.PaymentInstrument;
import com.xyram.daydrop.modelMapper.PhonePePayModel;
import com.xyram.daydrop.request.CustomerOrderReplicaRequest;
import com.xyram.daydrop.response.RazorPayRequest;
import com.xyram.daydrop.service.CustomerOrderPriceService;
import com.xyram.daydrop.service.CustomerOrderReplicaService;
import com.xyram.daydrop.util.HashEncoder;
import com.xyram.daydrop.util.RazorPay;
import com.xyram.daydrop.service.ConsumerService;

@Transactional
@Service
public class CustomerOrderReplicaServiceImpl implements CustomerOrderReplicaService {

	@Autowired
	CustomerOrderReplicaDoa customerOrderReplicaDoa;

	@Autowired
	ApartmentDao apartmentDao;

	@Autowired
	SheduleDao scheduleDao;

	@Autowired
	CustomerDetailsDao customerDetailsDao;

	@Autowired
	ConsumerService consumerService;

	@Autowired
	CurrentUser currentUser;

	@Autowired
	PhonepeServiceImpl phonepeServiceImpl;

	@Value("${merchant_id}")
	private String merchantId;

	@Value("${salt_key}")
	private String saltKey;

	@Value("${salt_index}")
	private String saltIndex;

	@Override
	public Map createCustomerOrderReplicaService(CustomerOrderReplicaRequest customerOrderReplicaRequest,
			String contactNumber, Integer aparmentId)

	{

		Map response = new HashedMap<>();

		response.put("message", "success");
		CustomerOrderReplica customerOrderReplica = null;

		if (customerOrderReplicaRequest.getCartId() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "cartId is mandatory ");
		}
		long razorPayCount = 0;
		if (customerOrderReplicaRequest.getOrderId() != null) {

			razorPayCount = customerOrderReplicaDoa.getRazorPayExistByCartId(customerOrderReplicaRequest.getOrderId());
		}

		if (customerOrderReplicaRequest.getCustomerDetails() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Order Details  is mandatory ");
		}

		customerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(customerOrderReplicaRequest.getCartId(),
				contactNumber);

		if (customerOrderReplica != null) {
			customerOrderReplica.setCartId(customerOrderReplica.getCartId());

			if (customerOrderReplica.isOrdered()) {
				throw new ResponseStatusException(HttpStatus.CONFLICT, "Your Order is Placed With cart Details");
			}

//			if (razorPayCount >= 1 && !(customerOrderReplica.getRazorPayOrderId() != null
//					&& customerOrderReplica.getRazorPayOrderId().equals(customerOrderReplicaRequest.getOrderId()))) {
//				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
//			}

			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);

			customerOrderReplica.setAttempts(customerOrderReplica.getAttempts() + 1);
			customerOrderReplica.setUpdatedTime(new Date());

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		} else {

			customerOrderReplica = new CustomerOrderReplica();
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);
			customerOrderReplica.setCartId(customerOrderReplicaRequest.getCartId());
			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());

			if (razorPayCount > 0) {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
			}

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			Schedule schedule = scheduleDao.getlatestScheduleCustomers();

			if (schedule != null) {

				try {
					customerOrderReplica.setSchedule(schedule.getsId() != null ? schedule.getsId().toString() : null);
				} catch (Exception e) {
					e.printStackTrace();
				}
			} else {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
						"Sorry We Are Not Accepting Any Order Right now");

			}

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		}

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicas(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String schedule = null;

		Map filter = request.containsKey("filters") ? (Map) request.get("filters") : null;
		if (filter != null) {
			statusType = filter.containsKey("statusType") ? ((String) filter.get("statusType")).toLowerCase() : null;
			searchQuery = filter.containsKey("searchQuery") ? ((String) filter.get("searchQuery")).toLowerCase() : null;
			schedule = filter.containsKey("schedule") ? (String.valueOf(filter.get("schedule"))) : null;

		}

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplica(searchQuery, statusType, schedule);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");

				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setStreetName(
						customers.get("streetName") != null ? (String) customers.get("streetName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicasBySchedule(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String scheduleId = null;

		Schedule schedule = scheduleDao.getlatestScheduleCustomers();

		if (schedule != null) {

			try {
				scheduleId = schedule.getsId() != null ? schedule.getsId().toString() : null;
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

		statusType = request.containsKey("statusType") ? ((String) request.get("statusType")).toLowerCase() : "Success";

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplicaBySchdeule(statusType, scheduleId);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");
				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				System.out.println("customers" + customers.get("customerName"));

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public CustomerOrderReplica getCustomerOrderReplicaByCartId(String cartId) {

		CustomerOrderReplica CustomerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(cartId,
				currentUser.getContactNumber());

		ObjectMapper objectMapper = new ObjectMapper();
		try {

			// convert JSON string to Map
			Map<String, Object> customerOrderReplicaMap = objectMapper
					.readValue(CustomerOrderReplica.getCustomerOrderDetails(), Map.class);

			Object customerOrder = customerOrderReplicaMap.get("customerOrder");
			Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

			Object quanityList = items.get("quantity");
			Map customers = customerDetailsDao.getByContactNumberAndApartment(CustomerOrderReplica.getContactNumber(),
					CustomerOrderReplica.getApartmentId());

			System.out.println("customers" + customers.get("customerName"));

			// Apartments apartments =
			// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
			CustomerOrderReplica.setApartmentName(
					customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

			CustomerOrderReplica.setCustomerDetails(customers);

			CustomerOrderReplica.setCustomerOrder(customerOrder);
			CustomerOrderReplica.setQuatityList(quanityList);

		} catch (Exception e) {
			e.printStackTrace();
		}

		return CustomerOrderReplica;

	}

	@Override
	public Map createCustomerOrderReplica(CustomerOrderReplicaRequest customerOrderReplicaRequest, String contactNumber,
			Integer aparmentId) {

		if (customerOrderReplicaRequest.getRazorPayRequest() != null) {

//			Map razorPay = consumerService.createRazorPayOrder(customerOrderReplicaRequest.getRazorPayRequest());
//			customerOrderReplicaRequest.setOrderId(razorPay.get("order") != null ? (String)((RazorPay) razorPay.get("order")).getId() : null);	
//	
//			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);
//
//			razorPay.put("cartId", customerOrderReplicaRequest.getCartId());

			Map customerOrderReplicaMap = new HashMap<>();

			Map orderId = new HashMap<>();
			String transactionId = getMerchantTransactionId();
			orderId.put("id", transactionId);

			customerOrderReplicaMap.put("order", orderId);

			customerOrderReplicaRequest.setOrderId(transactionId);
			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);

			customerOrderReplicaMap.put("cartId", customerOrderReplicaRequest.getCartId());

			try {
				customerOrderReplicaMap.put("phonePeResponse",
						phonepeServiceImpl.initiatePhonepePayment(transactionId,
								Integer.valueOf(customerOrderReplicaRequest.getRazorPayRequest().getAmount()),
								contactNumber, customerOrderReplicaRequest.getRedirectUrl(), customerOrderReplicaRequest.getCallBackUrl()));

			} catch (Exception e) {
				e.printStackTrace();
				customerOrderReplicaMap.put("phonePeResponse", new HashedMap<>());
			}

			return customerOrderReplicaMap;

		} else {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
					"paymentDetails transcation Details are mandatory");
		}

	}

	private static String getMerchantTransactionId() {

		return "OD_" + MerchantTransactionIdGenerator.getRandomString();
	}


	@Override
	public List<CustomerOrderReplica> getCustomerOrderByMoblieNo(String contactNumber, Integer aid) {

	    Schedule latestSchedule = customerOrderReplicaDoa.getlatestschedule();

	    if (latestSchedule != null && latestSchedule.getCreationTimestamp() != null) {
	        if (latestSchedule.getStatus().equals(UserStatus.ACTIVE)) {
	            Customers customer = customerDetailsDao.getByContactNoAndApartment(contactNumber, aid);

	            if (customer != null) { // Ensure the customer exists
	                List<CustomerOrder> customerOrderList = customerOrderReplicaDoa.getListCustomerOrderByCustomerId(customer.getCtId());

	                double totalOrderAmount = 0.0;

	                if (customerOrderList != null && !customerOrderList.isEmpty()) {
	                    for (CustomerOrder customerOrder : customerOrderList) {
	                        Double orderAmount = customerOrder.getAmount();
	                        if (orderAmount != null) {
	                            totalOrderAmount += orderAmount;
	                            if(totalOrderAmount>200) {
	                            	totalOrderAmount+= customerOrder.getDelivaryCharges();
	                            }
	                            else(totalOrderAmount<200){}
	                        }
	                    }

	                    // Define the minimum order amount for applying delivery charges
	                    double minimumOrderAmount = 200.0;

	                    if (totalOrderAmount < minimumOrderAmount) {
	                        System.out.println("Delivery Charges will be applicable");
	                    } else {
	                        // No delivery charges applicable
	                        System.out.println("No Delivery charges applicable");
	                    }

	                    List<CustomerOrderReplica> customerOrderReplicas = new ArrayList<>();
	                    return customerOrderReplicas;
	                } else {
	                    return Collections.emptyList();
	                }
	            } else {
	                return null; // or an appropriate value
	            }
	        } else {
	            // Handle the case when the latest schedule is not active
	            return null; // or an appropriate value
	        }
	    } else {
	        // Handle the case when there is no latest schedule or its creation timestamp is null
	        return null; // or an appropriate value
	    }
	}

}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-09-21 15:33:35.425
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-09-21 15:33:35.427
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-21 15:33:36.016
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.xyram.daydrop.serviceimpl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.transaction.Transactional;

import org.apache.commons.collections4.map.HashedMap;
import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.server.ResponseStatusException;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.xyram.daydrop.admin.model.CurrentUser;
import com.xyram.daydrop.basemodel.Base64Wrapper;
import com.xyram.daydrop.basemodel.MerchantTransactionIdGenerator;
import com.xyram.daydrop.basemodel.PhonepeSerializer;
import com.xyram.daydrop.dao.ApartmentDao;
import com.xyram.daydrop.dao.CustomerDetailsDao;
import com.xyram.daydrop.dao.CustomerOrderDao;
import com.xyram.daydrop.dao.CustomerOrderReplicaDoa;
import com.xyram.daydrop.dao.SheduleDao;
import com.xyram.daydrop.enumtypes.UserStatus;
import com.xyram.daydrop.model.Apartments;
import com.xyram.daydrop.model.CustomerOrder;
import com.xyram.daydrop.model.CustomerOrderReplica;
import com.xyram.daydrop.model.Customers;
import com.xyram.daydrop.model.Schedule;
import com.xyram.daydrop.modelMapper.PaymentInstrument;
import com.xyram.daydrop.modelMapper.PhonePePayModel;
import com.xyram.daydrop.request.CustomerOrderReplicaRequest;
import com.xyram.daydrop.response.RazorPayRequest;
import com.xyram.daydrop.service.CustomerOrderPriceService;
import com.xyram.daydrop.service.CustomerOrderReplicaService;
import com.xyram.daydrop.util.HashEncoder;
import com.xyram.daydrop.util.RazorPay;
import com.xyram.daydrop.service.ConsumerService;

@Transactional
@Service
public class CustomerOrderReplicaServiceImpl implements CustomerOrderReplicaService {

	@Autowired
	CustomerOrderReplicaDoa customerOrderReplicaDoa;

	@Autowired
	ApartmentDao apartmentDao;

	@Autowired
	SheduleDao scheduleDao;

	@Autowired
	CustomerDetailsDao customerDetailsDao;

	@Autowired
	ConsumerService consumerService;

	@Autowired
	CurrentUser currentUser;

	@Autowired
	PhonepeServiceImpl phonepeServiceImpl;

	@Value("${merchant_id}")
	private String merchantId;

	@Value("${salt_key}")
	private String saltKey;

	@Value("${salt_index}")
	private String saltIndex;

	@Override
	public Map createCustomerOrderReplicaService(CustomerOrderReplicaRequest customerOrderReplicaRequest,
			String contactNumber, Integer aparmentId)

	{

		Map response = new HashedMap<>();

		response.put("message", "success");
		CustomerOrderReplica customerOrderReplica = null;

		if (customerOrderReplicaRequest.getCartId() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "cartId is mandatory ");
		}
		long razorPayCount = 0;
		if (customerOrderReplicaRequest.getOrderId() != null) {

			razorPayCount = customerOrderReplicaDoa.getRazorPayExistByCartId(customerOrderReplicaRequest.getOrderId());
		}

		if (customerOrderReplicaRequest.getCustomerDetails() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Order Details  is mandatory ");
		}

		customerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(customerOrderReplicaRequest.getCartId(),
				contactNumber);

		if (customerOrderReplica != null) {
			customerOrderReplica.setCartId(customerOrderReplica.getCartId());

			if (customerOrderReplica.isOrdered()) {
				throw new ResponseStatusException(HttpStatus.CONFLICT, "Your Order is Placed With cart Details");
			}

//			if (razorPayCount >= 1 && !(customerOrderReplica.getRazorPayOrderId() != null
//					&& customerOrderReplica.getRazorPayOrderId().equals(customerOrderReplicaRequest.getOrderId()))) {
//				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
//			}

			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);

			customerOrderReplica.setAttempts(customerOrderReplica.getAttempts() + 1);
			customerOrderReplica.setUpdatedTime(new Date());

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		} else {

			customerOrderReplica = new CustomerOrderReplica();
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);
			customerOrderReplica.setCartId(customerOrderReplicaRequest.getCartId());
			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());

			if (razorPayCount > 0) {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
			}

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			Schedule schedule = scheduleDao.getlatestScheduleCustomers();

			if (schedule != null) {

				try {
					customerOrderReplica.setSchedule(schedule.getsId() != null ? schedule.getsId().toString() : null);
				} catch (Exception e) {
					e.printStackTrace();
				}
			} else {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
						"Sorry We Are Not Accepting Any Order Right now");

			}

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		}

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicas(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String schedule = null;

		Map filter = request.containsKey("filters") ? (Map) request.get("filters") : null;
		if (filter != null) {
			statusType = filter.containsKey("statusType") ? ((String) filter.get("statusType")).toLowerCase() : null;
			searchQuery = filter.containsKey("searchQuery") ? ((String) filter.get("searchQuery")).toLowerCase() : null;
			schedule = filter.containsKey("schedule") ? (String.valueOf(filter.get("schedule"))) : null;

		}

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplica(searchQuery, statusType, schedule);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");

				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setStreetName(
						customers.get("streetName") != null ? (String) customers.get("streetName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicasBySchedule(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String scheduleId = null;

		Schedule schedule = scheduleDao.getlatestScheduleCustomers();

		if (schedule != null) {

			try {
				scheduleId = schedule.getsId() != null ? schedule.getsId().toString() : null;
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

		statusType = request.containsKey("statusType") ? ((String) request.get("statusType")).toLowerCase() : "Success";

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplicaBySchdeule(statusType, scheduleId);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");
				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				System.out.println("customers" + customers.get("customerName"));

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public CustomerOrderReplica getCustomerOrderReplicaByCartId(String cartId) {

		CustomerOrderReplica CustomerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(cartId,
				currentUser.getContactNumber());

		ObjectMapper objectMapper = new ObjectMapper();
		try {

			// convert JSON string to Map
			Map<String, Object> customerOrderReplicaMap = objectMapper
					.readValue(CustomerOrderReplica.getCustomerOrderDetails(), Map.class);

			Object customerOrder = customerOrderReplicaMap.get("customerOrder");
			Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

			Object quanityList = items.get("quantity");
			Map customers = customerDetailsDao.getByContactNumberAndApartment(CustomerOrderReplica.getContactNumber(),
					CustomerOrderReplica.getApartmentId());

			System.out.println("customers" + customers.get("customerName"));

			// Apartments apartments =
			// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
			CustomerOrderReplica.setApartmentName(
					customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

			CustomerOrderReplica.setCustomerDetails(customers);

			CustomerOrderReplica.setCustomerOrder(customerOrder);
			CustomerOrderReplica.setQuatityList(quanityList);

		} catch (Exception e) {
			e.printStackTrace();
		}

		return CustomerOrderReplica;

	}

	@Override
	public Map createCustomerOrderReplica(CustomerOrderReplicaRequest customerOrderReplicaRequest, String contactNumber,
			Integer aparmentId) {

		if (customerOrderReplicaRequest.getRazorPayRequest() != null) {

//			Map razorPay = consumerService.createRazorPayOrder(customerOrderReplicaRequest.getRazorPayRequest());
//			customerOrderReplicaRequest.setOrderId(razorPay.get("order") != null ? (String)((RazorPay) razorPay.get("order")).getId() : null);	
//	
//			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);
//
//			razorPay.put("cartId", customerOrderReplicaRequest.getCartId());

			Map customerOrderReplicaMap = new HashMap<>();

			Map orderId = new HashMap<>();
			String transactionId = getMerchantTransactionId();
			orderId.put("id", transactionId);

			customerOrderReplicaMap.put("order", orderId);

			customerOrderReplicaRequest.setOrderId(transactionId);
			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);

			customerOrderReplicaMap.put("cartId", customerOrderReplicaRequest.getCartId());

			try {
				customerOrderReplicaMap.put("phonePeResponse",
						phonepeServiceImpl.initiatePhonepePayment(transactionId,
								Integer.valueOf(customerOrderReplicaRequest.getRazorPayRequest().getAmount()),
								contactNumber, customerOrderReplicaRequest.getRedirectUrl(), customerOrderReplicaRequest.getCallBackUrl()));

			} catch (Exception e) {
				e.printStackTrace();
				customerOrderReplicaMap.put("phonePeResponse", new HashedMap<>());
			}

			return customerOrderReplicaMap;

		} else {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
					"paymentDetails transcation Details are mandatory");
		}

	}

	private static String getMerchantTransactionId() {

		return "OD_" + MerchantTransactionIdGenerator.getRandomString();
	}


	@Override
	public List<CustomerOrderReplica> getCustomerOrderByMoblieNo(String contactNumber, Integer aid) {

	    Schedule latestSchedule = customerOrderReplicaDoa.getlatestschedule();

	    if (latestSchedule != null && latestSchedule.getCreationTimestamp() != null) {
	        if (latestSchedule.getStatus().equals(UserStatus.ACTIVE)) {
	            Customers customer = customerDetailsDao.getByContactNoAndApartment(contactNumber, aid);

	            if (customer != null) { // Ensure the customer exists
	                List<CustomerOrder> customerOrderList = customerOrderReplicaDoa.getListCustomerOrderByCustomerId(customer.getCtId());

	                double totalOrderAmount = 0.0;

	                if (customerOrderList != null && !customerOrderList.isEmpty()) {
	                    for (CustomerOrder customerOrder : customerOrderList) {
	                        Double orderAmount = customerOrder.getAmount();
	                        if (orderAmount != null) {
	                            totalOrderAmount += orderAmount;
	                            if(totalOrderAmount>200) {
	                            	totalOrderAmount+= customerOrder.getDelivaryCharges();
	                            }
	                            else(totalOrderAmount<200){
	                            	
	                            }
	                        }
	                    }

	                    // Define the minimum order amount for applying delivery charges
	                    double minimumOrderAmount = 200.0;

	                    if (totalOrderAmount < minimumOrderAmount) {
	                        System.out.println("Delivery Charges will be applicable");
	                    } else {
	                        // No delivery charges applicable
	                        System.out.println("No Delivery charges applicable");
	                    }

	                    List<CustomerOrderReplica> customerOrderReplicas = new ArrayList<>();
	                    return customerOrderReplicas;
	                } else {
	                    return Collections.emptyList();
	                }
	            } else {
	                return null; // or an appropriate value
	            }
	        } else {
	            // Handle the case when the latest schedule is not active
	            return null; // or an appropriate value
	        }
	    } else {
	        // Handle the case when there is no latest schedule or its creation timestamp is null
	        return null; // or an appropriate value
	    }
	}

}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-09-21 15:33:36.018
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-09-21 15:33:36.020
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-21 15:33:36.112
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.xyram.daydrop.serviceimpl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.transaction.Transactional;

import org.apache.commons.collections4.map.HashedMap;
import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.server.ResponseStatusException;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.xyram.daydrop.admin.model.CurrentUser;
import com.xyram.daydrop.basemodel.Base64Wrapper;
import com.xyram.daydrop.basemodel.MerchantTransactionIdGenerator;
import com.xyram.daydrop.basemodel.PhonepeSerializer;
import com.xyram.daydrop.dao.ApartmentDao;
import com.xyram.daydrop.dao.CustomerDetailsDao;
import com.xyram.daydrop.dao.CustomerOrderDao;
import com.xyram.daydrop.dao.CustomerOrderReplicaDoa;
import com.xyram.daydrop.dao.SheduleDao;
import com.xyram.daydrop.enumtypes.UserStatus;
import com.xyram.daydrop.model.Apartments;
import com.xyram.daydrop.model.CustomerOrder;
import com.xyram.daydrop.model.CustomerOrderReplica;
import com.xyram.daydrop.model.Customers;
import com.xyram.daydrop.model.Schedule;
import com.xyram.daydrop.modelMapper.PaymentInstrument;
import com.xyram.daydrop.modelMapper.PhonePePayModel;
import com.xyram.daydrop.request.CustomerOrderReplicaRequest;
import com.xyram.daydrop.response.RazorPayRequest;
import com.xyram.daydrop.service.CustomerOrderPriceService;
import com.xyram.daydrop.service.CustomerOrderReplicaService;
import com.xyram.daydrop.util.HashEncoder;
import com.xyram.daydrop.util.RazorPay;
import com.xyram.daydrop.service.ConsumerService;

@Transactional
@Service
public class CustomerOrderReplicaServiceImpl implements CustomerOrderReplicaService {

	@Autowired
	CustomerOrderReplicaDoa customerOrderReplicaDoa;

	@Autowired
	ApartmentDao apartmentDao;

	@Autowired
	SheduleDao scheduleDao;

	@Autowired
	CustomerDetailsDao customerDetailsDao;

	@Autowired
	ConsumerService consumerService;

	@Autowired
	CurrentUser currentUser;

	@Autowired
	PhonepeServiceImpl phonepeServiceImpl;

	@Value("${merchant_id}")
	private String merchantId;

	@Value("${salt_key}")
	private String saltKey;

	@Value("${salt_index}")
	private String saltIndex;

	@Override
	public Map createCustomerOrderReplicaService(CustomerOrderReplicaRequest customerOrderReplicaRequest,
			String contactNumber, Integer aparmentId)

	{

		Map response = new HashedMap<>();

		response.put("message", "success");
		CustomerOrderReplica customerOrderReplica = null;

		if (customerOrderReplicaRequest.getCartId() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "cartId is mandatory ");
		}
		long razorPayCount = 0;
		if (customerOrderReplicaRequest.getOrderId() != null) {

			razorPayCount = customerOrderReplicaDoa.getRazorPayExistByCartId(customerOrderReplicaRequest.getOrderId());
		}

		if (customerOrderReplicaRequest.getCustomerDetails() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Order Details  is mandatory ");
		}

		customerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(customerOrderReplicaRequest.getCartId(),
				contactNumber);

		if (customerOrderReplica != null) {
			customerOrderReplica.setCartId(customerOrderReplica.getCartId());

			if (customerOrderReplica.isOrdered()) {
				throw new ResponseStatusException(HttpStatus.CONFLICT, "Your Order is Placed With cart Details");
			}

//			if (razorPayCount >= 1 && !(customerOrderReplica.getRazorPayOrderId() != null
//					&& customerOrderReplica.getRazorPayOrderId().equals(customerOrderReplicaRequest.getOrderId()))) {
//				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
//			}

			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);

			customerOrderReplica.setAttempts(customerOrderReplica.getAttempts() + 1);
			customerOrderReplica.setUpdatedTime(new Date());

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		} else {

			customerOrderReplica = new CustomerOrderReplica();
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);
			customerOrderReplica.setCartId(customerOrderReplicaRequest.getCartId());
			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());

			if (razorPayCount > 0) {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
			}

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			Schedule schedule = scheduleDao.getlatestScheduleCustomers();

			if (schedule != null) {

				try {
					customerOrderReplica.setSchedule(schedule.getsId() != null ? schedule.getsId().toString() : null);
				} catch (Exception e) {
					e.printStackTrace();
				}
			} else {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
						"Sorry We Are Not Accepting Any Order Right now");

			}

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		}

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicas(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String schedule = null;

		Map filter = request.containsKey("filters") ? (Map) request.get("filters") : null;
		if (filter != null) {
			statusType = filter.containsKey("statusType") ? ((String) filter.get("statusType")).toLowerCase() : null;
			searchQuery = filter.containsKey("searchQuery") ? ((String) filter.get("searchQuery")).toLowerCase() : null;
			schedule = filter.containsKey("schedule") ? (String.valueOf(filter.get("schedule"))) : null;

		}

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplica(searchQuery, statusType, schedule);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");

				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setStreetName(
						customers.get("streetName") != null ? (String) customers.get("streetName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicasBySchedule(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String scheduleId = null;

		Schedule schedule = scheduleDao.getlatestScheduleCustomers();

		if (schedule != null) {

			try {
				scheduleId = schedule.getsId() != null ? schedule.getsId().toString() : null;
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

		statusType = request.containsKey("statusType") ? ((String) request.get("statusType")).toLowerCase() : "Success";

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplicaBySchdeule(statusType, scheduleId);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");
				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				System.out.println("customers" + customers.get("customerName"));

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public CustomerOrderReplica getCustomerOrderReplicaByCartId(String cartId) {

		CustomerOrderReplica CustomerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(cartId,
				currentUser.getContactNumber());

		ObjectMapper objectMapper = new ObjectMapper();
		try {

			// convert JSON string to Map
			Map<String, Object> customerOrderReplicaMap = objectMapper
					.readValue(CustomerOrderReplica.getCustomerOrderDetails(), Map.class);

			Object customerOrder = customerOrderReplicaMap.get("customerOrder");
			Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

			Object quanityList = items.get("quantity");
			Map customers = customerDetailsDao.getByContactNumberAndApartment(CustomerOrderReplica.getContactNumber(),
					CustomerOrderReplica.getApartmentId());

			System.out.println("customers" + customers.get("customerName"));

			// Apartments apartments =
			// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
			CustomerOrderReplica.setApartmentName(
					customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

			CustomerOrderReplica.setCustomerDetails(customers);

			CustomerOrderReplica.setCustomerOrder(customerOrder);
			CustomerOrderReplica.setQuatityList(quanityList);

		} catch (Exception e) {
			e.printStackTrace();
		}

		return CustomerOrderReplica;

	}

	@Override
	public Map createCustomerOrderReplica(CustomerOrderReplicaRequest customerOrderReplicaRequest, String contactNumber,
			Integer aparmentId) {

		if (customerOrderReplicaRequest.getRazorPayRequest() != null) {

//			Map razorPay = consumerService.createRazorPayOrder(customerOrderReplicaRequest.getRazorPayRequest());
//			customerOrderReplicaRequest.setOrderId(razorPay.get("order") != null ? (String)((RazorPay) razorPay.get("order")).getId() : null);	
//	
//			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);
//
//			razorPay.put("cartId", customerOrderReplicaRequest.getCartId());

			Map customerOrderReplicaMap = new HashMap<>();

			Map orderId = new HashMap<>();
			String transactionId = getMerchantTransactionId();
			orderId.put("id", transactionId);

			customerOrderReplicaMap.put("order", orderId);

			customerOrderReplicaRequest.setOrderId(transactionId);
			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);

			customerOrderReplicaMap.put("cartId", customerOrderReplicaRequest.getCartId());

			try {
				customerOrderReplicaMap.put("phonePeResponse",
						phonepeServiceImpl.initiatePhonepePayment(transactionId,
								Integer.valueOf(customerOrderReplicaRequest.getRazorPayRequest().getAmount()),
								contactNumber, customerOrderReplicaRequest.getRedirectUrl(), customerOrderReplicaRequest.getCallBackUrl()));

			} catch (Exception e) {
				e.printStackTrace();
				customerOrderReplicaMap.put("phonePeResponse", new HashedMap<>());
			}

			return customerOrderReplicaMap;

		} else {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
					"paymentDetails transcation Details are mandatory");
		}

	}

	private static String getMerchantTransactionId() {

		return "OD_" + MerchantTransactionIdGenerator.getRandomString();
	}


	@Override
	public List<CustomerOrderReplica> getCustomerOrderByMoblieNo(String contactNumber, Integer aid) {

	    Schedule latestSchedule = customerOrderReplicaDoa.getlatestschedule();

	    if (latestSchedule != null && latestSchedule.getCreationTimestamp() != null) {
	        if (latestSchedule.getStatus().equals(UserStatus.ACTIVE)) {
	            Customers customer = customerDetailsDao.getByContactNoAndApartment(contactNumber, aid);

	            if (customer != null) { // Ensure the customer exists
	                List<CustomerOrder> customerOrderList = customerOrderReplicaDoa.getListCustomerOrderByCustomerId(customer.getCtId());

	                double totalOrderAmount = 0.0;

	                if (customerOrderList != null && !customerOrderList.isEmpty()) {
	                    for (CustomerOrder customerOrder : customerOrderList) {
	                        Double orderAmount = customerOrder.getAmount();
	                        if (orderAmount != null) {
	                            totalOrderAmount += orderAmount;
	                            if(totalOrderAmount>200) {
	                            	totalOrderAmount+= customerOrder.getDelivaryCharges();
	                            }
	                            else(totalOrderAmount<200){
	                            	
	                            }
	                        }
	                    }

	                    // Define the minimum order amount for applying delivery charges
	                    double minimumOrderAmount = 200.0;

	                    if (totalOrderAmount < minimumOrderAmount) {
	                        System.out.println("Delivery Charges will be applicable");
	                    } else {
	                        // No delivery charges applicable
	                        System.out.println("No Delivery charges applicable");
	                    }

	                    List<CustomerOrderReplica> customerOrderReplicas = new ArrayList<>();
	                    return customerOrderReplicas;
	                } else {
	                    return Collections.emptyList();
	                }
	            } else {
	                return null; // or an appropriate value
	            }
	        } else {
	            // Handle the case when the latest schedule is not active
	            return null; // or an appropriate value
	        }
	    } else {
	        // Handle the case when there is no latest schedule or its creation timestamp is null
	        return null; // or an appropriate value
	    }
	}

}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-09-21 15:33:36.114
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-09-21 15:33:36.117
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-21 15:33:37.290
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.xyram.daydrop.serviceimpl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.transaction.Transactional;

import org.apache.commons.collections4.map.HashedMap;
import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.server.ResponseStatusException;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.xyram.daydrop.admin.model.CurrentUser;
import com.xyram.daydrop.basemodel.Base64Wrapper;
import com.xyram.daydrop.basemodel.MerchantTransactionIdGenerator;
import com.xyram.daydrop.basemodel.PhonepeSerializer;
import com.xyram.daydrop.dao.ApartmentDao;
import com.xyram.daydrop.dao.CustomerDetailsDao;
import com.xyram.daydrop.dao.CustomerOrderDao;
import com.xyram.daydrop.dao.CustomerOrderReplicaDoa;
import com.xyram.daydrop.dao.SheduleDao;
import com.xyram.daydrop.enumtypes.UserStatus;
import com.xyram.daydrop.model.Apartments;
import com.xyram.daydrop.model.CustomerOrder;
import com.xyram.daydrop.model.CustomerOrderReplica;
import com.xyram.daydrop.model.Customers;
import com.xyram.daydrop.model.Schedule;
import com.xyram.daydrop.modelMapper.PaymentInstrument;
import com.xyram.daydrop.modelMapper.PhonePePayModel;
import com.xyram.daydrop.request.CustomerOrderReplicaRequest;
import com.xyram.daydrop.response.RazorPayRequest;
import com.xyram.daydrop.service.CustomerOrderPriceService;
import com.xyram.daydrop.service.CustomerOrderReplicaService;
import com.xyram.daydrop.util.HashEncoder;
import com.xyram.daydrop.util.RazorPay;
import com.xyram.daydrop.service.ConsumerService;

@Transactional
@Service
public class CustomerOrderReplicaServiceImpl implements CustomerOrderReplicaService {

	@Autowired
	CustomerOrderReplicaDoa customerOrderReplicaDoa;

	@Autowired
	ApartmentDao apartmentDao;

	@Autowired
	SheduleDao scheduleDao;

	@Autowired
	CustomerDetailsDao customerDetailsDao;

	@Autowired
	ConsumerService consumerService;

	@Autowired
	CurrentUser currentUser;

	@Autowired
	PhonepeServiceImpl phonepeServiceImpl;

	@Value("${merchant_id}")
	private String merchantId;

	@Value("${salt_key}")
	private String saltKey;

	@Value("${salt_index}")
	private String saltIndex;

	@Override
	public Map createCustomerOrderReplicaService(CustomerOrderReplicaRequest customerOrderReplicaRequest,
			String contactNumber, Integer aparmentId)

	{

		Map response = new HashedMap<>();

		response.put("message", "success");
		CustomerOrderReplica customerOrderReplica = null;

		if (customerOrderReplicaRequest.getCartId() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "cartId is mandatory ");
		}
		long razorPayCount = 0;
		if (customerOrderReplicaRequest.getOrderId() != null) {

			razorPayCount = customerOrderReplicaDoa.getRazorPayExistByCartId(customerOrderReplicaRequest.getOrderId());
		}

		if (customerOrderReplicaRequest.getCustomerDetails() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Order Details  is mandatory ");
		}

		customerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(customerOrderReplicaRequest.getCartId(),
				contactNumber);

		if (customerOrderReplica != null) {
			customerOrderReplica.setCartId(customerOrderReplica.getCartId());

			if (customerOrderReplica.isOrdered()) {
				throw new ResponseStatusException(HttpStatus.CONFLICT, "Your Order is Placed With cart Details");
			}

//			if (razorPayCount >= 1 && !(customerOrderReplica.getRazorPayOrderId() != null
//					&& customerOrderReplica.getRazorPayOrderId().equals(customerOrderReplicaRequest.getOrderId()))) {
//				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
//			}

			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);

			customerOrderReplica.setAttempts(customerOrderReplica.getAttempts() + 1);
			customerOrderReplica.setUpdatedTime(new Date());

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		} else {

			customerOrderReplica = new CustomerOrderReplica();
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);
			customerOrderReplica.setCartId(customerOrderReplicaRequest.getCartId());
			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());

			if (razorPayCount > 0) {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
			}

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			Schedule schedule = scheduleDao.getlatestScheduleCustomers();

			if (schedule != null) {

				try {
					customerOrderReplica.setSchedule(schedule.getsId() != null ? schedule.getsId().toString() : null);
				} catch (Exception e) {
					e.printStackTrace();
				}
			} else {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
						"Sorry We Are Not Accepting Any Order Right now");

			}

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		}

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicas(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String schedule = null;

		Map filter = request.containsKey("filters") ? (Map) request.get("filters") : null;
		if (filter != null) {
			statusType = filter.containsKey("statusType") ? ((String) filter.get("statusType")).toLowerCase() : null;
			searchQuery = filter.containsKey("searchQuery") ? ((String) filter.get("searchQuery")).toLowerCase() : null;
			schedule = filter.containsKey("schedule") ? (String.valueOf(filter.get("schedule"))) : null;

		}

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplica(searchQuery, statusType, schedule);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");

				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setStreetName(
						customers.get("streetName") != null ? (String) customers.get("streetName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicasBySchedule(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String scheduleId = null;

		Schedule schedule = scheduleDao.getlatestScheduleCustomers();

		if (schedule != null) {

			try {
				scheduleId = schedule.getsId() != null ? schedule.getsId().toString() : null;
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

		statusType = request.containsKey("statusType") ? ((String) request.get("statusType")).toLowerCase() : "Success";

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplicaBySchdeule(statusType, scheduleId);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");
				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				System.out.println("customers" + customers.get("customerName"));

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public CustomerOrderReplica getCustomerOrderReplicaByCartId(String cartId) {

		CustomerOrderReplica CustomerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(cartId,
				currentUser.getContactNumber());

		ObjectMapper objectMapper = new ObjectMapper();
		try {

			// convert JSON string to Map
			Map<String, Object> customerOrderReplicaMap = objectMapper
					.readValue(CustomerOrderReplica.getCustomerOrderDetails(), Map.class);

			Object customerOrder = customerOrderReplicaMap.get("customerOrder");
			Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

			Object quanityList = items.get("quantity");
			Map customers = customerDetailsDao.getByContactNumberAndApartment(CustomerOrderReplica.getContactNumber(),
					CustomerOrderReplica.getApartmentId());

			System.out.println("customers" + customers.get("customerName"));

			// Apartments apartments =
			// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
			CustomerOrderReplica.setApartmentName(
					customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

			CustomerOrderReplica.setCustomerDetails(customers);

			CustomerOrderReplica.setCustomerOrder(customerOrder);
			CustomerOrderReplica.setQuatityList(quanityList);

		} catch (Exception e) {
			e.printStackTrace();
		}

		return CustomerOrderReplica;

	}

	@Override
	public Map createCustomerOrderReplica(CustomerOrderReplicaRequest customerOrderReplicaRequest, String contactNumber,
			Integer aparmentId) {

		if (customerOrderReplicaRequest.getRazorPayRequest() != null) {

//			Map razorPay = consumerService.createRazorPayOrder(customerOrderReplicaRequest.getRazorPayRequest());
//			customerOrderReplicaRequest.setOrderId(razorPay.get("order") != null ? (String)((RazorPay) razorPay.get("order")).getId() : null);	
//	
//			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);
//
//			razorPay.put("cartId", customerOrderReplicaRequest.getCartId());

			Map customerOrderReplicaMap = new HashMap<>();

			Map orderId = new HashMap<>();
			String transactionId = getMerchantTransactionId();
			orderId.put("id", transactionId);

			customerOrderReplicaMap.put("order", orderId);

			customerOrderReplicaRequest.setOrderId(transactionId);
			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);

			customerOrderReplicaMap.put("cartId", customerOrderReplicaRequest.getCartId());

			try {
				customerOrderReplicaMap.put("phonePeResponse",
						phonepeServiceImpl.initiatePhonepePayment(transactionId,
								Integer.valueOf(customerOrderReplicaRequest.getRazorPayRequest().getAmount()),
								contactNumber, customerOrderReplicaRequest.getRedirectUrl(), customerOrderReplicaRequest.getCallBackUrl()));

			} catch (Exception e) {
				e.printStackTrace();
				customerOrderReplicaMap.put("phonePeResponse", new HashedMap<>());
			}

			return customerOrderReplicaMap;

		} else {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
					"paymentDetails transcation Details are mandatory");
		}

	}

	private static String getMerchantTransactionId() {

		return "OD_" + MerchantTransactionIdGenerator.getRandomString();
	}


	@Override
	public List<CustomerOrderReplica> getCustomerOrderByMoblieNo(String contactNumber, Integer aid) {

	    Schedule latestSchedule = customerOrderReplicaDoa.getlatestschedule();

	    if (latestSchedule != null && latestSchedule.getCreationTimestamp() != null) {
	        if (latestSchedule.getStatus().equals(UserStatus.ACTIVE)) {
	            Customers customer = customerDetailsDao.getByContactNoAndApartment(contactNumber, aid);

	            if (customer != null) { // Ensure the customer exists
	                List<CustomerOrder> customerOrderList = customerOrderReplicaDoa.getListCustomerOrderByCustomerId(customer.getCtId());

	                double totalOrderAmount = 0.0;

	                if (customerOrderList != null && !customerOrderList.isEmpty()) {
	                    for (CustomerOrder customerOrder : customerOrderList) {
	                        Double orderAmount = customerOrder.getAmount();
	                        if (orderAmount != null) {
	                            totalOrderAmount += orderAmount;
	                            if(totalOrderAmount>200) {
	                            	totalOrderAmount+= customerOrder.getDelivaryCharges();
	                            }
	                            else(totalOrderAmount<200){
	                            	
	                            }
	                        }
	                    }

	                    // Define the minimum order amount for applying delivery charges
	                    double minimumOrderAmount = 200.0;

	                    if (totalOrderAmount < minimumOrderAmount) {
	                        System.out.println("Delivery Charges will be applicable");
	                    } else {
	                        // No delivery charges applicable
	                        System.out.println("No Delivery charges applicable");
	                    }

	                    List<CustomerOrderReplica> customerOrderReplicas = new ArrayList<>();
	                    return customerOrderReplicas;
	                } else {
	                    return Collections.emptyList();
	                }
	            } else {
	                return null; // or an appropriate value
	            }
	        } else {
	            // Handle the case when the latest schedule is not active
	            return null; // or an appropriate value
	        }
	    } else {
	        // Handle the case when there is no latest schedule or its creation timestamp is null
	        return null; // or an appropriate value
	    }
	}

}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-09-21 15:33:37.292
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-09-21 15:33:37.293
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-21 15:33:38.466
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.xyram.daydrop.serviceimpl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.transaction.Transactional;

import org.apache.commons.collections4.map.HashedMap;
import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.server.ResponseStatusException;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.xyram.daydrop.admin.model.CurrentUser;
import com.xyram.daydrop.basemodel.Base64Wrapper;
import com.xyram.daydrop.basemodel.MerchantTransactionIdGenerator;
import com.xyram.daydrop.basemodel.PhonepeSerializer;
import com.xyram.daydrop.dao.ApartmentDao;
import com.xyram.daydrop.dao.CustomerDetailsDao;
import com.xyram.daydrop.dao.CustomerOrderDao;
import com.xyram.daydrop.dao.CustomerOrderReplicaDoa;
import com.xyram.daydrop.dao.SheduleDao;
import com.xyram.daydrop.enumtypes.UserStatus;
import com.xyram.daydrop.model.Apartments;
import com.xyram.daydrop.model.CustomerOrder;
import com.xyram.daydrop.model.CustomerOrderReplica;
import com.xyram.daydrop.model.Customers;
import com.xyram.daydrop.model.Schedule;
import com.xyram.daydrop.modelMapper.PaymentInstrument;
import com.xyram.daydrop.modelMapper.PhonePePayModel;
import com.xyram.daydrop.request.CustomerOrderReplicaRequest;
import com.xyram.daydrop.response.RazorPayRequest;
import com.xyram.daydrop.service.CustomerOrderPriceService;
import com.xyram.daydrop.service.CustomerOrderReplicaService;
import com.xyram.daydrop.util.HashEncoder;
import com.xyram.daydrop.util.RazorPay;
import com.xyram.daydrop.service.ConsumerService;

@Transactional
@Service
public class CustomerOrderReplicaServiceImpl implements CustomerOrderReplicaService {

	@Autowired
	CustomerOrderReplicaDoa customerOrderReplicaDoa;

	@Autowired
	ApartmentDao apartmentDao;

	@Autowired
	SheduleDao scheduleDao;

	@Autowired
	CustomerDetailsDao customerDetailsDao;

	@Autowired
	ConsumerService consumerService;

	@Autowired
	CurrentUser currentUser;

	@Autowired
	PhonepeServiceImpl phonepeServiceImpl;

	@Value("${merchant_id}")
	private String merchantId;

	@Value("${salt_key}")
	private String saltKey;

	@Value("${salt_index}")
	private String saltIndex;

	@Override
	public Map createCustomerOrderReplicaService(CustomerOrderReplicaRequest customerOrderReplicaRequest,
			String contactNumber, Integer aparmentId)

	{

		Map response = new HashedMap<>();

		response.put("message", "success");
		CustomerOrderReplica customerOrderReplica = null;

		if (customerOrderReplicaRequest.getCartId() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "cartId is mandatory ");
		}
		long razorPayCount = 0;
		if (customerOrderReplicaRequest.getOrderId() != null) {

			razorPayCount = customerOrderReplicaDoa.getRazorPayExistByCartId(customerOrderReplicaRequest.getOrderId());
		}

		if (customerOrderReplicaRequest.getCustomerDetails() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Order Details  is mandatory ");
		}

		customerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(customerOrderReplicaRequest.getCartId(),
				contactNumber);

		if (customerOrderReplica != null) {
			customerOrderReplica.setCartId(customerOrderReplica.getCartId());

			if (customerOrderReplica.isOrdered()) {
				throw new ResponseStatusException(HttpStatus.CONFLICT, "Your Order is Placed With cart Details");
			}

//			if (razorPayCount >= 1 && !(customerOrderReplica.getRazorPayOrderId() != null
//					&& customerOrderReplica.getRazorPayOrderId().equals(customerOrderReplicaRequest.getOrderId()))) {
//				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
//			}

			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);

			customerOrderReplica.setAttempts(customerOrderReplica.getAttempts() + 1);
			customerOrderReplica.setUpdatedTime(new Date());

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		} else {

			customerOrderReplica = new CustomerOrderReplica();
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);
			customerOrderReplica.setCartId(customerOrderReplicaRequest.getCartId());
			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());

			if (razorPayCount > 0) {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
			}

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			Schedule schedule = scheduleDao.getlatestScheduleCustomers();

			if (schedule != null) {

				try {
					customerOrderReplica.setSchedule(schedule.getsId() != null ? schedule.getsId().toString() : null);
				} catch (Exception e) {
					e.printStackTrace();
				}
			} else {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
						"Sorry We Are Not Accepting Any Order Right now");

			}

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		}

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicas(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String schedule = null;

		Map filter = request.containsKey("filters") ? (Map) request.get("filters") : null;
		if (filter != null) {
			statusType = filter.containsKey("statusType") ? ((String) filter.get("statusType")).toLowerCase() : null;
			searchQuery = filter.containsKey("searchQuery") ? ((String) filter.get("searchQuery")).toLowerCase() : null;
			schedule = filter.containsKey("schedule") ? (String.valueOf(filter.get("schedule"))) : null;

		}

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplica(searchQuery, statusType, schedule);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");

				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setStreetName(
						customers.get("streetName") != null ? (String) customers.get("streetName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicasBySchedule(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String scheduleId = null;

		Schedule schedule = scheduleDao.getlatestScheduleCustomers();

		if (schedule != null) {

			try {
				scheduleId = schedule.getsId() != null ? schedule.getsId().toString() : null;
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

		statusType = request.containsKey("statusType") ? ((String) request.get("statusType")).toLowerCase() : "Success";

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplicaBySchdeule(statusType, scheduleId);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");
				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				System.out.println("customers" + customers.get("customerName"));

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public CustomerOrderReplica getCustomerOrderReplicaByCartId(String cartId) {

		CustomerOrderReplica CustomerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(cartId,
				currentUser.getContactNumber());

		ObjectMapper objectMapper = new ObjectMapper();
		try {

			// convert JSON string to Map
			Map<String, Object> customerOrderReplicaMap = objectMapper
					.readValue(CustomerOrderReplica.getCustomerOrderDetails(), Map.class);

			Object customerOrder = customerOrderReplicaMap.get("customerOrder");
			Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

			Object quanityList = items.get("quantity");
			Map customers = customerDetailsDao.getByContactNumberAndApartment(CustomerOrderReplica.getContactNumber(),
					CustomerOrderReplica.getApartmentId());

			System.out.println("customers" + customers.get("customerName"));

			// Apartments apartments =
			// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
			CustomerOrderReplica.setApartmentName(
					customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

			CustomerOrderReplica.setCustomerDetails(customers);

			CustomerOrderReplica.setCustomerOrder(customerOrder);
			CustomerOrderReplica.setQuatityList(quanityList);

		} catch (Exception e) {
			e.printStackTrace();
		}

		return CustomerOrderReplica;

	}

	@Override
	public Map createCustomerOrderReplica(CustomerOrderReplicaRequest customerOrderReplicaRequest, String contactNumber,
			Integer aparmentId) {

		if (customerOrderReplicaRequest.getRazorPayRequest() != null) {

//			Map razorPay = consumerService.createRazorPayOrder(customerOrderReplicaRequest.getRazorPayRequest());
//			customerOrderReplicaRequest.setOrderId(razorPay.get("order") != null ? (String)((RazorPay) razorPay.get("order")).getId() : null);	
//	
//			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);
//
//			razorPay.put("cartId", customerOrderReplicaRequest.getCartId());

			Map customerOrderReplicaMap = new HashMap<>();

			Map orderId = new HashMap<>();
			String transactionId = getMerchantTransactionId();
			orderId.put("id", transactionId);

			customerOrderReplicaMap.put("order", orderId);

			customerOrderReplicaRequest.setOrderId(transactionId);
			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);

			customerOrderReplicaMap.put("cartId", customerOrderReplicaRequest.getCartId());

			try {
				customerOrderReplicaMap.put("phonePeResponse",
						phonepeServiceImpl.initiatePhonepePayment(transactionId,
								Integer.valueOf(customerOrderReplicaRequest.getRazorPayRequest().getAmount()),
								contactNumber, customerOrderReplicaRequest.getRedirectUrl(), customerOrderReplicaRequest.getCallBackUrl()));

			} catch (Exception e) {
				e.printStackTrace();
				customerOrderReplicaMap.put("phonePeResponse", new HashedMap<>());
			}

			return customerOrderReplicaMap;

		} else {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
					"paymentDetails transcation Details are mandatory");
		}

	}

	private static String getMerchantTransactionId() {

		return "OD_" + MerchantTransactionIdGenerator.getRandomString();
	}


	@Override
	public List<CustomerOrderReplica> getCustomerOrderByMoblieNo(String contactNumber, Integer aid) {

	    Schedule latestSchedule = customerOrderReplicaDoa.getlatestschedule();

	    if (latestSchedule != null && latestSchedule.getCreationTimestamp() != null) {
	        if (latestSchedule.getStatus().equals(UserStatus.ACTIVE)) {
	            Customers customer = customerDetailsDao.getByContactNoAndApartment(contactNumber, aid);

	            if (customer != null) { // Ensure the customer exists
	                List<CustomerOrder> customerOrderList = customerOrderReplicaDoa.getListCustomerOrderByCustomerId(customer.getCtId());

	                double totalOrderAmount = 0.0;

	                if (customerOrderList != null && !customerOrderList.isEmpty()) {
	                    for (CustomerOrder customerOrder : customerOrderList) {
	                        Double orderAmount = customerOrder.getAmount();
	                        if (orderAmount != null) {
	                            totalOrderAmount += orderAmount;
	                            if(totalOrderAmount>200) {
	                            	totalOrderAmount+= customerOrder.getDelivaryCharges();
	                            }
	                            else(totalOrderAmount<200){
	                            	
	                            }
	                        }
	                    }

	                    // Define the minimum order amount for applying delivery charges
	                    double minimumOrderAmount = 200.0;

	                    if (totalOrderAmount < minimumOrderAmount) {
	                        System.out.println("Delivery Charges will be applicable");
	                    } else {
	                        // No delivery charges applicable
	                        System.out.println("No Delivery charges applicable");
	                    }

	                    List<CustomerOrderReplica> customerOrderReplicas = new ArrayList<>();
	                    return customerOrderReplicas;
	                } else {
	                    return Collections.emptyList();
	                }
	            } else {
	                return null; // or an appropriate value
	            }
	        } else {
	            // Handle the case when the latest schedule is not active
	            return null; // or an appropriate value
	        }
	    } else {
	        // Handle the case when there is no latest schedule or its creation timestamp is null
	        return null; // or an appropriate value
	    }
	}

}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-09-21 15:33:38.468
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-09-21 15:33:38.470
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-21 15:33:39.089
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.xyram.daydrop.serviceimpl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.transaction.Transactional;

import org.apache.commons.collections4.map.HashedMap;
import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.server.ResponseStatusException;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.xyram.daydrop.admin.model.CurrentUser;
import com.xyram.daydrop.basemodel.Base64Wrapper;
import com.xyram.daydrop.basemodel.MerchantTransactionIdGenerator;
import com.xyram.daydrop.basemodel.PhonepeSerializer;
import com.xyram.daydrop.dao.ApartmentDao;
import com.xyram.daydrop.dao.CustomerDetailsDao;
import com.xyram.daydrop.dao.CustomerOrderDao;
import com.xyram.daydrop.dao.CustomerOrderReplicaDoa;
import com.xyram.daydrop.dao.SheduleDao;
import com.xyram.daydrop.enumtypes.UserStatus;
import com.xyram.daydrop.model.Apartments;
import com.xyram.daydrop.model.CustomerOrder;
import com.xyram.daydrop.model.CustomerOrderReplica;
import com.xyram.daydrop.model.Customers;
import com.xyram.daydrop.model.Schedule;
import com.xyram.daydrop.modelMapper.PaymentInstrument;
import com.xyram.daydrop.modelMapper.PhonePePayModel;
import com.xyram.daydrop.request.CustomerOrderReplicaRequest;
import com.xyram.daydrop.response.RazorPayRequest;
import com.xyram.daydrop.service.CustomerOrderPriceService;
import com.xyram.daydrop.service.CustomerOrderReplicaService;
import com.xyram.daydrop.util.HashEncoder;
import com.xyram.daydrop.util.RazorPay;
import com.xyram.daydrop.service.ConsumerService;

@Transactional
@Service
public class CustomerOrderReplicaServiceImpl implements CustomerOrderReplicaService {

	@Autowired
	CustomerOrderReplicaDoa customerOrderReplicaDoa;

	@Autowired
	ApartmentDao apartmentDao;

	@Autowired
	SheduleDao scheduleDao;

	@Autowired
	CustomerDetailsDao customerDetailsDao;

	@Autowired
	ConsumerService consumerService;

	@Autowired
	CurrentUser currentUser;

	@Autowired
	PhonepeServiceImpl phonepeServiceImpl;

	@Value("${merchant_id}")
	private String merchantId;

	@Value("${salt_key}")
	private String saltKey;

	@Value("${salt_index}")
	private String saltIndex;

	@Override
	public Map createCustomerOrderReplicaService(CustomerOrderReplicaRequest customerOrderReplicaRequest,
			String contactNumber, Integer aparmentId)

	{

		Map response = new HashedMap<>();

		response.put("message", "success");
		CustomerOrderReplica customerOrderReplica = null;

		if (customerOrderReplicaRequest.getCartId() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "cartId is mandatory ");
		}
		long razorPayCount = 0;
		if (customerOrderReplicaRequest.getOrderId() != null) {

			razorPayCount = customerOrderReplicaDoa.getRazorPayExistByCartId(customerOrderReplicaRequest.getOrderId());
		}

		if (customerOrderReplicaRequest.getCustomerDetails() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Order Details  is mandatory ");
		}

		customerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(customerOrderReplicaRequest.getCartId(),
				contactNumber);

		if (customerOrderReplica != null) {
			customerOrderReplica.setCartId(customerOrderReplica.getCartId());

			if (customerOrderReplica.isOrdered()) {
				throw new ResponseStatusException(HttpStatus.CONFLICT, "Your Order is Placed With cart Details");
			}

//			if (razorPayCount >= 1 && !(customerOrderReplica.getRazorPayOrderId() != null
//					&& customerOrderReplica.getRazorPayOrderId().equals(customerOrderReplicaRequest.getOrderId()))) {
//				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
//			}

			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);

			customerOrderReplica.setAttempts(customerOrderReplica.getAttempts() + 1);
			customerOrderReplica.setUpdatedTime(new Date());

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		} else {

			customerOrderReplica = new CustomerOrderReplica();
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);
			customerOrderReplica.setCartId(customerOrderReplicaRequest.getCartId());
			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());

			if (razorPayCount > 0) {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
			}

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			Schedule schedule = scheduleDao.getlatestScheduleCustomers();

			if (schedule != null) {

				try {
					customerOrderReplica.setSchedule(schedule.getsId() != null ? schedule.getsId().toString() : null);
				} catch (Exception e) {
					e.printStackTrace();
				}
			} else {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
						"Sorry We Are Not Accepting Any Order Right now");

			}

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		}

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicas(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String schedule = null;

		Map filter = request.containsKey("filters") ? (Map) request.get("filters") : null;
		if (filter != null) {
			statusType = filter.containsKey("statusType") ? ((String) filter.get("statusType")).toLowerCase() : null;
			searchQuery = filter.containsKey("searchQuery") ? ((String) filter.get("searchQuery")).toLowerCase() : null;
			schedule = filter.containsKey("schedule") ? (String.valueOf(filter.get("schedule"))) : null;

		}

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplica(searchQuery, statusType, schedule);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");

				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setStreetName(
						customers.get("streetName") != null ? (String) customers.get("streetName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicasBySchedule(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String scheduleId = null;

		Schedule schedule = scheduleDao.getlatestScheduleCustomers();

		if (schedule != null) {

			try {
				scheduleId = schedule.getsId() != null ? schedule.getsId().toString() : null;
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

		statusType = request.containsKey("statusType") ? ((String) request.get("statusType")).toLowerCase() : "Success";

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplicaBySchdeule(statusType, scheduleId);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");
				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				System.out.println("customers" + customers.get("customerName"));

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public CustomerOrderReplica getCustomerOrderReplicaByCartId(String cartId) {

		CustomerOrderReplica CustomerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(cartId,
				currentUser.getContactNumber());

		ObjectMapper objectMapper = new ObjectMapper();
		try {

			// convert JSON string to Map
			Map<String, Object> customerOrderReplicaMap = objectMapper
					.readValue(CustomerOrderReplica.getCustomerOrderDetails(), Map.class);

			Object customerOrder = customerOrderReplicaMap.get("customerOrder");
			Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

			Object quanityList = items.get("quantity");
			Map customers = customerDetailsDao.getByContactNumberAndApartment(CustomerOrderReplica.getContactNumber(),
					CustomerOrderReplica.getApartmentId());

			System.out.println("customers" + customers.get("customerName"));

			// Apartments apartments =
			// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
			CustomerOrderReplica.setApartmentName(
					customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

			CustomerOrderReplica.setCustomerDetails(customers);

			CustomerOrderReplica.setCustomerOrder(customerOrder);
			CustomerOrderReplica.setQuatityList(quanityList);

		} catch (Exception e) {
			e.printStackTrace();
		}

		return CustomerOrderReplica;

	}

	@Override
	public Map createCustomerOrderReplica(CustomerOrderReplicaRequest customerOrderReplicaRequest, String contactNumber,
			Integer aparmentId) {

		if (customerOrderReplicaRequest.getRazorPayRequest() != null) {

//			Map razorPay = consumerService.createRazorPayOrder(customerOrderReplicaRequest.getRazorPayRequest());
//			customerOrderReplicaRequest.setOrderId(razorPay.get("order") != null ? (String)((RazorPay) razorPay.get("order")).getId() : null);	
//	
//			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);
//
//			razorPay.put("cartId", customerOrderReplicaRequest.getCartId());

			Map customerOrderReplicaMap = new HashMap<>();

			Map orderId = new HashMap<>();
			String transactionId = getMerchantTransactionId();
			orderId.put("id", transactionId);

			customerOrderReplicaMap.put("order", orderId);

			customerOrderReplicaRequest.setOrderId(transactionId);
			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);

			customerOrderReplicaMap.put("cartId", customerOrderReplicaRequest.getCartId());

			try {
				customerOrderReplicaMap.put("phonePeResponse",
						phonepeServiceImpl.initiatePhonepePayment(transactionId,
								Integer.valueOf(customerOrderReplicaRequest.getRazorPayRequest().getAmount()),
								contactNumber, customerOrderReplicaRequest.getRedirectUrl(), customerOrderReplicaRequest.getCallBackUrl()));

			} catch (Exception e) {
				e.printStackTrace();
				customerOrderReplicaMap.put("phonePeResponse", new HashedMap<>());
			}

			return customerOrderReplicaMap;

		} else {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
					"paymentDetails transcation Details are mandatory");
		}

	}

	private static String getMerchantTransactionId() {

		return "OD_" + MerchantTransactionIdGenerator.getRandomString();
	}


	@Override
	public List<CustomerOrderReplica> getCustomerOrderByMoblieNo(String contactNumber, Integer aid) {

	    Schedule latestSchedule = customerOrderReplicaDoa.getlatestschedule();

	    if (latestSchedule != null && latestSchedule.getCreationTimestamp() != null) {
	        if (latestSchedule.getStatus().equals(UserStatus.ACTIVE)) {
	            Customers customer = customerDetailsDao.getByContactNoAndApartment(contactNumber, aid);

	            if (customer != null) { // Ensure the customer exists
	                List<CustomerOrder> customerOrderList = customerOrderReplicaDoa.getListCustomerOrderByCustomerId(customer.getCtId());

	                double totalOrderAmount = 0.0;

	                if (customerOrderList != null && !customerOrderList.isEmpty()) {
	                    for (CustomerOrder customerOrder : customerOrderList) {
	                        Double orderAmount = customerOrder.getAmount();
	                        if (orderAmount != null) {
	                            totalOrderAmount += orderAmount;
	                            if(totalOrderAmount>200) {
	                            	totalOrderAmount+= customerOrder.getDelivaryCharges();
	                            }
	                            else(totalOrderAmount<200){
	                            	
	                            }
	                        }
	                    }

	                    // Define the minimum order amount for applying delivery charges
	                    double minimumOrderAmount = 200.0;

	                    if (totalOrderAmount < minimumOrderAmount) {
	                        System.out.println("Delivery Charges will be applicable");
	                    } else {
	                        // No delivery charges applicable
	                        System.out.println("No Delivery charges applicable");
	                    }

	                    List<CustomerOrderReplica> customerOrderReplicas = new ArrayList<>();
	                    return customerOrderReplicas;
	                } else {
	                    return Collections.emptyList();
	                }
	            } else {
	                return null; // or an appropriate value
	            }
	        } else {
	            // Handle the case when the latest schedule is not active
	            return null; // or an appropriate value
	        }
	    } else {
	        // Handle the case when there is no latest schedule or its creation timestamp is null
	        return null; // or an appropriate value
	    }
	}

}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-09-21 15:33:39.092
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-09-21 15:33:39.094
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-21 15:33:39.744
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.xyram.daydrop.serviceimpl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.transaction.Transactional;

import org.apache.commons.collections4.map.HashedMap;
import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.server.ResponseStatusException;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.xyram.daydrop.admin.model.CurrentUser;
import com.xyram.daydrop.basemodel.Base64Wrapper;
import com.xyram.daydrop.basemodel.MerchantTransactionIdGenerator;
import com.xyram.daydrop.basemodel.PhonepeSerializer;
import com.xyram.daydrop.dao.ApartmentDao;
import com.xyram.daydrop.dao.CustomerDetailsDao;
import com.xyram.daydrop.dao.CustomerOrderDao;
import com.xyram.daydrop.dao.CustomerOrderReplicaDoa;
import com.xyram.daydrop.dao.SheduleDao;
import com.xyram.daydrop.enumtypes.UserStatus;
import com.xyram.daydrop.model.Apartments;
import com.xyram.daydrop.model.CustomerOrder;
import com.xyram.daydrop.model.CustomerOrderReplica;
import com.xyram.daydrop.model.Customers;
import com.xyram.daydrop.model.Schedule;
import com.xyram.daydrop.modelMapper.PaymentInstrument;
import com.xyram.daydrop.modelMapper.PhonePePayModel;
import com.xyram.daydrop.request.CustomerOrderReplicaRequest;
import com.xyram.daydrop.response.RazorPayRequest;
import com.xyram.daydrop.service.CustomerOrderPriceService;
import com.xyram.daydrop.service.CustomerOrderReplicaService;
import com.xyram.daydrop.util.HashEncoder;
import com.xyram.daydrop.util.RazorPay;
import com.xyram.daydrop.service.ConsumerService;

@Transactional
@Service
public class CustomerOrderReplicaServiceImpl implements CustomerOrderReplicaService {

	@Autowired
	CustomerOrderReplicaDoa customerOrderReplicaDoa;

	@Autowired
	ApartmentDao apartmentDao;

	@Autowired
	SheduleDao scheduleDao;

	@Autowired
	CustomerDetailsDao customerDetailsDao;

	@Autowired
	ConsumerService consumerService;

	@Autowired
	CurrentUser currentUser;

	@Autowired
	PhonepeServiceImpl phonepeServiceImpl;

	@Value("${merchant_id}")
	private String merchantId;

	@Value("${salt_key}")
	private String saltKey;

	@Value("${salt_index}")
	private String saltIndex;

	@Override
	public Map createCustomerOrderReplicaService(CustomerOrderReplicaRequest customerOrderReplicaRequest,
			String contactNumber, Integer aparmentId)

	{

		Map response = new HashedMap<>();

		response.put("message", "success");
		CustomerOrderReplica customerOrderReplica = null;

		if (customerOrderReplicaRequest.getCartId() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "cartId is mandatory ");
		}
		long razorPayCount = 0;
		if (customerOrderReplicaRequest.getOrderId() != null) {

			razorPayCount = customerOrderReplicaDoa.getRazorPayExistByCartId(customerOrderReplicaRequest.getOrderId());
		}

		if (customerOrderReplicaRequest.getCustomerDetails() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Order Details  is mandatory ");
		}

		customerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(customerOrderReplicaRequest.getCartId(),
				contactNumber);

		if (customerOrderReplica != null) {
			customerOrderReplica.setCartId(customerOrderReplica.getCartId());

			if (customerOrderReplica.isOrdered()) {
				throw new ResponseStatusException(HttpStatus.CONFLICT, "Your Order is Placed With cart Details");
			}

//			if (razorPayCount >= 1 && !(customerOrderReplica.getRazorPayOrderId() != null
//					&& customerOrderReplica.getRazorPayOrderId().equals(customerOrderReplicaRequest.getOrderId()))) {
//				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
//			}

			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);

			customerOrderReplica.setAttempts(customerOrderReplica.getAttempts() + 1);
			customerOrderReplica.setUpdatedTime(new Date());

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		} else {

			customerOrderReplica = new CustomerOrderReplica();
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);
			customerOrderReplica.setCartId(customerOrderReplicaRequest.getCartId());
			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());

			if (razorPayCount > 0) {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
			}

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			Schedule schedule = scheduleDao.getlatestScheduleCustomers();

			if (schedule != null) {

				try {
					customerOrderReplica.setSchedule(schedule.getsId() != null ? schedule.getsId().toString() : null);
				} catch (Exception e) {
					e.printStackTrace();
				}
			} else {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
						"Sorry We Are Not Accepting Any Order Right now");

			}

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		}

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicas(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String schedule = null;

		Map filter = request.containsKey("filters") ? (Map) request.get("filters") : null;
		if (filter != null) {
			statusType = filter.containsKey("statusType") ? ((String) filter.get("statusType")).toLowerCase() : null;
			searchQuery = filter.containsKey("searchQuery") ? ((String) filter.get("searchQuery")).toLowerCase() : null;
			schedule = filter.containsKey("schedule") ? (String.valueOf(filter.get("schedule"))) : null;

		}

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplica(searchQuery, statusType, schedule);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");

				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setStreetName(
						customers.get("streetName") != null ? (String) customers.get("streetName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicasBySchedule(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String scheduleId = null;

		Schedule schedule = scheduleDao.getlatestScheduleCustomers();

		if (schedule != null) {

			try {
				scheduleId = schedule.getsId() != null ? schedule.getsId().toString() : null;
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

		statusType = request.containsKey("statusType") ? ((String) request.get("statusType")).toLowerCase() : "Success";

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplicaBySchdeule(statusType, scheduleId);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");
				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				System.out.println("customers" + customers.get("customerName"));

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public CustomerOrderReplica getCustomerOrderReplicaByCartId(String cartId) {

		CustomerOrderReplica CustomerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(cartId,
				currentUser.getContactNumber());

		ObjectMapper objectMapper = new ObjectMapper();
		try {

			// convert JSON string to Map
			Map<String, Object> customerOrderReplicaMap = objectMapper
					.readValue(CustomerOrderReplica.getCustomerOrderDetails(), Map.class);

			Object customerOrder = customerOrderReplicaMap.get("customerOrder");
			Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

			Object quanityList = items.get("quantity");
			Map customers = customerDetailsDao.getByContactNumberAndApartment(CustomerOrderReplica.getContactNumber(),
					CustomerOrderReplica.getApartmentId());

			System.out.println("customers" + customers.get("customerName"));

			// Apartments apartments =
			// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
			CustomerOrderReplica.setApartmentName(
					customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

			CustomerOrderReplica.setCustomerDetails(customers);

			CustomerOrderReplica.setCustomerOrder(customerOrder);
			CustomerOrderReplica.setQuatityList(quanityList);

		} catch (Exception e) {
			e.printStackTrace();
		}

		return CustomerOrderReplica;

	}

	@Override
	public Map createCustomerOrderReplica(CustomerOrderReplicaRequest customerOrderReplicaRequest, String contactNumber,
			Integer aparmentId) {

		if (customerOrderReplicaRequest.getRazorPayRequest() != null) {

//			Map razorPay = consumerService.createRazorPayOrder(customerOrderReplicaRequest.getRazorPayRequest());
//			customerOrderReplicaRequest.setOrderId(razorPay.get("order") != null ? (String)((RazorPay) razorPay.get("order")).getId() : null);	
//	
//			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);
//
//			razorPay.put("cartId", customerOrderReplicaRequest.getCartId());

			Map customerOrderReplicaMap = new HashMap<>();

			Map orderId = new HashMap<>();
			String transactionId = getMerchantTransactionId();
			orderId.put("id", transactionId);

			customerOrderReplicaMap.put("order", orderId);

			customerOrderReplicaRequest.setOrderId(transactionId);
			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);

			customerOrderReplicaMap.put("cartId", customerOrderReplicaRequest.getCartId());

			try {
				customerOrderReplicaMap.put("phonePeResponse",
						phonepeServiceImpl.initiatePhonepePayment(transactionId,
								Integer.valueOf(customerOrderReplicaRequest.getRazorPayRequest().getAmount()),
								contactNumber, customerOrderReplicaRequest.getRedirectUrl(), customerOrderReplicaRequest.getCallBackUrl()));

			} catch (Exception e) {
				e.printStackTrace();
				customerOrderReplicaMap.put("phonePeResponse", new HashedMap<>());
			}

			return customerOrderReplicaMap;

		} else {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
					"paymentDetails transcation Details are mandatory");
		}

	}

	private static String getMerchantTransactionId() {

		return "OD_" + MerchantTransactionIdGenerator.getRandomString();
	}


	@Override
	public List<CustomerOrderReplica> getCustomerOrderByMoblieNo(String contactNumber, Integer aid) {

	    Schedule latestSchedule = customerOrderReplicaDoa.getlatestschedule();

	    if (latestSchedule != null && latestSchedule.getCreationTimestamp() != null) {
	        if (latestSchedule.getStatus().equals(UserStatus.ACTIVE)) {
	            Customers customer = customerDetailsDao.getByContactNoAndApartment(contactNumber, aid);

	            if (customer != null) { // Ensure the customer exists
	                List<CustomerOrder> customerOrderList = customerOrderReplicaDoa.getListCustomerOrderByCustomerId(customer.getCtId());

	                double totalOrderAmount = 0.0;

	                if (customerOrderList != null && !customerOrderList.isEmpty()) {
	                    for (CustomerOrder customerOrder : customerOrderList) {
	                        Double orderAmount = customerOrder.getAmount();
	                        if (orderAmount != null) {
	                            totalOrderAmount += orderAmount;
	                            if(totalOrderAmount>200) {
	                            	totalOrderAmount+= customerOrder.getDelivaryCharges();
	                            }
	                            else(totalOrderAmount<200){
	                            	
	                            }
	                        }
	                    }

	                    // Define the minimum order amount for applying delivery charges
	                    double minimumOrderAmount = 200.0;

	                    if (totalOrderAmount < minimumOrderAmount) {
	                        System.out.println("Delivery Charges will be applicable");
	                    } else {
	                        // No delivery charges applicable
	                        System.out.println("No Delivery charges applicable");
	                    }

	                    List<CustomerOrderReplica> customerOrderReplicas = new ArrayList<>();
	                    return customerOrderReplicas;
	                } else {
	                    return Collections.emptyList();
	                }
	            } else {
	                return null; // or an appropriate value
	            }
	        } else {
	            // Handle the case when the latest schedule is not active
	            return null; // or an appropriate value
	        }
	    } else {
	        // Handle the case when there is no latest schedule or its creation timestamp is null
	        return null; // or an appropriate value
	    }
	}

}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-09-21 15:33:39.746
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-09-21 15:33:39.748
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-21 15:33:39.925
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.xyram.daydrop.serviceimpl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.transaction.Transactional;

import org.apache.commons.collections4.map.HashedMap;
import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.server.ResponseStatusException;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.xyram.daydrop.admin.model.CurrentUser;
import com.xyram.daydrop.basemodel.Base64Wrapper;
import com.xyram.daydrop.basemodel.MerchantTransactionIdGenerator;
import com.xyram.daydrop.basemodel.PhonepeSerializer;
import com.xyram.daydrop.dao.ApartmentDao;
import com.xyram.daydrop.dao.CustomerDetailsDao;
import com.xyram.daydrop.dao.CustomerOrderDao;
import com.xyram.daydrop.dao.CustomerOrderReplicaDoa;
import com.xyram.daydrop.dao.SheduleDao;
import com.xyram.daydrop.enumtypes.UserStatus;
import com.xyram.daydrop.model.Apartments;
import com.xyram.daydrop.model.CustomerOrder;
import com.xyram.daydrop.model.CustomerOrderReplica;
import com.xyram.daydrop.model.Customers;
import com.xyram.daydrop.model.Schedule;
import com.xyram.daydrop.modelMapper.PaymentInstrument;
import com.xyram.daydrop.modelMapper.PhonePePayModel;
import com.xyram.daydrop.request.CustomerOrderReplicaRequest;
import com.xyram.daydrop.response.RazorPayRequest;
import com.xyram.daydrop.service.CustomerOrderPriceService;
import com.xyram.daydrop.service.CustomerOrderReplicaService;
import com.xyram.daydrop.util.HashEncoder;
import com.xyram.daydrop.util.RazorPay;
import com.xyram.daydrop.service.ConsumerService;

@Transactional
@Service
public class CustomerOrderReplicaServiceImpl implements CustomerOrderReplicaService {

	@Autowired
	CustomerOrderReplicaDoa customerOrderReplicaDoa;

	@Autowired
	ApartmentDao apartmentDao;

	@Autowired
	SheduleDao scheduleDao;

	@Autowired
	CustomerDetailsDao customerDetailsDao;

	@Autowired
	ConsumerService consumerService;

	@Autowired
	CurrentUser currentUser;

	@Autowired
	PhonepeServiceImpl phonepeServiceImpl;

	@Value("${merchant_id}")
	private String merchantId;

	@Value("${salt_key}")
	private String saltKey;

	@Value("${salt_index}")
	private String saltIndex;

	@Override
	public Map createCustomerOrderReplicaService(CustomerOrderReplicaRequest customerOrderReplicaRequest,
			String contactNumber, Integer aparmentId)

	{

		Map response = new HashedMap<>();

		response.put("message", "success");
		CustomerOrderReplica customerOrderReplica = null;

		if (customerOrderReplicaRequest.getCartId() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "cartId is mandatory ");
		}
		long razorPayCount = 0;
		if (customerOrderReplicaRequest.getOrderId() != null) {

			razorPayCount = customerOrderReplicaDoa.getRazorPayExistByCartId(customerOrderReplicaRequest.getOrderId());
		}

		if (customerOrderReplicaRequest.getCustomerDetails() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Order Details  is mandatory ");
		}

		customerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(customerOrderReplicaRequest.getCartId(),
				contactNumber);

		if (customerOrderReplica != null) {
			customerOrderReplica.setCartId(customerOrderReplica.getCartId());

			if (customerOrderReplica.isOrdered()) {
				throw new ResponseStatusException(HttpStatus.CONFLICT, "Your Order is Placed With cart Details");
			}

//			if (razorPayCount >= 1 && !(customerOrderReplica.getRazorPayOrderId() != null
//					&& customerOrderReplica.getRazorPayOrderId().equals(customerOrderReplicaRequest.getOrderId()))) {
//				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
//			}

			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);

			customerOrderReplica.setAttempts(customerOrderReplica.getAttempts() + 1);
			customerOrderReplica.setUpdatedTime(new Date());

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		} else {

			customerOrderReplica = new CustomerOrderReplica();
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);
			customerOrderReplica.setCartId(customerOrderReplicaRequest.getCartId());
			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());

			if (razorPayCount > 0) {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
			}

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			Schedule schedule = scheduleDao.getlatestScheduleCustomers();

			if (schedule != null) {

				try {
					customerOrderReplica.setSchedule(schedule.getsId() != null ? schedule.getsId().toString() : null);
				} catch (Exception e) {
					e.printStackTrace();
				}
			} else {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
						"Sorry We Are Not Accepting Any Order Right now");

			}

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		}

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicas(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String schedule = null;

		Map filter = request.containsKey("filters") ? (Map) request.get("filters") : null;
		if (filter != null) {
			statusType = filter.containsKey("statusType") ? ((String) filter.get("statusType")).toLowerCase() : null;
			searchQuery = filter.containsKey("searchQuery") ? ((String) filter.get("searchQuery")).toLowerCase() : null;
			schedule = filter.containsKey("schedule") ? (String.valueOf(filter.get("schedule"))) : null;

		}

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplica(searchQuery, statusType, schedule);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");

				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setStreetName(
						customers.get("streetName") != null ? (String) customers.get("streetName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicasBySchedule(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String scheduleId = null;

		Schedule schedule = scheduleDao.getlatestScheduleCustomers();

		if (schedule != null) {

			try {
				scheduleId = schedule.getsId() != null ? schedule.getsId().toString() : null;
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

		statusType = request.containsKey("statusType") ? ((String) request.get("statusType")).toLowerCase() : "Success";

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplicaBySchdeule(statusType, scheduleId);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");
				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				System.out.println("customers" + customers.get("customerName"));

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public CustomerOrderReplica getCustomerOrderReplicaByCartId(String cartId) {

		CustomerOrderReplica CustomerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(cartId,
				currentUser.getContactNumber());

		ObjectMapper objectMapper = new ObjectMapper();
		try {

			// convert JSON string to Map
			Map<String, Object> customerOrderReplicaMap = objectMapper
					.readValue(CustomerOrderReplica.getCustomerOrderDetails(), Map.class);

			Object customerOrder = customerOrderReplicaMap.get("customerOrder");
			Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

			Object quanityList = items.get("quantity");
			Map customers = customerDetailsDao.getByContactNumberAndApartment(CustomerOrderReplica.getContactNumber(),
					CustomerOrderReplica.getApartmentId());

			System.out.println("customers" + customers.get("customerName"));

			// Apartments apartments =
			// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
			CustomerOrderReplica.setApartmentName(
					customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

			CustomerOrderReplica.setCustomerDetails(customers);

			CustomerOrderReplica.setCustomerOrder(customerOrder);
			CustomerOrderReplica.setQuatityList(quanityList);

		} catch (Exception e) {
			e.printStackTrace();
		}

		return CustomerOrderReplica;

	}

	@Override
	public Map createCustomerOrderReplica(CustomerOrderReplicaRequest customerOrderReplicaRequest, String contactNumber,
			Integer aparmentId) {

		if (customerOrderReplicaRequest.getRazorPayRequest() != null) {

//			Map razorPay = consumerService.createRazorPayOrder(customerOrderReplicaRequest.getRazorPayRequest());
//			customerOrderReplicaRequest.setOrderId(razorPay.get("order") != null ? (String)((RazorPay) razorPay.get("order")).getId() : null);	
//	
//			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);
//
//			razorPay.put("cartId", customerOrderReplicaRequest.getCartId());

			Map customerOrderReplicaMap = new HashMap<>();

			Map orderId = new HashMap<>();
			String transactionId = getMerchantTransactionId();
			orderId.put("id", transactionId);

			customerOrderReplicaMap.put("order", orderId);

			customerOrderReplicaRequest.setOrderId(transactionId);
			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);

			customerOrderReplicaMap.put("cartId", customerOrderReplicaRequest.getCartId());

			try {
				customerOrderReplicaMap.put("phonePeResponse",
						phonepeServiceImpl.initiatePhonepePayment(transactionId,
								Integer.valueOf(customerOrderReplicaRequest.getRazorPayRequest().getAmount()),
								contactNumber, customerOrderReplicaRequest.getRedirectUrl(), customerOrderReplicaRequest.getCallBackUrl()));

			} catch (Exception e) {
				e.printStackTrace();
				customerOrderReplicaMap.put("phonePeResponse", new HashedMap<>());
			}

			return customerOrderReplicaMap;

		} else {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
					"paymentDetails transcation Details are mandatory");
		}

	}

	private static String getMerchantTransactionId() {

		return "OD_" + MerchantTransactionIdGenerator.getRandomString();
	}


	@Override
	public List<CustomerOrderReplica> getCustomerOrderByMoblieNo(String contactNumber, Integer aid) {

	    Schedule latestSchedule = customerOrderReplicaDoa.getlatestschedule();

	    if (latestSchedule != null && latestSchedule.getCreationTimestamp() != null) {
	        if (latestSchedule.getStatus().equals(UserStatus.ACTIVE)) {
	            Customers customer = customerDetailsDao.getByContactNoAndApartment(contactNumber, aid);

	            if (customer != null) { // Ensure the customer exists
	                List<CustomerOrder> customerOrderList = customerOrderReplicaDoa.getListCustomerOrderByCustomerId(customer.getCtId());

	                double totalOrderAmount = 0.0;

	                if (customerOrderList != null && !customerOrderList.isEmpty()) {
	                    for (CustomerOrder customerOrder : customerOrderList) {
	                        Double orderAmount = customerOrder.getAmount();
	                        if (orderAmount != null) {
	                            totalOrderAmount += orderAmount;
	                            if(totalOrderAmount>200) {
	                            	totalOrderAmount+= customerOrder.getDelivaryCharges();
	                            }
	                            else(totalOrderAmount<200){
	                            	
	                            }
	                        }
	                    }

	                    // Define the minimum order amount for applying delivery charges
	                    double minimumOrderAmount = 200.0;

	                    if (totalOrderAmount < minimumOrderAmount) {
	                        System.out.println("Delivery Charges will be applicable");
	                    } else {
	                        // No delivery charges applicable
	                        System.out.println("No Delivery charges applicable");
	                    }

	                    List<CustomerOrderReplica> customerOrderReplicas = new ArrayList<>();
	                    return customerOrderReplicas;
	                } else {
	                    return Collections.emptyList();
	                }
	            } else {
	                return null; // or an appropriate value
	            }
	        } else {
	            // Handle the case when the latest schedule is not active
	            return null; // or an appropriate value
	        }
	    } else {
	        // Handle the case when there is no latest schedule or its creation timestamp is null
	        return null; // or an appropriate value
	    }
	}

}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.getClipboardData(ClipboardOperationAction.java:479)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.doCutCopyWithImportsOperation(ClipboardOperationAction.java:406)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.internalDoOperation(ClipboardOperationAction.java:365)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.run(ClipboardOperationAction.java:286)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:121)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:97)
	at jdk.internal.reflect.GeneratedMethodAccessor79.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:317)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:251)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:173)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:156)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:488)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:487)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:213)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:308)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:580)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:647)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:439)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:96)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1280)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1062)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1087)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1072)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1114)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1110)
	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1539)
	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4868)
	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:345)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4746)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5023)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3630)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-09-21 15:33:39.927
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.getClipboardData(ClipboardOperationAction.java:479)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.doCutCopyWithImportsOperation(ClipboardOperationAction.java:406)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.internalDoOperation(ClipboardOperationAction.java:365)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.run(ClipboardOperationAction.java:286)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:121)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:97)
	at jdk.internal.reflect.GeneratedMethodAccessor79.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:317)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:251)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:173)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:156)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:488)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:487)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:213)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:308)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:580)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:647)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:439)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:96)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1280)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1062)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1087)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1072)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1114)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1110)
	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1539)
	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4868)
	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:345)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4746)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5023)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3630)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-09-21 15:33:39.929
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.getClipboardData(ClipboardOperationAction.java:479)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.doCutCopyWithImportsOperation(ClipboardOperationAction.java:406)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.internalDoOperation(ClipboardOperationAction.java:365)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.run(ClipboardOperationAction.java:286)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:121)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:97)
	at jdk.internal.reflect.GeneratedMethodAccessor79.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:317)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:251)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:173)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:156)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:488)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:487)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:213)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:308)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:580)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:647)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:439)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:96)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1280)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1062)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1087)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1072)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1114)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1110)
	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1539)
	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4868)
	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:345)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4746)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5023)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3630)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-21 15:33:41.469
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.xyram.daydrop.serviceimpl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.transaction.Transactional;

import org.apache.commons.collections4.map.HashedMap;
import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.server.ResponseStatusException;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.xyram.daydrop.admin.model.CurrentUser;
import com.xyram.daydrop.basemodel.Base64Wrapper;
import com.xyram.daydrop.basemodel.MerchantTransactionIdGenerator;
import com.xyram.daydrop.basemodel.PhonepeSerializer;
import com.xyram.daydrop.dao.ApartmentDao;
import com.xyram.daydrop.dao.CustomerDetailsDao;
import com.xyram.daydrop.dao.CustomerOrderDao;
import com.xyram.daydrop.dao.CustomerOrderReplicaDoa;
import com.xyram.daydrop.dao.SheduleDao;
import com.xyram.daydrop.enumtypes.UserStatus;
import com.xyram.daydrop.model.Apartments;
import com.xyram.daydrop.model.CustomerOrder;
import com.xyram.daydrop.model.CustomerOrderReplica;
import com.xyram.daydrop.model.Customers;
import com.xyram.daydrop.model.Schedule;
import com.xyram.daydrop.modelMapper.PaymentInstrument;
import com.xyram.daydrop.modelMapper.PhonePePayModel;
import com.xyram.daydrop.request.CustomerOrderReplicaRequest;
import com.xyram.daydrop.response.RazorPayRequest;
import com.xyram.daydrop.service.CustomerOrderPriceService;
import com.xyram.daydrop.service.CustomerOrderReplicaService;
import com.xyram.daydrop.util.HashEncoder;
import com.xyram.daydrop.util.RazorPay;
import com.xyram.daydrop.service.ConsumerService;

@Transactional
@Service
public class CustomerOrderReplicaServiceImpl implements CustomerOrderReplicaService {

	@Autowired
	CustomerOrderReplicaDoa customerOrderReplicaDoa;

	@Autowired
	ApartmentDao apartmentDao;

	@Autowired
	SheduleDao scheduleDao;

	@Autowired
	CustomerDetailsDao customerDetailsDao;

	@Autowired
	ConsumerService consumerService;

	@Autowired
	CurrentUser currentUser;

	@Autowired
	PhonepeServiceImpl phonepeServiceImpl;

	@Value("${merchant_id}")
	private String merchantId;

	@Value("${salt_key}")
	private String saltKey;

	@Value("${salt_index}")
	private String saltIndex;

	@Override
	public Map createCustomerOrderReplicaService(CustomerOrderReplicaRequest customerOrderReplicaRequest,
			String contactNumber, Integer aparmentId)

	{

		Map response = new HashedMap<>();

		response.put("message", "success");
		CustomerOrderReplica customerOrderReplica = null;

		if (customerOrderReplicaRequest.getCartId() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "cartId is mandatory ");
		}
		long razorPayCount = 0;
		if (customerOrderReplicaRequest.getOrderId() != null) {

			razorPayCount = customerOrderReplicaDoa.getRazorPayExistByCartId(customerOrderReplicaRequest.getOrderId());
		}

		if (customerOrderReplicaRequest.getCustomerDetails() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Order Details  is mandatory ");
		}

		customerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(customerOrderReplicaRequest.getCartId(),
				contactNumber);

		if (customerOrderReplica != null) {
			customerOrderReplica.setCartId(customerOrderReplica.getCartId());

			if (customerOrderReplica.isOrdered()) {
				throw new ResponseStatusException(HttpStatus.CONFLICT, "Your Order is Placed With cart Details");
			}

//			if (razorPayCount >= 1 && !(customerOrderReplica.getRazorPayOrderId() != null
//					&& customerOrderReplica.getRazorPayOrderId().equals(customerOrderReplicaRequest.getOrderId()))) {
//				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
//			}

			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);

			customerOrderReplica.setAttempts(customerOrderReplica.getAttempts() + 1);
			customerOrderReplica.setUpdatedTime(new Date());

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		} else {

			customerOrderReplica = new CustomerOrderReplica();
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);
			customerOrderReplica.setCartId(customerOrderReplicaRequest.getCartId());
			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());

			if (razorPayCount > 0) {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
			}

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			Schedule schedule = scheduleDao.getlatestScheduleCustomers();

			if (schedule != null) {

				try {
					customerOrderReplica.setSchedule(schedule.getsId() != null ? schedule.getsId().toString() : null);
				} catch (Exception e) {
					e.printStackTrace();
				}
			} else {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
						"Sorry We Are Not Accepting Any Order Right now");

			}

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		}

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicas(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String schedule = null;

		Map filter = request.containsKey("filters") ? (Map) request.get("filters") : null;
		if (filter != null) {
			statusType = filter.containsKey("statusType") ? ((String) filter.get("statusType")).toLowerCase() : null;
			searchQuery = filter.containsKey("searchQuery") ? ((String) filter.get("searchQuery")).toLowerCase() : null;
			schedule = filter.containsKey("schedule") ? (String.valueOf(filter.get("schedule"))) : null;

		}

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplica(searchQuery, statusType, schedule);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");

				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setStreetName(
						customers.get("streetName") != null ? (String) customers.get("streetName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicasBySchedule(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String scheduleId = null;

		Schedule schedule = scheduleDao.getlatestScheduleCustomers();

		if (schedule != null) {

			try {
				scheduleId = schedule.getsId() != null ? schedule.getsId().toString() : null;
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

		statusType = request.containsKey("statusType") ? ((String) request.get("statusType")).toLowerCase() : "Success";

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplicaBySchdeule(statusType, scheduleId);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");
				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				System.out.println("customers" + customers.get("customerName"));

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public CustomerOrderReplica getCustomerOrderReplicaByCartId(String cartId) {

		CustomerOrderReplica CustomerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(cartId,
				currentUser.getContactNumber());

		ObjectMapper objectMapper = new ObjectMapper();
		try {

			// convert JSON string to Map
			Map<String, Object> customerOrderReplicaMap = objectMapper
					.readValue(CustomerOrderReplica.getCustomerOrderDetails(), Map.class);

			Object customerOrder = customerOrderReplicaMap.get("customerOrder");
			Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

			Object quanityList = items.get("quantity");
			Map customers = customerDetailsDao.getByContactNumberAndApartment(CustomerOrderReplica.getContactNumber(),
					CustomerOrderReplica.getApartmentId());

			System.out.println("customers" + customers.get("customerName"));

			// Apartments apartments =
			// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
			CustomerOrderReplica.setApartmentName(
					customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

			CustomerOrderReplica.setCustomerDetails(customers);

			CustomerOrderReplica.setCustomerOrder(customerOrder);
			CustomerOrderReplica.setQuatityList(quanityList);

		} catch (Exception e) {
			e.printStackTrace();
		}

		return CustomerOrderReplica;

	}

	@Override
	public Map createCustomerOrderReplica(CustomerOrderReplicaRequest customerOrderReplicaRequest, String contactNumber,
			Integer aparmentId) {

		if (customerOrderReplicaRequest.getRazorPayRequest() != null) {

//			Map razorPay = consumerService.createRazorPayOrder(customerOrderReplicaRequest.getRazorPayRequest());
//			customerOrderReplicaRequest.setOrderId(razorPay.get("order") != null ? (String)((RazorPay) razorPay.get("order")).getId() : null);	
//	
//			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);
//
//			razorPay.put("cartId", customerOrderReplicaRequest.getCartId());

			Map customerOrderReplicaMap = new HashMap<>();

			Map orderId = new HashMap<>();
			String transactionId = getMerchantTransactionId();
			orderId.put("id", transactionId);

			customerOrderReplicaMap.put("order", orderId);

			customerOrderReplicaRequest.setOrderId(transactionId);
			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);

			customerOrderReplicaMap.put("cartId", customerOrderReplicaRequest.getCartId());

			try {
				customerOrderReplicaMap.put("phonePeResponse",
						phonepeServiceImpl.initiatePhonepePayment(transactionId,
								Integer.valueOf(customerOrderReplicaRequest.getRazorPayRequest().getAmount()),
								contactNumber, customerOrderReplicaRequest.getRedirectUrl(), customerOrderReplicaRequest.getCallBackUrl()));

			} catch (Exception e) {
				e.printStackTrace();
				customerOrderReplicaMap.put("phonePeResponse", new HashedMap<>());
			}

			return customerOrderReplicaMap;

		} else {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
					"paymentDetails transcation Details are mandatory");
		}

	}

	private static String getMerchantTransactionId() {

		return "OD_" + MerchantTransactionIdGenerator.getRandomString();
	}


	@Override
	public List<CustomerOrderReplica> getCustomerOrderByMoblieNo(String contactNumber, Integer aid) {

	    Schedule latestSchedule = customerOrderReplicaDoa.getlatestschedule();

	    if (latestSchedule != null && latestSchedule.getCreationTimestamp() != null) {
	        if (latestSchedule.getStatus().equals(UserStatus.ACTIVE)) {
	            Customers customer = customerDetailsDao.getByContactNoAndApartment(contactNumber, aid);

	            if (customer != null) { // Ensure the customer exists
	                List<CustomerOrder> customerOrderList = customerOrderReplicaDoa.getListCustomerOrderByCustomerId(customer.getCtId());

	                double totalOrderAmount = 0.0;

	                if (customerOrderList != null && !customerOrderList.isEmpty()) {
	                    for (CustomerOrder customerOrder : customerOrderList) {
	                        Double orderAmount = customerOrder.getAmount();
	                        if (orderAmount != null) {
	                            totalOrderAmount += orderAmount;
	                            if(totalOrderAmount>200) {
	                            	totalOrderAmount+= customerOrder.getDelivaryCharges();
	                            }
	                            else(totalOrderAmount<200){
	                            	totalOrderAmount+= customerOrder.getDelivaryCharges();
	                            }
	                        }
	                    }

	                    // Define the minimum order amount for applying delivery charges
	                    double minimumOrderAmount = 200.0;

	                    if (totalOrderAmount < minimumOrderAmount) {
	                        System.out.println("Delivery Charges will be applicable");
	                    } else {
	                        // No delivery charges applicable
	                        System.out.println("No Delivery charges applicable");
	                    }

	                    List<CustomerOrderReplica> customerOrderReplicas = new ArrayList<>();
	                    return customerOrderReplicas;
	                } else {
	                    return Collections.emptyList();
	                }
	            } else {
	                return null; // or an appropriate value
	            }
	        } else {
	            // Handle the case when the latest schedule is not active
	            return null; // or an appropriate value
	        }
	    } else {
	        // Handle the case when there is no latest schedule or its creation timestamp is null
	        return null; // or an appropriate value
	    }
	}

}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-09-21 15:33:41.472
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-09-21 15:33:41.473
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-21 15:33:41.555
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.xyram.daydrop.serviceimpl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.transaction.Transactional;

import org.apache.commons.collections4.map.HashedMap;
import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.server.ResponseStatusException;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.xyram.daydrop.admin.model.CurrentUser;
import com.xyram.daydrop.basemodel.Base64Wrapper;
import com.xyram.daydrop.basemodel.MerchantTransactionIdGenerator;
import com.xyram.daydrop.basemodel.PhonepeSerializer;
import com.xyram.daydrop.dao.ApartmentDao;
import com.xyram.daydrop.dao.CustomerDetailsDao;
import com.xyram.daydrop.dao.CustomerOrderDao;
import com.xyram.daydrop.dao.CustomerOrderReplicaDoa;
import com.xyram.daydrop.dao.SheduleDao;
import com.xyram.daydrop.enumtypes.UserStatus;
import com.xyram.daydrop.model.Apartments;
import com.xyram.daydrop.model.CustomerOrder;
import com.xyram.daydrop.model.CustomerOrderReplica;
import com.xyram.daydrop.model.Customers;
import com.xyram.daydrop.model.Schedule;
import com.xyram.daydrop.modelMapper.PaymentInstrument;
import com.xyram.daydrop.modelMapper.PhonePePayModel;
import com.xyram.daydrop.request.CustomerOrderReplicaRequest;
import com.xyram.daydrop.response.RazorPayRequest;
import com.xyram.daydrop.service.CustomerOrderPriceService;
import com.xyram.daydrop.service.CustomerOrderReplicaService;
import com.xyram.daydrop.util.HashEncoder;
import com.xyram.daydrop.util.RazorPay;
import com.xyram.daydrop.service.ConsumerService;

@Transactional
@Service
public class CustomerOrderReplicaServiceImpl implements CustomerOrderReplicaService {

	@Autowired
	CustomerOrderReplicaDoa customerOrderReplicaDoa;

	@Autowired
	ApartmentDao apartmentDao;

	@Autowired
	SheduleDao scheduleDao;

	@Autowired
	CustomerDetailsDao customerDetailsDao;

	@Autowired
	ConsumerService consumerService;

	@Autowired
	CurrentUser currentUser;

	@Autowired
	PhonepeServiceImpl phonepeServiceImpl;

	@Value("${merchant_id}")
	private String merchantId;

	@Value("${salt_key}")
	private String saltKey;

	@Value("${salt_index}")
	private String saltIndex;

	@Override
	public Map createCustomerOrderReplicaService(CustomerOrderReplicaRequest customerOrderReplicaRequest,
			String contactNumber, Integer aparmentId)

	{

		Map response = new HashedMap<>();

		response.put("message", "success");
		CustomerOrderReplica customerOrderReplica = null;

		if (customerOrderReplicaRequest.getCartId() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "cartId is mandatory ");
		}
		long razorPayCount = 0;
		if (customerOrderReplicaRequest.getOrderId() != null) {

			razorPayCount = customerOrderReplicaDoa.getRazorPayExistByCartId(customerOrderReplicaRequest.getOrderId());
		}

		if (customerOrderReplicaRequest.getCustomerDetails() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Order Details  is mandatory ");
		}

		customerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(customerOrderReplicaRequest.getCartId(),
				contactNumber);

		if (customerOrderReplica != null) {
			customerOrderReplica.setCartId(customerOrderReplica.getCartId());

			if (customerOrderReplica.isOrdered()) {
				throw new ResponseStatusException(HttpStatus.CONFLICT, "Your Order is Placed With cart Details");
			}

//			if (razorPayCount >= 1 && !(customerOrderReplica.getRazorPayOrderId() != null
//					&& customerOrderReplica.getRazorPayOrderId().equals(customerOrderReplicaRequest.getOrderId()))) {
//				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
//			}

			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);

			customerOrderReplica.setAttempts(customerOrderReplica.getAttempts() + 1);
			customerOrderReplica.setUpdatedTime(new Date());

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		} else {

			customerOrderReplica = new CustomerOrderReplica();
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);
			customerOrderReplica.setCartId(customerOrderReplicaRequest.getCartId());
			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());

			if (razorPayCount > 0) {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
			}

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			Schedule schedule = scheduleDao.getlatestScheduleCustomers();

			if (schedule != null) {

				try {
					customerOrderReplica.setSchedule(schedule.getsId() != null ? schedule.getsId().toString() : null);
				} catch (Exception e) {
					e.printStackTrace();
				}
			} else {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
						"Sorry We Are Not Accepting Any Order Right now");

			}

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		}

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicas(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String schedule = null;

		Map filter = request.containsKey("filters") ? (Map) request.get("filters") : null;
		if (filter != null) {
			statusType = filter.containsKey("statusType") ? ((String) filter.get("statusType")).toLowerCase() : null;
			searchQuery = filter.containsKey("searchQuery") ? ((String) filter.get("searchQuery")).toLowerCase() : null;
			schedule = filter.containsKey("schedule") ? (String.valueOf(filter.get("schedule"))) : null;

		}

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplica(searchQuery, statusType, schedule);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");

				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setStreetName(
						customers.get("streetName") != null ? (String) customers.get("streetName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicasBySchedule(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String scheduleId = null;

		Schedule schedule = scheduleDao.getlatestScheduleCustomers();

		if (schedule != null) {

			try {
				scheduleId = schedule.getsId() != null ? schedule.getsId().toString() : null;
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

		statusType = request.containsKey("statusType") ? ((String) request.get("statusType")).toLowerCase() : "Success";

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplicaBySchdeule(statusType, scheduleId);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");
				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				System.out.println("customers" + customers.get("customerName"));

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public CustomerOrderReplica getCustomerOrderReplicaByCartId(String cartId) {

		CustomerOrderReplica CustomerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(cartId,
				currentUser.getContactNumber());

		ObjectMapper objectMapper = new ObjectMapper();
		try {

			// convert JSON string to Map
			Map<String, Object> customerOrderReplicaMap = objectMapper
					.readValue(CustomerOrderReplica.getCustomerOrderDetails(), Map.class);

			Object customerOrder = customerOrderReplicaMap.get("customerOrder");
			Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

			Object quanityList = items.get("quantity");
			Map customers = customerDetailsDao.getByContactNumberAndApartment(CustomerOrderReplica.getContactNumber(),
					CustomerOrderReplica.getApartmentId());

			System.out.println("customers" + customers.get("customerName"));

			// Apartments apartments =
			// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
			CustomerOrderReplica.setApartmentName(
					customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

			CustomerOrderReplica.setCustomerDetails(customers);

			CustomerOrderReplica.setCustomerOrder(customerOrder);
			CustomerOrderReplica.setQuatityList(quanityList);

		} catch (Exception e) {
			e.printStackTrace();
		}

		return CustomerOrderReplica;

	}

	@Override
	public Map createCustomerOrderReplica(CustomerOrderReplicaRequest customerOrderReplicaRequest, String contactNumber,
			Integer aparmentId) {

		if (customerOrderReplicaRequest.getRazorPayRequest() != null) {

//			Map razorPay = consumerService.createRazorPayOrder(customerOrderReplicaRequest.getRazorPayRequest());
//			customerOrderReplicaRequest.setOrderId(razorPay.get("order") != null ? (String)((RazorPay) razorPay.get("order")).getId() : null);	
//	
//			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);
//
//			razorPay.put("cartId", customerOrderReplicaRequest.getCartId());

			Map customerOrderReplicaMap = new HashMap<>();

			Map orderId = new HashMap<>();
			String transactionId = getMerchantTransactionId();
			orderId.put("id", transactionId);

			customerOrderReplicaMap.put("order", orderId);

			customerOrderReplicaRequest.setOrderId(transactionId);
			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);

			customerOrderReplicaMap.put("cartId", customerOrderReplicaRequest.getCartId());

			try {
				customerOrderReplicaMap.put("phonePeResponse",
						phonepeServiceImpl.initiatePhonepePayment(transactionId,
								Integer.valueOf(customerOrderReplicaRequest.getRazorPayRequest().getAmount()),
								contactNumber, customerOrderReplicaRequest.getRedirectUrl(), customerOrderReplicaRequest.getCallBackUrl()));

			} catch (Exception e) {
				e.printStackTrace();
				customerOrderReplicaMap.put("phonePeResponse", new HashedMap<>());
			}

			return customerOrderReplicaMap;

		} else {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
					"paymentDetails transcation Details are mandatory");
		}

	}

	private static String getMerchantTransactionId() {

		return "OD_" + MerchantTransactionIdGenerator.getRandomString();
	}


	@Override
	public List<CustomerOrderReplica> getCustomerOrderByMoblieNo(String contactNumber, Integer aid) {

	    Schedule latestSchedule = customerOrderReplicaDoa.getlatestschedule();

	    if (latestSchedule != null && latestSchedule.getCreationTimestamp() != null) {
	        if (latestSchedule.getStatus().equals(UserStatus.ACTIVE)) {
	            Customers customer = customerDetailsDao.getByContactNoAndApartment(contactNumber, aid);

	            if (customer != null) { // Ensure the customer exists
	                List<CustomerOrder> customerOrderList = customerOrderReplicaDoa.getListCustomerOrderByCustomerId(customer.getCtId());

	                double totalOrderAmount = 0.0;

	                if (customerOrderList != null && !customerOrderList.isEmpty()) {
	                    for (CustomerOrder customerOrder : customerOrderList) {
	                        Double orderAmount = customerOrder.getAmount();
	                        if (orderAmount != null) {
	                            totalOrderAmount += orderAmount;
	                            if(totalOrderAmount>200) {
	                            	totalOrderAmount+= customerOrder.getDelivaryCharges();
	                            }
	                            else(totalOrderAmount<200){
	                            	totalOrderAmount+= customerOrder.getDelivaryCharges();
	                            }
	                        }
	                    }

	                    // Define the minimum order amount for applying delivery charges
	                    double minimumOrderAmount = 200.0;

	                    if (totalOrderAmount < minimumOrderAmount) {
	                        System.out.println("Delivery Charges will be applicable");
	                    } else {
	                        // No delivery charges applicable
	                        System.out.println("No Delivery charges applicable");
	                    }

	                    List<CustomerOrderReplica> customerOrderReplicas = new ArrayList<>();
	                    return customerOrderReplicas;
	                } else {
	                    return Collections.emptyList();
	                }
	            } else {
	                return null; // or an appropriate value
	            }
	        } else {
	            // Handle the case when the latest schedule is not active
	            return null; // or an appropriate value
	        }
	    } else {
	        // Handle the case when there is no latest schedule or its creation timestamp is null
	        return null; // or an appropriate value
	    }
	}

}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-09-21 15:33:41.558
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-09-21 15:33:41.560
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-21 15:33:43.490
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.xyram.daydrop.serviceimpl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.transaction.Transactional;

import org.apache.commons.collections4.map.HashedMap;
import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.server.ResponseStatusException;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.xyram.daydrop.admin.model.CurrentUser;
import com.xyram.daydrop.basemodel.Base64Wrapper;
import com.xyram.daydrop.basemodel.MerchantTransactionIdGenerator;
import com.xyram.daydrop.basemodel.PhonepeSerializer;
import com.xyram.daydrop.dao.ApartmentDao;
import com.xyram.daydrop.dao.CustomerDetailsDao;
import com.xyram.daydrop.dao.CustomerOrderDao;
import com.xyram.daydrop.dao.CustomerOrderReplicaDoa;
import com.xyram.daydrop.dao.SheduleDao;
import com.xyram.daydrop.enumtypes.UserStatus;
import com.xyram.daydrop.model.Apartments;
import com.xyram.daydrop.model.CustomerOrder;
import com.xyram.daydrop.model.CustomerOrderReplica;
import com.xyram.daydrop.model.Customers;
import com.xyram.daydrop.model.Schedule;
import com.xyram.daydrop.modelMapper.PaymentInstrument;
import com.xyram.daydrop.modelMapper.PhonePePayModel;
import com.xyram.daydrop.request.CustomerOrderReplicaRequest;
import com.xyram.daydrop.response.RazorPayRequest;
import com.xyram.daydrop.service.CustomerOrderPriceService;
import com.xyram.daydrop.service.CustomerOrderReplicaService;
import com.xyram.daydrop.util.HashEncoder;
import com.xyram.daydrop.util.RazorPay;
import com.xyram.daydrop.service.ConsumerService;

@Transactional
@Service
public class CustomerOrderReplicaServiceImpl implements CustomerOrderReplicaService {

	@Autowired
	CustomerOrderReplicaDoa customerOrderReplicaDoa;

	@Autowired
	ApartmentDao apartmentDao;

	@Autowired
	SheduleDao scheduleDao;

	@Autowired
	CustomerDetailsDao customerDetailsDao;

	@Autowired
	ConsumerService consumerService;

	@Autowired
	CurrentUser currentUser;

	@Autowired
	PhonepeServiceImpl phonepeServiceImpl;

	@Value("${merchant_id}")
	private String merchantId;

	@Value("${salt_key}")
	private String saltKey;

	@Value("${salt_index}")
	private String saltIndex;

	@Override
	public Map createCustomerOrderReplicaService(CustomerOrderReplicaRequest customerOrderReplicaRequest,
			String contactNumber, Integer aparmentId)

	{

		Map response = new HashedMap<>();

		response.put("message", "success");
		CustomerOrderReplica customerOrderReplica = null;

		if (customerOrderReplicaRequest.getCartId() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "cartId is mandatory ");
		}
		long razorPayCount = 0;
		if (customerOrderReplicaRequest.getOrderId() != null) {

			razorPayCount = customerOrderReplicaDoa.getRazorPayExistByCartId(customerOrderReplicaRequest.getOrderId());
		}

		if (customerOrderReplicaRequest.getCustomerDetails() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Order Details  is mandatory ");
		}

		customerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(customerOrderReplicaRequest.getCartId(),
				contactNumber);

		if (customerOrderReplica != null) {
			customerOrderReplica.setCartId(customerOrderReplica.getCartId());

			if (customerOrderReplica.isOrdered()) {
				throw new ResponseStatusException(HttpStatus.CONFLICT, "Your Order is Placed With cart Details");
			}

//			if (razorPayCount >= 1 && !(customerOrderReplica.getRazorPayOrderId() != null
//					&& customerOrderReplica.getRazorPayOrderId().equals(customerOrderReplicaRequest.getOrderId()))) {
//				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
//			}

			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);

			customerOrderReplica.setAttempts(customerOrderReplica.getAttempts() + 1);
			customerOrderReplica.setUpdatedTime(new Date());

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		} else {

			customerOrderReplica = new CustomerOrderReplica();
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);
			customerOrderReplica.setCartId(customerOrderReplicaRequest.getCartId());
			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());

			if (razorPayCount > 0) {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
			}

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			Schedule schedule = scheduleDao.getlatestScheduleCustomers();

			if (schedule != null) {

				try {
					customerOrderReplica.setSchedule(schedule.getsId() != null ? schedule.getsId().toString() : null);
				} catch (Exception e) {
					e.printStackTrace();
				}
			} else {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
						"Sorry We Are Not Accepting Any Order Right now");

			}

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		}

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicas(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String schedule = null;

		Map filter = request.containsKey("filters") ? (Map) request.get("filters") : null;
		if (filter != null) {
			statusType = filter.containsKey("statusType") ? ((String) filter.get("statusType")).toLowerCase() : null;
			searchQuery = filter.containsKey("searchQuery") ? ((String) filter.get("searchQuery")).toLowerCase() : null;
			schedule = filter.containsKey("schedule") ? (String.valueOf(filter.get("schedule"))) : null;

		}

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplica(searchQuery, statusType, schedule);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");

				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setStreetName(
						customers.get("streetName") != null ? (String) customers.get("streetName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicasBySchedule(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String scheduleId = null;

		Schedule schedule = scheduleDao.getlatestScheduleCustomers();

		if (schedule != null) {

			try {
				scheduleId = schedule.getsId() != null ? schedule.getsId().toString() : null;
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

		statusType = request.containsKey("statusType") ? ((String) request.get("statusType")).toLowerCase() : "Success";

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplicaBySchdeule(statusType, scheduleId);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");
				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				System.out.println("customers" + customers.get("customerName"));

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public CustomerOrderReplica getCustomerOrderReplicaByCartId(String cartId) {

		CustomerOrderReplica CustomerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(cartId,
				currentUser.getContactNumber());

		ObjectMapper objectMapper = new ObjectMapper();
		try {

			// convert JSON string to Map
			Map<String, Object> customerOrderReplicaMap = objectMapper
					.readValue(CustomerOrderReplica.getCustomerOrderDetails(), Map.class);

			Object customerOrder = customerOrderReplicaMap.get("customerOrder");
			Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

			Object quanityList = items.get("quantity");
			Map customers = customerDetailsDao.getByContactNumberAndApartment(CustomerOrderReplica.getContactNumber(),
					CustomerOrderReplica.getApartmentId());

			System.out.println("customers" + customers.get("customerName"));

			// Apartments apartments =
			// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
			CustomerOrderReplica.setApartmentName(
					customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

			CustomerOrderReplica.setCustomerDetails(customers);

			CustomerOrderReplica.setCustomerOrder(customerOrder);
			CustomerOrderReplica.setQuatityList(quanityList);

		} catch (Exception e) {
			e.printStackTrace();
		}

		return CustomerOrderReplica;

	}

	@Override
	public Map createCustomerOrderReplica(CustomerOrderReplicaRequest customerOrderReplicaRequest, String contactNumber,
			Integer aparmentId) {

		if (customerOrderReplicaRequest.getRazorPayRequest() != null) {

//			Map razorPay = consumerService.createRazorPayOrder(customerOrderReplicaRequest.getRazorPayRequest());
//			customerOrderReplicaRequest.setOrderId(razorPay.get("order") != null ? (String)((RazorPay) razorPay.get("order")).getId() : null);	
//	
//			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);
//
//			razorPay.put("cartId", customerOrderReplicaRequest.getCartId());

			Map customerOrderReplicaMap = new HashMap<>();

			Map orderId = new HashMap<>();
			String transactionId = getMerchantTransactionId();
			orderId.put("id", transactionId);

			customerOrderReplicaMap.put("order", orderId);

			customerOrderReplicaRequest.setOrderId(transactionId);
			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);

			customerOrderReplicaMap.put("cartId", customerOrderReplicaRequest.getCartId());

			try {
				customerOrderReplicaMap.put("phonePeResponse",
						phonepeServiceImpl.initiatePhonepePayment(transactionId,
								Integer.valueOf(customerOrderReplicaRequest.getRazorPayRequest().getAmount()),
								contactNumber, customerOrderReplicaRequest.getRedirectUrl(), customerOrderReplicaRequest.getCallBackUrl()));

			} catch (Exception e) {
				e.printStackTrace();
				customerOrderReplicaMap.put("phonePeResponse", new HashedMap<>());
			}

			return customerOrderReplicaMap;

		} else {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
					"paymentDetails transcation Details are mandatory");
		}

	}

	private static String getMerchantTransactionId() {

		return "OD_" + MerchantTransactionIdGenerator.getRandomString();
	}


	@Override
	public List<CustomerOrderReplica> getCustomerOrderByMoblieNo(String contactNumber, Integer aid) {

	    Schedule latestSchedule = customerOrderReplicaDoa.getlatestschedule();

	    if (latestSchedule != null && latestSchedule.getCreationTimestamp() != null) {
	        if (latestSchedule.getStatus().equals(UserStatus.ACTIVE)) {
	            Customers customer = customerDetailsDao.getByContactNoAndApartment(contactNumber, aid);

	            if (customer != null) { // Ensure the customer exists
	                List<CustomerOrder> customerOrderList = customerOrderReplicaDoa.getListCustomerOrderByCustomerId(customer.getCtId());

	                double totalOrderAmount = 0.0;

	                if (customerOrderList != null && !customerOrderList.isEmpty()) {
	                    for (CustomerOrder customerOrder : customerOrderList) {
	                        Double orderAmount = customerOrder.getAmount();
	                        if (orderAmount != null) {
	                            totalOrderAmount += orderAmount;
	                            if(totalOrderAmount>200) {
	                            	totalOrderAmount+= customerOrder.getDelivaryCharges();
	                            }
	                            else(totalOrderAmount<200){
	                            	totalOrderAmount= customerOrder.getDelivaryCharges();
	                            }
	                        }
	                    }

	                    // Define the minimum order amount for applying delivery charges
	                    double minimumOrderAmount = 200.0;

	                    if (totalOrderAmount < minimumOrderAmount) {
	                        System.out.println("Delivery Charges will be applicable");
	                    } else {
	                        // No delivery charges applicable
	                        System.out.println("No Delivery charges applicable");
	                    }

	                    List<CustomerOrderReplica> customerOrderReplicas = new ArrayList<>();
	                    return customerOrderReplicas;
	                } else {
	                    return Collections.emptyList();
	                }
	            } else {
	                return null; // or an appropriate value
	            }
	        } else {
	            // Handle the case when the latest schedule is not active
	            return null; // or an appropriate value
	        }
	    } else {
	        // Handle the case when there is no latest schedule or its creation timestamp is null
	        return null; // or an appropriate value
	    }
	}

}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-09-21 15:33:43.492
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-09-21 15:33:43.494
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-21 15:33:43.572
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.xyram.daydrop.serviceimpl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.transaction.Transactional;

import org.apache.commons.collections4.map.HashedMap;
import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.server.ResponseStatusException;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.xyram.daydrop.admin.model.CurrentUser;
import com.xyram.daydrop.basemodel.Base64Wrapper;
import com.xyram.daydrop.basemodel.MerchantTransactionIdGenerator;
import com.xyram.daydrop.basemodel.PhonepeSerializer;
import com.xyram.daydrop.dao.ApartmentDao;
import com.xyram.daydrop.dao.CustomerDetailsDao;
import com.xyram.daydrop.dao.CustomerOrderDao;
import com.xyram.daydrop.dao.CustomerOrderReplicaDoa;
import com.xyram.daydrop.dao.SheduleDao;
import com.xyram.daydrop.enumtypes.UserStatus;
import com.xyram.daydrop.model.Apartments;
import com.xyram.daydrop.model.CustomerOrder;
import com.xyram.daydrop.model.CustomerOrderReplica;
import com.xyram.daydrop.model.Customers;
import com.xyram.daydrop.model.Schedule;
import com.xyram.daydrop.modelMapper.PaymentInstrument;
import com.xyram.daydrop.modelMapper.PhonePePayModel;
import com.xyram.daydrop.request.CustomerOrderReplicaRequest;
import com.xyram.daydrop.response.RazorPayRequest;
import com.xyram.daydrop.service.CustomerOrderPriceService;
import com.xyram.daydrop.service.CustomerOrderReplicaService;
import com.xyram.daydrop.util.HashEncoder;
import com.xyram.daydrop.util.RazorPay;
import com.xyram.daydrop.service.ConsumerService;

@Transactional
@Service
public class CustomerOrderReplicaServiceImpl implements CustomerOrderReplicaService {

	@Autowired
	CustomerOrderReplicaDoa customerOrderReplicaDoa;

	@Autowired
	ApartmentDao apartmentDao;

	@Autowired
	SheduleDao scheduleDao;

	@Autowired
	CustomerDetailsDao customerDetailsDao;

	@Autowired
	ConsumerService consumerService;

	@Autowired
	CurrentUser currentUser;

	@Autowired
	PhonepeServiceImpl phonepeServiceImpl;

	@Value("${merchant_id}")
	private String merchantId;

	@Value("${salt_key}")
	private String saltKey;

	@Value("${salt_index}")
	private String saltIndex;

	@Override
	public Map createCustomerOrderReplicaService(CustomerOrderReplicaRequest customerOrderReplicaRequest,
			String contactNumber, Integer aparmentId)

	{

		Map response = new HashedMap<>();

		response.put("message", "success");
		CustomerOrderReplica customerOrderReplica = null;

		if (customerOrderReplicaRequest.getCartId() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "cartId is mandatory ");
		}
		long razorPayCount = 0;
		if (customerOrderReplicaRequest.getOrderId() != null) {

			razorPayCount = customerOrderReplicaDoa.getRazorPayExistByCartId(customerOrderReplicaRequest.getOrderId());
		}

		if (customerOrderReplicaRequest.getCustomerDetails() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Order Details  is mandatory ");
		}

		customerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(customerOrderReplicaRequest.getCartId(),
				contactNumber);

		if (customerOrderReplica != null) {
			customerOrderReplica.setCartId(customerOrderReplica.getCartId());

			if (customerOrderReplica.isOrdered()) {
				throw new ResponseStatusException(HttpStatus.CONFLICT, "Your Order is Placed With cart Details");
			}

//			if (razorPayCount >= 1 && !(customerOrderReplica.getRazorPayOrderId() != null
//					&& customerOrderReplica.getRazorPayOrderId().equals(customerOrderReplicaRequest.getOrderId()))) {
//				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
//			}

			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);

			customerOrderReplica.setAttempts(customerOrderReplica.getAttempts() + 1);
			customerOrderReplica.setUpdatedTime(new Date());

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		} else {

			customerOrderReplica = new CustomerOrderReplica();
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);
			customerOrderReplica.setCartId(customerOrderReplicaRequest.getCartId());
			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());

			if (razorPayCount > 0) {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
			}

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			Schedule schedule = scheduleDao.getlatestScheduleCustomers();

			if (schedule != null) {

				try {
					customerOrderReplica.setSchedule(schedule.getsId() != null ? schedule.getsId().toString() : null);
				} catch (Exception e) {
					e.printStackTrace();
				}
			} else {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
						"Sorry We Are Not Accepting Any Order Right now");

			}

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		}

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicas(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String schedule = null;

		Map filter = request.containsKey("filters") ? (Map) request.get("filters") : null;
		if (filter != null) {
			statusType = filter.containsKey("statusType") ? ((String) filter.get("statusType")).toLowerCase() : null;
			searchQuery = filter.containsKey("searchQuery") ? ((String) filter.get("searchQuery")).toLowerCase() : null;
			schedule = filter.containsKey("schedule") ? (String.valueOf(filter.get("schedule"))) : null;

		}

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplica(searchQuery, statusType, schedule);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");

				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setStreetName(
						customers.get("streetName") != null ? (String) customers.get("streetName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicasBySchedule(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String scheduleId = null;

		Schedule schedule = scheduleDao.getlatestScheduleCustomers();

		if (schedule != null) {

			try {
				scheduleId = schedule.getsId() != null ? schedule.getsId().toString() : null;
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

		statusType = request.containsKey("statusType") ? ((String) request.get("statusType")).toLowerCase() : "Success";

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplicaBySchdeule(statusType, scheduleId);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");
				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				System.out.println("customers" + customers.get("customerName"));

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public CustomerOrderReplica getCustomerOrderReplicaByCartId(String cartId) {

		CustomerOrderReplica CustomerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(cartId,
				currentUser.getContactNumber());

		ObjectMapper objectMapper = new ObjectMapper();
		try {

			// convert JSON string to Map
			Map<String, Object> customerOrderReplicaMap = objectMapper
					.readValue(CustomerOrderReplica.getCustomerOrderDetails(), Map.class);

			Object customerOrder = customerOrderReplicaMap.get("customerOrder");
			Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

			Object quanityList = items.get("quantity");
			Map customers = customerDetailsDao.getByContactNumberAndApartment(CustomerOrderReplica.getContactNumber(),
					CustomerOrderReplica.getApartmentId());

			System.out.println("customers" + customers.get("customerName"));

			// Apartments apartments =
			// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
			CustomerOrderReplica.setApartmentName(
					customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

			CustomerOrderReplica.setCustomerDetails(customers);

			CustomerOrderReplica.setCustomerOrder(customerOrder);
			CustomerOrderReplica.setQuatityList(quanityList);

		} catch (Exception e) {
			e.printStackTrace();
		}

		return CustomerOrderReplica;

	}

	@Override
	public Map createCustomerOrderReplica(CustomerOrderReplicaRequest customerOrderReplicaRequest, String contactNumber,
			Integer aparmentId) {

		if (customerOrderReplicaRequest.getRazorPayRequest() != null) {

//			Map razorPay = consumerService.createRazorPayOrder(customerOrderReplicaRequest.getRazorPayRequest());
//			customerOrderReplicaRequest.setOrderId(razorPay.get("order") != null ? (String)((RazorPay) razorPay.get("order")).getId() : null);	
//	
//			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);
//
//			razorPay.put("cartId", customerOrderReplicaRequest.getCartId());

			Map customerOrderReplicaMap = new HashMap<>();

			Map orderId = new HashMap<>();
			String transactionId = getMerchantTransactionId();
			orderId.put("id", transactionId);

			customerOrderReplicaMap.put("order", orderId);

			customerOrderReplicaRequest.setOrderId(transactionId);
			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);

			customerOrderReplicaMap.put("cartId", customerOrderReplicaRequest.getCartId());

			try {
				customerOrderReplicaMap.put("phonePeResponse",
						phonepeServiceImpl.initiatePhonepePayment(transactionId,
								Integer.valueOf(customerOrderReplicaRequest.getRazorPayRequest().getAmount()),
								contactNumber, customerOrderReplicaRequest.getRedirectUrl(), customerOrderReplicaRequest.getCallBackUrl()));

			} catch (Exception e) {
				e.printStackTrace();
				customerOrderReplicaMap.put("phonePeResponse", new HashedMap<>());
			}

			return customerOrderReplicaMap;

		} else {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
					"paymentDetails transcation Details are mandatory");
		}

	}

	private static String getMerchantTransactionId() {

		return "OD_" + MerchantTransactionIdGenerator.getRandomString();
	}


	@Override
	public List<CustomerOrderReplica> getCustomerOrderByMoblieNo(String contactNumber, Integer aid) {

	    Schedule latestSchedule = customerOrderReplicaDoa.getlatestschedule();

	    if (latestSchedule != null && latestSchedule.getCreationTimestamp() != null) {
	        if (latestSchedule.getStatus().equals(UserStatus.ACTIVE)) {
	            Customers customer = customerDetailsDao.getByContactNoAndApartment(contactNumber, aid);

	            if (customer != null) { // Ensure the customer exists
	                List<CustomerOrder> customerOrderList = customerOrderReplicaDoa.getListCustomerOrderByCustomerId(customer.getCtId());

	                double totalOrderAmount = 0.0;

	                if (customerOrderList != null && !customerOrderList.isEmpty()) {
	                    for (CustomerOrder customerOrder : customerOrderList) {
	                        Double orderAmount = customerOrder.getAmount();
	                        if (orderAmount != null) {
	                            totalOrderAmount += orderAmount;
	                            if(totalOrderAmount>200) {
	                            	totalOrderAmount+= customerOrder.getDelivaryCharges();
	                            }
	                            else(totalOrderAmount<200){
	                            	totalOrderAmount= customerOrder.getDelivaryCharges();
	                            }
	                        }
	                    }

	                    // Define the minimum order amount for applying delivery charges
	                    double minimumOrderAmount = 200.0;

	                    if (totalOrderAmount < minimumOrderAmount) {
	                        System.out.println("Delivery Charges will be applicable");
	                    } else {
	                        // No delivery charges applicable
	                        System.out.println("No Delivery charges applicable");
	                    }

	                    List<CustomerOrderReplica> customerOrderReplicas = new ArrayList<>();
	                    return customerOrderReplicas;
	                } else {
	                    return Collections.emptyList();
	                }
	            } else {
	                return null; // or an appropriate value
	            }
	        } else {
	            // Handle the case when the latest schedule is not active
	            return null; // or an appropriate value
	        }
	    } else {
	        // Handle the case when there is no latest schedule or its creation timestamp is null
	        return null; // or an appropriate value
	    }
	}

}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-09-21 15:33:43.574
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-09-21 15:33:43.576
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-21 15:33:43.946
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.xyram.daydrop.serviceimpl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.transaction.Transactional;

import org.apache.commons.collections4.map.HashedMap;
import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.server.ResponseStatusException;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.xyram.daydrop.admin.model.CurrentUser;
import com.xyram.daydrop.basemodel.Base64Wrapper;
import com.xyram.daydrop.basemodel.MerchantTransactionIdGenerator;
import com.xyram.daydrop.basemodel.PhonepeSerializer;
import com.xyram.daydrop.dao.ApartmentDao;
import com.xyram.daydrop.dao.CustomerDetailsDao;
import com.xyram.daydrop.dao.CustomerOrderDao;
import com.xyram.daydrop.dao.CustomerOrderReplicaDoa;
import com.xyram.daydrop.dao.SheduleDao;
import com.xyram.daydrop.enumtypes.UserStatus;
import com.xyram.daydrop.model.Apartments;
import com.xyram.daydrop.model.CustomerOrder;
import com.xyram.daydrop.model.CustomerOrderReplica;
import com.xyram.daydrop.model.Customers;
import com.xyram.daydrop.model.Schedule;
import com.xyram.daydrop.modelMapper.PaymentInstrument;
import com.xyram.daydrop.modelMapper.PhonePePayModel;
import com.xyram.daydrop.request.CustomerOrderReplicaRequest;
import com.xyram.daydrop.response.RazorPayRequest;
import com.xyram.daydrop.service.CustomerOrderPriceService;
import com.xyram.daydrop.service.CustomerOrderReplicaService;
import com.xyram.daydrop.util.HashEncoder;
import com.xyram.daydrop.util.RazorPay;
import com.xyram.daydrop.service.ConsumerService;

@Transactional
@Service
public class CustomerOrderReplicaServiceImpl implements CustomerOrderReplicaService {

	@Autowired
	CustomerOrderReplicaDoa customerOrderReplicaDoa;

	@Autowired
	ApartmentDao apartmentDao;

	@Autowired
	SheduleDao scheduleDao;

	@Autowired
	CustomerDetailsDao customerDetailsDao;

	@Autowired
	ConsumerService consumerService;

	@Autowired
	CurrentUser currentUser;

	@Autowired
	PhonepeServiceImpl phonepeServiceImpl;

	@Value("${merchant_id}")
	private String merchantId;

	@Value("${salt_key}")
	private String saltKey;

	@Value("${salt_index}")
	private String saltIndex;

	@Override
	public Map createCustomerOrderReplicaService(CustomerOrderReplicaRequest customerOrderReplicaRequest,
			String contactNumber, Integer aparmentId)

	{

		Map response = new HashedMap<>();

		response.put("message", "success");
		CustomerOrderReplica customerOrderReplica = null;

		if (customerOrderReplicaRequest.getCartId() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "cartId is mandatory ");
		}
		long razorPayCount = 0;
		if (customerOrderReplicaRequest.getOrderId() != null) {

			razorPayCount = customerOrderReplicaDoa.getRazorPayExistByCartId(customerOrderReplicaRequest.getOrderId());
		}

		if (customerOrderReplicaRequest.getCustomerDetails() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Order Details  is mandatory ");
		}

		customerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(customerOrderReplicaRequest.getCartId(),
				contactNumber);

		if (customerOrderReplica != null) {
			customerOrderReplica.setCartId(customerOrderReplica.getCartId());

			if (customerOrderReplica.isOrdered()) {
				throw new ResponseStatusException(HttpStatus.CONFLICT, "Your Order is Placed With cart Details");
			}

//			if (razorPayCount >= 1 && !(customerOrderReplica.getRazorPayOrderId() != null
//					&& customerOrderReplica.getRazorPayOrderId().equals(customerOrderReplicaRequest.getOrderId()))) {
//				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
//			}

			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);

			customerOrderReplica.setAttempts(customerOrderReplica.getAttempts() + 1);
			customerOrderReplica.setUpdatedTime(new Date());

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		} else {

			customerOrderReplica = new CustomerOrderReplica();
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);
			customerOrderReplica.setCartId(customerOrderReplicaRequest.getCartId());
			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());

			if (razorPayCount > 0) {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
			}

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			Schedule schedule = scheduleDao.getlatestScheduleCustomers();

			if (schedule != null) {

				try {
					customerOrderReplica.setSchedule(schedule.getsId() != null ? schedule.getsId().toString() : null);
				} catch (Exception e) {
					e.printStackTrace();
				}
			} else {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
						"Sorry We Are Not Accepting Any Order Right now");

			}

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		}

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicas(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String schedule = null;

		Map filter = request.containsKey("filters") ? (Map) request.get("filters") : null;
		if (filter != null) {
			statusType = filter.containsKey("statusType") ? ((String) filter.get("statusType")).toLowerCase() : null;
			searchQuery = filter.containsKey("searchQuery") ? ((String) filter.get("searchQuery")).toLowerCase() : null;
			schedule = filter.containsKey("schedule") ? (String.valueOf(filter.get("schedule"))) : null;

		}

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplica(searchQuery, statusType, schedule);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");

				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setStreetName(
						customers.get("streetName") != null ? (String) customers.get("streetName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicasBySchedule(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String scheduleId = null;

		Schedule schedule = scheduleDao.getlatestScheduleCustomers();

		if (schedule != null) {

			try {
				scheduleId = schedule.getsId() != null ? schedule.getsId().toString() : null;
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

		statusType = request.containsKey("statusType") ? ((String) request.get("statusType")).toLowerCase() : "Success";

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplicaBySchdeule(statusType, scheduleId);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");
				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				System.out.println("customers" + customers.get("customerName"));

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public CustomerOrderReplica getCustomerOrderReplicaByCartId(String cartId) {

		CustomerOrderReplica CustomerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(cartId,
				currentUser.getContactNumber());

		ObjectMapper objectMapper = new ObjectMapper();
		try {

			// convert JSON string to Map
			Map<String, Object> customerOrderReplicaMap = objectMapper
					.readValue(CustomerOrderReplica.getCustomerOrderDetails(), Map.class);

			Object customerOrder = customerOrderReplicaMap.get("customerOrder");
			Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

			Object quanityList = items.get("quantity");
			Map customers = customerDetailsDao.getByContactNumberAndApartment(CustomerOrderReplica.getContactNumber(),
					CustomerOrderReplica.getApartmentId());

			System.out.println("customers" + customers.get("customerName"));

			// Apartments apartments =
			// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
			CustomerOrderReplica.setApartmentName(
					customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

			CustomerOrderReplica.setCustomerDetails(customers);

			CustomerOrderReplica.setCustomerOrder(customerOrder);
			CustomerOrderReplica.setQuatityList(quanityList);

		} catch (Exception e) {
			e.printStackTrace();
		}

		return CustomerOrderReplica;

	}

	@Override
	public Map createCustomerOrderReplica(CustomerOrderReplicaRequest customerOrderReplicaRequest, String contactNumber,
			Integer aparmentId) {

		if (customerOrderReplicaRequest.getRazorPayRequest() != null) {

//			Map razorPay = consumerService.createRazorPayOrder(customerOrderReplicaRequest.getRazorPayRequest());
//			customerOrderReplicaRequest.setOrderId(razorPay.get("order") != null ? (String)((RazorPay) razorPay.get("order")).getId() : null);	
//	
//			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);
//
//			razorPay.put("cartId", customerOrderReplicaRequest.getCartId());

			Map customerOrderReplicaMap = new HashMap<>();

			Map orderId = new HashMap<>();
			String transactionId = getMerchantTransactionId();
			orderId.put("id", transactionId);

			customerOrderReplicaMap.put("order", orderId);

			customerOrderReplicaRequest.setOrderId(transactionId);
			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);

			customerOrderReplicaMap.put("cartId", customerOrderReplicaRequest.getCartId());

			try {
				customerOrderReplicaMap.put("phonePeResponse",
						phonepeServiceImpl.initiatePhonepePayment(transactionId,
								Integer.valueOf(customerOrderReplicaRequest.getRazorPayRequest().getAmount()),
								contactNumber, customerOrderReplicaRequest.getRedirectUrl(), customerOrderReplicaRequest.getCallBackUrl()));

			} catch (Exception e) {
				e.printStackTrace();
				customerOrderReplicaMap.put("phonePeResponse", new HashedMap<>());
			}

			return customerOrderReplicaMap;

		} else {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
					"paymentDetails transcation Details are mandatory");
		}

	}

	private static String getMerchantTransactionId() {

		return "OD_" + MerchantTransactionIdGenerator.getRandomString();
	}


	@Override
	public List<CustomerOrderReplica> getCustomerOrderByMoblieNo(String contactNumber, Integer aid) {

	    Schedule latestSchedule = customerOrderReplicaDoa.getlatestschedule();

	    if (latestSchedule != null && latestSchedule.getCreationTimestamp() != null) {
	        if (latestSchedule.getStatus().equals(UserStatus.ACTIVE)) {
	            Customers customer = customerDetailsDao.getByContactNoAndApartment(contactNumber, aid);

	            if (customer != null) { // Ensure the customer exists
	                List<CustomerOrder> customerOrderList = customerOrderReplicaDoa.getListCustomerOrderByCustomerId(customer.getCtId());

	                double totalOrderAmount = 0.0;

	                if (customerOrderList != null && !customerOrderList.isEmpty()) {
	                    for (CustomerOrder customerOrder : customerOrderList) {
	                        Double orderAmount = customerOrder.getAmount();
	                        if (orderAmount != null) {
	                            totalOrderAmount += orderAmount;
	                            if(totalOrderAmount>200) {
	                            	totalOrderAmount+= customerOrder.getDelivaryCharges();
	                            }
	                            else(totalOrderAmount<200){
	                            	totalOrderAmount-= customerOrder.getDelivaryCharges();
	                            }
	                        }
	                    }

	                    // Define the minimum order amount for applying delivery charges
	                    double minimumOrderAmount = 200.0;

	                    if (totalOrderAmount < minimumOrderAmount) {
	                        System.out.println("Delivery Charges will be applicable");
	                    } else {
	                        // No delivery charges applicable
	                        System.out.println("No Delivery charges applicable");
	                    }

	                    List<CustomerOrderReplica> customerOrderReplicas = new ArrayList<>();
	                    return customerOrderReplicas;
	                } else {
	                    return Collections.emptyList();
	                }
	            } else {
	                return null; // or an appropriate value
	            }
	        } else {
	            // Handle the case when the latest schedule is not active
	            return null; // or an appropriate value
	        }
	    } else {
	        // Handle the case when there is no latest schedule or its creation timestamp is null
	        return null; // or an appropriate value
	    }
	}

}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-09-21 15:33:43.949
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-09-21 15:33:43.951
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-21 15:33:44.041
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.xyram.daydrop.serviceimpl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.transaction.Transactional;

import org.apache.commons.collections4.map.HashedMap;
import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.server.ResponseStatusException;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.xyram.daydrop.admin.model.CurrentUser;
import com.xyram.daydrop.basemodel.Base64Wrapper;
import com.xyram.daydrop.basemodel.MerchantTransactionIdGenerator;
import com.xyram.daydrop.basemodel.PhonepeSerializer;
import com.xyram.daydrop.dao.ApartmentDao;
import com.xyram.daydrop.dao.CustomerDetailsDao;
import com.xyram.daydrop.dao.CustomerOrderDao;
import com.xyram.daydrop.dao.CustomerOrderReplicaDoa;
import com.xyram.daydrop.dao.SheduleDao;
import com.xyram.daydrop.enumtypes.UserStatus;
import com.xyram.daydrop.model.Apartments;
import com.xyram.daydrop.model.CustomerOrder;
import com.xyram.daydrop.model.CustomerOrderReplica;
import com.xyram.daydrop.model.Customers;
import com.xyram.daydrop.model.Schedule;
import com.xyram.daydrop.modelMapper.PaymentInstrument;
import com.xyram.daydrop.modelMapper.PhonePePayModel;
import com.xyram.daydrop.request.CustomerOrderReplicaRequest;
import com.xyram.daydrop.response.RazorPayRequest;
import com.xyram.daydrop.service.CustomerOrderPriceService;
import com.xyram.daydrop.service.CustomerOrderReplicaService;
import com.xyram.daydrop.util.HashEncoder;
import com.xyram.daydrop.util.RazorPay;
import com.xyram.daydrop.service.ConsumerService;

@Transactional
@Service
public class CustomerOrderReplicaServiceImpl implements CustomerOrderReplicaService {

	@Autowired
	CustomerOrderReplicaDoa customerOrderReplicaDoa;

	@Autowired
	ApartmentDao apartmentDao;

	@Autowired
	SheduleDao scheduleDao;

	@Autowired
	CustomerDetailsDao customerDetailsDao;

	@Autowired
	ConsumerService consumerService;

	@Autowired
	CurrentUser currentUser;

	@Autowired
	PhonepeServiceImpl phonepeServiceImpl;

	@Value("${merchant_id}")
	private String merchantId;

	@Value("${salt_key}")
	private String saltKey;

	@Value("${salt_index}")
	private String saltIndex;

	@Override
	public Map createCustomerOrderReplicaService(CustomerOrderReplicaRequest customerOrderReplicaRequest,
			String contactNumber, Integer aparmentId)

	{

		Map response = new HashedMap<>();

		response.put("message", "success");
		CustomerOrderReplica customerOrderReplica = null;

		if (customerOrderReplicaRequest.getCartId() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "cartId is mandatory ");
		}
		long razorPayCount = 0;
		if (customerOrderReplicaRequest.getOrderId() != null) {

			razorPayCount = customerOrderReplicaDoa.getRazorPayExistByCartId(customerOrderReplicaRequest.getOrderId());
		}

		if (customerOrderReplicaRequest.getCustomerDetails() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Order Details  is mandatory ");
		}

		customerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(customerOrderReplicaRequest.getCartId(),
				contactNumber);

		if (customerOrderReplica != null) {
			customerOrderReplica.setCartId(customerOrderReplica.getCartId());

			if (customerOrderReplica.isOrdered()) {
				throw new ResponseStatusException(HttpStatus.CONFLICT, "Your Order is Placed With cart Details");
			}

//			if (razorPayCount >= 1 && !(customerOrderReplica.getRazorPayOrderId() != null
//					&& customerOrderReplica.getRazorPayOrderId().equals(customerOrderReplicaRequest.getOrderId()))) {
//				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
//			}

			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);

			customerOrderReplica.setAttempts(customerOrderReplica.getAttempts() + 1);
			customerOrderReplica.setUpdatedTime(new Date());

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		} else {

			customerOrderReplica = new CustomerOrderReplica();
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);
			customerOrderReplica.setCartId(customerOrderReplicaRequest.getCartId());
			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());

			if (razorPayCount > 0) {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
			}

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			Schedule schedule = scheduleDao.getlatestScheduleCustomers();

			if (schedule != null) {

				try {
					customerOrderReplica.setSchedule(schedule.getsId() != null ? schedule.getsId().toString() : null);
				} catch (Exception e) {
					e.printStackTrace();
				}
			} else {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
						"Sorry We Are Not Accepting Any Order Right now");

			}

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		}

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicas(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String schedule = null;

		Map filter = request.containsKey("filters") ? (Map) request.get("filters") : null;
		if (filter != null) {
			statusType = filter.containsKey("statusType") ? ((String) filter.get("statusType")).toLowerCase() : null;
			searchQuery = filter.containsKey("searchQuery") ? ((String) filter.get("searchQuery")).toLowerCase() : null;
			schedule = filter.containsKey("schedule") ? (String.valueOf(filter.get("schedule"))) : null;

		}

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplica(searchQuery, statusType, schedule);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");

				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setStreetName(
						customers.get("streetName") != null ? (String) customers.get("streetName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicasBySchedule(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String scheduleId = null;

		Schedule schedule = scheduleDao.getlatestScheduleCustomers();

		if (schedule != null) {

			try {
				scheduleId = schedule.getsId() != null ? schedule.getsId().toString() : null;
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

		statusType = request.containsKey("statusType") ? ((String) request.get("statusType")).toLowerCase() : "Success";

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplicaBySchdeule(statusType, scheduleId);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");
				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				System.out.println("customers" + customers.get("customerName"));

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public CustomerOrderReplica getCustomerOrderReplicaByCartId(String cartId) {

		CustomerOrderReplica CustomerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(cartId,
				currentUser.getContactNumber());

		ObjectMapper objectMapper = new ObjectMapper();
		try {

			// convert JSON string to Map
			Map<String, Object> customerOrderReplicaMap = objectMapper
					.readValue(CustomerOrderReplica.getCustomerOrderDetails(), Map.class);

			Object customerOrder = customerOrderReplicaMap.get("customerOrder");
			Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

			Object quanityList = items.get("quantity");
			Map customers = customerDetailsDao.getByContactNumberAndApartment(CustomerOrderReplica.getContactNumber(),
					CustomerOrderReplica.getApartmentId());

			System.out.println("customers" + customers.get("customerName"));

			// Apartments apartments =
			// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
			CustomerOrderReplica.setApartmentName(
					customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

			CustomerOrderReplica.setCustomerDetails(customers);

			CustomerOrderReplica.setCustomerOrder(customerOrder);
			CustomerOrderReplica.setQuatityList(quanityList);

		} catch (Exception e) {
			e.printStackTrace();
		}

		return CustomerOrderReplica;

	}

	@Override
	public Map createCustomerOrderReplica(CustomerOrderReplicaRequest customerOrderReplicaRequest, String contactNumber,
			Integer aparmentId) {

		if (customerOrderReplicaRequest.getRazorPayRequest() != null) {

//			Map razorPay = consumerService.createRazorPayOrder(customerOrderReplicaRequest.getRazorPayRequest());
//			customerOrderReplicaRequest.setOrderId(razorPay.get("order") != null ? (String)((RazorPay) razorPay.get("order")).getId() : null);	
//	
//			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);
//
//			razorPay.put("cartId", customerOrderReplicaRequest.getCartId());

			Map customerOrderReplicaMap = new HashMap<>();

			Map orderId = new HashMap<>();
			String transactionId = getMerchantTransactionId();
			orderId.put("id", transactionId);

			customerOrderReplicaMap.put("order", orderId);

			customerOrderReplicaRequest.setOrderId(transactionId);
			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);

			customerOrderReplicaMap.put("cartId", customerOrderReplicaRequest.getCartId());

			try {
				customerOrderReplicaMap.put("phonePeResponse",
						phonepeServiceImpl.initiatePhonepePayment(transactionId,
								Integer.valueOf(customerOrderReplicaRequest.getRazorPayRequest().getAmount()),
								contactNumber, customerOrderReplicaRequest.getRedirectUrl(), customerOrderReplicaRequest.getCallBackUrl()));

			} catch (Exception e) {
				e.printStackTrace();
				customerOrderReplicaMap.put("phonePeResponse", new HashedMap<>());
			}

			return customerOrderReplicaMap;

		} else {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
					"paymentDetails transcation Details are mandatory");
		}

	}

	private static String getMerchantTransactionId() {

		return "OD_" + MerchantTransactionIdGenerator.getRandomString();
	}


	@Override
	public List<CustomerOrderReplica> getCustomerOrderByMoblieNo(String contactNumber, Integer aid) {

	    Schedule latestSchedule = customerOrderReplicaDoa.getlatestschedule();

	    if (latestSchedule != null && latestSchedule.getCreationTimestamp() != null) {
	        if (latestSchedule.getStatus().equals(UserStatus.ACTIVE)) {
	            Customers customer = customerDetailsDao.getByContactNoAndApartment(contactNumber, aid);

	            if (customer != null) { // Ensure the customer exists
	                List<CustomerOrder> customerOrderList = customerOrderReplicaDoa.getListCustomerOrderByCustomerId(customer.getCtId());

	                double totalOrderAmount = 0.0;

	                if (customerOrderList != null && !customerOrderList.isEmpty()) {
	                    for (CustomerOrder customerOrder : customerOrderList) {
	                        Double orderAmount = customerOrder.getAmount();
	                        if (orderAmount != null) {
	                            totalOrderAmount += orderAmount;
	                            if(totalOrderAmount>200) {
	                            	totalOrderAmount+= customerOrder.getDelivaryCharges();
	                            }
	                            else(totalOrderAmount<200){
	                            	totalOrderAmount-= customerOrder.getDelivaryCharges();
	                            }
	                        }
	                    }

	                    // Define the minimum order amount for applying delivery charges
	                    double minimumOrderAmount = 200.0;

	                    if (totalOrderAmount < minimumOrderAmount) {
	                        System.out.println("Delivery Charges will be applicable");
	                    } else {
	                        // No delivery charges applicable
	                        System.out.println("No Delivery charges applicable");
	                    }

	                    List<CustomerOrderReplica> customerOrderReplicas = new ArrayList<>();
	                    return customerOrderReplicas;
	                } else {
	                    return Collections.emptyList();
	                }
	            } else {
	                return null; // or an appropriate value
	            }
	        } else {
	            // Handle the case when the latest schedule is not active
	            return null; // or an appropriate value
	        }
	    } else {
	        // Handle the case when there is no latest schedule or its creation timestamp is null
	        return null; // or an appropriate value
	    }
	}

}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-09-21 15:33:44.044
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-09-21 15:33:44.046
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-21 15:33:45.862
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.xyram.daydrop.serviceimpl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.transaction.Transactional;

import org.apache.commons.collections4.map.HashedMap;
import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.server.ResponseStatusException;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.xyram.daydrop.admin.model.CurrentUser;
import com.xyram.daydrop.basemodel.Base64Wrapper;
import com.xyram.daydrop.basemodel.MerchantTransactionIdGenerator;
import com.xyram.daydrop.basemodel.PhonepeSerializer;
import com.xyram.daydrop.dao.ApartmentDao;
import com.xyram.daydrop.dao.CustomerDetailsDao;
import com.xyram.daydrop.dao.CustomerOrderDao;
import com.xyram.daydrop.dao.CustomerOrderReplicaDoa;
import com.xyram.daydrop.dao.SheduleDao;
import com.xyram.daydrop.enumtypes.UserStatus;
import com.xyram.daydrop.model.Apartments;
import com.xyram.daydrop.model.CustomerOrder;
import com.xyram.daydrop.model.CustomerOrderReplica;
import com.xyram.daydrop.model.Customers;
import com.xyram.daydrop.model.Schedule;
import com.xyram.daydrop.modelMapper.PaymentInstrument;
import com.xyram.daydrop.modelMapper.PhonePePayModel;
import com.xyram.daydrop.request.CustomerOrderReplicaRequest;
import com.xyram.daydrop.response.RazorPayRequest;
import com.xyram.daydrop.service.CustomerOrderPriceService;
import com.xyram.daydrop.service.CustomerOrderReplicaService;
import com.xyram.daydrop.util.HashEncoder;
import com.xyram.daydrop.util.RazorPay;
import com.xyram.daydrop.service.ConsumerService;

@Transactional
@Service
public class CustomerOrderReplicaServiceImpl implements CustomerOrderReplicaService {

	@Autowired
	CustomerOrderReplicaDoa customerOrderReplicaDoa;

	@Autowired
	ApartmentDao apartmentDao;

	@Autowired
	SheduleDao scheduleDao;

	@Autowired
	CustomerDetailsDao customerDetailsDao;

	@Autowired
	ConsumerService consumerService;

	@Autowired
	CurrentUser currentUser;

	@Autowired
	PhonepeServiceImpl phonepeServiceImpl;

	@Value("${merchant_id}")
	private String merchantId;

	@Value("${salt_key}")
	private String saltKey;

	@Value("${salt_index}")
	private String saltIndex;

	@Override
	public Map createCustomerOrderReplicaService(CustomerOrderReplicaRequest customerOrderReplicaRequest,
			String contactNumber, Integer aparmentId)

	{

		Map response = new HashedMap<>();

		response.put("message", "success");
		CustomerOrderReplica customerOrderReplica = null;

		if (customerOrderReplicaRequest.getCartId() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "cartId is mandatory ");
		}
		long razorPayCount = 0;
		if (customerOrderReplicaRequest.getOrderId() != null) {

			razorPayCount = customerOrderReplicaDoa.getRazorPayExistByCartId(customerOrderReplicaRequest.getOrderId());
		}

		if (customerOrderReplicaRequest.getCustomerDetails() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Order Details  is mandatory ");
		}

		customerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(customerOrderReplicaRequest.getCartId(),
				contactNumber);

		if (customerOrderReplica != null) {
			customerOrderReplica.setCartId(customerOrderReplica.getCartId());

			if (customerOrderReplica.isOrdered()) {
				throw new ResponseStatusException(HttpStatus.CONFLICT, "Your Order is Placed With cart Details");
			}

//			if (razorPayCount >= 1 && !(customerOrderReplica.getRazorPayOrderId() != null
//					&& customerOrderReplica.getRazorPayOrderId().equals(customerOrderReplicaRequest.getOrderId()))) {
//				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
//			}

			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);

			customerOrderReplica.setAttempts(customerOrderReplica.getAttempts() + 1);
			customerOrderReplica.setUpdatedTime(new Date());

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		} else {

			customerOrderReplica = new CustomerOrderReplica();
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);
			customerOrderReplica.setCartId(customerOrderReplicaRequest.getCartId());
			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());

			if (razorPayCount > 0) {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
			}

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			Schedule schedule = scheduleDao.getlatestScheduleCustomers();

			if (schedule != null) {

				try {
					customerOrderReplica.setSchedule(schedule.getsId() != null ? schedule.getsId().toString() : null);
				} catch (Exception e) {
					e.printStackTrace();
				}
			} else {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
						"Sorry We Are Not Accepting Any Order Right now");

			}

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		}

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicas(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String schedule = null;

		Map filter = request.containsKey("filters") ? (Map) request.get("filters") : null;
		if (filter != null) {
			statusType = filter.containsKey("statusType") ? ((String) filter.get("statusType")).toLowerCase() : null;
			searchQuery = filter.containsKey("searchQuery") ? ((String) filter.get("searchQuery")).toLowerCase() : null;
			schedule = filter.containsKey("schedule") ? (String.valueOf(filter.get("schedule"))) : null;

		}

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplica(searchQuery, statusType, schedule);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");

				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setStreetName(
						customers.get("streetName") != null ? (String) customers.get("streetName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicasBySchedule(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String scheduleId = null;

		Schedule schedule = scheduleDao.getlatestScheduleCustomers();

		if (schedule != null) {

			try {
				scheduleId = schedule.getsId() != null ? schedule.getsId().toString() : null;
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

		statusType = request.containsKey("statusType") ? ((String) request.get("statusType")).toLowerCase() : "Success";

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplicaBySchdeule(statusType, scheduleId);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");
				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				System.out.println("customers" + customers.get("customerName"));

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public CustomerOrderReplica getCustomerOrderReplicaByCartId(String cartId) {

		CustomerOrderReplica CustomerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(cartId,
				currentUser.getContactNumber());

		ObjectMapper objectMapper = new ObjectMapper();
		try {

			// convert JSON string to Map
			Map<String, Object> customerOrderReplicaMap = objectMapper
					.readValue(CustomerOrderReplica.getCustomerOrderDetails(), Map.class);

			Object customerOrder = customerOrderReplicaMap.get("customerOrder");
			Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

			Object quanityList = items.get("quantity");
			Map customers = customerDetailsDao.getByContactNumberAndApartment(CustomerOrderReplica.getContactNumber(),
					CustomerOrderReplica.getApartmentId());

			System.out.println("customers" + customers.get("customerName"));

			// Apartments apartments =
			// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
			CustomerOrderReplica.setApartmentName(
					customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

			CustomerOrderReplica.setCustomerDetails(customers);

			CustomerOrderReplica.setCustomerOrder(customerOrder);
			CustomerOrderReplica.setQuatityList(quanityList);

		} catch (Exception e) {
			e.printStackTrace();
		}

		return CustomerOrderReplica;

	}

	@Override
	public Map createCustomerOrderReplica(CustomerOrderReplicaRequest customerOrderReplicaRequest, String contactNumber,
			Integer aparmentId) {

		if (customerOrderReplicaRequest.getRazorPayRequest() != null) {

//			Map razorPay = consumerService.createRazorPayOrder(customerOrderReplicaRequest.getRazorPayRequest());
//			customerOrderReplicaRequest.setOrderId(razorPay.get("order") != null ? (String)((RazorPay) razorPay.get("order")).getId() : null);	
//	
//			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);
//
//			razorPay.put("cartId", customerOrderReplicaRequest.getCartId());

			Map customerOrderReplicaMap = new HashMap<>();

			Map orderId = new HashMap<>();
			String transactionId = getMerchantTransactionId();
			orderId.put("id", transactionId);

			customerOrderReplicaMap.put("order", orderId);

			customerOrderReplicaRequest.setOrderId(transactionId);
			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);

			customerOrderReplicaMap.put("cartId", customerOrderReplicaRequest.getCartId());

			try {
				customerOrderReplicaMap.put("phonePeResponse",
						phonepeServiceImpl.initiatePhonepePayment(transactionId,
								Integer.valueOf(customerOrderReplicaRequest.getRazorPayRequest().getAmount()),
								contactNumber, customerOrderReplicaRequest.getRedirectUrl(), customerOrderReplicaRequest.getCallBackUrl()));

			} catch (Exception e) {
				e.printStackTrace();
				customerOrderReplicaMap.put("phonePeResponse", new HashedMap<>());
			}

			return customerOrderReplicaMap;

		} else {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
					"paymentDetails transcation Details are mandatory");
		}

	}

	private static String getMerchantTransactionId() {

		return "OD_" + MerchantTransactionIdGenerator.getRandomString();
	}


	@Override
	public List<CustomerOrderReplica> getCustomerOrderByMoblieNo(String contactNumber, Integer aid) {

	    Schedule latestSchedule = customerOrderReplicaDoa.getlatestschedule();

	    if (latestSchedule != null && latestSchedule.getCreationTimestamp() != null) {
	        if (latestSchedule.getStatus().equals(UserStatus.ACTIVE)) {
	            Customers customer = customerDetailsDao.getByContactNoAndApartment(contactNumber, aid);

	            if (customer != null) { // Ensure the customer exists
	                List<CustomerOrder> customerOrderList = customerOrderReplicaDoa.getListCustomerOrderByCustomerId(customer.getCtId());

	                double totalOrderAmount = 0.0;

	                if (customerOrderList != null && !customerOrderList.isEmpty()) {
	                    for (CustomerOrder customerOrder : customerOrderList) {
	                        Double orderAmount = customerOrder.getAmount();
	                        if (orderAmount != null) {
	                            totalOrderAmount += orderAmount;
	                            if(totalOrderAmount>200) {
	                            	totalOrderAmount+= customerOrder.getDelivaryCharges();
	                            }
	                            else(totalOrderAmount<200){
	                            	totalOrderAmount-= customerOrder.getDelivaryCharges();
	                            }
	                        }
	                    }

	                    // Define the minimum order amount for applying delivery charges
	                    double minimumOrderAmount = 200.0;

	                    if (totalOrderAmount < minimumOrderAmount) {
	                        System.out.println("Delivery Charges will be applicable");
	                    } else {
	                        // No delivery charges applicable
	                        System.out.println("No Delivery charges applicable");
	                    }

	                    List<CustomerOrderReplica> customerOrderReplicas = new ArrayList<>();
	                    return customerOrderReplicas;
	                } else {
	                    return Collections.emptyList();
	                }
	            } else {
	                return null; // or an appropriate value
	            }
	        } else {
	            // Handle the case when the latest schedule is not active
	            return null; // or an appropriate value
	        }
	    } else {
	        // Handle the case when there is no latest schedule or its creation timestamp is null
	        return null; // or an appropriate value
	    }
	}

}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.debug.ui.BreakpointMarkerUpdater.updateMarker(BreakpointMarkerUpdater.java:112)
	at org.eclipse.ui.texteditor.AbstractMarkerAnnotationModel.updateMarker(AbstractMarkerAnnotationModel.java:578)
	at org.eclipse.ui.texteditor.AbstractMarkerAnnotationModel.updateMarkers(AbstractMarkerAnnotationModel.java:638)
	at org.eclipse.ui.texteditor.AbstractMarkerAnnotationModel.commit(AbstractMarkerAnnotationModel.java:701)
	at org.eclipse.core.internal.filebuffers.ResourceTextFileBuffer.commitFileBufferContent(ResourceTextFileBuffer.java:368)
	at org.eclipse.core.internal.filebuffers.ResourceFileBuffer.commit(ResourceFileBuffer.java:317)
	at org.eclipse.jdt.internal.ui.javaeditor.DocumentAdapter.save(DocumentAdapter.java:516)
	at org.eclipse.jdt.internal.core.CommitWorkingCopyOperation.executeOperation(CommitWorkingCopyOperation.java:127)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2315)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2340)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:811)
	at org.eclipse.jdt.internal.core.CompilationUnit.commitWorkingCopy(CompilationUnit.java:405)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitDocumentProvider.commitWorkingCopy(CompilationUnitDocumentProvider.java:1418)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitDocumentProvider$3.execute(CompilationUnitDocumentProvider.java:1495)
	at org.eclipse.ui.editors.text.TextFileDocumentProvider$DocumentProviderOperation.run(TextFileDocumentProvider.java:133)
	at org.eclipse.ui.actions.WorkspaceModifyDelegatingOperation.execute(WorkspaceModifyDelegatingOperation.java:71)
	at org.eclipse.ui.actions.WorkspaceModifyOperation.lambda$0(WorkspaceModifyOperation.java:110)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2315)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2340)
	at org.eclipse.ui.actions.WorkspaceModifyOperation.run(WorkspaceModifyOperation.java:131)
	at org.eclipse.ui.internal.editors.text.WorkspaceOperationRunner.run(WorkspaceOperationRunner.java:76)
	at org.eclipse.ui.internal.editors.text.WorkspaceOperationRunner.run(WorkspaceOperationRunner.java:66)
	at org.eclipse.ui.editors.text.TextFileDocumentProvider.executeOperation(TextFileDocumentProvider.java:461)
	at org.eclipse.ui.editors.text.TextFileDocumentProvider.saveDocument(TextFileDocumentProvider.java:764)
	at org.eclipse.ui.texteditor.AbstractTextEditor.performSave(AbstractTextEditor.java:4996)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor.performSave(CompilationUnitEditor.java:1263)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor.doSave(CompilationUnitEditor.java:1317)
	at org.eclipse.ui.texteditor.AbstractTextEditor$TextEditorSavable.doSave(AbstractTextEditor.java:7162)
	at org.eclipse.ui.Saveable.doSave(Saveable.java:213)
	at org.eclipse.ui.internal.SaveableHelper.doSaveModel(SaveableHelper.java:333)
	at org.eclipse.ui.internal.SaveableHelper.lambda$1(SaveableHelper.java:196)
	at org.eclipse.ui.internal.SaveableHelper.lambda$3(SaveableHelper.java:271)
	at org.eclipse.jface.operation.ModalContext.runInCurrentThread(ModalContext.java:434)
	at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:352)
	at org.eclipse.ui.internal.WorkbenchWindow.lambda$7(WorkbenchWindow.java:2345)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.ui.internal.WorkbenchWindow.run(WorkbenchWindow.java:2343)
	at org.eclipse.ui.internal.SaveableHelper.runProgressMonitorOperation(SaveableHelper.java:278)
	at org.eclipse.ui.internal.SaveableHelper.runProgressMonitorOperation(SaveableHelper.java:260)
	at org.eclipse.ui.internal.SaveableHelper.saveModels(SaveableHelper.java:207)
	at org.eclipse.ui.internal.SaveableHelper.savePart(SaveableHelper.java:150)
	at org.eclipse.ui.internal.WorkbenchPage.saveSaveable(WorkbenchPage.java:3799)
	at org.eclipse.ui.internal.WorkbenchPage.saveEditor(WorkbenchPage.java:3812)
	at org.eclipse.ui.internal.handlers.SaveHandler.execute(SaveHandler.java:82)
	at org.eclipse.ui.internal.handlers.HandlerProxy.execute(HandlerProxy.java:283)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:97)
	at jdk.internal.reflect.GeneratedMethodAccessor79.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:317)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:251)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:173)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:156)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:488)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:487)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:213)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:308)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:580)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:647)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:439)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:96)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1280)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1062)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1087)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1072)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1114)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1110)
	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1539)
	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4868)
	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:345)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4746)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5015)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3630)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-09-21 15:33:45.864
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.debug.ui.BreakpointMarkerUpdater.updateMarker(BreakpointMarkerUpdater.java:112)
	at org.eclipse.ui.texteditor.AbstractMarkerAnnotationModel.updateMarker(AbstractMarkerAnnotationModel.java:578)
	at org.eclipse.ui.texteditor.AbstractMarkerAnnotationModel.updateMarkers(AbstractMarkerAnnotationModel.java:638)
	at org.eclipse.ui.texteditor.AbstractMarkerAnnotationModel.commit(AbstractMarkerAnnotationModel.java:701)
	at org.eclipse.core.internal.filebuffers.ResourceTextFileBuffer.commitFileBufferContent(ResourceTextFileBuffer.java:368)
	at org.eclipse.core.internal.filebuffers.ResourceFileBuffer.commit(ResourceFileBuffer.java:317)
	at org.eclipse.jdt.internal.ui.javaeditor.DocumentAdapter.save(DocumentAdapter.java:516)
	at org.eclipse.jdt.internal.core.CommitWorkingCopyOperation.executeOperation(CommitWorkingCopyOperation.java:127)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2315)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2340)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:811)
	at org.eclipse.jdt.internal.core.CompilationUnit.commitWorkingCopy(CompilationUnit.java:405)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitDocumentProvider.commitWorkingCopy(CompilationUnitDocumentProvider.java:1418)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitDocumentProvider$3.execute(CompilationUnitDocumentProvider.java:1495)
	at org.eclipse.ui.editors.text.TextFileDocumentProvider$DocumentProviderOperation.run(TextFileDocumentProvider.java:133)
	at org.eclipse.ui.actions.WorkspaceModifyDelegatingOperation.execute(WorkspaceModifyDelegatingOperation.java:71)
	at org.eclipse.ui.actions.WorkspaceModifyOperation.lambda$0(WorkspaceModifyOperation.java:110)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2315)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2340)
	at org.eclipse.ui.actions.WorkspaceModifyOperation.run(WorkspaceModifyOperation.java:131)
	at org.eclipse.ui.internal.editors.text.WorkspaceOperationRunner.run(WorkspaceOperationRunner.java:76)
	at org.eclipse.ui.internal.editors.text.WorkspaceOperationRunner.run(WorkspaceOperationRunner.java:66)
	at org.eclipse.ui.editors.text.TextFileDocumentProvider.executeOperation(TextFileDocumentProvider.java:461)
	at org.eclipse.ui.editors.text.TextFileDocumentProvider.saveDocument(TextFileDocumentProvider.java:764)
	at org.eclipse.ui.texteditor.AbstractTextEditor.performSave(AbstractTextEditor.java:4996)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor.performSave(CompilationUnitEditor.java:1263)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor.doSave(CompilationUnitEditor.java:1317)
	at org.eclipse.ui.texteditor.AbstractTextEditor$TextEditorSavable.doSave(AbstractTextEditor.java:7162)
	at org.eclipse.ui.Saveable.doSave(Saveable.java:213)
	at org.eclipse.ui.internal.SaveableHelper.doSaveModel(SaveableHelper.java:333)
	at org.eclipse.ui.internal.SaveableHelper.lambda$1(SaveableHelper.java:196)
	at org.eclipse.ui.internal.SaveableHelper.lambda$3(SaveableHelper.java:271)
	at org.eclipse.jface.operation.ModalContext.runInCurrentThread(ModalContext.java:434)
	at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:352)
	at org.eclipse.ui.internal.WorkbenchWindow.lambda$7(WorkbenchWindow.java:2345)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.ui.internal.WorkbenchWindow.run(WorkbenchWindow.java:2343)
	at org.eclipse.ui.internal.SaveableHelper.runProgressMonitorOperation(SaveableHelper.java:278)
	at org.eclipse.ui.internal.SaveableHelper.runProgressMonitorOperation(SaveableHelper.java:260)
	at org.eclipse.ui.internal.SaveableHelper.saveModels(SaveableHelper.java:207)
	at org.eclipse.ui.internal.SaveableHelper.savePart(SaveableHelper.java:150)
	at org.eclipse.ui.internal.WorkbenchPage.saveSaveable(WorkbenchPage.java:3799)
	at org.eclipse.ui.internal.WorkbenchPage.saveEditor(WorkbenchPage.java:3812)
	at org.eclipse.ui.internal.handlers.SaveHandler.execute(SaveHandler.java:82)
	at org.eclipse.ui.internal.handlers.HandlerProxy.execute(HandlerProxy.java:283)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:97)
	at jdk.internal.reflect.GeneratedMethodAccessor79.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:317)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:251)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:173)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:156)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:488)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:487)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:213)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:308)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:580)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:647)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:439)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:96)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1280)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1062)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1087)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1072)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1114)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1110)
	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1539)
	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4868)
	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:345)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4746)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5015)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3630)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-09-21 15:33:45.866
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.debug.ui.BreakpointMarkerUpdater.updateMarker(BreakpointMarkerUpdater.java:112)
	at org.eclipse.ui.texteditor.AbstractMarkerAnnotationModel.updateMarker(AbstractMarkerAnnotationModel.java:578)
	at org.eclipse.ui.texteditor.AbstractMarkerAnnotationModel.updateMarkers(AbstractMarkerAnnotationModel.java:638)
	at org.eclipse.ui.texteditor.AbstractMarkerAnnotationModel.commit(AbstractMarkerAnnotationModel.java:701)
	at org.eclipse.core.internal.filebuffers.ResourceTextFileBuffer.commitFileBufferContent(ResourceTextFileBuffer.java:368)
	at org.eclipse.core.internal.filebuffers.ResourceFileBuffer.commit(ResourceFileBuffer.java:317)
	at org.eclipse.jdt.internal.ui.javaeditor.DocumentAdapter.save(DocumentAdapter.java:516)
	at org.eclipse.jdt.internal.core.CommitWorkingCopyOperation.executeOperation(CommitWorkingCopyOperation.java:127)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2315)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2340)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:811)
	at org.eclipse.jdt.internal.core.CompilationUnit.commitWorkingCopy(CompilationUnit.java:405)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitDocumentProvider.commitWorkingCopy(CompilationUnitDocumentProvider.java:1418)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitDocumentProvider$3.execute(CompilationUnitDocumentProvider.java:1495)
	at org.eclipse.ui.editors.text.TextFileDocumentProvider$DocumentProviderOperation.run(TextFileDocumentProvider.java:133)
	at org.eclipse.ui.actions.WorkspaceModifyDelegatingOperation.execute(WorkspaceModifyDelegatingOperation.java:71)
	at org.eclipse.ui.actions.WorkspaceModifyOperation.lambda$0(WorkspaceModifyOperation.java:110)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2315)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2340)
	at org.eclipse.ui.actions.WorkspaceModifyOperation.run(WorkspaceModifyOperation.java:131)
	at org.eclipse.ui.internal.editors.text.WorkspaceOperationRunner.run(WorkspaceOperationRunner.java:76)
	at org.eclipse.ui.internal.editors.text.WorkspaceOperationRunner.run(WorkspaceOperationRunner.java:66)
	at org.eclipse.ui.editors.text.TextFileDocumentProvider.executeOperation(TextFileDocumentProvider.java:461)
	at org.eclipse.ui.editors.text.TextFileDocumentProvider.saveDocument(TextFileDocumentProvider.java:764)
	at org.eclipse.ui.texteditor.AbstractTextEditor.performSave(AbstractTextEditor.java:4996)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor.performSave(CompilationUnitEditor.java:1263)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor.doSave(CompilationUnitEditor.java:1317)
	at org.eclipse.ui.texteditor.AbstractTextEditor$TextEditorSavable.doSave(AbstractTextEditor.java:7162)
	at org.eclipse.ui.Saveable.doSave(Saveable.java:213)
	at org.eclipse.ui.internal.SaveableHelper.doSaveModel(SaveableHelper.java:333)
	at org.eclipse.ui.internal.SaveableHelper.lambda$1(SaveableHelper.java:196)
	at org.eclipse.ui.internal.SaveableHelper.lambda$3(SaveableHelper.java:271)
	at org.eclipse.jface.operation.ModalContext.runInCurrentThread(ModalContext.java:434)
	at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:352)
	at org.eclipse.ui.internal.WorkbenchWindow.lambda$7(WorkbenchWindow.java:2345)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.ui.internal.WorkbenchWindow.run(WorkbenchWindow.java:2343)
	at org.eclipse.ui.internal.SaveableHelper.runProgressMonitorOperation(SaveableHelper.java:278)
	at org.eclipse.ui.internal.SaveableHelper.runProgressMonitorOperation(SaveableHelper.java:260)
	at org.eclipse.ui.internal.SaveableHelper.saveModels(SaveableHelper.java:207)
	at org.eclipse.ui.internal.SaveableHelper.savePart(SaveableHelper.java:150)
	at org.eclipse.ui.internal.WorkbenchPage.saveSaveable(WorkbenchPage.java:3799)
	at org.eclipse.ui.internal.WorkbenchPage.saveEditor(WorkbenchPage.java:3812)
	at org.eclipse.ui.internal.handlers.SaveHandler.execute(SaveHandler.java:82)
	at org.eclipse.ui.internal.handlers.HandlerProxy.execute(HandlerProxy.java:283)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:97)
	at jdk.internal.reflect.GeneratedMethodAccessor79.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:317)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:251)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:173)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:156)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:488)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:487)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:213)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:308)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:580)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:647)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:439)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:96)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1280)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1062)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1087)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1072)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1114)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1110)
	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1539)
	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4868)
	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:345)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4746)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5015)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3630)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-21 15:33:46.423
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.xyram.daydrop.serviceimpl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.transaction.Transactional;

import org.apache.commons.collections4.map.HashedMap;
import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.server.ResponseStatusException;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.xyram.daydrop.admin.model.CurrentUser;
import com.xyram.daydrop.basemodel.Base64Wrapper;
import com.xyram.daydrop.basemodel.MerchantTransactionIdGenerator;
import com.xyram.daydrop.basemodel.PhonepeSerializer;
import com.xyram.daydrop.dao.ApartmentDao;
import com.xyram.daydrop.dao.CustomerDetailsDao;
import com.xyram.daydrop.dao.CustomerOrderDao;
import com.xyram.daydrop.dao.CustomerOrderReplicaDoa;
import com.xyram.daydrop.dao.SheduleDao;
import com.xyram.daydrop.enumtypes.UserStatus;
import com.xyram.daydrop.model.Apartments;
import com.xyram.daydrop.model.CustomerOrder;
import com.xyram.daydrop.model.CustomerOrderReplica;
import com.xyram.daydrop.model.Customers;
import com.xyram.daydrop.model.Schedule;
import com.xyram.daydrop.modelMapper.PaymentInstrument;
import com.xyram.daydrop.modelMapper.PhonePePayModel;
import com.xyram.daydrop.request.CustomerOrderReplicaRequest;
import com.xyram.daydrop.response.RazorPayRequest;
import com.xyram.daydrop.service.CustomerOrderPriceService;
import com.xyram.daydrop.service.CustomerOrderReplicaService;
import com.xyram.daydrop.util.HashEncoder;
import com.xyram.daydrop.util.RazorPay;
import com.xyram.daydrop.service.ConsumerService;

@Transactional
@Service
public class CustomerOrderReplicaServiceImpl implements CustomerOrderReplicaService {

	@Autowired
	CustomerOrderReplicaDoa customerOrderReplicaDoa;

	@Autowired
	ApartmentDao apartmentDao;

	@Autowired
	SheduleDao scheduleDao;

	@Autowired
	CustomerDetailsDao customerDetailsDao;

	@Autowired
	ConsumerService consumerService;

	@Autowired
	CurrentUser currentUser;

	@Autowired
	PhonepeServiceImpl phonepeServiceImpl;

	@Value("${merchant_id}")
	private String merchantId;

	@Value("${salt_key}")
	private String saltKey;

	@Value("${salt_index}")
	private String saltIndex;

	@Override
	public Map createCustomerOrderReplicaService(CustomerOrderReplicaRequest customerOrderReplicaRequest,
			String contactNumber, Integer aparmentId)

	{

		Map response = new HashedMap<>();

		response.put("message", "success");
		CustomerOrderReplica customerOrderReplica = null;

		if (customerOrderReplicaRequest.getCartId() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "cartId is mandatory ");
		}
		long razorPayCount = 0;
		if (customerOrderReplicaRequest.getOrderId() != null) {

			razorPayCount = customerOrderReplicaDoa.getRazorPayExistByCartId(customerOrderReplicaRequest.getOrderId());
		}

		if (customerOrderReplicaRequest.getCustomerDetails() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Order Details  is mandatory ");
		}

		customerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(customerOrderReplicaRequest.getCartId(),
				contactNumber);

		if (customerOrderReplica != null) {
			customerOrderReplica.setCartId(customerOrderReplica.getCartId());

			if (customerOrderReplica.isOrdered()) {
				throw new ResponseStatusException(HttpStatus.CONFLICT, "Your Order is Placed With cart Details");
			}

//			if (razorPayCount >= 1 && !(customerOrderReplica.getRazorPayOrderId() != null
//					&& customerOrderReplica.getRazorPayOrderId().equals(customerOrderReplicaRequest.getOrderId()))) {
//				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
//			}

			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);

			customerOrderReplica.setAttempts(customerOrderReplica.getAttempts() + 1);
			customerOrderReplica.setUpdatedTime(new Date());

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		} else {

			customerOrderReplica = new CustomerOrderReplica();
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);
			customerOrderReplica.setCartId(customerOrderReplicaRequest.getCartId());
			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());

			if (razorPayCount > 0) {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
			}

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			Schedule schedule = scheduleDao.getlatestScheduleCustomers();

			if (schedule != null) {

				try {
					customerOrderReplica.setSchedule(schedule.getsId() != null ? schedule.getsId().toString() : null);
				} catch (Exception e) {
					e.printStackTrace();
				}
			} else {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
						"Sorry We Are Not Accepting Any Order Right now");

			}

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		}

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicas(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String schedule = null;

		Map filter = request.containsKey("filters") ? (Map) request.get("filters") : null;
		if (filter != null) {
			statusType = filter.containsKey("statusType") ? ((String) filter.get("statusType")).toLowerCase() : null;
			searchQuery = filter.containsKey("searchQuery") ? ((String) filter.get("searchQuery")).toLowerCase() : null;
			schedule = filter.containsKey("schedule") ? (String.valueOf(filter.get("schedule"))) : null;

		}

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplica(searchQuery, statusType, schedule);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");

				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setStreetName(
						customers.get("streetName") != null ? (String) customers.get("streetName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicasBySchedule(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String scheduleId = null;

		Schedule schedule = scheduleDao.getlatestScheduleCustomers();

		if (schedule != null) {

			try {
				scheduleId = schedule.getsId() != null ? schedule.getsId().toString() : null;
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

		statusType = request.containsKey("statusType") ? ((String) request.get("statusType")).toLowerCase() : "Success";

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplicaBySchdeule(statusType, scheduleId);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");
				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				System.out.println("customers" + customers.get("customerName"));

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public CustomerOrderReplica getCustomerOrderReplicaByCartId(String cartId) {

		CustomerOrderReplica CustomerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(cartId,
				currentUser.getContactNumber());

		ObjectMapper objectMapper = new ObjectMapper();
		try {

			// convert JSON string to Map
			Map<String, Object> customerOrderReplicaMap = objectMapper
					.readValue(CustomerOrderReplica.getCustomerOrderDetails(), Map.class);

			Object customerOrder = customerOrderReplicaMap.get("customerOrder");
			Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

			Object quanityList = items.get("quantity");
			Map customers = customerDetailsDao.getByContactNumberAndApartment(CustomerOrderReplica.getContactNumber(),
					CustomerOrderReplica.getApartmentId());

			System.out.println("customers" + customers.get("customerName"));

			// Apartments apartments =
			// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
			CustomerOrderReplica.setApartmentName(
					customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

			CustomerOrderReplica.setCustomerDetails(customers);

			CustomerOrderReplica.setCustomerOrder(customerOrder);
			CustomerOrderReplica.setQuatityList(quanityList);

		} catch (Exception e) {
			e.printStackTrace();
		}

		return CustomerOrderReplica;

	}

	@Override
	public Map createCustomerOrderReplica(CustomerOrderReplicaRequest customerOrderReplicaRequest, String contactNumber,
			Integer aparmentId) {

		if (customerOrderReplicaRequest.getRazorPayRequest() != null) {

//			Map razorPay = consumerService.createRazorPayOrder(customerOrderReplicaRequest.getRazorPayRequest());
//			customerOrderReplicaRequest.setOrderId(razorPay.get("order") != null ? (String)((RazorPay) razorPay.get("order")).getId() : null);	
//	
//			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);
//
//			razorPay.put("cartId", customerOrderReplicaRequest.getCartId());

			Map customerOrderReplicaMap = new HashMap<>();

			Map orderId = new HashMap<>();
			String transactionId = getMerchantTransactionId();
			orderId.put("id", transactionId);

			customerOrderReplicaMap.put("order", orderId);

			customerOrderReplicaRequest.setOrderId(transactionId);
			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);

			customerOrderReplicaMap.put("cartId", customerOrderReplicaRequest.getCartId());

			try {
				customerOrderReplicaMap.put("phonePeResponse",
						phonepeServiceImpl.initiatePhonepePayment(transactionId,
								Integer.valueOf(customerOrderReplicaRequest.getRazorPayRequest().getAmount()),
								contactNumber, customerOrderReplicaRequest.getRedirectUrl(), customerOrderReplicaRequest.getCallBackUrl()));

			} catch (Exception e) {
				e.printStackTrace();
				customerOrderReplicaMap.put("phonePeResponse", new HashedMap<>());
			}

			return customerOrderReplicaMap;

		} else {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
					"paymentDetails transcation Details are mandatory");
		}

	}

	private static String getMerchantTransactionId() {

		return "OD_" + MerchantTransactionIdGenerator.getRandomString();
	}


	@Override
	public List<CustomerOrderReplica> getCustomerOrderByMoblieNo(String contactNumber, Integer aid) {

	    Schedule latestSchedule = customerOrderReplicaDoa.getlatestschedule();

	    if (latestSchedule != null && latestSchedule.getCreationTimestamp() != null) {
	        if (latestSchedule.getStatus().equals(UserStatus.ACTIVE)) {
	            Customers customer = customerDetailsDao.getByContactNoAndApartment(contactNumber, aid);

	            if (customer != null) { // Ensure the customer exists
	                List<CustomerOrder> customerOrderList = customerOrderReplicaDoa.getListCustomerOrderByCustomerId(customer.getCtId());

	                double totalOrderAmount = 0.0;

	                if (customerOrderList != null && !customerOrderList.isEmpty()) {
	                    for (CustomerOrder customerOrder : customerOrderList) {
	                        Double orderAmount = customerOrder.getAmount();
	                        if (orderAmount != null) {
	                            totalOrderAmount += orderAmount;
	                            if(totalOrderAmount>200) {
	                            	totalOrderAmount+= customerOrder.getDelivaryCharges();
	                            }
	                            else(totalOrderAmount<200){
	                            	totalOrderAmount-= customerOrder.getDelivaryCharges();
	                            }
	                        }
	                    }

	                    // Define the minimum order amount for applying delivery charges
	                    double minimumOrderAmount = 200.0;

	                    if (totalOrderAmount < minimumOrderAmount) {
	                        System.out.println("Delivery Charges will be applicable");
	                    } else {
	                        // No delivery charges applicable
	                        System.out.println("No Delivery charges applicable");
	                    }

	                    List<CustomerOrderReplica> customerOrderReplicas = new ArrayList<>();
	                    return customerOrderReplicas;
	                } else {
	                    return Collections.emptyList();
	                }
	            } else {
	                return null; // or an appropriate value
	            }
	        } else {
	            // Handle the case when the latest schedule is not active
	            return null; // or an appropriate value
	        }
	    } else {
	        // Handle the case when there is no latest schedule or its creation timestamp is null
	        return null; // or an appropriate value
	    }
	}

}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-09-21 15:33:46.461
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-09-21 15:33:46.468
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-21 15:33:46.866
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.xyram.daydrop.serviceimpl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.transaction.Transactional;

import org.apache.commons.collections4.map.HashedMap;
import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.server.ResponseStatusException;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.xyram.daydrop.admin.model.CurrentUser;
import com.xyram.daydrop.basemodel.Base64Wrapper;
import com.xyram.daydrop.basemodel.MerchantTransactionIdGenerator;
import com.xyram.daydrop.basemodel.PhonepeSerializer;
import com.xyram.daydrop.dao.ApartmentDao;
import com.xyram.daydrop.dao.CustomerDetailsDao;
import com.xyram.daydrop.dao.CustomerOrderDao;
import com.xyram.daydrop.dao.CustomerOrderReplicaDoa;
import com.xyram.daydrop.dao.SheduleDao;
import com.xyram.daydrop.enumtypes.UserStatus;
import com.xyram.daydrop.model.Apartments;
import com.xyram.daydrop.model.CustomerOrder;
import com.xyram.daydrop.model.CustomerOrderReplica;
import com.xyram.daydrop.model.Customers;
import com.xyram.daydrop.model.Schedule;
import com.xyram.daydrop.modelMapper.PaymentInstrument;
import com.xyram.daydrop.modelMapper.PhonePePayModel;
import com.xyram.daydrop.request.CustomerOrderReplicaRequest;
import com.xyram.daydrop.response.RazorPayRequest;
import com.xyram.daydrop.service.CustomerOrderPriceService;
import com.xyram.daydrop.service.CustomerOrderReplicaService;
import com.xyram.daydrop.util.HashEncoder;
import com.xyram.daydrop.util.RazorPay;
import com.xyram.daydrop.service.ConsumerService;

@Transactional
@Service
public class CustomerOrderReplicaServiceImpl implements CustomerOrderReplicaService {

	@Autowired
	CustomerOrderReplicaDoa customerOrderReplicaDoa;

	@Autowired
	ApartmentDao apartmentDao;

	@Autowired
	SheduleDao scheduleDao;

	@Autowired
	CustomerDetailsDao customerDetailsDao;

	@Autowired
	ConsumerService consumerService;

	@Autowired
	CurrentUser currentUser;

	@Autowired
	PhonepeServiceImpl phonepeServiceImpl;

	@Value("${merchant_id}")
	private String merchantId;

	@Value("${salt_key}")
	private String saltKey;

	@Value("${salt_index}")
	private String saltIndex;

	@Override
	public Map createCustomerOrderReplicaService(CustomerOrderReplicaRequest customerOrderReplicaRequest,
			String contactNumber, Integer aparmentId)

	{

		Map response = new HashedMap<>();

		response.put("message", "success");
		CustomerOrderReplica customerOrderReplica = null;

		if (customerOrderReplicaRequest.getCartId() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "cartId is mandatory ");
		}
		long razorPayCount = 0;
		if (customerOrderReplicaRequest.getOrderId() != null) {

			razorPayCount = customerOrderReplicaDoa.getRazorPayExistByCartId(customerOrderReplicaRequest.getOrderId());
		}

		if (customerOrderReplicaRequest.getCustomerDetails() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Order Details  is mandatory ");
		}

		customerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(customerOrderReplicaRequest.getCartId(),
				contactNumber);

		if (customerOrderReplica != null) {
			customerOrderReplica.setCartId(customerOrderReplica.getCartId());

			if (customerOrderReplica.isOrdered()) {
				throw new ResponseStatusException(HttpStatus.CONFLICT, "Your Order is Placed With cart Details");
			}

//			if (razorPayCount >= 1 && !(customerOrderReplica.getRazorPayOrderId() != null
//					&& customerOrderReplica.getRazorPayOrderId().equals(customerOrderReplicaRequest.getOrderId()))) {
//				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
//			}

			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);

			customerOrderReplica.setAttempts(customerOrderReplica.getAttempts() + 1);
			customerOrderReplica.setUpdatedTime(new Date());

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		} else {

			customerOrderReplica = new CustomerOrderReplica();
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);
			customerOrderReplica.setCartId(customerOrderReplicaRequest.getCartId());
			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());

			if (razorPayCount > 0) {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
			}

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			Schedule schedule = scheduleDao.getlatestScheduleCustomers();

			if (schedule != null) {

				try {
					customerOrderReplica.setSchedule(schedule.getsId() != null ? schedule.getsId().toString() : null);
				} catch (Exception e) {
					e.printStackTrace();
				}
			} else {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
						"Sorry We Are Not Accepting Any Order Right now");

			}

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		}

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicas(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String schedule = null;

		Map filter = request.containsKey("filters") ? (Map) request.get("filters") : null;
		if (filter != null) {
			statusType = filter.containsKey("statusType") ? ((String) filter.get("statusType")).toLowerCase() : null;
			searchQuery = filter.containsKey("searchQuery") ? ((String) filter.get("searchQuery")).toLowerCase() : null;
			schedule = filter.containsKey("schedule") ? (String.valueOf(filter.get("schedule"))) : null;

		}

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplica(searchQuery, statusType, schedule);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");

				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setStreetName(
						customers.get("streetName") != null ? (String) customers.get("streetName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicasBySchedule(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String scheduleId = null;

		Schedule schedule = scheduleDao.getlatestScheduleCustomers();

		if (schedule != null) {

			try {
				scheduleId = schedule.getsId() != null ? schedule.getsId().toString() : null;
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

		statusType = request.containsKey("statusType") ? ((String) request.get("statusType")).toLowerCase() : "Success";

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplicaBySchdeule(statusType, scheduleId);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");
				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				System.out.println("customers" + customers.get("customerName"));

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public CustomerOrderReplica getCustomerOrderReplicaByCartId(String cartId) {

		CustomerOrderReplica CustomerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(cartId,
				currentUser.getContactNumber());

		ObjectMapper objectMapper = new ObjectMapper();
		try {

			// convert JSON string to Map
			Map<String, Object> customerOrderReplicaMap = objectMapper
					.readValue(CustomerOrderReplica.getCustomerOrderDetails(), Map.class);

			Object customerOrder = customerOrderReplicaMap.get("customerOrder");
			Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

			Object quanityList = items.get("quantity");
			Map customers = customerDetailsDao.getByContactNumberAndApartment(CustomerOrderReplica.getContactNumber(),
					CustomerOrderReplica.getApartmentId());

			System.out.println("customers" + customers.get("customerName"));

			// Apartments apartments =
			// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
			CustomerOrderReplica.setApartmentName(
					customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

			CustomerOrderReplica.setCustomerDetails(customers);

			CustomerOrderReplica.setCustomerOrder(customerOrder);
			CustomerOrderReplica.setQuatityList(quanityList);

		} catch (Exception e) {
			e.printStackTrace();
		}

		return CustomerOrderReplica;

	}

	@Override
	public Map createCustomerOrderReplica(CustomerOrderReplicaRequest customerOrderReplicaRequest, String contactNumber,
			Integer aparmentId) {

		if (customerOrderReplicaRequest.getRazorPayRequest() != null) {

//			Map razorPay = consumerService.createRazorPayOrder(customerOrderReplicaRequest.getRazorPayRequest());
//			customerOrderReplicaRequest.setOrderId(razorPay.get("order") != null ? (String)((RazorPay) razorPay.get("order")).getId() : null);	
//	
//			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);
//
//			razorPay.put("cartId", customerOrderReplicaRequest.getCartId());

			Map customerOrderReplicaMap = new HashMap<>();

			Map orderId = new HashMap<>();
			String transactionId = getMerchantTransactionId();
			orderId.put("id", transactionId);

			customerOrderReplicaMap.put("order", orderId);

			customerOrderReplicaRequest.setOrderId(transactionId);
			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);

			customerOrderReplicaMap.put("cartId", customerOrderReplicaRequest.getCartId());

			try {
				customerOrderReplicaMap.put("phonePeResponse",
						phonepeServiceImpl.initiatePhonepePayment(transactionId,
								Integer.valueOf(customerOrderReplicaRequest.getRazorPayRequest().getAmount()),
								contactNumber, customerOrderReplicaRequest.getRedirectUrl(), customerOrderReplicaRequest.getCallBackUrl()));

			} catch (Exception e) {
				e.printStackTrace();
				customerOrderReplicaMap.put("phonePeResponse", new HashedMap<>());
			}

			return customerOrderReplicaMap;

		} else {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
					"paymentDetails transcation Details are mandatory");
		}

	}

	private static String getMerchantTransactionId() {

		return "OD_" + MerchantTransactionIdGenerator.getRandomString();
	}


	@Override
	public List<CustomerOrderReplica> getCustomerOrderByMoblieNo(String contactNumber, Integer aid) {

	    Schedule latestSchedule = customerOrderReplicaDoa.getlatestschedule();

	    if (latestSchedule != null && latestSchedule.getCreationTimestamp() != null) {
	        if (latestSchedule.getStatus().equals(UserStatus.ACTIVE)) {
	            Customers customer = customerDetailsDao.getByContactNoAndApartment(contactNumber, aid);

	            if (customer != null) { // Ensure the customer exists
	                List<CustomerOrder> customerOrderList = customerOrderReplicaDoa.getListCustomerOrderByCustomerId(customer.getCtId());

	                double totalOrderAmount = 0.0;

	                if (customerOrderList != null && !customerOrderList.isEmpty()) {
	                    for (CustomerOrder customerOrder : customerOrderList) {
	                        Double orderAmount = customerOrder.getAmount();
	                        if (orderAmount != null) {
	                            totalOrderAmount += orderAmount;
	                            if(totalOrderAmount>200) {
	                            	totalOrderAmount+= customerOrder.getDelivaryCharges();
	                            }
	                            else(totalOrderAmount<200){
	                            	totalOrderAmount-= customerOrder.getDelivaryCharges();
	                            }
	                        }
	                    }

	                    // Define the minimum order amount for applying delivery charges
	                    double minimumOrderAmount = 200.0;

	                    if (totalOrderAmount < minimumOrderAmount) {
	                        System.out.println("Delivery Charges will be applicable");
	                    } else {
	                        // No delivery charges applicable
	                        System.out.println("No Delivery charges applicable");
	                    }

	                    List<CustomerOrderReplica> customerOrderReplicas = new ArrayList<>();
	                    return customerOrderReplicas;
	                } else {
	                    return Collections.emptyList();
	                }
	            } else {
	                return null; // or an appropriate value
	            }
	        } else {
	            // Handle the case when the latest schedule is not active
	            return null; // or an appropriate value
	        }
	    } else {
	        // Handle the case when there is no latest schedule or its creation timestamp is null
	        return null; // or an appropriate value
	    }
	}

}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-09-21 15:33:46.876
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-09-21 15:33:46.900
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-21 15:33:46.984
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.xyram.daydrop.serviceimpl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.transaction.Transactional;

import org.apache.commons.collections4.map.HashedMap;
import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.server.ResponseStatusException;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.xyram.daydrop.admin.model.CurrentUser;
import com.xyram.daydrop.basemodel.Base64Wrapper;
import com.xyram.daydrop.basemodel.MerchantTransactionIdGenerator;
import com.xyram.daydrop.basemodel.PhonepeSerializer;
import com.xyram.daydrop.dao.ApartmentDao;
import com.xyram.daydrop.dao.CustomerDetailsDao;
import com.xyram.daydrop.dao.CustomerOrderDao;
import com.xyram.daydrop.dao.CustomerOrderReplicaDoa;
import com.xyram.daydrop.dao.SheduleDao;
import com.xyram.daydrop.enumtypes.UserStatus;
import com.xyram.daydrop.model.Apartments;
import com.xyram.daydrop.model.CustomerOrder;
import com.xyram.daydrop.model.CustomerOrderReplica;
import com.xyram.daydrop.model.Customers;
import com.xyram.daydrop.model.Schedule;
import com.xyram.daydrop.modelMapper.PaymentInstrument;
import com.xyram.daydrop.modelMapper.PhonePePayModel;
import com.xyram.daydrop.request.CustomerOrderReplicaRequest;
import com.xyram.daydrop.response.RazorPayRequest;
import com.xyram.daydrop.service.CustomerOrderPriceService;
import com.xyram.daydrop.service.CustomerOrderReplicaService;
import com.xyram.daydrop.util.HashEncoder;
import com.xyram.daydrop.util.RazorPay;
import com.xyram.daydrop.service.ConsumerService;

@Transactional
@Service
public class CustomerOrderReplicaServiceImpl implements CustomerOrderReplicaService {

	@Autowired
	CustomerOrderReplicaDoa customerOrderReplicaDoa;

	@Autowired
	ApartmentDao apartmentDao;

	@Autowired
	SheduleDao scheduleDao;

	@Autowired
	CustomerDetailsDao customerDetailsDao;

	@Autowired
	ConsumerService consumerService;

	@Autowired
	CurrentUser currentUser;

	@Autowired
	PhonepeServiceImpl phonepeServiceImpl;

	@Value("${merchant_id}")
	private String merchantId;

	@Value("${salt_key}")
	private String saltKey;

	@Value("${salt_index}")
	private String saltIndex;

	@Override
	public Map createCustomerOrderReplicaService(CustomerOrderReplicaRequest customerOrderReplicaRequest,
			String contactNumber, Integer aparmentId)

	{

		Map response = new HashedMap<>();

		response.put("message", "success");
		CustomerOrderReplica customerOrderReplica = null;

		if (customerOrderReplicaRequest.getCartId() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "cartId is mandatory ");
		}
		long razorPayCount = 0;
		if (customerOrderReplicaRequest.getOrderId() != null) {

			razorPayCount = customerOrderReplicaDoa.getRazorPayExistByCartId(customerOrderReplicaRequest.getOrderId());
		}

		if (customerOrderReplicaRequest.getCustomerDetails() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Order Details  is mandatory ");
		}

		customerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(customerOrderReplicaRequest.getCartId(),
				contactNumber);

		if (customerOrderReplica != null) {
			customerOrderReplica.setCartId(customerOrderReplica.getCartId());

			if (customerOrderReplica.isOrdered()) {
				throw new ResponseStatusException(HttpStatus.CONFLICT, "Your Order is Placed With cart Details");
			}

//			if (razorPayCount >= 1 && !(customerOrderReplica.getRazorPayOrderId() != null
//					&& customerOrderReplica.getRazorPayOrderId().equals(customerOrderReplicaRequest.getOrderId()))) {
//				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
//			}

			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);

			customerOrderReplica.setAttempts(customerOrderReplica.getAttempts() + 1);
			customerOrderReplica.setUpdatedTime(new Date());

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		} else {

			customerOrderReplica = new CustomerOrderReplica();
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);
			customerOrderReplica.setCartId(customerOrderReplicaRequest.getCartId());
			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());

			if (razorPayCount > 0) {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
			}

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			Schedule schedule = scheduleDao.getlatestScheduleCustomers();

			if (schedule != null) {

				try {
					customerOrderReplica.setSchedule(schedule.getsId() != null ? schedule.getsId().toString() : null);
				} catch (Exception e) {
					e.printStackTrace();
				}
			} else {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
						"Sorry We Are Not Accepting Any Order Right now");

			}

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		}

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicas(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String schedule = null;

		Map filter = request.containsKey("filters") ? (Map) request.get("filters") : null;
		if (filter != null) {
			statusType = filter.containsKey("statusType") ? ((String) filter.get("statusType")).toLowerCase() : null;
			searchQuery = filter.containsKey("searchQuery") ? ((String) filter.get("searchQuery")).toLowerCase() : null;
			schedule = filter.containsKey("schedule") ? (String.valueOf(filter.get("schedule"))) : null;

		}

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplica(searchQuery, statusType, schedule);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");

				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setStreetName(
						customers.get("streetName") != null ? (String) customers.get("streetName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicasBySchedule(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String scheduleId = null;

		Schedule schedule = scheduleDao.getlatestScheduleCustomers();

		if (schedule != null) {

			try {
				scheduleId = schedule.getsId() != null ? schedule.getsId().toString() : null;
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

		statusType = request.containsKey("statusType") ? ((String) request.get("statusType")).toLowerCase() : "Success";

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplicaBySchdeule(statusType, scheduleId);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");
				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				System.out.println("customers" + customers.get("customerName"));

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public CustomerOrderReplica getCustomerOrderReplicaByCartId(String cartId) {

		CustomerOrderReplica CustomerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(cartId,
				currentUser.getContactNumber());

		ObjectMapper objectMapper = new ObjectMapper();
		try {

			// convert JSON string to Map
			Map<String, Object> customerOrderReplicaMap = objectMapper
					.readValue(CustomerOrderReplica.getCustomerOrderDetails(), Map.class);

			Object customerOrder = customerOrderReplicaMap.get("customerOrder");
			Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

			Object quanityList = items.get("quantity");
			Map customers = customerDetailsDao.getByContactNumberAndApartment(CustomerOrderReplica.getContactNumber(),
					CustomerOrderReplica.getApartmentId());

			System.out.println("customers" + customers.get("customerName"));

			// Apartments apartments =
			// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
			CustomerOrderReplica.setApartmentName(
					customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

			CustomerOrderReplica.setCustomerDetails(customers);

			CustomerOrderReplica.setCustomerOrder(customerOrder);
			CustomerOrderReplica.setQuatityList(quanityList);

		} catch (Exception e) {
			e.printStackTrace();
		}

		return CustomerOrderReplica;

	}

	@Override
	public Map createCustomerOrderReplica(CustomerOrderReplicaRequest customerOrderReplicaRequest, String contactNumber,
			Integer aparmentId) {

		if (customerOrderReplicaRequest.getRazorPayRequest() != null) {

//			Map razorPay = consumerService.createRazorPayOrder(customerOrderReplicaRequest.getRazorPayRequest());
//			customerOrderReplicaRequest.setOrderId(razorPay.get("order") != null ? (String)((RazorPay) razorPay.get("order")).getId() : null);	
//	
//			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);
//
//			razorPay.put("cartId", customerOrderReplicaRequest.getCartId());

			Map customerOrderReplicaMap = new HashMap<>();

			Map orderId = new HashMap<>();
			String transactionId = getMerchantTransactionId();
			orderId.put("id", transactionId);

			customerOrderReplicaMap.put("order", orderId);

			customerOrderReplicaRequest.setOrderId(transactionId);
			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);

			customerOrderReplicaMap.put("cartId", customerOrderReplicaRequest.getCartId());

			try {
				customerOrderReplicaMap.put("phonePeResponse",
						phonepeServiceImpl.initiatePhonepePayment(transactionId,
								Integer.valueOf(customerOrderReplicaRequest.getRazorPayRequest().getAmount()),
								contactNumber, customerOrderReplicaRequest.getRedirectUrl(), customerOrderReplicaRequest.getCallBackUrl()));

			} catch (Exception e) {
				e.printStackTrace();
				customerOrderReplicaMap.put("phonePeResponse", new HashedMap<>());
			}

			return customerOrderReplicaMap;

		} else {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
					"paymentDetails transcation Details are mandatory");
		}

	}

	private static String getMerchantTransactionId() {

		return "OD_" + MerchantTransactionIdGenerator.getRandomString();
	}


	@Override
	public List<CustomerOrderReplica> getCustomerOrderByMoblieNo(String contactNumber, Integer aid) {

	    Schedule latestSchedule = customerOrderReplicaDoa.getlatestschedule();

	    if (latestSchedule != null && latestSchedule.getCreationTimestamp() != null) {
	        if (latestSchedule.getStatus().equals(UserStatus.ACTIVE)) {
	            Customers customer = customerDetailsDao.getByContactNoAndApartment(contactNumber, aid);

	            if (customer != null) { // Ensure the customer exists
	                List<CustomerOrder> customerOrderList = customerOrderReplicaDoa.getListCustomerOrderByCustomerId(customer.getCtId());

	                double totalOrderAmount = 0.0;

	                if (customerOrderList != null && !customerOrderList.isEmpty()) {
	                    for (CustomerOrder customerOrder : customerOrderList) {
	                        Double orderAmount = customerOrder.getAmount();
	                        if (orderAmount != null) {
	                            totalOrderAmount += orderAmount;
	                            if(totalOrderAmount>200) {
	                            	totalOrderAmount+= customerOrder.getDelivaryCharges();
	                            }
	                            else(totalOrderAmount<200){
	                            	totalOrderAmount-= customerOrder.getDelivaryCharges();
	                            }
	                        }
	                    }

	                    // Define the minimum order amount for applying delivery charges
	                    double minimumOrderAmount = 200.0;

	                    if (totalOrderAmount < minimumOrderAmount) {
	                        System.out.println("Delivery Charges will be applicable");
	                    } else {
	                        // No delivery charges applicable
	                        System.out.println("No Delivery charges applicable");
	                    }

	                    List<CustomerOrderReplica> customerOrderReplicas = new ArrayList<>();
	                    return customerOrderReplicas;
	                } else {
	                    return Collections.emptyList();
	                }
	            } else {
	                return null; // or an appropriate value
	            }
	        } else {
	            // Handle the case when the latest schedule is not active
	            return null; // or an appropriate value
	        }
	    } else {
	        // Handle the case when there is no latest schedule or its creation timestamp is null
	        return null; // or an appropriate value
	    }
	}

}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-09-21 15:33:46.987
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-09-21 15:33:46.989
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-21 15:33:48.929
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.xyram.daydrop.serviceimpl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.transaction.Transactional;

import org.apache.commons.collections4.map.HashedMap;
import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.server.ResponseStatusException;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.xyram.daydrop.admin.model.CurrentUser;
import com.xyram.daydrop.basemodel.Base64Wrapper;
import com.xyram.daydrop.basemodel.MerchantTransactionIdGenerator;
import com.xyram.daydrop.basemodel.PhonepeSerializer;
import com.xyram.daydrop.dao.ApartmentDao;
import com.xyram.daydrop.dao.CustomerDetailsDao;
import com.xyram.daydrop.dao.CustomerOrderDao;
import com.xyram.daydrop.dao.CustomerOrderReplicaDoa;
import com.xyram.daydrop.dao.SheduleDao;
import com.xyram.daydrop.enumtypes.UserStatus;
import com.xyram.daydrop.model.Apartments;
import com.xyram.daydrop.model.CustomerOrder;
import com.xyram.daydrop.model.CustomerOrderReplica;
import com.xyram.daydrop.model.Customers;
import com.xyram.daydrop.model.Schedule;
import com.xyram.daydrop.modelMapper.PaymentInstrument;
import com.xyram.daydrop.modelMapper.PhonePePayModel;
import com.xyram.daydrop.request.CustomerOrderReplicaRequest;
import com.xyram.daydrop.response.RazorPayRequest;
import com.xyram.daydrop.service.CustomerOrderPriceService;
import com.xyram.daydrop.service.CustomerOrderReplicaService;
import com.xyram.daydrop.util.HashEncoder;
import com.xyram.daydrop.util.RazorPay;
import com.xyram.daydrop.service.ConsumerService;

@Transactional
@Service
public class CustomerOrderReplicaServiceImpl implements CustomerOrderReplicaService {

	@Autowired
	CustomerOrderReplicaDoa customerOrderReplicaDoa;

	@Autowired
	ApartmentDao apartmentDao;

	@Autowired
	SheduleDao scheduleDao;

	@Autowired
	CustomerDetailsDao customerDetailsDao;

	@Autowired
	ConsumerService consumerService;

	@Autowired
	CurrentUser currentUser;

	@Autowired
	PhonepeServiceImpl phonepeServiceImpl;

	@Value("${merchant_id}")
	private String merchantId;

	@Value("${salt_key}")
	private String saltKey;

	@Value("${salt_index}")
	private String saltIndex;

	@Override
	public Map createCustomerOrderReplicaService(CustomerOrderReplicaRequest customerOrderReplicaRequest,
			String contactNumber, Integer aparmentId)

	{

		Map response = new HashedMap<>();

		response.put("message", "success");
		CustomerOrderReplica customerOrderReplica = null;

		if (customerOrderReplicaRequest.getCartId() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "cartId is mandatory ");
		}
		long razorPayCount = 0;
		if (customerOrderReplicaRequest.getOrderId() != null) {

			razorPayCount = customerOrderReplicaDoa.getRazorPayExistByCartId(customerOrderReplicaRequest.getOrderId());
		}

		if (customerOrderReplicaRequest.getCustomerDetails() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Order Details  is mandatory ");
		}

		customerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(customerOrderReplicaRequest.getCartId(),
				contactNumber);

		if (customerOrderReplica != null) {
			customerOrderReplica.setCartId(customerOrderReplica.getCartId());

			if (customerOrderReplica.isOrdered()) {
				throw new ResponseStatusException(HttpStatus.CONFLICT, "Your Order is Placed With cart Details");
			}

//			if (razorPayCount >= 1 && !(customerOrderReplica.getRazorPayOrderId() != null
//					&& customerOrderReplica.getRazorPayOrderId().equals(customerOrderReplicaRequest.getOrderId()))) {
//				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
//			}

			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);

			customerOrderReplica.setAttempts(customerOrderReplica.getAttempts() + 1);
			customerOrderReplica.setUpdatedTime(new Date());

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		} else {

			customerOrderReplica = new CustomerOrderReplica();
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);
			customerOrderReplica.setCartId(customerOrderReplicaRequest.getCartId());
			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());

			if (razorPayCount > 0) {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
			}

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			Schedule schedule = scheduleDao.getlatestScheduleCustomers();

			if (schedule != null) {

				try {
					customerOrderReplica.setSchedule(schedule.getsId() != null ? schedule.getsId().toString() : null);
				} catch (Exception e) {
					e.printStackTrace();
				}
			} else {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
						"Sorry We Are Not Accepting Any Order Right now");

			}

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		}

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicas(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String schedule = null;

		Map filter = request.containsKey("filters") ? (Map) request.get("filters") : null;
		if (filter != null) {
			statusType = filter.containsKey("statusType") ? ((String) filter.get("statusType")).toLowerCase() : null;
			searchQuery = filter.containsKey("searchQuery") ? ((String) filter.get("searchQuery")).toLowerCase() : null;
			schedule = filter.containsKey("schedule") ? (String.valueOf(filter.get("schedule"))) : null;

		}

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplica(searchQuery, statusType, schedule);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");

				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setStreetName(
						customers.get("streetName") != null ? (String) customers.get("streetName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicasBySchedule(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String scheduleId = null;

		Schedule schedule = scheduleDao.getlatestScheduleCustomers();

		if (schedule != null) {

			try {
				scheduleId = schedule.getsId() != null ? schedule.getsId().toString() : null;
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

		statusType = request.containsKey("statusType") ? ((String) request.get("statusType")).toLowerCase() : "Success";

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplicaBySchdeule(statusType, scheduleId);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");
				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				System.out.println("customers" + customers.get("customerName"));

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public CustomerOrderReplica getCustomerOrderReplicaByCartId(String cartId) {

		CustomerOrderReplica CustomerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(cartId,
				currentUser.getContactNumber());

		ObjectMapper objectMapper = new ObjectMapper();
		try {

			// convert JSON string to Map
			Map<String, Object> customerOrderReplicaMap = objectMapper
					.readValue(CustomerOrderReplica.getCustomerOrderDetails(), Map.class);

			Object customerOrder = customerOrderReplicaMap.get("customerOrder");
			Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

			Object quanityList = items.get("quantity");
			Map customers = customerDetailsDao.getByContactNumberAndApartment(CustomerOrderReplica.getContactNumber(),
					CustomerOrderReplica.getApartmentId());

			System.out.println("customers" + customers.get("customerName"));

			// Apartments apartments =
			// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
			CustomerOrderReplica.setApartmentName(
					customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

			CustomerOrderReplica.setCustomerDetails(customers);

			CustomerOrderReplica.setCustomerOrder(customerOrder);
			CustomerOrderReplica.setQuatityList(quanityList);

		} catch (Exception e) {
			e.printStackTrace();
		}

		return CustomerOrderReplica;

	}

	@Override
	public Map createCustomerOrderReplica(CustomerOrderReplicaRequest customerOrderReplicaRequest, String contactNumber,
			Integer aparmentId) {

		if (customerOrderReplicaRequest.getRazorPayRequest() != null) {

//			Map razorPay = consumerService.createRazorPayOrder(customerOrderReplicaRequest.getRazorPayRequest());
//			customerOrderReplicaRequest.setOrderId(razorPay.get("order") != null ? (String)((RazorPay) razorPay.get("order")).getId() : null);	
//	
//			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);
//
//			razorPay.put("cartId", customerOrderReplicaRequest.getCartId());

			Map customerOrderReplicaMap = new HashMap<>();

			Map orderId = new HashMap<>();
			String transactionId = getMerchantTransactionId();
			orderId.put("id", transactionId);

			customerOrderReplicaMap.put("order", orderId);

			customerOrderReplicaRequest.setOrderId(transactionId);
			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);

			customerOrderReplicaMap.put("cartId", customerOrderReplicaRequest.getCartId());

			try {
				customerOrderReplicaMap.put("phonePeResponse",
						phonepeServiceImpl.initiatePhonepePayment(transactionId,
								Integer.valueOf(customerOrderReplicaRequest.getRazorPayRequest().getAmount()),
								contactNumber, customerOrderReplicaRequest.getRedirectUrl(), customerOrderReplicaRequest.getCallBackUrl()));

			} catch (Exception e) {
				e.printStackTrace();
				customerOrderReplicaMap.put("phonePeResponse", new HashedMap<>());
			}

			return customerOrderReplicaMap;

		} else {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
					"paymentDetails transcation Details are mandatory");
		}

	}

	private static String getMerchantTransactionId() {

		return "OD_" + MerchantTransactionIdGenerator.getRandomString();
	}


	@Override
	public List<CustomerOrderReplica> getCustomerOrderByMoblieNo(String contactNumber, Integer aid) {

	    Schedule latestSchedule = customerOrderReplicaDoa.getlatestschedule();

	    if (latestSchedule != null && latestSchedule.getCreationTimestamp() != null) {
	        if (latestSchedule.getStatus().equals(UserStatus.ACTIVE)) {
	            Customers customer = customerDetailsDao.getByContactNoAndApartment(contactNumber, aid);

	            if (customer != null) { // Ensure the customer exists
	                List<CustomerOrder> customerOrderList = customerOrderReplicaDoa.getListCustomerOrderByCustomerId(customer.getCtId());

	                double totalOrderAmount = 0.0;

	                if (customerOrderList != null && !customerOrderList.isEmpty()) {
	                    for (CustomerOrder customerOrder : customerOrderList) {
	                        Double orderAmount = customerOrder.getAmount();
	                        if (orderAmount != null) {
	                            totalOrderAmount += orderAmount;
	                            if(totalOrderAmount>200) {
	                            	totalOrderAmount+= customerOrder.getDelivaryCharges();
	                            }
	                            else(totalOrderAmount<200){
	                            	totalOrderAmount-= customerOrder.getDelivaryCharges();
	                            }
	                        }
	                    }

	                    // Define the minimum order amount for applying delivery charges
	                    double minimumOrderAmount = 200.0;

	                    if (totalOrderAmount < minimumOrderAmount) {
	                        System.out.println("Delivery Charges will be applicable");
	                    } else {
	                        // No delivery charges applicable
	                        System.out.println("No Delivery charges applicable");
	                    }

	                    List<CustomerOrderReplica> customerOrderReplicas = new ArrayList<>();
	                    return customerOrderReplicas;
	                } else {
	                    return Collections.emptyList();
	                }
	            } else {
	                return null; // or an appropriate value
	            }
	        } else {
	            // Handle the case when the latest schedule is not active
	            return null; // or an appropriate value
	        }
	    } else {
	        // Handle the case when there is no latest schedule or its creation timestamp is null
	        return null; // or an appropriate value
	    }
	}

}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1003)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:799)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:743)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:666)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:658)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.lambda$0(LSJavaHoverProvider.java:68)
	at java.base/java.util.concurrent.CompletableFuture$AsyncRun.run(CompletableFuture.java:1804)
	at java.base/java.util.concurrent.CompletableFuture$AsyncRun.exec(CompletableFuture.java:1796)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:373)
	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1182)
	at java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1655)
	at java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1622)
	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:165)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-09-21 15:33:48.931
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1003)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:799)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:743)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:666)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:658)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.lambda$0(LSJavaHoverProvider.java:68)
	at java.base/java.util.concurrent.CompletableFuture$AsyncRun.run(CompletableFuture.java:1804)
	at java.base/java.util.concurrent.CompletableFuture$AsyncRun.exec(CompletableFuture.java:1796)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:373)
	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1182)
	at java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1655)
	at java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1622)
	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:165)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-09-21 15:33:48.933
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1003)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:799)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:743)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:666)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:658)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.lambda$0(LSJavaHoverProvider.java:68)
	at java.base/java.util.concurrent.CompletableFuture$AsyncRun.run(CompletableFuture.java:1804)
	at java.base/java.util.concurrent.CompletableFuture$AsyncRun.exec(CompletableFuture.java:1796)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:373)
	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1182)
	at java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1655)
	at java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1622)
	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:165)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-21 15:33:49.029
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.xyram.daydrop.serviceimpl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.transaction.Transactional;

import org.apache.commons.collections4.map.HashedMap;
import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.server.ResponseStatusException;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.xyram.daydrop.admin.model.CurrentUser;
import com.xyram.daydrop.basemodel.Base64Wrapper;
import com.xyram.daydrop.basemodel.MerchantTransactionIdGenerator;
import com.xyram.daydrop.basemodel.PhonepeSerializer;
import com.xyram.daydrop.dao.ApartmentDao;
import com.xyram.daydrop.dao.CustomerDetailsDao;
import com.xyram.daydrop.dao.CustomerOrderDao;
import com.xyram.daydrop.dao.CustomerOrderReplicaDoa;
import com.xyram.daydrop.dao.SheduleDao;
import com.xyram.daydrop.enumtypes.UserStatus;
import com.xyram.daydrop.model.Apartments;
import com.xyram.daydrop.model.CustomerOrder;
import com.xyram.daydrop.model.CustomerOrderReplica;
import com.xyram.daydrop.model.Customers;
import com.xyram.daydrop.model.Schedule;
import com.xyram.daydrop.modelMapper.PaymentInstrument;
import com.xyram.daydrop.modelMapper.PhonePePayModel;
import com.xyram.daydrop.request.CustomerOrderReplicaRequest;
import com.xyram.daydrop.response.RazorPayRequest;
import com.xyram.daydrop.service.CustomerOrderPriceService;
import com.xyram.daydrop.service.CustomerOrderReplicaService;
import com.xyram.daydrop.util.HashEncoder;
import com.xyram.daydrop.util.RazorPay;
import com.xyram.daydrop.service.ConsumerService;

@Transactional
@Service
public class CustomerOrderReplicaServiceImpl implements CustomerOrderReplicaService {

	@Autowired
	CustomerOrderReplicaDoa customerOrderReplicaDoa;

	@Autowired
	ApartmentDao apartmentDao;

	@Autowired
	SheduleDao scheduleDao;

	@Autowired
	CustomerDetailsDao customerDetailsDao;

	@Autowired
	ConsumerService consumerService;

	@Autowired
	CurrentUser currentUser;

	@Autowired
	PhonepeServiceImpl phonepeServiceImpl;

	@Value("${merchant_id}")
	private String merchantId;

	@Value("${salt_key}")
	private String saltKey;

	@Value("${salt_index}")
	private String saltIndex;

	@Override
	public Map createCustomerOrderReplicaService(CustomerOrderReplicaRequest customerOrderReplicaRequest,
			String contactNumber, Integer aparmentId)

	{

		Map response = new HashedMap<>();

		response.put("message", "success");
		CustomerOrderReplica customerOrderReplica = null;

		if (customerOrderReplicaRequest.getCartId() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "cartId is mandatory ");
		}
		long razorPayCount = 0;
		if (customerOrderReplicaRequest.getOrderId() != null) {

			razorPayCount = customerOrderReplicaDoa.getRazorPayExistByCartId(customerOrderReplicaRequest.getOrderId());
		}

		if (customerOrderReplicaRequest.getCustomerDetails() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Order Details  is mandatory ");
		}

		customerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(customerOrderReplicaRequest.getCartId(),
				contactNumber);

		if (customerOrderReplica != null) {
			customerOrderReplica.setCartId(customerOrderReplica.getCartId());

			if (customerOrderReplica.isOrdered()) {
				throw new ResponseStatusException(HttpStatus.CONFLICT, "Your Order is Placed With cart Details");
			}

//			if (razorPayCount >= 1 && !(customerOrderReplica.getRazorPayOrderId() != null
//					&& customerOrderReplica.getRazorPayOrderId().equals(customerOrderReplicaRequest.getOrderId()))) {
//				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
//			}

			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);

			customerOrderReplica.setAttempts(customerOrderReplica.getAttempts() + 1);
			customerOrderReplica.setUpdatedTime(new Date());

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		} else {

			customerOrderReplica = new CustomerOrderReplica();
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);
			customerOrderReplica.setCartId(customerOrderReplicaRequest.getCartId());
			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());

			if (razorPayCount > 0) {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
			}

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			Schedule schedule = scheduleDao.getlatestScheduleCustomers();

			if (schedule != null) {

				try {
					customerOrderReplica.setSchedule(schedule.getsId() != null ? schedule.getsId().toString() : null);
				} catch (Exception e) {
					e.printStackTrace();
				}
			} else {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
						"Sorry We Are Not Accepting Any Order Right now");

			}

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		}

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicas(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String schedule = null;

		Map filter = request.containsKey("filters") ? (Map) request.get("filters") : null;
		if (filter != null) {
			statusType = filter.containsKey("statusType") ? ((String) filter.get("statusType")).toLowerCase() : null;
			searchQuery = filter.containsKey("searchQuery") ? ((String) filter.get("searchQuery")).toLowerCase() : null;
			schedule = filter.containsKey("schedule") ? (String.valueOf(filter.get("schedule"))) : null;

		}

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplica(searchQuery, statusType, schedule);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");

				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setStreetName(
						customers.get("streetName") != null ? (String) customers.get("streetName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicasBySchedule(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String scheduleId = null;

		Schedule schedule = scheduleDao.getlatestScheduleCustomers();

		if (schedule != null) {

			try {
				scheduleId = schedule.getsId() != null ? schedule.getsId().toString() : null;
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

		statusType = request.containsKey("statusType") ? ((String) request.get("statusType")).toLowerCase() : "Success";

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplicaBySchdeule(statusType, scheduleId);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");
				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				System.out.println("customers" + customers.get("customerName"));

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public CustomerOrderReplica getCustomerOrderReplicaByCartId(String cartId) {

		CustomerOrderReplica CustomerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(cartId,
				currentUser.getContactNumber());

		ObjectMapper objectMapper = new ObjectMapper();
		try {

			// convert JSON string to Map
			Map<String, Object> customerOrderReplicaMap = objectMapper
					.readValue(CustomerOrderReplica.getCustomerOrderDetails(), Map.class);

			Object customerOrder = customerOrderReplicaMap.get("customerOrder");
			Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

			Object quanityList = items.get("quantity");
			Map customers = customerDetailsDao.getByContactNumberAndApartment(CustomerOrderReplica.getContactNumber(),
					CustomerOrderReplica.getApartmentId());

			System.out.println("customers" + customers.get("customerName"));

			// Apartments apartments =
			// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
			CustomerOrderReplica.setApartmentName(
					customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

			CustomerOrderReplica.setCustomerDetails(customers);

			CustomerOrderReplica.setCustomerOrder(customerOrder);
			CustomerOrderReplica.setQuatityList(quanityList);

		} catch (Exception e) {
			e.printStackTrace();
		}

		return CustomerOrderReplica;

	}

	@Override
	public Map createCustomerOrderReplica(CustomerOrderReplicaRequest customerOrderReplicaRequest, String contactNumber,
			Integer aparmentId) {

		if (customerOrderReplicaRequest.getRazorPayRequest() != null) {

//			Map razorPay = consumerService.createRazorPayOrder(customerOrderReplicaRequest.getRazorPayRequest());
//			customerOrderReplicaRequest.setOrderId(razorPay.get("order") != null ? (String)((RazorPay) razorPay.get("order")).getId() : null);	
//	
//			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);
//
//			razorPay.put("cartId", customerOrderReplicaRequest.getCartId());

			Map customerOrderReplicaMap = new HashMap<>();

			Map orderId = new HashMap<>();
			String transactionId = getMerchantTransactionId();
			orderId.put("id", transactionId);

			customerOrderReplicaMap.put("order", orderId);

			customerOrderReplicaRequest.setOrderId(transactionId);
			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);

			customerOrderReplicaMap.put("cartId", customerOrderReplicaRequest.getCartId());

			try {
				customerOrderReplicaMap.put("phonePeResponse",
						phonepeServiceImpl.initiatePhonepePayment(transactionId,
								Integer.valueOf(customerOrderReplicaRequest.getRazorPayRequest().getAmount()),
								contactNumber, customerOrderReplicaRequest.getRedirectUrl(), customerOrderReplicaRequest.getCallBackUrl()));

			} catch (Exception e) {
				e.printStackTrace();
				customerOrderReplicaMap.put("phonePeResponse", new HashedMap<>());
			}

			return customerOrderReplicaMap;

		} else {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
					"paymentDetails transcation Details are mandatory");
		}

	}

	private static String getMerchantTransactionId() {

		return "OD_" + MerchantTransactionIdGenerator.getRandomString();
	}


	@Override
	public List<CustomerOrderReplica> getCustomerOrderByMoblieNo(String contactNumber, Integer aid) {

	    Schedule latestSchedule = customerOrderReplicaDoa.getlatestschedule();

	    if (latestSchedule != null && latestSchedule.getCreationTimestamp() != null) {
	        if (latestSchedule.getStatus().equals(UserStatus.ACTIVE)) {
	            Customers customer = customerDetailsDao.getByContactNoAndApartment(contactNumber, aid);

	            if (customer != null) { // Ensure the customer exists
	                List<CustomerOrder> customerOrderList = customerOrderReplicaDoa.getListCustomerOrderByCustomerId(customer.getCtId());

	                double totalOrderAmount = 0.0;

	                if (customerOrderList != null && !customerOrderList.isEmpty()) {
	                    for (CustomerOrder customerOrder : customerOrderList) {
	                        Double orderAmount = customerOrder.getAmount();
	                        if (orderAmount != null) {
	                            totalOrderAmount += orderAmount;
	                            if(totalOrderAmount>200) {
	                            	totalOrderAmount+= customerOrder.getDelivaryCharges();
	                            }
	                            else(totalOrderAmount<200){
	                            	totalOrderAmount-= customerOrder.getDelivaryCharges();
	                            }
	                        }
	                    }

	                    // Define the minimum order amount for applying delivery charges
	                    double minimumOrderAmount = 200.0;

	                    if (totalOrderAmount < minimumOrderAmount) {
	                        System.out.println("Delivery Charges will be applicable");
	                    } else {
	                        // No delivery charges applicable
	                        System.out.println("No Delivery charges applicable");
	                    }

	                    List<CustomerOrderReplica> customerOrderReplicas = new ArrayList<>();
	                    return customerOrderReplicas;
	                } else {
	                    return Collections.emptyList();
	                }
	            } else {
	                return null; // or an appropriate value
	            }
	        } else {
	            // Handle the case when the latest schedule is not active
	            return null; // or an appropriate value
	        }
	    } else {
	        // Handle the case when there is no latest schedule or its creation timestamp is null
	        return null; // or an appropriate value
	    }
	}

}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4035)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3635)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-09-21 15:33:49.031
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4035)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3635)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-09-21 15:33:49.033
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4035)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3635)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-21 15:33:49.087
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.xyram.daydrop.serviceimpl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.transaction.Transactional;

import org.apache.commons.collections4.map.HashedMap;
import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.server.ResponseStatusException;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.xyram.daydrop.admin.model.CurrentUser;
import com.xyram.daydrop.basemodel.Base64Wrapper;
import com.xyram.daydrop.basemodel.MerchantTransactionIdGenerator;
import com.xyram.daydrop.basemodel.PhonepeSerializer;
import com.xyram.daydrop.dao.ApartmentDao;
import com.xyram.daydrop.dao.CustomerDetailsDao;
import com.xyram.daydrop.dao.CustomerOrderDao;
import com.xyram.daydrop.dao.CustomerOrderReplicaDoa;
import com.xyram.daydrop.dao.SheduleDao;
import com.xyram.daydrop.enumtypes.UserStatus;
import com.xyram.daydrop.model.Apartments;
import com.xyram.daydrop.model.CustomerOrder;
import com.xyram.daydrop.model.CustomerOrderReplica;
import com.xyram.daydrop.model.Customers;
import com.xyram.daydrop.model.Schedule;
import com.xyram.daydrop.modelMapper.PaymentInstrument;
import com.xyram.daydrop.modelMapper.PhonePePayModel;
import com.xyram.daydrop.request.CustomerOrderReplicaRequest;
import com.xyram.daydrop.response.RazorPayRequest;
import com.xyram.daydrop.service.CustomerOrderPriceService;
import com.xyram.daydrop.service.CustomerOrderReplicaService;
import com.xyram.daydrop.util.HashEncoder;
import com.xyram.daydrop.util.RazorPay;
import com.xyram.daydrop.service.ConsumerService;

@Transactional
@Service
public class CustomerOrderReplicaServiceImpl implements CustomerOrderReplicaService {

	@Autowired
	CustomerOrderReplicaDoa customerOrderReplicaDoa;

	@Autowired
	ApartmentDao apartmentDao;

	@Autowired
	SheduleDao scheduleDao;

	@Autowired
	CustomerDetailsDao customerDetailsDao;

	@Autowired
	ConsumerService consumerService;

	@Autowired
	CurrentUser currentUser;

	@Autowired
	PhonepeServiceImpl phonepeServiceImpl;

	@Value("${merchant_id}")
	private String merchantId;

	@Value("${salt_key}")
	private String saltKey;

	@Value("${salt_index}")
	private String saltIndex;

	@Override
	public Map createCustomerOrderReplicaService(CustomerOrderReplicaRequest customerOrderReplicaRequest,
			String contactNumber, Integer aparmentId)

	{

		Map response = new HashedMap<>();

		response.put("message", "success");
		CustomerOrderReplica customerOrderReplica = null;

		if (customerOrderReplicaRequest.getCartId() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "cartId is mandatory ");
		}
		long razorPayCount = 0;
		if (customerOrderReplicaRequest.getOrderId() != null) {

			razorPayCount = customerOrderReplicaDoa.getRazorPayExistByCartId(customerOrderReplicaRequest.getOrderId());
		}

		if (customerOrderReplicaRequest.getCustomerDetails() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Order Details  is mandatory ");
		}

		customerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(customerOrderReplicaRequest.getCartId(),
				contactNumber);

		if (customerOrderReplica != null) {
			customerOrderReplica.setCartId(customerOrderReplica.getCartId());

			if (customerOrderReplica.isOrdered()) {
				throw new ResponseStatusException(HttpStatus.CONFLICT, "Your Order is Placed With cart Details");
			}

//			if (razorPayCount >= 1 && !(customerOrderReplica.getRazorPayOrderId() != null
//					&& customerOrderReplica.getRazorPayOrderId().equals(customerOrderReplicaRequest.getOrderId()))) {
//				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
//			}

			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);

			customerOrderReplica.setAttempts(customerOrderReplica.getAttempts() + 1);
			customerOrderReplica.setUpdatedTime(new Date());

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		} else {

			customerOrderReplica = new CustomerOrderReplica();
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);
			customerOrderReplica.setCartId(customerOrderReplicaRequest.getCartId());
			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());

			if (razorPayCount > 0) {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
			}

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			Schedule schedule = scheduleDao.getlatestScheduleCustomers();

			if (schedule != null) {

				try {
					customerOrderReplica.setSchedule(schedule.getsId() != null ? schedule.getsId().toString() : null);
				} catch (Exception e) {
					e.printStackTrace();
				}
			} else {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
						"Sorry We Are Not Accepting Any Order Right now");

			}

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		}

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicas(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String schedule = null;

		Map filter = request.containsKey("filters") ? (Map) request.get("filters") : null;
		if (filter != null) {
			statusType = filter.containsKey("statusType") ? ((String) filter.get("statusType")).toLowerCase() : null;
			searchQuery = filter.containsKey("searchQuery") ? ((String) filter.get("searchQuery")).toLowerCase() : null;
			schedule = filter.containsKey("schedule") ? (String.valueOf(filter.get("schedule"))) : null;

		}

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplica(searchQuery, statusType, schedule);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");

				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setStreetName(
						customers.get("streetName") != null ? (String) customers.get("streetName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicasBySchedule(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String scheduleId = null;

		Schedule schedule = scheduleDao.getlatestScheduleCustomers();

		if (schedule != null) {

			try {
				scheduleId = schedule.getsId() != null ? schedule.getsId().toString() : null;
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

		statusType = request.containsKey("statusType") ? ((String) request.get("statusType")).toLowerCase() : "Success";

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplicaBySchdeule(statusType, scheduleId);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");
				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				System.out.println("customers" + customers.get("customerName"));

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public CustomerOrderReplica getCustomerOrderReplicaByCartId(String cartId) {

		CustomerOrderReplica CustomerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(cartId,
				currentUser.getContactNumber());

		ObjectMapper objectMapper = new ObjectMapper();
		try {

			// convert JSON string to Map
			Map<String, Object> customerOrderReplicaMap = objectMapper
					.readValue(CustomerOrderReplica.getCustomerOrderDetails(), Map.class);

			Object customerOrder = customerOrderReplicaMap.get("customerOrder");
			Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

			Object quanityList = items.get("quantity");
			Map customers = customerDetailsDao.getByContactNumberAndApartment(CustomerOrderReplica.getContactNumber(),
					CustomerOrderReplica.getApartmentId());

			System.out.println("customers" + customers.get("customerName"));

			// Apartments apartments =
			// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
			CustomerOrderReplica.setApartmentName(
					customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

			CustomerOrderReplica.setCustomerDetails(customers);

			CustomerOrderReplica.setCustomerOrder(customerOrder);
			CustomerOrderReplica.setQuatityList(quanityList);

		} catch (Exception e) {
			e.printStackTrace();
		}

		return CustomerOrderReplica;

	}

	@Override
	public Map createCustomerOrderReplica(CustomerOrderReplicaRequest customerOrderReplicaRequest, String contactNumber,
			Integer aparmentId) {

		if (customerOrderReplicaRequest.getRazorPayRequest() != null) {

//			Map razorPay = consumerService.createRazorPayOrder(customerOrderReplicaRequest.getRazorPayRequest());
//			customerOrderReplicaRequest.setOrderId(razorPay.get("order") != null ? (String)((RazorPay) razorPay.get("order")).getId() : null);	
//	
//			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);
//
//			razorPay.put("cartId", customerOrderReplicaRequest.getCartId());

			Map customerOrderReplicaMap = new HashMap<>();

			Map orderId = new HashMap<>();
			String transactionId = getMerchantTransactionId();
			orderId.put("id", transactionId);

			customerOrderReplicaMap.put("order", orderId);

			customerOrderReplicaRequest.setOrderId(transactionId);
			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);

			customerOrderReplicaMap.put("cartId", customerOrderReplicaRequest.getCartId());

			try {
				customerOrderReplicaMap.put("phonePeResponse",
						phonepeServiceImpl.initiatePhonepePayment(transactionId,
								Integer.valueOf(customerOrderReplicaRequest.getRazorPayRequest().getAmount()),
								contactNumber, customerOrderReplicaRequest.getRedirectUrl(), customerOrderReplicaRequest.getCallBackUrl()));

			} catch (Exception e) {
				e.printStackTrace();
				customerOrderReplicaMap.put("phonePeResponse", new HashedMap<>());
			}

			return customerOrderReplicaMap;

		} else {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
					"paymentDetails transcation Details are mandatory");
		}

	}

	private static String getMerchantTransactionId() {

		return "OD_" + MerchantTransactionIdGenerator.getRandomString();
	}


	@Override
	public List<CustomerOrderReplica> getCustomerOrderByMoblieNo(String contactNumber, Integer aid) {

	    Schedule latestSchedule = customerOrderReplicaDoa.getlatestschedule();

	    if (latestSchedule != null && latestSchedule.getCreationTimestamp() != null) {
	        if (latestSchedule.getStatus().equals(UserStatus.ACTIVE)) {
	            Customers customer = customerDetailsDao.getByContactNoAndApartment(contactNumber, aid);

	            if (customer != null) { // Ensure the customer exists
	                List<CustomerOrder> customerOrderList = customerOrderReplicaDoa.getListCustomerOrderByCustomerId(customer.getCtId());

	                double totalOrderAmount = 0.0;

	                if (customerOrderList != null && !customerOrderList.isEmpty()) {
	                    for (CustomerOrder customerOrder : customerOrderList) {
	                        Double orderAmount = customerOrder.getAmount();
	                        if (orderAmount != null) {
	                            totalOrderAmount += orderAmount;
	                            if(totalOrderAmount>200) {
	                            	totalOrderAmount+= customerOrder.getDelivaryCharges();
	                            }
	                            else(totalOrderAmount<200){
	                            	totalOrderAmount-= customerOrder.getDelivaryCharges();
	                            }
	                        }
	                    }

	                    // Define the minimum order amount for applying delivery charges
	                    double minimumOrderAmount = 200.0;

	                    if (totalOrderAmount < minimumOrderAmount) {
	                        System.out.println("Delivery Charges will be applicable");
	                    } else {
	                        // No delivery charges applicable
	                        System.out.println("No Delivery charges applicable");
	                    }

	                    List<CustomerOrderReplica> customerOrderReplicas = new ArrayList<>();
	                    return customerOrderReplicas;
	                } else {
	                    return Collections.emptyList();
	                }
	            } else {
	                return null; // or an appropriate value
	            }
	        } else {
	            // Handle the case when the latest schedule is not active
	            return null; // or an appropriate value
	        }
	    } else {
	        // Handle the case when there is no latest schedule or its creation timestamp is null
	        return null; // or an appropriate value
	    }
	}

}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.internal.core.manipulation.dom.ASTResolving.createQuickFixAST(ASTResolving.java:1052)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:131)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4035)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3635)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.ui 4 0 2023-09-21 15:33:49.089
!MESSAGE Unhandled event loop exception
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.internal.core.manipulation.dom.ASTResolving.createQuickFixAST(ASTResolving.java:1052)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:131)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4035)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3635)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-21 15:33:53.074
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.xyram.daydrop.serviceimpl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.transaction.Transactional;

import org.apache.commons.collections4.map.HashedMap;
import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.server.ResponseStatusException;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.xyram.daydrop.admin.model.CurrentUser;
import com.xyram.daydrop.basemodel.Base64Wrapper;
import com.xyram.daydrop.basemodel.MerchantTransactionIdGenerator;
import com.xyram.daydrop.basemodel.PhonepeSerializer;
import com.xyram.daydrop.dao.ApartmentDao;
import com.xyram.daydrop.dao.CustomerDetailsDao;
import com.xyram.daydrop.dao.CustomerOrderDao;
import com.xyram.daydrop.dao.CustomerOrderReplicaDoa;
import com.xyram.daydrop.dao.SheduleDao;
import com.xyram.daydrop.enumtypes.UserStatus;
import com.xyram.daydrop.model.Apartments;
import com.xyram.daydrop.model.CustomerOrder;
import com.xyram.daydrop.model.CustomerOrderReplica;
import com.xyram.daydrop.model.Customers;
import com.xyram.daydrop.model.Schedule;
import com.xyram.daydrop.modelMapper.PaymentInstrument;
import com.xyram.daydrop.modelMapper.PhonePePayModel;
import com.xyram.daydrop.request.CustomerOrderReplicaRequest;
import com.xyram.daydrop.response.RazorPayRequest;
import com.xyram.daydrop.service.CustomerOrderPriceService;
import com.xyram.daydrop.service.CustomerOrderReplicaService;
import com.xyram.daydrop.util.HashEncoder;
import com.xyram.daydrop.util.RazorPay;
import com.xyram.daydrop.service.ConsumerService;

@Transactional
@Service
public class CustomerOrderReplicaServiceImpl implements CustomerOrderReplicaService {

	@Autowired
	CustomerOrderReplicaDoa customerOrderReplicaDoa;

	@Autowired
	ApartmentDao apartmentDao;

	@Autowired
	SheduleDao scheduleDao;

	@Autowired
	CustomerDetailsDao customerDetailsDao;

	@Autowired
	ConsumerService consumerService;

	@Autowired
	CurrentUser currentUser;

	@Autowired
	PhonepeServiceImpl phonepeServiceImpl;

	@Value("${merchant_id}")
	private String merchantId;

	@Value("${salt_key}")
	private String saltKey;

	@Value("${salt_index}")
	private String saltIndex;

	@Override
	public Map createCustomerOrderReplicaService(CustomerOrderReplicaRequest customerOrderReplicaRequest,
			String contactNumber, Integer aparmentId)

	{

		Map response = new HashedMap<>();

		response.put("message", "success");
		CustomerOrderReplica customerOrderReplica = null;

		if (customerOrderReplicaRequest.getCartId() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "cartId is mandatory ");
		}
		long razorPayCount = 0;
		if (customerOrderReplicaRequest.getOrderId() != null) {

			razorPayCount = customerOrderReplicaDoa.getRazorPayExistByCartId(customerOrderReplicaRequest.getOrderId());
		}

		if (customerOrderReplicaRequest.getCustomerDetails() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Order Details  is mandatory ");
		}

		customerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(customerOrderReplicaRequest.getCartId(),
				contactNumber);

		if (customerOrderReplica != null) {
			customerOrderReplica.setCartId(customerOrderReplica.getCartId());

			if (customerOrderReplica.isOrdered()) {
				throw new ResponseStatusException(HttpStatus.CONFLICT, "Your Order is Placed With cart Details");
			}

//			if (razorPayCount >= 1 && !(customerOrderReplica.getRazorPayOrderId() != null
//					&& customerOrderReplica.getRazorPayOrderId().equals(customerOrderReplicaRequest.getOrderId()))) {
//				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
//			}

			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);

			customerOrderReplica.setAttempts(customerOrderReplica.getAttempts() + 1);
			customerOrderReplica.setUpdatedTime(new Date());

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		} else {

			customerOrderReplica = new CustomerOrderReplica();
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);
			customerOrderReplica.setCartId(customerOrderReplicaRequest.getCartId());
			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());

			if (razorPayCount > 0) {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
			}

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			Schedule schedule = scheduleDao.getlatestScheduleCustomers();

			if (schedule != null) {

				try {
					customerOrderReplica.setSchedule(schedule.getsId() != null ? schedule.getsId().toString() : null);
				} catch (Exception e) {
					e.printStackTrace();
				}
			} else {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
						"Sorry We Are Not Accepting Any Order Right now");

			}

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		}

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicas(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String schedule = null;

		Map filter = request.containsKey("filters") ? (Map) request.get("filters") : null;
		if (filter != null) {
			statusType = filter.containsKey("statusType") ? ((String) filter.get("statusType")).toLowerCase() : null;
			searchQuery = filter.containsKey("searchQuery") ? ((String) filter.get("searchQuery")).toLowerCase() : null;
			schedule = filter.containsKey("schedule") ? (String.valueOf(filter.get("schedule"))) : null;

		}

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplica(searchQuery, statusType, schedule);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");

				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setStreetName(
						customers.get("streetName") != null ? (String) customers.get("streetName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicasBySchedule(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String scheduleId = null;

		Schedule schedule = scheduleDao.getlatestScheduleCustomers();

		if (schedule != null) {

			try {
				scheduleId = schedule.getsId() != null ? schedule.getsId().toString() : null;
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

		statusType = request.containsKey("statusType") ? ((String) request.get("statusType")).toLowerCase() : "Success";

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplicaBySchdeule(statusType, scheduleId);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");
				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				System.out.println("customers" + customers.get("customerName"));

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public CustomerOrderReplica getCustomerOrderReplicaByCartId(String cartId) {

		CustomerOrderReplica CustomerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(cartId,
				currentUser.getContactNumber());

		ObjectMapper objectMapper = new ObjectMapper();
		try {

			// convert JSON string to Map
			Map<String, Object> customerOrderReplicaMap = objectMapper
					.readValue(CustomerOrderReplica.getCustomerOrderDetails(), Map.class);

			Object customerOrder = customerOrderReplicaMap.get("customerOrder");
			Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

			Object quanityList = items.get("quantity");
			Map customers = customerDetailsDao.getByContactNumberAndApartment(CustomerOrderReplica.getContactNumber(),
					CustomerOrderReplica.getApartmentId());

			System.out.println("customers" + customers.get("customerName"));

			// Apartments apartments =
			// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
			CustomerOrderReplica.setApartmentName(
					customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

			CustomerOrderReplica.setCustomerDetails(customers);

			CustomerOrderReplica.setCustomerOrder(customerOrder);
			CustomerOrderReplica.setQuatityList(quanityList);

		} catch (Exception e) {
			e.printStackTrace();
		}

		return CustomerOrderReplica;

	}

	@Override
	public Map createCustomerOrderReplica(CustomerOrderReplicaRequest customerOrderReplicaRequest, String contactNumber,
			Integer aparmentId) {

		if (customerOrderReplicaRequest.getRazorPayRequest() != null) {

//			Map razorPay = consumerService.createRazorPayOrder(customerOrderReplicaRequest.getRazorPayRequest());
//			customerOrderReplicaRequest.setOrderId(razorPay.get("order") != null ? (String)((RazorPay) razorPay.get("order")).getId() : null);	
//	
//			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);
//
//			razorPay.put("cartId", customerOrderReplicaRequest.getCartId());

			Map customerOrderReplicaMap = new HashMap<>();

			Map orderId = new HashMap<>();
			String transactionId = getMerchantTransactionId();
			orderId.put("id", transactionId);

			customerOrderReplicaMap.put("order", orderId);

			customerOrderReplicaRequest.setOrderId(transactionId);
			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);

			customerOrderReplicaMap.put("cartId", customerOrderReplicaRequest.getCartId());

			try {
				customerOrderReplicaMap.put("phonePeResponse",
						phonepeServiceImpl.initiatePhonepePayment(transactionId,
								Integer.valueOf(customerOrderReplicaRequest.getRazorPayRequest().getAmount()),
								contactNumber, customerOrderReplicaRequest.getRedirectUrl(), customerOrderReplicaRequest.getCallBackUrl()));

			} catch (Exception e) {
				e.printStackTrace();
				customerOrderReplicaMap.put("phonePeResponse", new HashedMap<>());
			}

			return customerOrderReplicaMap;

		} else {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
					"paymentDetails transcation Details are mandatory");
		}

	}

	private static String getMerchantTransactionId() {

		return "OD_" + MerchantTransactionIdGenerator.getRandomString();
	}


	@Override
	public List<CustomerOrderReplica> getCustomerOrderByMoblieNo(String contactNumber, Integer aid) {

	    Schedule latestSchedule = customerOrderReplicaDoa.getlatestschedule();

	    if (latestSchedule != null && latestSchedule.getCreationTimestamp() != null) {
	        if (latestSchedule.getStatus().equals(UserStatus.ACTIVE)) {
	            Customers customer = customerDetailsDao.getByContactNoAndApartment(contactNumber, aid);

	            if (customer != null) { // Ensure the customer exists
	                List<CustomerOrder> customerOrderList = customerOrderReplicaDoa.getListCustomerOrderByCustomerId(customer.getCtId());

	                double totalOrderAmount = 0.0;

	                if (customerOrderList != null && !customerOrderList.isEmpty()) {
	                    for (CustomerOrder customerOrder : customerOrderList) {
	                        Double orderAmount = customerOrder.getAmount();
	                        if (orderAmount != null) {
	                            totalOrderAmount += orderAmount;
	                            if(totalOrderAmount>200) {
	                            	totalOrderAmount+= customerOrder.getDelivaryCharges();
	                            }
	                            else(totalOrderAmount<200){
	                            	totalOrderAmount-= customerOrder.getDelivaryCharges();
	                            }
	                        }
	                    }

	                    // Define the minimum order amount for applying delivery charges
	                    double minimumOrderAmount = 200.0;

	                    if (totalOrderAmount < minimumOrderAmount) {
	                        System.out.println("Delivery Charges will be applicable");
	                    } else {
	                        // No delivery charges applicable
	                        System.out.println("No Delivery charges applicable");
	                    }

	                    List<CustomerOrderReplica> customerOrderReplicas = new ArrayList<>();
	                    return customerOrderReplicas;
	                } else {
	                    return Collections.emptyList();
	                }
	            } else {
	                return null; // or an appropriate value
	            }
	        } else {
	            // Handle the case when the latest schedule is not active
	            return null; // or an appropriate value
	        }
	    } else {
	        // Handle the case when there is no latest schedule or its creation timestamp is null
	        return null; // or an appropriate value
	    }
	}

}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-09-21 15:33:53.077
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-09-21 15:33:53.078
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-21 15:33:53.479
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.xyram.daydrop.serviceimpl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.transaction.Transactional;

import org.apache.commons.collections4.map.HashedMap;
import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.server.ResponseStatusException;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.xyram.daydrop.admin.model.CurrentUser;
import com.xyram.daydrop.basemodel.Base64Wrapper;
import com.xyram.daydrop.basemodel.MerchantTransactionIdGenerator;
import com.xyram.daydrop.basemodel.PhonepeSerializer;
import com.xyram.daydrop.dao.ApartmentDao;
import com.xyram.daydrop.dao.CustomerDetailsDao;
import com.xyram.daydrop.dao.CustomerOrderDao;
import com.xyram.daydrop.dao.CustomerOrderReplicaDoa;
import com.xyram.daydrop.dao.SheduleDao;
import com.xyram.daydrop.enumtypes.UserStatus;
import com.xyram.daydrop.model.Apartments;
import com.xyram.daydrop.model.CustomerOrder;
import com.xyram.daydrop.model.CustomerOrderReplica;
import com.xyram.daydrop.model.Customers;
import com.xyram.daydrop.model.Schedule;
import com.xyram.daydrop.modelMapper.PaymentInstrument;
import com.xyram.daydrop.modelMapper.PhonePePayModel;
import com.xyram.daydrop.request.CustomerOrderReplicaRequest;
import com.xyram.daydrop.response.RazorPayRequest;
import com.xyram.daydrop.service.CustomerOrderPriceService;
import com.xyram.daydrop.service.CustomerOrderReplicaService;
import com.xyram.daydrop.util.HashEncoder;
import com.xyram.daydrop.util.RazorPay;
import com.xyram.daydrop.service.ConsumerService;

@Transactional
@Service
public class CustomerOrderReplicaServiceImpl implements CustomerOrderReplicaService {

	@Autowired
	CustomerOrderReplicaDoa customerOrderReplicaDoa;

	@Autowired
	ApartmentDao apartmentDao;

	@Autowired
	SheduleDao scheduleDao;

	@Autowired
	CustomerDetailsDao customerDetailsDao;

	@Autowired
	ConsumerService consumerService;

	@Autowired
	CurrentUser currentUser;

	@Autowired
	PhonepeServiceImpl phonepeServiceImpl;

	@Value("${merchant_id}")
	private String merchantId;

	@Value("${salt_key}")
	private String saltKey;

	@Value("${salt_index}")
	private String saltIndex;

	@Override
	public Map createCustomerOrderReplicaService(CustomerOrderReplicaRequest customerOrderReplicaRequest,
			String contactNumber, Integer aparmentId)

	{

		Map response = new HashedMap<>();

		response.put("message", "success");
		CustomerOrderReplica customerOrderReplica = null;

		if (customerOrderReplicaRequest.getCartId() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "cartId is mandatory ");
		}
		long razorPayCount = 0;
		if (customerOrderReplicaRequest.getOrderId() != null) {

			razorPayCount = customerOrderReplicaDoa.getRazorPayExistByCartId(customerOrderReplicaRequest.getOrderId());
		}

		if (customerOrderReplicaRequest.getCustomerDetails() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Order Details  is mandatory ");
		}

		customerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(customerOrderReplicaRequest.getCartId(),
				contactNumber);

		if (customerOrderReplica != null) {
			customerOrderReplica.setCartId(customerOrderReplica.getCartId());

			if (customerOrderReplica.isOrdered()) {
				throw new ResponseStatusException(HttpStatus.CONFLICT, "Your Order is Placed With cart Details");
			}

//			if (razorPayCount >= 1 && !(customerOrderReplica.getRazorPayOrderId() != null
//					&& customerOrderReplica.getRazorPayOrderId().equals(customerOrderReplicaRequest.getOrderId()))) {
//				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
//			}

			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);

			customerOrderReplica.setAttempts(customerOrderReplica.getAttempts() + 1);
			customerOrderReplica.setUpdatedTime(new Date());

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		} else {

			customerOrderReplica = new CustomerOrderReplica();
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);
			customerOrderReplica.setCartId(customerOrderReplicaRequest.getCartId());
			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());

			if (razorPayCount > 0) {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
			}

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			Schedule schedule = scheduleDao.getlatestScheduleCustomers();

			if (schedule != null) {

				try {
					customerOrderReplica.setSchedule(schedule.getsId() != null ? schedule.getsId().toString() : null);
				} catch (Exception e) {
					e.printStackTrace();
				}
			} else {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
						"Sorry We Are Not Accepting Any Order Right now");

			}

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		}

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicas(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String schedule = null;

		Map filter = request.containsKey("filters") ? (Map) request.get("filters") : null;
		if (filter != null) {
			statusType = filter.containsKey("statusType") ? ((String) filter.get("statusType")).toLowerCase() : null;
			searchQuery = filter.containsKey("searchQuery") ? ((String) filter.get("searchQuery")).toLowerCase() : null;
			schedule = filter.containsKey("schedule") ? (String.valueOf(filter.get("schedule"))) : null;

		}

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplica(searchQuery, statusType, schedule);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");

				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setStreetName(
						customers.get("streetName") != null ? (String) customers.get("streetName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicasBySchedule(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String scheduleId = null;

		Schedule schedule = scheduleDao.getlatestScheduleCustomers();

		if (schedule != null) {

			try {
				scheduleId = schedule.getsId() != null ? schedule.getsId().toString() : null;
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

		statusType = request.containsKey("statusType") ? ((String) request.get("statusType")).toLowerCase() : "Success";

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplicaBySchdeule(statusType, scheduleId);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");
				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				System.out.println("customers" + customers.get("customerName"));

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public CustomerOrderReplica getCustomerOrderReplicaByCartId(String cartId) {

		CustomerOrderReplica CustomerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(cartId,
				currentUser.getContactNumber());

		ObjectMapper objectMapper = new ObjectMapper();
		try {

			// convert JSON string to Map
			Map<String, Object> customerOrderReplicaMap = objectMapper
					.readValue(CustomerOrderReplica.getCustomerOrderDetails(), Map.class);

			Object customerOrder = customerOrderReplicaMap.get("customerOrder");
			Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

			Object quanityList = items.get("quantity");
			Map customers = customerDetailsDao.getByContactNumberAndApartment(CustomerOrderReplica.getContactNumber(),
					CustomerOrderReplica.getApartmentId());

			System.out.println("customers" + customers.get("customerName"));

			// Apartments apartments =
			// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
			CustomerOrderReplica.setApartmentName(
					customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

			CustomerOrderReplica.setCustomerDetails(customers);

			CustomerOrderReplica.setCustomerOrder(customerOrder);
			CustomerOrderReplica.setQuatityList(quanityList);

		} catch (Exception e) {
			e.printStackTrace();
		}

		return CustomerOrderReplica;

	}

	@Override
	public Map createCustomerOrderReplica(CustomerOrderReplicaRequest customerOrderReplicaRequest, String contactNumber,
			Integer aparmentId) {

		if (customerOrderReplicaRequest.getRazorPayRequest() != null) {

//			Map razorPay = consumerService.createRazorPayOrder(customerOrderReplicaRequest.getRazorPayRequest());
//			customerOrderReplicaRequest.setOrderId(razorPay.get("order") != null ? (String)((RazorPay) razorPay.get("order")).getId() : null);	
//	
//			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);
//
//			razorPay.put("cartId", customerOrderReplicaRequest.getCartId());

			Map customerOrderReplicaMap = new HashMap<>();

			Map orderId = new HashMap<>();
			String transactionId = getMerchantTransactionId();
			orderId.put("id", transactionId);

			customerOrderReplicaMap.put("order", orderId);

			customerOrderReplicaRequest.setOrderId(transactionId);
			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);

			customerOrderReplicaMap.put("cartId", customerOrderReplicaRequest.getCartId());

			try {
				customerOrderReplicaMap.put("phonePeResponse",
						phonepeServiceImpl.initiatePhonepePayment(transactionId,
								Integer.valueOf(customerOrderReplicaRequest.getRazorPayRequest().getAmount()),
								contactNumber, customerOrderReplicaRequest.getRedirectUrl(), customerOrderReplicaRequest.getCallBackUrl()));

			} catch (Exception e) {
				e.printStackTrace();
				customerOrderReplicaMap.put("phonePeResponse", new HashedMap<>());
			}

			return customerOrderReplicaMap;

		} else {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
					"paymentDetails transcation Details are mandatory");
		}

	}

	private static String getMerchantTransactionId() {

		return "OD_" + MerchantTransactionIdGenerator.getRandomString();
	}


	@Override
	public List<CustomerOrderReplica> getCustomerOrderByMoblieNo(String contactNumber, Integer aid) {

	    Schedule latestSchedule = customerOrderReplicaDoa.getlatestschedule();

	    if (latestSchedule != null && latestSchedule.getCreationTimestamp() != null) {
	        if (latestSchedule.getStatus().equals(UserStatus.ACTIVE)) {
	            Customers customer = customerDetailsDao.getByContactNoAndApartment(contactNumber, aid);

	            if (customer != null) { // Ensure the customer exists
	                List<CustomerOrder> customerOrderList = customerOrderReplicaDoa.getListCustomerOrderByCustomerId(customer.getCtId());

	                double totalOrderAmount = 0.0;

	                if (customerOrderList != null && !customerOrderList.isEmpty()) {
	                    for (CustomerOrder customerOrder : customerOrderList) {
	                        Double orderAmount = customerOrder.getAmount();
	                        if (orderAmount != null) {
	                            totalOrderAmount += orderAmount;
	                            if(totalOrderAmount>200) {
	                            	totalOrderAmount+= customerOrder.getDelivaryCharges();
	                            }
	                            else(totalOrderAmount<200){
	                            	totalOrderAmount-= customerOrder.getDelivaryCharges();
	                            }
	                        }
	                    }

	                    // Define the minimum order amount for applying delivery charges
	                    double minimumOrderAmount = 200.0;

	                    if (totalOrderAmount < minimumOrderAmount) {
	                        System.out.println("Delivery Charges will be applicable");
	                    } else {
	                        // No delivery charges applicable
	                        System.out.println("No Delivery charges applicable");
	                    }

	                    List<CustomerOrderReplica> customerOrderReplicas = new ArrayList<>();
	                    return customerOrderReplicas;
	                } else {
	                    return Collections.emptyList();
	                }
	            } else {
	                return null; // or an appropriate value
	            }
	        } else {
	            // Handle the case when the latest schedule is not active
	            return null; // or an appropriate value
	        }
	    } else {
	        // Handle the case when there is no latest schedule or its creation timestamp is null
	        return null; // or an appropriate value
	    }
	}

}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1003)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:799)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:743)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:666)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:658)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.lambda$0(LSJavaHoverProvider.java:68)
	at java.base/java.util.concurrent.CompletableFuture$AsyncRun.run(CompletableFuture.java:1804)
	at java.base/java.util.concurrent.CompletableFuture$AsyncRun.exec(CompletableFuture.java:1796)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:373)
	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1182)
	at java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1655)
	at java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1622)
	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:165)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-09-21 15:33:53.481
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1003)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:799)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:743)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:666)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:658)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.lambda$0(LSJavaHoverProvider.java:68)
	at java.base/java.util.concurrent.CompletableFuture$AsyncRun.run(CompletableFuture.java:1804)
	at java.base/java.util.concurrent.CompletableFuture$AsyncRun.exec(CompletableFuture.java:1796)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:373)
	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1182)
	at java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1655)
	at java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1622)
	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:165)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-09-21 15:33:53.483
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1003)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:799)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:743)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:666)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:658)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.lambda$0(LSJavaHoverProvider.java:68)
	at java.base/java.util.concurrent.CompletableFuture$AsyncRun.run(CompletableFuture.java:1804)
	at java.base/java.util.concurrent.CompletableFuture$AsyncRun.exec(CompletableFuture.java:1796)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:373)
	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1182)
	at java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1655)
	at java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1622)
	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:165)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-21 15:33:53.591
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.xyram.daydrop.serviceimpl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.transaction.Transactional;

import org.apache.commons.collections4.map.HashedMap;
import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.server.ResponseStatusException;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.xyram.daydrop.admin.model.CurrentUser;
import com.xyram.daydrop.basemodel.Base64Wrapper;
import com.xyram.daydrop.basemodel.MerchantTransactionIdGenerator;
import com.xyram.daydrop.basemodel.PhonepeSerializer;
import com.xyram.daydrop.dao.ApartmentDao;
import com.xyram.daydrop.dao.CustomerDetailsDao;
import com.xyram.daydrop.dao.CustomerOrderDao;
import com.xyram.daydrop.dao.CustomerOrderReplicaDoa;
import com.xyram.daydrop.dao.SheduleDao;
import com.xyram.daydrop.enumtypes.UserStatus;
import com.xyram.daydrop.model.Apartments;
import com.xyram.daydrop.model.CustomerOrder;
import com.xyram.daydrop.model.CustomerOrderReplica;
import com.xyram.daydrop.model.Customers;
import com.xyram.daydrop.model.Schedule;
import com.xyram.daydrop.modelMapper.PaymentInstrument;
import com.xyram.daydrop.modelMapper.PhonePePayModel;
import com.xyram.daydrop.request.CustomerOrderReplicaRequest;
import com.xyram.daydrop.response.RazorPayRequest;
import com.xyram.daydrop.service.CustomerOrderPriceService;
import com.xyram.daydrop.service.CustomerOrderReplicaService;
import com.xyram.daydrop.util.HashEncoder;
import com.xyram.daydrop.util.RazorPay;
import com.xyram.daydrop.service.ConsumerService;

@Transactional
@Service
public class CustomerOrderReplicaServiceImpl implements CustomerOrderReplicaService {

	@Autowired
	CustomerOrderReplicaDoa customerOrderReplicaDoa;

	@Autowired
	ApartmentDao apartmentDao;

	@Autowired
	SheduleDao scheduleDao;

	@Autowired
	CustomerDetailsDao customerDetailsDao;

	@Autowired
	ConsumerService consumerService;

	@Autowired
	CurrentUser currentUser;

	@Autowired
	PhonepeServiceImpl phonepeServiceImpl;

	@Value("${merchant_id}")
	private String merchantId;

	@Value("${salt_key}")
	private String saltKey;

	@Value("${salt_index}")
	private String saltIndex;

	@Override
	public Map createCustomerOrderReplicaService(CustomerOrderReplicaRequest customerOrderReplicaRequest,
			String contactNumber, Integer aparmentId)

	{

		Map response = new HashedMap<>();

		response.put("message", "success");
		CustomerOrderReplica customerOrderReplica = null;

		if (customerOrderReplicaRequest.getCartId() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "cartId is mandatory ");
		}
		long razorPayCount = 0;
		if (customerOrderReplicaRequest.getOrderId() != null) {

			razorPayCount = customerOrderReplicaDoa.getRazorPayExistByCartId(customerOrderReplicaRequest.getOrderId());
		}

		if (customerOrderReplicaRequest.getCustomerDetails() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Order Details  is mandatory ");
		}

		customerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(customerOrderReplicaRequest.getCartId(),
				contactNumber);

		if (customerOrderReplica != null) {
			customerOrderReplica.setCartId(customerOrderReplica.getCartId());

			if (customerOrderReplica.isOrdered()) {
				throw new ResponseStatusException(HttpStatus.CONFLICT, "Your Order is Placed With cart Details");
			}

//			if (razorPayCount >= 1 && !(customerOrderReplica.getRazorPayOrderId() != null
//					&& customerOrderReplica.getRazorPayOrderId().equals(customerOrderReplicaRequest.getOrderId()))) {
//				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
//			}

			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);

			customerOrderReplica.setAttempts(customerOrderReplica.getAttempts() + 1);
			customerOrderReplica.setUpdatedTime(new Date());

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		} else {

			customerOrderReplica = new CustomerOrderReplica();
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);
			customerOrderReplica.setCartId(customerOrderReplicaRequest.getCartId());
			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());

			if (razorPayCount > 0) {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
			}

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			Schedule schedule = scheduleDao.getlatestScheduleCustomers();

			if (schedule != null) {

				try {
					customerOrderReplica.setSchedule(schedule.getsId() != null ? schedule.getsId().toString() : null);
				} catch (Exception e) {
					e.printStackTrace();
				}
			} else {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
						"Sorry We Are Not Accepting Any Order Right now");

			}

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		}

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicas(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String schedule = null;

		Map filter = request.containsKey("filters") ? (Map) request.get("filters") : null;
		if (filter != null) {
			statusType = filter.containsKey("statusType") ? ((String) filter.get("statusType")).toLowerCase() : null;
			searchQuery = filter.containsKey("searchQuery") ? ((String) filter.get("searchQuery")).toLowerCase() : null;
			schedule = filter.containsKey("schedule") ? (String.valueOf(filter.get("schedule"))) : null;

		}

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplica(searchQuery, statusType, schedule);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");

				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setStreetName(
						customers.get("streetName") != null ? (String) customers.get("streetName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicasBySchedule(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String scheduleId = null;

		Schedule schedule = scheduleDao.getlatestScheduleCustomers();

		if (schedule != null) {

			try {
				scheduleId = schedule.getsId() != null ? schedule.getsId().toString() : null;
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

		statusType = request.containsKey("statusType") ? ((String) request.get("statusType")).toLowerCase() : "Success";

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplicaBySchdeule(statusType, scheduleId);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");
				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				System.out.println("customers" + customers.get("customerName"));

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public CustomerOrderReplica getCustomerOrderReplicaByCartId(String cartId) {

		CustomerOrderReplica CustomerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(cartId,
				currentUser.getContactNumber());

		ObjectMapper objectMapper = new ObjectMapper();
		try {

			// convert JSON string to Map
			Map<String, Object> customerOrderReplicaMap = objectMapper
					.readValue(CustomerOrderReplica.getCustomerOrderDetails(), Map.class);

			Object customerOrder = customerOrderReplicaMap.get("customerOrder");
			Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

			Object quanityList = items.get("quantity");
			Map customers = customerDetailsDao.getByContactNumberAndApartment(CustomerOrderReplica.getContactNumber(),
					CustomerOrderReplica.getApartmentId());

			System.out.println("customers" + customers.get("customerName"));

			// Apartments apartments =
			// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
			CustomerOrderReplica.setApartmentName(
					customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

			CustomerOrderReplica.setCustomerDetails(customers);

			CustomerOrderReplica.setCustomerOrder(customerOrder);
			CustomerOrderReplica.setQuatityList(quanityList);

		} catch (Exception e) {
			e.printStackTrace();
		}

		return CustomerOrderReplica;

	}

	@Override
	public Map createCustomerOrderReplica(CustomerOrderReplicaRequest customerOrderReplicaRequest, String contactNumber,
			Integer aparmentId) {

		if (customerOrderReplicaRequest.getRazorPayRequest() != null) {

//			Map razorPay = consumerService.createRazorPayOrder(customerOrderReplicaRequest.getRazorPayRequest());
//			customerOrderReplicaRequest.setOrderId(razorPay.get("order") != null ? (String)((RazorPay) razorPay.get("order")).getId() : null);	
//	
//			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);
//
//			razorPay.put("cartId", customerOrderReplicaRequest.getCartId());

			Map customerOrderReplicaMap = new HashMap<>();

			Map orderId = new HashMap<>();
			String transactionId = getMerchantTransactionId();
			orderId.put("id", transactionId);

			customerOrderReplicaMap.put("order", orderId);

			customerOrderReplicaRequest.setOrderId(transactionId);
			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);

			customerOrderReplicaMap.put("cartId", customerOrderReplicaRequest.getCartId());

			try {
				customerOrderReplicaMap.put("phonePeResponse",
						phonepeServiceImpl.initiatePhonepePayment(transactionId,
								Integer.valueOf(customerOrderReplicaRequest.getRazorPayRequest().getAmount()),
								contactNumber, customerOrderReplicaRequest.getRedirectUrl(), customerOrderReplicaRequest.getCallBackUrl()));

			} catch (Exception e) {
				e.printStackTrace();
				customerOrderReplicaMap.put("phonePeResponse", new HashedMap<>());
			}

			return customerOrderReplicaMap;

		} else {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
					"paymentDetails transcation Details are mandatory");
		}

	}

	private static String getMerchantTransactionId() {

		return "OD_" + MerchantTransactionIdGenerator.getRandomString();
	}


	@Override
	public List<CustomerOrderReplica> getCustomerOrderByMoblieNo(String contactNumber, Integer aid) {

	    Schedule latestSchedule = customerOrderReplicaDoa.getlatestschedule();

	    if (latestSchedule != null && latestSchedule.getCreationTimestamp() != null) {
	        if (latestSchedule.getStatus().equals(UserStatus.ACTIVE)) {
	            Customers customer = customerDetailsDao.getByContactNoAndApartment(contactNumber, aid);

	            if (customer != null) { // Ensure the customer exists
	                List<CustomerOrder> customerOrderList = customerOrderReplicaDoa.getListCustomerOrderByCustomerId(customer.getCtId());

	                double totalOrderAmount = 0.0;

	                if (customerOrderList != null && !customerOrderList.isEmpty()) {
	                    for (CustomerOrder customerOrder : customerOrderList) {
	                        Double orderAmount = customerOrder.getAmount();
	                        if (orderAmount != null) {
	                            totalOrderAmount += orderAmount;
	                            if(totalOrderAmount>200) {
	                            	totalOrderAmount+= customerOrder.getDelivaryCharges();
	                            }
	                            else(totalOrderAmount<200){
	                            	totalOrderAmount-= customerOrder.getDelivaryCharges();
	                            }
	                        }
	                    }

	                    // Define the minimum order amount for applying delivery charges
	                    double minimumOrderAmount = 200.0;

	                    if (totalOrderAmount < minimumOrderAmount) {
	                        System.out.println("Delivery Charges will be applicable");
	                    } else {
	                        // No delivery charges applicable
	                        System.out.println("No Delivery charges applicable");
	                    }

	                    List<CustomerOrderReplica> customerOrderReplicas = new ArrayList<>();
	                    return customerOrderReplicas;
	                } else {
	                    return Collections.emptyList();
	                }
	            } else {
	                return null; // or an appropriate value
	            }
	        } else {
	            // Handle the case when the latest schedule is not active
	            return null; // or an appropriate value
	        }
	    } else {
	        // Handle the case when there is no latest schedule or its creation timestamp is null
	        return null; // or an appropriate value
	    }
	}

}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4035)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3635)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-09-21 15:33:53.593
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4035)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3635)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-09-21 15:33:53.595
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4035)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3635)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-21 15:33:53.651
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.xyram.daydrop.serviceimpl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.transaction.Transactional;

import org.apache.commons.collections4.map.HashedMap;
import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.server.ResponseStatusException;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.xyram.daydrop.admin.model.CurrentUser;
import com.xyram.daydrop.basemodel.Base64Wrapper;
import com.xyram.daydrop.basemodel.MerchantTransactionIdGenerator;
import com.xyram.daydrop.basemodel.PhonepeSerializer;
import com.xyram.daydrop.dao.ApartmentDao;
import com.xyram.daydrop.dao.CustomerDetailsDao;
import com.xyram.daydrop.dao.CustomerOrderDao;
import com.xyram.daydrop.dao.CustomerOrderReplicaDoa;
import com.xyram.daydrop.dao.SheduleDao;
import com.xyram.daydrop.enumtypes.UserStatus;
import com.xyram.daydrop.model.Apartments;
import com.xyram.daydrop.model.CustomerOrder;
import com.xyram.daydrop.model.CustomerOrderReplica;
import com.xyram.daydrop.model.Customers;
import com.xyram.daydrop.model.Schedule;
import com.xyram.daydrop.modelMapper.PaymentInstrument;
import com.xyram.daydrop.modelMapper.PhonePePayModel;
import com.xyram.daydrop.request.CustomerOrderReplicaRequest;
import com.xyram.daydrop.response.RazorPayRequest;
import com.xyram.daydrop.service.CustomerOrderPriceService;
import com.xyram.daydrop.service.CustomerOrderReplicaService;
import com.xyram.daydrop.util.HashEncoder;
import com.xyram.daydrop.util.RazorPay;
import com.xyram.daydrop.service.ConsumerService;

@Transactional
@Service
public class CustomerOrderReplicaServiceImpl implements CustomerOrderReplicaService {

	@Autowired
	CustomerOrderReplicaDoa customerOrderReplicaDoa;

	@Autowired
	ApartmentDao apartmentDao;

	@Autowired
	SheduleDao scheduleDao;

	@Autowired
	CustomerDetailsDao customerDetailsDao;

	@Autowired
	ConsumerService consumerService;

	@Autowired
	CurrentUser currentUser;

	@Autowired
	PhonepeServiceImpl phonepeServiceImpl;

	@Value("${merchant_id}")
	private String merchantId;

	@Value("${salt_key}")
	private String saltKey;

	@Value("${salt_index}")
	private String saltIndex;

	@Override
	public Map createCustomerOrderReplicaService(CustomerOrderReplicaRequest customerOrderReplicaRequest,
			String contactNumber, Integer aparmentId)

	{

		Map response = new HashedMap<>();

		response.put("message", "success");
		CustomerOrderReplica customerOrderReplica = null;

		if (customerOrderReplicaRequest.getCartId() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "cartId is mandatory ");
		}
		long razorPayCount = 0;
		if (customerOrderReplicaRequest.getOrderId() != null) {

			razorPayCount = customerOrderReplicaDoa.getRazorPayExistByCartId(customerOrderReplicaRequest.getOrderId());
		}

		if (customerOrderReplicaRequest.getCustomerDetails() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Order Details  is mandatory ");
		}

		customerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(customerOrderReplicaRequest.getCartId(),
				contactNumber);

		if (customerOrderReplica != null) {
			customerOrderReplica.setCartId(customerOrderReplica.getCartId());

			if (customerOrderReplica.isOrdered()) {
				throw new ResponseStatusException(HttpStatus.CONFLICT, "Your Order is Placed With cart Details");
			}

//			if (razorPayCount >= 1 && !(customerOrderReplica.getRazorPayOrderId() != null
//					&& customerOrderReplica.getRazorPayOrderId().equals(customerOrderReplicaRequest.getOrderId()))) {
//				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
//			}

			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);

			customerOrderReplica.setAttempts(customerOrderReplica.getAttempts() + 1);
			customerOrderReplica.setUpdatedTime(new Date());

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		} else {

			customerOrderReplica = new CustomerOrderReplica();
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);
			customerOrderReplica.setCartId(customerOrderReplicaRequest.getCartId());
			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());

			if (razorPayCount > 0) {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
			}

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			Schedule schedule = scheduleDao.getlatestScheduleCustomers();

			if (schedule != null) {

				try {
					customerOrderReplica.setSchedule(schedule.getsId() != null ? schedule.getsId().toString() : null);
				} catch (Exception e) {
					e.printStackTrace();
				}
			} else {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
						"Sorry We Are Not Accepting Any Order Right now");

			}

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		}

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicas(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String schedule = null;

		Map filter = request.containsKey("filters") ? (Map) request.get("filters") : null;
		if (filter != null) {
			statusType = filter.containsKey("statusType") ? ((String) filter.get("statusType")).toLowerCase() : null;
			searchQuery = filter.containsKey("searchQuery") ? ((String) filter.get("searchQuery")).toLowerCase() : null;
			schedule = filter.containsKey("schedule") ? (String.valueOf(filter.get("schedule"))) : null;

		}

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplica(searchQuery, statusType, schedule);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");

				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setStreetName(
						customers.get("streetName") != null ? (String) customers.get("streetName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicasBySchedule(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String scheduleId = null;

		Schedule schedule = scheduleDao.getlatestScheduleCustomers();

		if (schedule != null) {

			try {
				scheduleId = schedule.getsId() != null ? schedule.getsId().toString() : null;
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

		statusType = request.containsKey("statusType") ? ((String) request.get("statusType")).toLowerCase() : "Success";

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplicaBySchdeule(statusType, scheduleId);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");
				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				System.out.println("customers" + customers.get("customerName"));

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public CustomerOrderReplica getCustomerOrderReplicaByCartId(String cartId) {

		CustomerOrderReplica CustomerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(cartId,
				currentUser.getContactNumber());

		ObjectMapper objectMapper = new ObjectMapper();
		try {

			// convert JSON string to Map
			Map<String, Object> customerOrderReplicaMap = objectMapper
					.readValue(CustomerOrderReplica.getCustomerOrderDetails(), Map.class);

			Object customerOrder = customerOrderReplicaMap.get("customerOrder");
			Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

			Object quanityList = items.get("quantity");
			Map customers = customerDetailsDao.getByContactNumberAndApartment(CustomerOrderReplica.getContactNumber(),
					CustomerOrderReplica.getApartmentId());

			System.out.println("customers" + customers.get("customerName"));

			// Apartments apartments =
			// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
			CustomerOrderReplica.setApartmentName(
					customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

			CustomerOrderReplica.setCustomerDetails(customers);

			CustomerOrderReplica.setCustomerOrder(customerOrder);
			CustomerOrderReplica.setQuatityList(quanityList);

		} catch (Exception e) {
			e.printStackTrace();
		}

		return CustomerOrderReplica;

	}

	@Override
	public Map createCustomerOrderReplica(CustomerOrderReplicaRequest customerOrderReplicaRequest, String contactNumber,
			Integer aparmentId) {

		if (customerOrderReplicaRequest.getRazorPayRequest() != null) {

//			Map razorPay = consumerService.createRazorPayOrder(customerOrderReplicaRequest.getRazorPayRequest());
//			customerOrderReplicaRequest.setOrderId(razorPay.get("order") != null ? (String)((RazorPay) razorPay.get("order")).getId() : null);	
//	
//			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);
//
//			razorPay.put("cartId", customerOrderReplicaRequest.getCartId());

			Map customerOrderReplicaMap = new HashMap<>();

			Map orderId = new HashMap<>();
			String transactionId = getMerchantTransactionId();
			orderId.put("id", transactionId);

			customerOrderReplicaMap.put("order", orderId);

			customerOrderReplicaRequest.setOrderId(transactionId);
			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);

			customerOrderReplicaMap.put("cartId", customerOrderReplicaRequest.getCartId());

			try {
				customerOrderReplicaMap.put("phonePeResponse",
						phonepeServiceImpl.initiatePhonepePayment(transactionId,
								Integer.valueOf(customerOrderReplicaRequest.getRazorPayRequest().getAmount()),
								contactNumber, customerOrderReplicaRequest.getRedirectUrl(), customerOrderReplicaRequest.getCallBackUrl()));

			} catch (Exception e) {
				e.printStackTrace();
				customerOrderReplicaMap.put("phonePeResponse", new HashedMap<>());
			}

			return customerOrderReplicaMap;

		} else {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
					"paymentDetails transcation Details are mandatory");
		}

	}

	private static String getMerchantTransactionId() {

		return "OD_" + MerchantTransactionIdGenerator.getRandomString();
	}


	@Override
	public List<CustomerOrderReplica> getCustomerOrderByMoblieNo(String contactNumber, Integer aid) {

	    Schedule latestSchedule = customerOrderReplicaDoa.getlatestschedule();

	    if (latestSchedule != null && latestSchedule.getCreationTimestamp() != null) {
	        if (latestSchedule.getStatus().equals(UserStatus.ACTIVE)) {
	            Customers customer = customerDetailsDao.getByContactNoAndApartment(contactNumber, aid);

	            if (customer != null) { // Ensure the customer exists
	                List<CustomerOrder> customerOrderList = customerOrderReplicaDoa.getListCustomerOrderByCustomerId(customer.getCtId());

	                double totalOrderAmount = 0.0;

	                if (customerOrderList != null && !customerOrderList.isEmpty()) {
	                    for (CustomerOrder customerOrder : customerOrderList) {
	                        Double orderAmount = customerOrder.getAmount();
	                        if (orderAmount != null) {
	                            totalOrderAmount += orderAmount;
	                            if(totalOrderAmount>200) {
	                            	totalOrderAmount+= customerOrder.getDelivaryCharges();
	                            }
	                            else(totalOrderAmount<200){
	                            	totalOrderAmount-= customerOrder.getDelivaryCharges();
	                            }
	                        }
	                    }

	                    // Define the minimum order amount for applying delivery charges
	                    double minimumOrderAmount = 200.0;

	                    if (totalOrderAmount < minimumOrderAmount) {
	                        System.out.println("Delivery Charges will be applicable");
	                    } else {
	                        // No delivery charges applicable
	                        System.out.println("No Delivery charges applicable");
	                    }

	                    List<CustomerOrderReplica> customerOrderReplicas = new ArrayList<>();
	                    return customerOrderReplicas;
	                } else {
	                    return Collections.emptyList();
	                }
	            } else {
	                return null; // or an appropriate value
	            }
	        } else {
	            // Handle the case when the latest schedule is not active
	            return null; // or an appropriate value
	        }
	    } else {
	        // Handle the case when there is no latest schedule or its creation timestamp is null
	        return null; // or an appropriate value
	    }
	}

}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.internal.core.manipulation.dom.ASTResolving.createQuickFixAST(ASTResolving.java:1052)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:131)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4035)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3635)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.ui 4 0 2023-09-21 15:33:53.653
!MESSAGE Unhandled event loop exception
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.internal.core.manipulation.dom.ASTResolving.createQuickFixAST(ASTResolving.java:1052)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:131)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4035)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3635)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-21 15:33:55.618
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.xyram.daydrop.serviceimpl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.transaction.Transactional;

import org.apache.commons.collections4.map.HashedMap;
import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.server.ResponseStatusException;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.xyram.daydrop.admin.model.CurrentUser;
import com.xyram.daydrop.basemodel.Base64Wrapper;
import com.xyram.daydrop.basemodel.MerchantTransactionIdGenerator;
import com.xyram.daydrop.basemodel.PhonepeSerializer;
import com.xyram.daydrop.dao.ApartmentDao;
import com.xyram.daydrop.dao.CustomerDetailsDao;
import com.xyram.daydrop.dao.CustomerOrderDao;
import com.xyram.daydrop.dao.CustomerOrderReplicaDoa;
import com.xyram.daydrop.dao.SheduleDao;
import com.xyram.daydrop.enumtypes.UserStatus;
import com.xyram.daydrop.model.Apartments;
import com.xyram.daydrop.model.CustomerOrder;
import com.xyram.daydrop.model.CustomerOrderReplica;
import com.xyram.daydrop.model.Customers;
import com.xyram.daydrop.model.Schedule;
import com.xyram.daydrop.modelMapper.PaymentInstrument;
import com.xyram.daydrop.modelMapper.PhonePePayModel;
import com.xyram.daydrop.request.CustomerOrderReplicaRequest;
import com.xyram.daydrop.response.RazorPayRequest;
import com.xyram.daydrop.service.CustomerOrderPriceService;
import com.xyram.daydrop.service.CustomerOrderReplicaService;
import com.xyram.daydrop.util.HashEncoder;
import com.xyram.daydrop.util.RazorPay;
import com.xyram.daydrop.service.ConsumerService;

@Transactional
@Service
public class CustomerOrderReplicaServiceImpl implements CustomerOrderReplicaService {

	@Autowired
	CustomerOrderReplicaDoa customerOrderReplicaDoa;

	@Autowired
	ApartmentDao apartmentDao;

	@Autowired
	SheduleDao scheduleDao;

	@Autowired
	CustomerDetailsDao customerDetailsDao;

	@Autowired
	ConsumerService consumerService;

	@Autowired
	CurrentUser currentUser;

	@Autowired
	PhonepeServiceImpl phonepeServiceImpl;

	@Value("${merchant_id}")
	private String merchantId;

	@Value("${salt_key}")
	private String saltKey;

	@Value("${salt_index}")
	private String saltIndex;

	@Override
	public Map createCustomerOrderReplicaService(CustomerOrderReplicaRequest customerOrderReplicaRequest,
			String contactNumber, Integer aparmentId)

	{

		Map response = new HashedMap<>();

		response.put("message", "success");
		CustomerOrderReplica customerOrderReplica = null;

		if (customerOrderReplicaRequest.getCartId() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "cartId is mandatory ");
		}
		long razorPayCount = 0;
		if (customerOrderReplicaRequest.getOrderId() != null) {

			razorPayCount = customerOrderReplicaDoa.getRazorPayExistByCartId(customerOrderReplicaRequest.getOrderId());
		}

		if (customerOrderReplicaRequest.getCustomerDetails() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Order Details  is mandatory ");
		}

		customerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(customerOrderReplicaRequest.getCartId(),
				contactNumber);

		if (customerOrderReplica != null) {
			customerOrderReplica.setCartId(customerOrderReplica.getCartId());

			if (customerOrderReplica.isOrdered()) {
				throw new ResponseStatusException(HttpStatus.CONFLICT, "Your Order is Placed With cart Details");
			}

//			if (razorPayCount >= 1 && !(customerOrderReplica.getRazorPayOrderId() != null
//					&& customerOrderReplica.getRazorPayOrderId().equals(customerOrderReplicaRequest.getOrderId()))) {
//				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
//			}

			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);

			customerOrderReplica.setAttempts(customerOrderReplica.getAttempts() + 1);
			customerOrderReplica.setUpdatedTime(new Date());

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		} else {

			customerOrderReplica = new CustomerOrderReplica();
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);
			customerOrderReplica.setCartId(customerOrderReplicaRequest.getCartId());
			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());

			if (razorPayCount > 0) {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
			}

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			Schedule schedule = scheduleDao.getlatestScheduleCustomers();

			if (schedule != null) {

				try {
					customerOrderReplica.setSchedule(schedule.getsId() != null ? schedule.getsId().toString() : null);
				} catch (Exception e) {
					e.printStackTrace();
				}
			} else {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
						"Sorry We Are Not Accepting Any Order Right now");

			}

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		}

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicas(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String schedule = null;

		Map filter = request.containsKey("filters") ? (Map) request.get("filters") : null;
		if (filter != null) {
			statusType = filter.containsKey("statusType") ? ((String) filter.get("statusType")).toLowerCase() : null;
			searchQuery = filter.containsKey("searchQuery") ? ((String) filter.get("searchQuery")).toLowerCase() : null;
			schedule = filter.containsKey("schedule") ? (String.valueOf(filter.get("schedule"))) : null;

		}

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplica(searchQuery, statusType, schedule);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");

				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setStreetName(
						customers.get("streetName") != null ? (String) customers.get("streetName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicasBySchedule(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String scheduleId = null;

		Schedule schedule = scheduleDao.getlatestScheduleCustomers();

		if (schedule != null) {

			try {
				scheduleId = schedule.getsId() != null ? schedule.getsId().toString() : null;
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

		statusType = request.containsKey("statusType") ? ((String) request.get("statusType")).toLowerCase() : "Success";

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplicaBySchdeule(statusType, scheduleId);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");
				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				System.out.println("customers" + customers.get("customerName"));

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public CustomerOrderReplica getCustomerOrderReplicaByCartId(String cartId) {

		CustomerOrderReplica CustomerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(cartId,
				currentUser.getContactNumber());

		ObjectMapper objectMapper = new ObjectMapper();
		try {

			// convert JSON string to Map
			Map<String, Object> customerOrderReplicaMap = objectMapper
					.readValue(CustomerOrderReplica.getCustomerOrderDetails(), Map.class);

			Object customerOrder = customerOrderReplicaMap.get("customerOrder");
			Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

			Object quanityList = items.get("quantity");
			Map customers = customerDetailsDao.getByContactNumberAndApartment(CustomerOrderReplica.getContactNumber(),
					CustomerOrderReplica.getApartmentId());

			System.out.println("customers" + customers.get("customerName"));

			// Apartments apartments =
			// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
			CustomerOrderReplica.setApartmentName(
					customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

			CustomerOrderReplica.setCustomerDetails(customers);

			CustomerOrderReplica.setCustomerOrder(customerOrder);
			CustomerOrderReplica.setQuatityList(quanityList);

		} catch (Exception e) {
			e.printStackTrace();
		}

		return CustomerOrderReplica;

	}

	@Override
	public Map createCustomerOrderReplica(CustomerOrderReplicaRequest customerOrderReplicaRequest, String contactNumber,
			Integer aparmentId) {

		if (customerOrderReplicaRequest.getRazorPayRequest() != null) {

//			Map razorPay = consumerService.createRazorPayOrder(customerOrderReplicaRequest.getRazorPayRequest());
//			customerOrderReplicaRequest.setOrderId(razorPay.get("order") != null ? (String)((RazorPay) razorPay.get("order")).getId() : null);	
//	
//			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);
//
//			razorPay.put("cartId", customerOrderReplicaRequest.getCartId());

			Map customerOrderReplicaMap = new HashMap<>();

			Map orderId = new HashMap<>();
			String transactionId = getMerchantTransactionId();
			orderId.put("id", transactionId);

			customerOrderReplicaMap.put("order", orderId);

			customerOrderReplicaRequest.setOrderId(transactionId);
			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);

			customerOrderReplicaMap.put("cartId", customerOrderReplicaRequest.getCartId());

			try {
				customerOrderReplicaMap.put("phonePeResponse",
						phonepeServiceImpl.initiatePhonepePayment(transactionId,
								Integer.valueOf(customerOrderReplicaRequest.getRazorPayRequest().getAmount()),
								contactNumber, customerOrderReplicaRequest.getRedirectUrl(), customerOrderReplicaRequest.getCallBackUrl()));

			} catch (Exception e) {
				e.printStackTrace();
				customerOrderReplicaMap.put("phonePeResponse", new HashedMap<>());
			}

			return customerOrderReplicaMap;

		} else {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
					"paymentDetails transcation Details are mandatory");
		}

	}

	private static String getMerchantTransactionId() {

		return "OD_" + MerchantTransactionIdGenerator.getRandomString();
	}


	@Override
	public List<CustomerOrderReplica> getCustomerOrderByMoblieNo(String contactNumber, Integer aid) {

	    Schedule latestSchedule = customerOrderReplicaDoa.getlatestschedule();

	    if (latestSchedule != null && latestSchedule.getCreationTimestamp() != null) {
	        if (latestSchedule.getStatus().equals(UserStatus.ACTIVE)) {
	            Customers customer = customerDetailsDao.getByContactNoAndApartment(contactNumber, aid);

	            if (customer != null) { // Ensure the customer exists
	                List<CustomerOrder> customerOrderList = customerOrderReplicaDoa.getListCustomerOrderByCustomerId(customer.getCtId());

	                double totalOrderAmount = 0.0;

	                if (customerOrderList != null && !customerOrderList.isEmpty()) {
	                    for (CustomerOrder customerOrder : customerOrderList) {
	                        Double orderAmount = customerOrder.getAmount();
	                        if (orderAmount != null) {
	                            totalOrderAmount += orderAmount;
	                            if(totalOrderAmount>200) {
	                            	totalOrderAmount+= customerOrder.getDelivaryCharges();
	                            }
	                            else(totalOrderAmount<200){
	                            	totalOrderAmount-= customerOrder.getDelivaryCharges();
	                            }
	                        }
	                    }

	                    // Define the minimum order amount for applying delivery charges
	                    double minimumOrderAmount = 200.0;

	                    if (totalOrderAmount < minimumOrderAmount) {
	                        System.out.println("Delivery Charges will be applicable");
	                    } else {
	                        // No delivery charges applicable
	                        System.out.println("No Delivery charges applicable");
	                    }

	                    List<CustomerOrderReplica> customerOrderReplicas = new ArrayList<>();
	                    return customerOrderReplicas;
	                } else {
	                    return Collections.emptyList();
	                }
	            } else {
	                return null; // or an appropriate value
	            }
	        } else {
	            // Handle the case when the latest schedule is not active
	            return null; // or an appropriate value
	        }
	    } else {
	        // Handle the case when there is no latest schedule or its creation timestamp is null
	        return null; // or an appropriate value
	    }
	}

}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
