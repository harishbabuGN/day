!SESSION 2023-09-21 10:32:03.159 -----------------------------------------------
eclipse.buildId=4.14.1.202204250734
java.version=17.0.2
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.springframework.boot.ide.branding.sts4
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.springframework.boot.ide.branding.sts4

This is a continuation of log file D:\DaydropDEV\.metadata\.bak_9.log
Created Time: 2023-09-21 15:34:28.519

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-09-21 15:34:28.520
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-09-21 15:34:28.522
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-21 15:34:39.427
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.xyram.daydrop.serviceimpl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.transaction.Transactional;

import org.apache.commons.collections4.map.HashedMap;
import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.server.ResponseStatusException;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.xyram.daydrop.admin.model.CurrentUser;
import com.xyram.daydrop.basemodel.Base64Wrapper;
import com.xyram.daydrop.basemodel.MerchantTransactionIdGenerator;
import com.xyram.daydrop.basemodel.PhonepeSerializer;
import com.xyram.daydrop.dao.ApartmentDao;
import com.xyram.daydrop.dao.CustomerDetailsDao;
import com.xyram.daydrop.dao.CustomerOrderDao;
import com.xyram.daydrop.dao.CustomerOrderReplicaDoa;
import com.xyram.daydrop.dao.SheduleDao;
import com.xyram.daydrop.enumtypes.UserStatus;
import com.xyram.daydrop.model.Apartments;
import com.xyram.daydrop.model.CustomerOrder;
import com.xyram.daydrop.model.CustomerOrderReplica;
import com.xyram.daydrop.model.Customers;
import com.xyram.daydrop.model.Schedule;
import com.xyram.daydrop.modelMapper.PaymentInstrument;
import com.xyram.daydrop.modelMapper.PhonePePayModel;
import com.xyram.daydrop.request.CustomerOrderReplicaRequest;
import com.xyram.daydrop.response.RazorPayRequest;
import com.xyram.daydrop.service.CustomerOrderPriceService;
import com.xyram.daydrop.service.CustomerOrderReplicaService;
import com.xyram.daydrop.util.HashEncoder;
import com.xyram.daydrop.util.RazorPay;
import com.xyram.daydrop.service.ConsumerService;

@Transactional
@Service
public class CustomerOrderReplicaServiceImpl implements CustomerOrderReplicaService {

	@Autowired
	CustomerOrderReplicaDoa customerOrderReplicaDoa;

	@Autowired
	ApartmentDao apartmentDao;

	@Autowired
	SheduleDao scheduleDao;

	@Autowired
	CustomerDetailsDao customerDetailsDao;

	@Autowired
	ConsumerService consumerService;

	@Autowired
	CurrentUser currentUser;

	@Autowired
	PhonepeServiceImpl phonepeServiceImpl;

	@Value("${merchant_id}")
	private String merchantId;

	@Value("${salt_key}")
	private String saltKey;

	@Value("${salt_index}")
	private String saltIndex;

	@Override
	public Map createCustomerOrderReplicaService(CustomerOrderReplicaRequest customerOrderReplicaRequest,
			String contactNumber, Integer aparmentId)

	{

		Map response = new HashedMap<>();

		response.put("message", "success");
		CustomerOrderReplica customerOrderReplica = null;

		if (customerOrderReplicaRequest.getCartId() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "cartId is mandatory ");
		}
		long razorPayCount = 0;
		if (customerOrderReplicaRequest.getOrderId() != null) {

			razorPayCount = customerOrderReplicaDoa.getRazorPayExistByCartId(customerOrderReplicaRequest.getOrderId());
		}

		if (customerOrderReplicaRequest.getCustomerDetails() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Order Details  is mandatory ");
		}

		customerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(customerOrderReplicaRequest.getCartId(),
				contactNumber);

		if (customerOrderReplica != null) {
			customerOrderReplica.setCartId(customerOrderReplica.getCartId());

			if (customerOrderReplica.isOrdered()) {
				throw new ResponseStatusException(HttpStatus.CONFLICT, "Your Order is Placed With cart Details");
			}

//			if (razorPayCount >= 1 && !(customerOrderReplica.getRazorPayOrderId() != null
//					&& customerOrderReplica.getRazorPayOrderId().equals(customerOrderReplicaRequest.getOrderId()))) {
//				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
//			}

			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);

			customerOrderReplica.setAttempts(customerOrderReplica.getAttempts() + 1);
			customerOrderReplica.setUpdatedTime(new Date());

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		} else {

			customerOrderReplica = new CustomerOrderReplica();
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);
			customerOrderReplica.setCartId(customerOrderReplicaRequest.getCartId());
			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());

			if (razorPayCount > 0) {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
			}

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			Schedule schedule = scheduleDao.getlatestScheduleCustomers();

			if (schedule != null) {

				try {
					customerOrderReplica.setSchedule(schedule.getsId() != null ? schedule.getsId().toString() : null);
				} catch (Exception e) {
					e.printStackTrace();
				}
			} else {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
						"Sorry We Are Not Accepting Any Order Right now");

			}

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		}

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicas(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String schedule = null;

		Map filter = request.containsKey("filters") ? (Map) request.get("filters") : null;
		if (filter != null) {
			statusType = filter.containsKey("statusType") ? ((String) filter.get("statusType")).toLowerCase() : null;
			searchQuery = filter.containsKey("searchQuery") ? ((String) filter.get("searchQuery")).toLowerCase() : null;
			schedule = filter.containsKey("schedule") ? (String.valueOf(filter.get("schedule"))) : null;

		}

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplica(searchQuery, statusType, schedule);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");

				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setStreetName(
						customers.get("streetName") != null ? (String) customers.get("streetName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicasBySchedule(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String scheduleId = null;

		Schedule schedule = scheduleDao.getlatestScheduleCustomers();

		if (schedule != null) {

			try {
				scheduleId = schedule.getsId() != null ? schedule.getsId().toString() : null;
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

		statusType = request.containsKey("statusType") ? ((String) request.get("statusType")).toLowerCase() : "Success";

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplicaBySchdeule(statusType, scheduleId);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");
				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				System.out.println("customers" + customers.get("customerName"));

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public CustomerOrderReplica getCustomerOrderReplicaByCartId(String cartId) {

		CustomerOrderReplica CustomerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(cartId,
				currentUser.getContactNumber());

		ObjectMapper objectMapper = new ObjectMapper();
		try {

			// convert JSON string to Map
			Map<String, Object> customerOrderReplicaMap = objectMapper
					.readValue(CustomerOrderReplica.getCustomerOrderDetails(), Map.class);

			Object customerOrder = customerOrderReplicaMap.get("customerOrder");
			Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

			Object quanityList = items.get("quantity");
			Map customers = customerDetailsDao.getByContactNumberAndApartment(CustomerOrderReplica.getContactNumber(),
					CustomerOrderReplica.getApartmentId());

			System.out.println("customers" + customers.get("customerName"));

			// Apartments apartments =
			// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
			CustomerOrderReplica.setApartmentName(
					customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

			CustomerOrderReplica.setCustomerDetails(customers);

			CustomerOrderReplica.setCustomerOrder(customerOrder);
			CustomerOrderReplica.setQuatityList(quanityList);

		} catch (Exception e) {
			e.printStackTrace();
		}

		return CustomerOrderReplica;

	}

	@Override
	public Map createCustomerOrderReplica(CustomerOrderReplicaRequest customerOrderReplicaRequest, String contactNumber,
			Integer aparmentId) {

		if (customerOrderReplicaRequest.getRazorPayRequest() != null) {

//			Map razorPay = consumerService.createRazorPayOrder(customerOrderReplicaRequest.getRazorPayRequest());
//			customerOrderReplicaRequest.setOrderId(razorPay.get("order") != null ? (String)((RazorPay) razorPay.get("order")).getId() : null);	
//	
//			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);
//
//			razorPay.put("cartId", customerOrderReplicaRequest.getCartId());

			Map customerOrderReplicaMap = new HashMap<>();

			Map orderId = new HashMap<>();
			String transactionId = getMerchantTransactionId();
			orderId.put("id", transactionId);

			customerOrderReplicaMap.put("order", orderId);

			customerOrderReplicaRequest.setOrderId(transactionId);
			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);

			customerOrderReplicaMap.put("cartId", customerOrderReplicaRequest.getCartId());

			try {
				customerOrderReplicaMap.put("phonePeResponse",
						phonepeServiceImpl.initiatePhonepePayment(transactionId,
								Integer.valueOf(customerOrderReplicaRequest.getRazorPayRequest().getAmount()),
								contactNumber, customerOrderReplicaRequest.getRedirectUrl(), customerOrderReplicaRequest.getCallBackUrl()));

			} catch (Exception e) {
				e.printStackTrace();
				customerOrderReplicaMap.put("phonePeResponse", new HashedMap<>());
			}

			return customerOrderReplicaMap;

		} else {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
					"paymentDetails transcation Details are mandatory");
		}

	}

	private static String getMerchantTransactionId() {

		return "OD_" + MerchantTransactionIdGenerator.getRandomString();
	}


	@Override
	public List<CustomerOrderReplica> getCustomerOrderByMoblieNo(String contactNumber, Integer aid) {

	    Schedule latestSchedule = customerOrderReplicaDoa.getlatestschedule();

	    if (latestSchedule != null && latestSchedule.getCreationTimestamp() != null) {
	        if (latestSchedule.getStatus().equals(UserStatus.ACTIVE)) {
	            Customers customer = customerDetailsDao.getByContactNoAndApartment(contactNumber, aid);

	            if (customer != null) { // Ensure the customer exists
	                List<CustomerOrder> customerOrderList = customerOrderReplicaDoa.getListCustomerOrderByCustomerId(customer.getCtId());

	                double totalOrderAmount = 0.0;

	                if (customerOrderList != null && !customerOrderList.isEmpty()) {
	                    for (CustomerOrder customerOrder : customerOrderList) {
	                        Double orderAmount = customerOrder.getAmount();
	                        if (orderAmount != null) {
	                            totalOrderAmount += orderAmount;
	                            if(totalOrderAmount>200) {
	                            	totalOrderAmount+= customerOrder.getDelivaryCharges();
	                            }
	                            else(totalOrderAmount<200){
	                            	totalOrderAmount-= customerOrder.getDelivaryCharges();
	                            }
	                        }
	                    }

	                    // Define the minimum order amount for applying delivery charges
	                    double minimumOrderAmount = 200.0;

	                    if (totalOrderAmount < minimumOrderAmount) {
	                        System.out.println("Delivery Charges will be applicable");
	                    } else {
	                        // No delivery charges applicable
	                        System.out.println("No Delivery charges applicable");
	                    }

	                    List<CustomerOrderReplica> customerOrderReplicas = new ArrayList<>();
	                    return customerOrderReplicas;
	                } else {
	                    return Collections.emptyList();
	                }
	            } else {
	                return null; // or an appropriate value
	            }
	        } else {
	            // Handle the case when the latest schedule is not active
	            return null; // or an appropriate value
	        }
	    } else {
	        // Handle the case when there is no latest schedule or its creation timestamp is null
	        return null; // or an appropriate value
	    }
	}

}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-09-21 15:34:39.429
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-09-21 15:34:39.431
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-21 15:34:41.613
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.xyram.daydrop.serviceimpl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.transaction.Transactional;

import org.apache.commons.collections4.map.HashedMap;
import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.server.ResponseStatusException;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.xyram.daydrop.admin.model.CurrentUser;
import com.xyram.daydrop.basemodel.Base64Wrapper;
import com.xyram.daydrop.basemodel.MerchantTransactionIdGenerator;
import com.xyram.daydrop.basemodel.PhonepeSerializer;
import com.xyram.daydrop.dao.ApartmentDao;
import com.xyram.daydrop.dao.CustomerDetailsDao;
import com.xyram.daydrop.dao.CustomerOrderDao;
import com.xyram.daydrop.dao.CustomerOrderReplicaDoa;
import com.xyram.daydrop.dao.SheduleDao;
import com.xyram.daydrop.enumtypes.UserStatus;
import com.xyram.daydrop.model.Apartments;
import com.xyram.daydrop.model.CustomerOrder;
import com.xyram.daydrop.model.CustomerOrderReplica;
import com.xyram.daydrop.model.Customers;
import com.xyram.daydrop.model.Schedule;
import com.xyram.daydrop.modelMapper.PaymentInstrument;
import com.xyram.daydrop.modelMapper.PhonePePayModel;
import com.xyram.daydrop.request.CustomerOrderReplicaRequest;
import com.xyram.daydrop.response.RazorPayRequest;
import com.xyram.daydrop.service.CustomerOrderPriceService;
import com.xyram.daydrop.service.CustomerOrderReplicaService;
import com.xyram.daydrop.util.HashEncoder;
import com.xyram.daydrop.util.RazorPay;
import com.xyram.daydrop.service.ConsumerService;

@Transactional
@Service
public class CustomerOrderReplicaServiceImpl implements CustomerOrderReplicaService {

	@Autowired
	CustomerOrderReplicaDoa customerOrderReplicaDoa;

	@Autowired
	ApartmentDao apartmentDao;

	@Autowired
	SheduleDao scheduleDao;

	@Autowired
	CustomerDetailsDao customerDetailsDao;

	@Autowired
	ConsumerService consumerService;

	@Autowired
	CurrentUser currentUser;

	@Autowired
	PhonepeServiceImpl phonepeServiceImpl;

	@Value("${merchant_id}")
	private String merchantId;

	@Value("${salt_key}")
	private String saltKey;

	@Value("${salt_index}")
	private String saltIndex;

	@Override
	public Map createCustomerOrderReplicaService(CustomerOrderReplicaRequest customerOrderReplicaRequest,
			String contactNumber, Integer aparmentId)

	{

		Map response = new HashedMap<>();

		response.put("message", "success");
		CustomerOrderReplica customerOrderReplica = null;

		if (customerOrderReplicaRequest.getCartId() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "cartId is mandatory ");
		}
		long razorPayCount = 0;
		if (customerOrderReplicaRequest.getOrderId() != null) {

			razorPayCount = customerOrderReplicaDoa.getRazorPayExistByCartId(customerOrderReplicaRequest.getOrderId());
		}

		if (customerOrderReplicaRequest.getCustomerDetails() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Order Details  is mandatory ");
		}

		customerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(customerOrderReplicaRequest.getCartId(),
				contactNumber);

		if (customerOrderReplica != null) {
			customerOrderReplica.setCartId(customerOrderReplica.getCartId());

			if (customerOrderReplica.isOrdered()) {
				throw new ResponseStatusException(HttpStatus.CONFLICT, "Your Order is Placed With cart Details");
			}

//			if (razorPayCount >= 1 && !(customerOrderReplica.getRazorPayOrderId() != null
//					&& customerOrderReplica.getRazorPayOrderId().equals(customerOrderReplicaRequest.getOrderId()))) {
//				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
//			}

			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);

			customerOrderReplica.setAttempts(customerOrderReplica.getAttempts() + 1);
			customerOrderReplica.setUpdatedTime(new Date());

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		} else {

			customerOrderReplica = new CustomerOrderReplica();
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);
			customerOrderReplica.setCartId(customerOrderReplicaRequest.getCartId());
			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());

			if (razorPayCount > 0) {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
			}

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			Schedule schedule = scheduleDao.getlatestScheduleCustomers();

			if (schedule != null) {

				try {
					customerOrderReplica.setSchedule(schedule.getsId() != null ? schedule.getsId().toString() : null);
				} catch (Exception e) {
					e.printStackTrace();
				}
			} else {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
						"Sorry We Are Not Accepting Any Order Right now");

			}

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		}

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicas(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String schedule = null;

		Map filter = request.containsKey("filters") ? (Map) request.get("filters") : null;
		if (filter != null) {
			statusType = filter.containsKey("statusType") ? ((String) filter.get("statusType")).toLowerCase() : null;
			searchQuery = filter.containsKey("searchQuery") ? ((String) filter.get("searchQuery")).toLowerCase() : null;
			schedule = filter.containsKey("schedule") ? (String.valueOf(filter.get("schedule"))) : null;

		}

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplica(searchQuery, statusType, schedule);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");

				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setStreetName(
						customers.get("streetName") != null ? (String) customers.get("streetName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicasBySchedule(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String scheduleId = null;

		Schedule schedule = scheduleDao.getlatestScheduleCustomers();

		if (schedule != null) {

			try {
				scheduleId = schedule.getsId() != null ? schedule.getsId().toString() : null;
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

		statusType = request.containsKey("statusType") ? ((String) request.get("statusType")).toLowerCase() : "Success";

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplicaBySchdeule(statusType, scheduleId);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");
				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				System.out.println("customers" + customers.get("customerName"));

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public CustomerOrderReplica getCustomerOrderReplicaByCartId(String cartId) {

		CustomerOrderReplica CustomerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(cartId,
				currentUser.getContactNumber());

		ObjectMapper objectMapper = new ObjectMapper();
		try {

			// convert JSON string to Map
			Map<String, Object> customerOrderReplicaMap = objectMapper
					.readValue(CustomerOrderReplica.getCustomerOrderDetails(), Map.class);

			Object customerOrder = customerOrderReplicaMap.get("customerOrder");
			Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

			Object quanityList = items.get("quantity");
			Map customers = customerDetailsDao.getByContactNumberAndApartment(CustomerOrderReplica.getContactNumber(),
					CustomerOrderReplica.getApartmentId());

			System.out.println("customers" + customers.get("customerName"));

			// Apartments apartments =
			// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
			CustomerOrderReplica.setApartmentName(
					customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

			CustomerOrderReplica.setCustomerDetails(customers);

			CustomerOrderReplica.setCustomerOrder(customerOrder);
			CustomerOrderReplica.setQuatityList(quanityList);

		} catch (Exception e) {
			e.printStackTrace();
		}

		return CustomerOrderReplica;

	}

	@Override
	public Map createCustomerOrderReplica(CustomerOrderReplicaRequest customerOrderReplicaRequest, String contactNumber,
			Integer aparmentId) {

		if (customerOrderReplicaRequest.getRazorPayRequest() != null) {

//			Map razorPay = consumerService.createRazorPayOrder(customerOrderReplicaRequest.getRazorPayRequest());
//			customerOrderReplicaRequest.setOrderId(razorPay.get("order") != null ? (String)((RazorPay) razorPay.get("order")).getId() : null);	
//	
//			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);
//
//			razorPay.put("cartId", customerOrderReplicaRequest.getCartId());

			Map customerOrderReplicaMap = new HashMap<>();

			Map orderId = new HashMap<>();
			String transactionId = getMerchantTransactionId();
			orderId.put("id", transactionId);

			customerOrderReplicaMap.put("order", orderId);

			customerOrderReplicaRequest.setOrderId(transactionId);
			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);

			customerOrderReplicaMap.put("cartId", customerOrderReplicaRequest.getCartId());

			try {
				customerOrderReplicaMap.put("phonePeResponse",
						phonepeServiceImpl.initiatePhonepePayment(transactionId,
								Integer.valueOf(customerOrderReplicaRequest.getRazorPayRequest().getAmount()),
								contactNumber, customerOrderReplicaRequest.getRedirectUrl(), customerOrderReplicaRequest.getCallBackUrl()));

			} catch (Exception e) {
				e.printStackTrace();
				customerOrderReplicaMap.put("phonePeResponse", new HashedMap<>());
			}

			return customerOrderReplicaMap;

		} else {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
					"paymentDetails transcation Details are mandatory");
		}

	}

	private static String getMerchantTransactionId() {

		return "OD_" + MerchantTransactionIdGenerator.getRandomString();
	}


	@Override
	public List<CustomerOrderReplica> getCustomerOrderByMoblieNo(String contactNumber, Integer aid) {

	    Schedule latestSchedule = customerOrderReplicaDoa.getlatestschedule();

	    if (latestSchedule != null && latestSchedule.getCreationTimestamp() != null) {
	        if (latestSchedule.getStatus().equals(UserStatus.ACTIVE)) {
	            Customers customer = customerDetailsDao.getByContactNoAndApartment(contactNumber, aid);

	            if (customer != null) { // Ensure the customer exists
	                List<CustomerOrder> customerOrderList = customerOrderReplicaDoa.getListCustomerOrderByCustomerId(customer.getCtId());

	                double totalOrderAmount = 0.0;

	                if (customerOrderList != null && !customerOrderList.isEmpty()) {
	                    for (CustomerOrder customerOrder : customerOrderList) {
	                        Double orderAmount = customerOrder.getAmount();
	                        if (orderAmount != null) {
	                            totalOrderAmount += orderAmount;
	                            if(totalOrderAmount>200) {
	                            	totalOrderAmount+= customerOrder.getDelivaryCharges();
	                            }
	                            else(totalOrderAmount<200){
	                            	totalOrderAmount-= customerOrder.getDelivaryCharges();
	                            }
	                        }
	                    }

	                    // Define the minimum order amount for applying delivery charges
	                    double minimumOrderAmount = 200.0;

	                    if (totalOrderAmount < minimumOrderAmount) {
	                        System.out.println("Delivery Charges will be applicable");
	                    } else {
	                        // No delivery charges applicable
	                        System.out.println("No Delivery charges applicable");
	                    }

	                    List<CustomerOrderReplica> customerOrderReplicas = new ArrayList<>();
	                    return customerOrderReplicas;
	                } else {
	                    return Collections.emptyList();
	                }
	            } else {
	                return null; // or an appropriate value
	            }
	        } else {
	            // Handle the case when the latest schedule is not active
	            return null; // or an appropriate value
	        }
	    } else {
	        // Handle the case when there is no latest schedule or its creation timestamp is null
	        return null; // or an appropriate value
	    }
	}

}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4035)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3635)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-09-21 15:34:41.615
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4035)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3635)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-09-21 15:34:41.616
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4035)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3635)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-21 15:34:41.665
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.xyram.daydrop.serviceimpl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.transaction.Transactional;

import org.apache.commons.collections4.map.HashedMap;
import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.server.ResponseStatusException;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.xyram.daydrop.admin.model.CurrentUser;
import com.xyram.daydrop.basemodel.Base64Wrapper;
import com.xyram.daydrop.basemodel.MerchantTransactionIdGenerator;
import com.xyram.daydrop.basemodel.PhonepeSerializer;
import com.xyram.daydrop.dao.ApartmentDao;
import com.xyram.daydrop.dao.CustomerDetailsDao;
import com.xyram.daydrop.dao.CustomerOrderDao;
import com.xyram.daydrop.dao.CustomerOrderReplicaDoa;
import com.xyram.daydrop.dao.SheduleDao;
import com.xyram.daydrop.enumtypes.UserStatus;
import com.xyram.daydrop.model.Apartments;
import com.xyram.daydrop.model.CustomerOrder;
import com.xyram.daydrop.model.CustomerOrderReplica;
import com.xyram.daydrop.model.Customers;
import com.xyram.daydrop.model.Schedule;
import com.xyram.daydrop.modelMapper.PaymentInstrument;
import com.xyram.daydrop.modelMapper.PhonePePayModel;
import com.xyram.daydrop.request.CustomerOrderReplicaRequest;
import com.xyram.daydrop.response.RazorPayRequest;
import com.xyram.daydrop.service.CustomerOrderPriceService;
import com.xyram.daydrop.service.CustomerOrderReplicaService;
import com.xyram.daydrop.util.HashEncoder;
import com.xyram.daydrop.util.RazorPay;
import com.xyram.daydrop.service.ConsumerService;

@Transactional
@Service
public class CustomerOrderReplicaServiceImpl implements CustomerOrderReplicaService {

	@Autowired
	CustomerOrderReplicaDoa customerOrderReplicaDoa;

	@Autowired
	ApartmentDao apartmentDao;

	@Autowired
	SheduleDao scheduleDao;

	@Autowired
	CustomerDetailsDao customerDetailsDao;

	@Autowired
	ConsumerService consumerService;

	@Autowired
	CurrentUser currentUser;

	@Autowired
	PhonepeServiceImpl phonepeServiceImpl;

	@Value("${merchant_id}")
	private String merchantId;

	@Value("${salt_key}")
	private String saltKey;

	@Value("${salt_index}")
	private String saltIndex;

	@Override
	public Map createCustomerOrderReplicaService(CustomerOrderReplicaRequest customerOrderReplicaRequest,
			String contactNumber, Integer aparmentId)

	{

		Map response = new HashedMap<>();

		response.put("message", "success");
		CustomerOrderReplica customerOrderReplica = null;

		if (customerOrderReplicaRequest.getCartId() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "cartId is mandatory ");
		}
		long razorPayCount = 0;
		if (customerOrderReplicaRequest.getOrderId() != null) {

			razorPayCount = customerOrderReplicaDoa.getRazorPayExistByCartId(customerOrderReplicaRequest.getOrderId());
		}

		if (customerOrderReplicaRequest.getCustomerDetails() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Order Details  is mandatory ");
		}

		customerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(customerOrderReplicaRequest.getCartId(),
				contactNumber);

		if (customerOrderReplica != null) {
			customerOrderReplica.setCartId(customerOrderReplica.getCartId());

			if (customerOrderReplica.isOrdered()) {
				throw new ResponseStatusException(HttpStatus.CONFLICT, "Your Order is Placed With cart Details");
			}

//			if (razorPayCount >= 1 && !(customerOrderReplica.getRazorPayOrderId() != null
//					&& customerOrderReplica.getRazorPayOrderId().equals(customerOrderReplicaRequest.getOrderId()))) {
//				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
//			}

			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);

			customerOrderReplica.setAttempts(customerOrderReplica.getAttempts() + 1);
			customerOrderReplica.setUpdatedTime(new Date());

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		} else {

			customerOrderReplica = new CustomerOrderReplica();
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);
			customerOrderReplica.setCartId(customerOrderReplicaRequest.getCartId());
			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());

			if (razorPayCount > 0) {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
			}

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			Schedule schedule = scheduleDao.getlatestScheduleCustomers();

			if (schedule != null) {

				try {
					customerOrderReplica.setSchedule(schedule.getsId() != null ? schedule.getsId().toString() : null);
				} catch (Exception e) {
					e.printStackTrace();
				}
			} else {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
						"Sorry We Are Not Accepting Any Order Right now");

			}

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		}

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicas(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String schedule = null;

		Map filter = request.containsKey("filters") ? (Map) request.get("filters") : null;
		if (filter != null) {
			statusType = filter.containsKey("statusType") ? ((String) filter.get("statusType")).toLowerCase() : null;
			searchQuery = filter.containsKey("searchQuery") ? ((String) filter.get("searchQuery")).toLowerCase() : null;
			schedule = filter.containsKey("schedule") ? (String.valueOf(filter.get("schedule"))) : null;

		}

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplica(searchQuery, statusType, schedule);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");

				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setStreetName(
						customers.get("streetName") != null ? (String) customers.get("streetName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicasBySchedule(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String scheduleId = null;

		Schedule schedule = scheduleDao.getlatestScheduleCustomers();

		if (schedule != null) {

			try {
				scheduleId = schedule.getsId() != null ? schedule.getsId().toString() : null;
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

		statusType = request.containsKey("statusType") ? ((String) request.get("statusType")).toLowerCase() : "Success";

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplicaBySchdeule(statusType, scheduleId);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");
				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				System.out.println("customers" + customers.get("customerName"));

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public CustomerOrderReplica getCustomerOrderReplicaByCartId(String cartId) {

		CustomerOrderReplica CustomerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(cartId,
				currentUser.getContactNumber());

		ObjectMapper objectMapper = new ObjectMapper();
		try {

			// convert JSON string to Map
			Map<String, Object> customerOrderReplicaMap = objectMapper
					.readValue(CustomerOrderReplica.getCustomerOrderDetails(), Map.class);

			Object customerOrder = customerOrderReplicaMap.get("customerOrder");
			Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

			Object quanityList = items.get("quantity");
			Map customers = customerDetailsDao.getByContactNumberAndApartment(CustomerOrderReplica.getContactNumber(),
					CustomerOrderReplica.getApartmentId());

			System.out.println("customers" + customers.get("customerName"));

			// Apartments apartments =
			// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
			CustomerOrderReplica.setApartmentName(
					customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

			CustomerOrderReplica.setCustomerDetails(customers);

			CustomerOrderReplica.setCustomerOrder(customerOrder);
			CustomerOrderReplica.setQuatityList(quanityList);

		} catch (Exception e) {
			e.printStackTrace();
		}

		return CustomerOrderReplica;

	}

	@Override
	public Map createCustomerOrderReplica(CustomerOrderReplicaRequest customerOrderReplicaRequest, String contactNumber,
			Integer aparmentId) {

		if (customerOrderReplicaRequest.getRazorPayRequest() != null) {

//			Map razorPay = consumerService.createRazorPayOrder(customerOrderReplicaRequest.getRazorPayRequest());
//			customerOrderReplicaRequest.setOrderId(razorPay.get("order") != null ? (String)((RazorPay) razorPay.get("order")).getId() : null);	
//	
//			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);
//
//			razorPay.put("cartId", customerOrderReplicaRequest.getCartId());

			Map customerOrderReplicaMap = new HashMap<>();

			Map orderId = new HashMap<>();
			String transactionId = getMerchantTransactionId();
			orderId.put("id", transactionId);

			customerOrderReplicaMap.put("order", orderId);

			customerOrderReplicaRequest.setOrderId(transactionId);
			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);

			customerOrderReplicaMap.put("cartId", customerOrderReplicaRequest.getCartId());

			try {
				customerOrderReplicaMap.put("phonePeResponse",
						phonepeServiceImpl.initiatePhonepePayment(transactionId,
								Integer.valueOf(customerOrderReplicaRequest.getRazorPayRequest().getAmount()),
								contactNumber, customerOrderReplicaRequest.getRedirectUrl(), customerOrderReplicaRequest.getCallBackUrl()));

			} catch (Exception e) {
				e.printStackTrace();
				customerOrderReplicaMap.put("phonePeResponse", new HashedMap<>());
			}

			return customerOrderReplicaMap;

		} else {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
					"paymentDetails transcation Details are mandatory");
		}

	}

	private static String getMerchantTransactionId() {

		return "OD_" + MerchantTransactionIdGenerator.getRandomString();
	}


	@Override
	public List<CustomerOrderReplica> getCustomerOrderByMoblieNo(String contactNumber, Integer aid) {

	    Schedule latestSchedule = customerOrderReplicaDoa.getlatestschedule();

	    if (latestSchedule != null && latestSchedule.getCreationTimestamp() != null) {
	        if (latestSchedule.getStatus().equals(UserStatus.ACTIVE)) {
	            Customers customer = customerDetailsDao.getByContactNoAndApartment(contactNumber, aid);

	            if (customer != null) { // Ensure the customer exists
	                List<CustomerOrder> customerOrderList = customerOrderReplicaDoa.getListCustomerOrderByCustomerId(customer.getCtId());

	                double totalOrderAmount = 0.0;

	                if (customerOrderList != null && !customerOrderList.isEmpty()) {
	                    for (CustomerOrder customerOrder : customerOrderList) {
	                        Double orderAmount = customerOrder.getAmount();
	                        if (orderAmount != null) {
	                            totalOrderAmount += orderAmount;
	                            if(totalOrderAmount>200) {
	                            	totalOrderAmount+= customerOrder.getDelivaryCharges();
	                            }
	                            else(totalOrderAmount<200){
	                            	totalOrderAmount-= customerOrder.getDelivaryCharges();
	                            }
	                        }
	                    }

	                    // Define the minimum order amount for applying delivery charges
	                    double minimumOrderAmount = 200.0;

	                    if (totalOrderAmount < minimumOrderAmount) {
	                        System.out.println("Delivery Charges will be applicable");
	                    } else {
	                        // No delivery charges applicable
	                        System.out.println("No Delivery charges applicable");
	                    }

	                    List<CustomerOrderReplica> customerOrderReplicas = new ArrayList<>();
	                    return customerOrderReplicas;
	                } else {
	                    return Collections.emptyList();
	                }
	            } else {
	                return null; // or an appropriate value
	            }
	        } else {
	            // Handle the case when the latest schedule is not active
	            return null; // or an appropriate value
	        }
	    } else {
	        // Handle the case when there is no latest schedule or its creation timestamp is null
	        return null; // or an appropriate value
	    }
	}

}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.internal.core.manipulation.dom.ASTResolving.createQuickFixAST(ASTResolving.java:1052)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:131)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4035)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3635)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.ui 4 0 2023-09-21 15:34:41.667
!MESSAGE Unhandled event loop exception
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.internal.core.manipulation.dom.ASTResolving.createQuickFixAST(ASTResolving.java:1052)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:131)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4035)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3635)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-21 15:34:42.652
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.xyram.daydrop.serviceimpl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.transaction.Transactional;

import org.apache.commons.collections4.map.HashedMap;
import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.server.ResponseStatusException;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.xyram.daydrop.admin.model.CurrentUser;
import com.xyram.daydrop.basemodel.Base64Wrapper;
import com.xyram.daydrop.basemodel.MerchantTransactionIdGenerator;
import com.xyram.daydrop.basemodel.PhonepeSerializer;
import com.xyram.daydrop.dao.ApartmentDao;
import com.xyram.daydrop.dao.CustomerDetailsDao;
import com.xyram.daydrop.dao.CustomerOrderDao;
import com.xyram.daydrop.dao.CustomerOrderReplicaDoa;
import com.xyram.daydrop.dao.SheduleDao;
import com.xyram.daydrop.enumtypes.UserStatus;
import com.xyram.daydrop.model.Apartments;
import com.xyram.daydrop.model.CustomerOrder;
import com.xyram.daydrop.model.CustomerOrderReplica;
import com.xyram.daydrop.model.Customers;
import com.xyram.daydrop.model.Schedule;
import com.xyram.daydrop.modelMapper.PaymentInstrument;
import com.xyram.daydrop.modelMapper.PhonePePayModel;
import com.xyram.daydrop.request.CustomerOrderReplicaRequest;
import com.xyram.daydrop.response.RazorPayRequest;
import com.xyram.daydrop.service.CustomerOrderPriceService;
import com.xyram.daydrop.service.CustomerOrderReplicaService;
import com.xyram.daydrop.util.HashEncoder;
import com.xyram.daydrop.util.RazorPay;
import com.xyram.daydrop.service.ConsumerService;

@Transactional
@Service
public class CustomerOrderReplicaServiceImpl implements CustomerOrderReplicaService {

	@Autowired
	CustomerOrderReplicaDoa customerOrderReplicaDoa;

	@Autowired
	ApartmentDao apartmentDao;

	@Autowired
	SheduleDao scheduleDao;

	@Autowired
	CustomerDetailsDao customerDetailsDao;

	@Autowired
	ConsumerService consumerService;

	@Autowired
	CurrentUser currentUser;

	@Autowired
	PhonepeServiceImpl phonepeServiceImpl;

	@Value("${merchant_id}")
	private String merchantId;

	@Value("${salt_key}")
	private String saltKey;

	@Value("${salt_index}")
	private String saltIndex;

	@Override
	public Map createCustomerOrderReplicaService(CustomerOrderReplicaRequest customerOrderReplicaRequest,
			String contactNumber, Integer aparmentId)

	{

		Map response = new HashedMap<>();

		response.put("message", "success");
		CustomerOrderReplica customerOrderReplica = null;

		if (customerOrderReplicaRequest.getCartId() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "cartId is mandatory ");
		}
		long razorPayCount = 0;
		if (customerOrderReplicaRequest.getOrderId() != null) {

			razorPayCount = customerOrderReplicaDoa.getRazorPayExistByCartId(customerOrderReplicaRequest.getOrderId());
		}

		if (customerOrderReplicaRequest.getCustomerDetails() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Order Details  is mandatory ");
		}

		customerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(customerOrderReplicaRequest.getCartId(),
				contactNumber);

		if (customerOrderReplica != null) {
			customerOrderReplica.setCartId(customerOrderReplica.getCartId());

			if (customerOrderReplica.isOrdered()) {
				throw new ResponseStatusException(HttpStatus.CONFLICT, "Your Order is Placed With cart Details");
			}

//			if (razorPayCount >= 1 && !(customerOrderReplica.getRazorPayOrderId() != null
//					&& customerOrderReplica.getRazorPayOrderId().equals(customerOrderReplicaRequest.getOrderId()))) {
//				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
//			}

			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);

			customerOrderReplica.setAttempts(customerOrderReplica.getAttempts() + 1);
			customerOrderReplica.setUpdatedTime(new Date());

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		} else {

			customerOrderReplica = new CustomerOrderReplica();
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);
			customerOrderReplica.setCartId(customerOrderReplicaRequest.getCartId());
			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());

			if (razorPayCount > 0) {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
			}

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			Schedule schedule = scheduleDao.getlatestScheduleCustomers();

			if (schedule != null) {

				try {
					customerOrderReplica.setSchedule(schedule.getsId() != null ? schedule.getsId().toString() : null);
				} catch (Exception e) {
					e.printStackTrace();
				}
			} else {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
						"Sorry We Are Not Accepting Any Order Right now");

			}

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		}

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicas(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String schedule = null;

		Map filter = request.containsKey("filters") ? (Map) request.get("filters") : null;
		if (filter != null) {
			statusType = filter.containsKey("statusType") ? ((String) filter.get("statusType")).toLowerCase() : null;
			searchQuery = filter.containsKey("searchQuery") ? ((String) filter.get("searchQuery")).toLowerCase() : null;
			schedule = filter.containsKey("schedule") ? (String.valueOf(filter.get("schedule"))) : null;

		}

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplica(searchQuery, statusType, schedule);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");

				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setStreetName(
						customers.get("streetName") != null ? (String) customers.get("streetName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicasBySchedule(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String scheduleId = null;

		Schedule schedule = scheduleDao.getlatestScheduleCustomers();

		if (schedule != null) {

			try {
				scheduleId = schedule.getsId() != null ? schedule.getsId().toString() : null;
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

		statusType = request.containsKey("statusType") ? ((String) request.get("statusType")).toLowerCase() : "Success";

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplicaBySchdeule(statusType, scheduleId);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");
				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				System.out.println("customers" + customers.get("customerName"));

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public CustomerOrderReplica getCustomerOrderReplicaByCartId(String cartId) {

		CustomerOrderReplica CustomerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(cartId,
				currentUser.getContactNumber());

		ObjectMapper objectMapper = new ObjectMapper();
		try {

			// convert JSON string to Map
			Map<String, Object> customerOrderReplicaMap = objectMapper
					.readValue(CustomerOrderReplica.getCustomerOrderDetails(), Map.class);

			Object customerOrder = customerOrderReplicaMap.get("customerOrder");
			Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

			Object quanityList = items.get("quantity");
			Map customers = customerDetailsDao.getByContactNumberAndApartment(CustomerOrderReplica.getContactNumber(),
					CustomerOrderReplica.getApartmentId());

			System.out.println("customers" + customers.get("customerName"));

			// Apartments apartments =
			// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
			CustomerOrderReplica.setApartmentName(
					customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

			CustomerOrderReplica.setCustomerDetails(customers);

			CustomerOrderReplica.setCustomerOrder(customerOrder);
			CustomerOrderReplica.setQuatityList(quanityList);

		} catch (Exception e) {
			e.printStackTrace();
		}

		return CustomerOrderReplica;

	}

	@Override
	public Map createCustomerOrderReplica(CustomerOrderReplicaRequest customerOrderReplicaRequest, String contactNumber,
			Integer aparmentId) {

		if (customerOrderReplicaRequest.getRazorPayRequest() != null) {

//			Map razorPay = consumerService.createRazorPayOrder(customerOrderReplicaRequest.getRazorPayRequest());
//			customerOrderReplicaRequest.setOrderId(razorPay.get("order") != null ? (String)((RazorPay) razorPay.get("order")).getId() : null);	
//	
//			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);
//
//			razorPay.put("cartId", customerOrderReplicaRequest.getCartId());

			Map customerOrderReplicaMap = new HashMap<>();

			Map orderId = new HashMap<>();
			String transactionId = getMerchantTransactionId();
			orderId.put("id", transactionId);

			customerOrderReplicaMap.put("order", orderId);

			customerOrderReplicaRequest.setOrderId(transactionId);
			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);

			customerOrderReplicaMap.put("cartId", customerOrderReplicaRequest.getCartId());

			try {
				customerOrderReplicaMap.put("phonePeResponse",
						phonepeServiceImpl.initiatePhonepePayment(transactionId,
								Integer.valueOf(customerOrderReplicaRequest.getRazorPayRequest().getAmount()),
								contactNumber, customerOrderReplicaRequest.getRedirectUrl(), customerOrderReplicaRequest.getCallBackUrl()));

			} catch (Exception e) {
				e.printStackTrace();
				customerOrderReplicaMap.put("phonePeResponse", new HashedMap<>());
			}

			return customerOrderReplicaMap;

		} else {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
					"paymentDetails transcation Details are mandatory");
		}

	}

	private static String getMerchantTransactionId() {

		return "OD_" + MerchantTransactionIdGenerator.getRandomString();
	}


	@Override
	public List<CustomerOrderReplica> getCustomerOrderByMoblieNo(String contactNumber, Integer aid) {

	    Schedule latestSchedule = customerOrderReplicaDoa.getlatestschedule();

	    if (latestSchedule != null && latestSchedule.getCreationTimestamp() != null) {
	        if (latestSchedule.getStatus().equals(UserStatus.ACTIVE)) {
	            Customers customer = customerDetailsDao.getByContactNoAndApartment(contactNumber, aid);

	            if (customer != null) { // Ensure the customer exists
	                List<CustomerOrder> customerOrderList = customerOrderReplicaDoa.getListCustomerOrderByCustomerId(customer.getCtId());

	                double totalOrderAmount = 0.0;

	                if (customerOrderList != null && !customerOrderList.isEmpty()) {
	                    for (CustomerOrder customerOrder : customerOrderList) {
	                        Double orderAmount = customerOrder.getAmount();
	                        if (orderAmount != null) {
	                            totalOrderAmount += orderAmount;
	                            if(totalOrderAmount>200) {
	                            	totalOrderAmount+= customerOrder.getDelivaryCharges();
	                            }
	                            else(totalOrderAmount<200){
	                            	totalOrderAmount-= customerOrder.getDelivaryCharges();
	                            }
	                        }
	                    }

	                    // Define the minimum order amount for applying delivery charges
	                    double minimumOrderAmount = 200.0;

	                    if (totalOrderAmount < minimumOrderAmount) {
	                        System.out.println("Delivery Charges will be applicable");
	                    } else {
	                        // No delivery charges applicable
	                        System.out.println("No Delivery charges applicable");
	                    }

	                    List<CustomerOrderReplica> customerOrderReplicas = new ArrayList<>();
	                    return customerOrderReplicas;
	                } else {
	                    return Collections.emptyList();
	                }
	            } else {
	                return null; // or an appropriate value
	            }
	        } else {
	            // Handle the case when the latest schedule is not active
	            return null; // or an appropriate value
	        }
	    } else {
	        // Handle the case when there is no latest schedule or its creation timestamp is null
	        return null; // or an appropriate value
	    }
	}

}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-09-21 15:34:42.654
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-09-21 15:34:42.656
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-21 15:34:43.652
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.xyram.daydrop.serviceimpl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.transaction.Transactional;

import org.apache.commons.collections4.map.HashedMap;
import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.server.ResponseStatusException;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.xyram.daydrop.admin.model.CurrentUser;
import com.xyram.daydrop.basemodel.Base64Wrapper;
import com.xyram.daydrop.basemodel.MerchantTransactionIdGenerator;
import com.xyram.daydrop.basemodel.PhonepeSerializer;
import com.xyram.daydrop.dao.ApartmentDao;
import com.xyram.daydrop.dao.CustomerDetailsDao;
import com.xyram.daydrop.dao.CustomerOrderDao;
import com.xyram.daydrop.dao.CustomerOrderReplicaDoa;
import com.xyram.daydrop.dao.SheduleDao;
import com.xyram.daydrop.enumtypes.UserStatus;
import com.xyram.daydrop.model.Apartments;
import com.xyram.daydrop.model.CustomerOrder;
import com.xyram.daydrop.model.CustomerOrderReplica;
import com.xyram.daydrop.model.Customers;
import com.xyram.daydrop.model.Schedule;
import com.xyram.daydrop.modelMapper.PaymentInstrument;
import com.xyram.daydrop.modelMapper.PhonePePayModel;
import com.xyram.daydrop.request.CustomerOrderReplicaRequest;
import com.xyram.daydrop.response.RazorPayRequest;
import com.xyram.daydrop.service.CustomerOrderPriceService;
import com.xyram.daydrop.service.CustomerOrderReplicaService;
import com.xyram.daydrop.util.HashEncoder;
import com.xyram.daydrop.util.RazorPay;
import com.xyram.daydrop.service.ConsumerService;

@Transactional
@Service
public class CustomerOrderReplicaServiceImpl implements CustomerOrderReplicaService {

	@Autowired
	CustomerOrderReplicaDoa customerOrderReplicaDoa;

	@Autowired
	ApartmentDao apartmentDao;

	@Autowired
	SheduleDao scheduleDao;

	@Autowired
	CustomerDetailsDao customerDetailsDao;

	@Autowired
	ConsumerService consumerService;

	@Autowired
	CurrentUser currentUser;

	@Autowired
	PhonepeServiceImpl phonepeServiceImpl;

	@Value("${merchant_id}")
	private String merchantId;

	@Value("${salt_key}")
	private String saltKey;

	@Value("${salt_index}")
	private String saltIndex;

	@Override
	public Map createCustomerOrderReplicaService(CustomerOrderReplicaRequest customerOrderReplicaRequest,
			String contactNumber, Integer aparmentId)

	{

		Map response = new HashedMap<>();

		response.put("message", "success");
		CustomerOrderReplica customerOrderReplica = null;

		if (customerOrderReplicaRequest.getCartId() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "cartId is mandatory ");
		}
		long razorPayCount = 0;
		if (customerOrderReplicaRequest.getOrderId() != null) {

			razorPayCount = customerOrderReplicaDoa.getRazorPayExistByCartId(customerOrderReplicaRequest.getOrderId());
		}

		if (customerOrderReplicaRequest.getCustomerDetails() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Order Details  is mandatory ");
		}

		customerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(customerOrderReplicaRequest.getCartId(),
				contactNumber);

		if (customerOrderReplica != null) {
			customerOrderReplica.setCartId(customerOrderReplica.getCartId());

			if (customerOrderReplica.isOrdered()) {
				throw new ResponseStatusException(HttpStatus.CONFLICT, "Your Order is Placed With cart Details");
			}

//			if (razorPayCount >= 1 && !(customerOrderReplica.getRazorPayOrderId() != null
//					&& customerOrderReplica.getRazorPayOrderId().equals(customerOrderReplicaRequest.getOrderId()))) {
//				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
//			}

			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);

			customerOrderReplica.setAttempts(customerOrderReplica.getAttempts() + 1);
			customerOrderReplica.setUpdatedTime(new Date());

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		} else {

			customerOrderReplica = new CustomerOrderReplica();
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);
			customerOrderReplica.setCartId(customerOrderReplicaRequest.getCartId());
			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());

			if (razorPayCount > 0) {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
			}

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			Schedule schedule = scheduleDao.getlatestScheduleCustomers();

			if (schedule != null) {

				try {
					customerOrderReplica.setSchedule(schedule.getsId() != null ? schedule.getsId().toString() : null);
				} catch (Exception e) {
					e.printStackTrace();
				}
			} else {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
						"Sorry We Are Not Accepting Any Order Right now");

			}

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		}

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicas(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String schedule = null;

		Map filter = request.containsKey("filters") ? (Map) request.get("filters") : null;
		if (filter != null) {
			statusType = filter.containsKey("statusType") ? ((String) filter.get("statusType")).toLowerCase() : null;
			searchQuery = filter.containsKey("searchQuery") ? ((String) filter.get("searchQuery")).toLowerCase() : null;
			schedule = filter.containsKey("schedule") ? (String.valueOf(filter.get("schedule"))) : null;

		}

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplica(searchQuery, statusType, schedule);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");

				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setStreetName(
						customers.get("streetName") != null ? (String) customers.get("streetName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicasBySchedule(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String scheduleId = null;

		Schedule schedule = scheduleDao.getlatestScheduleCustomers();

		if (schedule != null) {

			try {
				scheduleId = schedule.getsId() != null ? schedule.getsId().toString() : null;
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

		statusType = request.containsKey("statusType") ? ((String) request.get("statusType")).toLowerCase() : "Success";

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplicaBySchdeule(statusType, scheduleId);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");
				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				System.out.println("customers" + customers.get("customerName"));

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public CustomerOrderReplica getCustomerOrderReplicaByCartId(String cartId) {

		CustomerOrderReplica CustomerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(cartId,
				currentUser.getContactNumber());

		ObjectMapper objectMapper = new ObjectMapper();
		try {

			// convert JSON string to Map
			Map<String, Object> customerOrderReplicaMap = objectMapper
					.readValue(CustomerOrderReplica.getCustomerOrderDetails(), Map.class);

			Object customerOrder = customerOrderReplicaMap.get("customerOrder");
			Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

			Object quanityList = items.get("quantity");
			Map customers = customerDetailsDao.getByContactNumberAndApartment(CustomerOrderReplica.getContactNumber(),
					CustomerOrderReplica.getApartmentId());

			System.out.println("customers" + customers.get("customerName"));

			// Apartments apartments =
			// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
			CustomerOrderReplica.setApartmentName(
					customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

			CustomerOrderReplica.setCustomerDetails(customers);

			CustomerOrderReplica.setCustomerOrder(customerOrder);
			CustomerOrderReplica.setQuatityList(quanityList);

		} catch (Exception e) {
			e.printStackTrace();
		}

		return CustomerOrderReplica;

	}

	@Override
	public Map createCustomerOrderReplica(CustomerOrderReplicaRequest customerOrderReplicaRequest, String contactNumber,
			Integer aparmentId) {

		if (customerOrderReplicaRequest.getRazorPayRequest() != null) {

//			Map razorPay = consumerService.createRazorPayOrder(customerOrderReplicaRequest.getRazorPayRequest());
//			customerOrderReplicaRequest.setOrderId(razorPay.get("order") != null ? (String)((RazorPay) razorPay.get("order")).getId() : null);	
//	
//			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);
//
//			razorPay.put("cartId", customerOrderReplicaRequest.getCartId());

			Map customerOrderReplicaMap = new HashMap<>();

			Map orderId = new HashMap<>();
			String transactionId = getMerchantTransactionId();
			orderId.put("id", transactionId);

			customerOrderReplicaMap.put("order", orderId);

			customerOrderReplicaRequest.setOrderId(transactionId);
			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);

			customerOrderReplicaMap.put("cartId", customerOrderReplicaRequest.getCartId());

			try {
				customerOrderReplicaMap.put("phonePeResponse",
						phonepeServiceImpl.initiatePhonepePayment(transactionId,
								Integer.valueOf(customerOrderReplicaRequest.getRazorPayRequest().getAmount()),
								contactNumber, customerOrderReplicaRequest.getRedirectUrl(), customerOrderReplicaRequest.getCallBackUrl()));

			} catch (Exception e) {
				e.printStackTrace();
				customerOrderReplicaMap.put("phonePeResponse", new HashedMap<>());
			}

			return customerOrderReplicaMap;

		} else {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
					"paymentDetails transcation Details are mandatory");
		}

	}

	private static String getMerchantTransactionId() {

		return "OD_" + MerchantTransactionIdGenerator.getRandomString();
	}


	@Override
	public List<CustomerOrderReplica> getCustomerOrderByMoblieNo(String contactNumber, Integer aid) {

	    Schedule latestSchedule = customerOrderReplicaDoa.getlatestschedule();

	    if (latestSchedule != null && latestSchedule.getCreationTimestamp() != null) {
	        if (latestSchedule.getStatus().equals(UserStatus.ACTIVE)) {
	            Customers customer = customerDetailsDao.getByContactNoAndApartment(contactNumber, aid);

	            if (customer != null) { // Ensure the customer exists
	                List<CustomerOrder> customerOrderList = customerOrderReplicaDoa.getListCustomerOrderByCustomerId(customer.getCtId());

	                double totalOrderAmount = 0.0;

	                if (customerOrderList != null && !customerOrderList.isEmpty()) {
	                    for (CustomerOrder customerOrder : customerOrderList) {
	                        Double orderAmount = customerOrder.getAmount();
	                        if (orderAmount != null) {
	                            totalOrderAmount += orderAmount;
	                            if(totalOrderAmount>200) {
	                            	totalOrderAmount+= customerOrder.getDelivaryCharges();
	                            }
	                            else{(totalOrderAmount<200){
	                            	totalOrderAmount-= customerOrder.getDelivaryCharges();
	                            }
	                        }
	                    }

	                    // Define the minimum order amount for applying delivery charges
	                    double minimumOrderAmount = 200.0;

	                    if (totalOrderAmount < minimumOrderAmount) {
	                        System.out.println("Delivery Charges will be applicable");
	                    } else {
	                        // No delivery charges applicable
	                        System.out.println("No Delivery charges applicable");
	                    }

	                    List<CustomerOrderReplica> customerOrderReplicas = new ArrayList<>();
	                    return customerOrderReplicas;
	                } else {
	                    return Collections.emptyList();
	                }
	            } else {
	                return null; // or an appropriate value
	            }
	        } else {
	            // Handle the case when the latest schedule is not active
	            return null; // or an appropriate value
	        }
	    } else {
	        // Handle the case when there is no latest schedule or its creation timestamp is null
	        return null; // or an appropriate value
	    }
	}

}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-09-21 15:34:43.654
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-09-21 15:34:43.656
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-21 15:34:43.864
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.xyram.daydrop.serviceimpl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.transaction.Transactional;

import org.apache.commons.collections4.map.HashedMap;
import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.server.ResponseStatusException;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.xyram.daydrop.admin.model.CurrentUser;
import com.xyram.daydrop.basemodel.Base64Wrapper;
import com.xyram.daydrop.basemodel.MerchantTransactionIdGenerator;
import com.xyram.daydrop.basemodel.PhonepeSerializer;
import com.xyram.daydrop.dao.ApartmentDao;
import com.xyram.daydrop.dao.CustomerDetailsDao;
import com.xyram.daydrop.dao.CustomerOrderDao;
import com.xyram.daydrop.dao.CustomerOrderReplicaDoa;
import com.xyram.daydrop.dao.SheduleDao;
import com.xyram.daydrop.enumtypes.UserStatus;
import com.xyram.daydrop.model.Apartments;
import com.xyram.daydrop.model.CustomerOrder;
import com.xyram.daydrop.model.CustomerOrderReplica;
import com.xyram.daydrop.model.Customers;
import com.xyram.daydrop.model.Schedule;
import com.xyram.daydrop.modelMapper.PaymentInstrument;
import com.xyram.daydrop.modelMapper.PhonePePayModel;
import com.xyram.daydrop.request.CustomerOrderReplicaRequest;
import com.xyram.daydrop.response.RazorPayRequest;
import com.xyram.daydrop.service.CustomerOrderPriceService;
import com.xyram.daydrop.service.CustomerOrderReplicaService;
import com.xyram.daydrop.util.HashEncoder;
import com.xyram.daydrop.util.RazorPay;
import com.xyram.daydrop.service.ConsumerService;

@Transactional
@Service
public class CustomerOrderReplicaServiceImpl implements CustomerOrderReplicaService {

	@Autowired
	CustomerOrderReplicaDoa customerOrderReplicaDoa;

	@Autowired
	ApartmentDao apartmentDao;

	@Autowired
	SheduleDao scheduleDao;

	@Autowired
	CustomerDetailsDao customerDetailsDao;

	@Autowired
	ConsumerService consumerService;

	@Autowired
	CurrentUser currentUser;

	@Autowired
	PhonepeServiceImpl phonepeServiceImpl;

	@Value("${merchant_id}")
	private String merchantId;

	@Value("${salt_key}")
	private String saltKey;

	@Value("${salt_index}")
	private String saltIndex;

	@Override
	public Map createCustomerOrderReplicaService(CustomerOrderReplicaRequest customerOrderReplicaRequest,
			String contactNumber, Integer aparmentId)

	{

		Map response = new HashedMap<>();

		response.put("message", "success");
		CustomerOrderReplica customerOrderReplica = null;

		if (customerOrderReplicaRequest.getCartId() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "cartId is mandatory ");
		}
		long razorPayCount = 0;
		if (customerOrderReplicaRequest.getOrderId() != null) {

			razorPayCount = customerOrderReplicaDoa.getRazorPayExistByCartId(customerOrderReplicaRequest.getOrderId());
		}

		if (customerOrderReplicaRequest.getCustomerDetails() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Order Details  is mandatory ");
		}

		customerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(customerOrderReplicaRequest.getCartId(),
				contactNumber);

		if (customerOrderReplica != null) {
			customerOrderReplica.setCartId(customerOrderReplica.getCartId());

			if (customerOrderReplica.isOrdered()) {
				throw new ResponseStatusException(HttpStatus.CONFLICT, "Your Order is Placed With cart Details");
			}

//			if (razorPayCount >= 1 && !(customerOrderReplica.getRazorPayOrderId() != null
//					&& customerOrderReplica.getRazorPayOrderId().equals(customerOrderReplicaRequest.getOrderId()))) {
//				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
//			}

			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);

			customerOrderReplica.setAttempts(customerOrderReplica.getAttempts() + 1);
			customerOrderReplica.setUpdatedTime(new Date());

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		} else {

			customerOrderReplica = new CustomerOrderReplica();
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);
			customerOrderReplica.setCartId(customerOrderReplicaRequest.getCartId());
			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());

			if (razorPayCount > 0) {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
			}

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			Schedule schedule = scheduleDao.getlatestScheduleCustomers();

			if (schedule != null) {

				try {
					customerOrderReplica.setSchedule(schedule.getsId() != null ? schedule.getsId().toString() : null);
				} catch (Exception e) {
					e.printStackTrace();
				}
			} else {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
						"Sorry We Are Not Accepting Any Order Right now");

			}

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		}

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicas(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String schedule = null;

		Map filter = request.containsKey("filters") ? (Map) request.get("filters") : null;
		if (filter != null) {
			statusType = filter.containsKey("statusType") ? ((String) filter.get("statusType")).toLowerCase() : null;
			searchQuery = filter.containsKey("searchQuery") ? ((String) filter.get("searchQuery")).toLowerCase() : null;
			schedule = filter.containsKey("schedule") ? (String.valueOf(filter.get("schedule"))) : null;

		}

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplica(searchQuery, statusType, schedule);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");

				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setStreetName(
						customers.get("streetName") != null ? (String) customers.get("streetName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicasBySchedule(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String scheduleId = null;

		Schedule schedule = scheduleDao.getlatestScheduleCustomers();

		if (schedule != null) {

			try {
				scheduleId = schedule.getsId() != null ? schedule.getsId().toString() : null;
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

		statusType = request.containsKey("statusType") ? ((String) request.get("statusType")).toLowerCase() : "Success";

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplicaBySchdeule(statusType, scheduleId);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");
				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				System.out.println("customers" + customers.get("customerName"));

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public CustomerOrderReplica getCustomerOrderReplicaByCartId(String cartId) {

		CustomerOrderReplica CustomerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(cartId,
				currentUser.getContactNumber());

		ObjectMapper objectMapper = new ObjectMapper();
		try {

			// convert JSON string to Map
			Map<String, Object> customerOrderReplicaMap = objectMapper
					.readValue(CustomerOrderReplica.getCustomerOrderDetails(), Map.class);

			Object customerOrder = customerOrderReplicaMap.get("customerOrder");
			Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

			Object quanityList = items.get("quantity");
			Map customers = customerDetailsDao.getByContactNumberAndApartment(CustomerOrderReplica.getContactNumber(),
					CustomerOrderReplica.getApartmentId());

			System.out.println("customers" + customers.get("customerName"));

			// Apartments apartments =
			// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
			CustomerOrderReplica.setApartmentName(
					customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

			CustomerOrderReplica.setCustomerDetails(customers);

			CustomerOrderReplica.setCustomerOrder(customerOrder);
			CustomerOrderReplica.setQuatityList(quanityList);

		} catch (Exception e) {
			e.printStackTrace();
		}

		return CustomerOrderReplica;

	}

	@Override
	public Map createCustomerOrderReplica(CustomerOrderReplicaRequest customerOrderReplicaRequest, String contactNumber,
			Integer aparmentId) {

		if (customerOrderReplicaRequest.getRazorPayRequest() != null) {

//			Map razorPay = consumerService.createRazorPayOrder(customerOrderReplicaRequest.getRazorPayRequest());
//			customerOrderReplicaRequest.setOrderId(razorPay.get("order") != null ? (String)((RazorPay) razorPay.get("order")).getId() : null);	
//	
//			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);
//
//			razorPay.put("cartId", customerOrderReplicaRequest.getCartId());

			Map customerOrderReplicaMap = new HashMap<>();

			Map orderId = new HashMap<>();
			String transactionId = getMerchantTransactionId();
			orderId.put("id", transactionId);

			customerOrderReplicaMap.put("order", orderId);

			customerOrderReplicaRequest.setOrderId(transactionId);
			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);

			customerOrderReplicaMap.put("cartId", customerOrderReplicaRequest.getCartId());

			try {
				customerOrderReplicaMap.put("phonePeResponse",
						phonepeServiceImpl.initiatePhonepePayment(transactionId,
								Integer.valueOf(customerOrderReplicaRequest.getRazorPayRequest().getAmount()),
								contactNumber, customerOrderReplicaRequest.getRedirectUrl(), customerOrderReplicaRequest.getCallBackUrl()));

			} catch (Exception e) {
				e.printStackTrace();
				customerOrderReplicaMap.put("phonePeResponse", new HashedMap<>());
			}

			return customerOrderReplicaMap;

		} else {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
					"paymentDetails transcation Details are mandatory");
		}

	}

	private static String getMerchantTransactionId() {

		return "OD_" + MerchantTransactionIdGenerator.getRandomString();
	}


	@Override
	public List<CustomerOrderReplica> getCustomerOrderByMoblieNo(String contactNumber, Integer aid) {

	    Schedule latestSchedule = customerOrderReplicaDoa.getlatestschedule();

	    if (latestSchedule != null && latestSchedule.getCreationTimestamp() != null) {
	        if (latestSchedule.getStatus().equals(UserStatus.ACTIVE)) {
	            Customers customer = customerDetailsDao.getByContactNoAndApartment(contactNumber, aid);

	            if (customer != null) { // Ensure the customer exists
	                List<CustomerOrder> customerOrderList = customerOrderReplicaDoa.getListCustomerOrderByCustomerId(customer.getCtId());

	                double totalOrderAmount = 0.0;

	                if (customerOrderList != null && !customerOrderList.isEmpty()) {
	                    for (CustomerOrder customerOrder : customerOrderList) {
	                        Double orderAmount = customerOrder.getAmount();
	                        if (orderAmount != null) {
	                            totalOrderAmount += orderAmount;
	                            if(totalOrderAmount>200) {
	                            	totalOrderAmount+= customerOrder.getDelivaryCharges();
	                            }
	                            else{(totalOrderAmount<200){
	                            	totalOrderAmount-= customerOrder.getDelivaryCharges();
	                            }
	                        }
	                    }

	                    // Define the minimum order amount for applying delivery charges
	                    double minimumOrderAmount = 200.0;

	                    if (totalOrderAmount < minimumOrderAmount) {
	                        System.out.println("Delivery Charges will be applicable");
	                    } else {
	                        // No delivery charges applicable
	                        System.out.println("No Delivery charges applicable");
	                    }

	                    List<CustomerOrderReplica> customerOrderReplicas = new ArrayList<>();
	                    return customerOrderReplicas;
	                } else {
	                    return Collections.emptyList();
	                }
	            } else {
	                return null; // or an appropriate value
	            }
	        } else {
	            // Handle the case when the latest schedule is not active
	            return null; // or an appropriate value
	        }
	    } else {
	        // Handle the case when there is no latest schedule or its creation timestamp is null
	        return null; // or an appropriate value
	    }
	}

}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-09-21 15:34:43.866
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-09-21 15:34:43.868
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-21 15:34:45.001
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.xyram.daydrop.serviceimpl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.transaction.Transactional;

import org.apache.commons.collections4.map.HashedMap;
import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.server.ResponseStatusException;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.xyram.daydrop.admin.model.CurrentUser;
import com.xyram.daydrop.basemodel.Base64Wrapper;
import com.xyram.daydrop.basemodel.MerchantTransactionIdGenerator;
import com.xyram.daydrop.basemodel.PhonepeSerializer;
import com.xyram.daydrop.dao.ApartmentDao;
import com.xyram.daydrop.dao.CustomerDetailsDao;
import com.xyram.daydrop.dao.CustomerOrderDao;
import com.xyram.daydrop.dao.CustomerOrderReplicaDoa;
import com.xyram.daydrop.dao.SheduleDao;
import com.xyram.daydrop.enumtypes.UserStatus;
import com.xyram.daydrop.model.Apartments;
import com.xyram.daydrop.model.CustomerOrder;
import com.xyram.daydrop.model.CustomerOrderReplica;
import com.xyram.daydrop.model.Customers;
import com.xyram.daydrop.model.Schedule;
import com.xyram.daydrop.modelMapper.PaymentInstrument;
import com.xyram.daydrop.modelMapper.PhonePePayModel;
import com.xyram.daydrop.request.CustomerOrderReplicaRequest;
import com.xyram.daydrop.response.RazorPayRequest;
import com.xyram.daydrop.service.CustomerOrderPriceService;
import com.xyram.daydrop.service.CustomerOrderReplicaService;
import com.xyram.daydrop.util.HashEncoder;
import com.xyram.daydrop.util.RazorPay;
import com.xyram.daydrop.service.ConsumerService;

@Transactional
@Service
public class CustomerOrderReplicaServiceImpl implements CustomerOrderReplicaService {

	@Autowired
	CustomerOrderReplicaDoa customerOrderReplicaDoa;

	@Autowired
	ApartmentDao apartmentDao;

	@Autowired
	SheduleDao scheduleDao;

	@Autowired
	CustomerDetailsDao customerDetailsDao;

	@Autowired
	ConsumerService consumerService;

	@Autowired
	CurrentUser currentUser;

	@Autowired
	PhonepeServiceImpl phonepeServiceImpl;

	@Value("${merchant_id}")
	private String merchantId;

	@Value("${salt_key}")
	private String saltKey;

	@Value("${salt_index}")
	private String saltIndex;

	@Override
	public Map createCustomerOrderReplicaService(CustomerOrderReplicaRequest customerOrderReplicaRequest,
			String contactNumber, Integer aparmentId)

	{

		Map response = new HashedMap<>();

		response.put("message", "success");
		CustomerOrderReplica customerOrderReplica = null;

		if (customerOrderReplicaRequest.getCartId() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "cartId is mandatory ");
		}
		long razorPayCount = 0;
		if (customerOrderReplicaRequest.getOrderId() != null) {

			razorPayCount = customerOrderReplicaDoa.getRazorPayExistByCartId(customerOrderReplicaRequest.getOrderId());
		}

		if (customerOrderReplicaRequest.getCustomerDetails() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Order Details  is mandatory ");
		}

		customerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(customerOrderReplicaRequest.getCartId(),
				contactNumber);

		if (customerOrderReplica != null) {
			customerOrderReplica.setCartId(customerOrderReplica.getCartId());

			if (customerOrderReplica.isOrdered()) {
				throw new ResponseStatusException(HttpStatus.CONFLICT, "Your Order is Placed With cart Details");
			}

//			if (razorPayCount >= 1 && !(customerOrderReplica.getRazorPayOrderId() != null
//					&& customerOrderReplica.getRazorPayOrderId().equals(customerOrderReplicaRequest.getOrderId()))) {
//				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
//			}

			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);

			customerOrderReplica.setAttempts(customerOrderReplica.getAttempts() + 1);
			customerOrderReplica.setUpdatedTime(new Date());

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		} else {

			customerOrderReplica = new CustomerOrderReplica();
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);
			customerOrderReplica.setCartId(customerOrderReplicaRequest.getCartId());
			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());

			if (razorPayCount > 0) {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
			}

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			Schedule schedule = scheduleDao.getlatestScheduleCustomers();

			if (schedule != null) {

				try {
					customerOrderReplica.setSchedule(schedule.getsId() != null ? schedule.getsId().toString() : null);
				} catch (Exception e) {
					e.printStackTrace();
				}
			} else {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
						"Sorry We Are Not Accepting Any Order Right now");

			}

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		}

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicas(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String schedule = null;

		Map filter = request.containsKey("filters") ? (Map) request.get("filters") : null;
		if (filter != null) {
			statusType = filter.containsKey("statusType") ? ((String) filter.get("statusType")).toLowerCase() : null;
			searchQuery = filter.containsKey("searchQuery") ? ((String) filter.get("searchQuery")).toLowerCase() : null;
			schedule = filter.containsKey("schedule") ? (String.valueOf(filter.get("schedule"))) : null;

		}

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplica(searchQuery, statusType, schedule);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");

				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setStreetName(
						customers.get("streetName") != null ? (String) customers.get("streetName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicasBySchedule(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String scheduleId = null;

		Schedule schedule = scheduleDao.getlatestScheduleCustomers();

		if (schedule != null) {

			try {
				scheduleId = schedule.getsId() != null ? schedule.getsId().toString() : null;
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

		statusType = request.containsKey("statusType") ? ((String) request.get("statusType")).toLowerCase() : "Success";

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplicaBySchdeule(statusType, scheduleId);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");
				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				System.out.println("customers" + customers.get("customerName"));

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public CustomerOrderReplica getCustomerOrderReplicaByCartId(String cartId) {

		CustomerOrderReplica CustomerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(cartId,
				currentUser.getContactNumber());

		ObjectMapper objectMapper = new ObjectMapper();
		try {

			// convert JSON string to Map
			Map<String, Object> customerOrderReplicaMap = objectMapper
					.readValue(CustomerOrderReplica.getCustomerOrderDetails(), Map.class);

			Object customerOrder = customerOrderReplicaMap.get("customerOrder");
			Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

			Object quanityList = items.get("quantity");
			Map customers = customerDetailsDao.getByContactNumberAndApartment(CustomerOrderReplica.getContactNumber(),
					CustomerOrderReplica.getApartmentId());

			System.out.println("customers" + customers.get("customerName"));

			// Apartments apartments =
			// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
			CustomerOrderReplica.setApartmentName(
					customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

			CustomerOrderReplica.setCustomerDetails(customers);

			CustomerOrderReplica.setCustomerOrder(customerOrder);
			CustomerOrderReplica.setQuatityList(quanityList);

		} catch (Exception e) {
			e.printStackTrace();
		}

		return CustomerOrderReplica;

	}

	@Override
	public Map createCustomerOrderReplica(CustomerOrderReplicaRequest customerOrderReplicaRequest, String contactNumber,
			Integer aparmentId) {

		if (customerOrderReplicaRequest.getRazorPayRequest() != null) {

//			Map razorPay = consumerService.createRazorPayOrder(customerOrderReplicaRequest.getRazorPayRequest());
//			customerOrderReplicaRequest.setOrderId(razorPay.get("order") != null ? (String)((RazorPay) razorPay.get("order")).getId() : null);	
//	
//			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);
//
//			razorPay.put("cartId", customerOrderReplicaRequest.getCartId());

			Map customerOrderReplicaMap = new HashMap<>();

			Map orderId = new HashMap<>();
			String transactionId = getMerchantTransactionId();
			orderId.put("id", transactionId);

			customerOrderReplicaMap.put("order", orderId);

			customerOrderReplicaRequest.setOrderId(transactionId);
			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);

			customerOrderReplicaMap.put("cartId", customerOrderReplicaRequest.getCartId());

			try {
				customerOrderReplicaMap.put("phonePeResponse",
						phonepeServiceImpl.initiatePhonepePayment(transactionId,
								Integer.valueOf(customerOrderReplicaRequest.getRazorPayRequest().getAmount()),
								contactNumber, customerOrderReplicaRequest.getRedirectUrl(), customerOrderReplicaRequest.getCallBackUrl()));

			} catch (Exception e) {
				e.printStackTrace();
				customerOrderReplicaMap.put("phonePeResponse", new HashedMap<>());
			}

			return customerOrderReplicaMap;

		} else {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
					"paymentDetails transcation Details are mandatory");
		}

	}

	private static String getMerchantTransactionId() {

		return "OD_" + MerchantTransactionIdGenerator.getRandomString();
	}


	@Override
	public List<CustomerOrderReplica> getCustomerOrderByMoblieNo(String contactNumber, Integer aid) {

	    Schedule latestSchedule = customerOrderReplicaDoa.getlatestschedule();

	    if (latestSchedule != null && latestSchedule.getCreationTimestamp() != null) {
	        if (latestSchedule.getStatus().equals(UserStatus.ACTIVE)) {
	            Customers customer = customerDetailsDao.getByContactNoAndApartment(contactNumber, aid);

	            if (customer != null) { // Ensure the customer exists
	                List<CustomerOrder> customerOrderList = customerOrderReplicaDoa.getListCustomerOrderByCustomerId(customer.getCtId());

	                double totalOrderAmount = 0.0;

	                if (customerOrderList != null && !customerOrderList.isEmpty()) {
	                    for (CustomerOrder customerOrder : customerOrderList) {
	                        Double orderAmount = customerOrder.getAmount();
	                        if (orderAmount != null) {
	                            totalOrderAmount += orderAmount;
	                            if(totalOrderAmount>200) {
	                            	totalOrderAmount+= customerOrder.getDelivaryCharges();
	                            }
	                            else{(totalOrderAmount<200){
	                            	totalOrderAmount-= customerOrder.getDelivaryCharges();
	                            }
	                        }
	                    }

	                    // Define the minimum order amount for applying delivery charges
	                    double minimumOrderAmount = 200.0;

	                    if (totalOrderAmount < minimumOrderAmount) {
	                        System.out.println("Delivery Charges will be applicable");
	                    } else {
	                        // No delivery charges applicable
	                        System.out.println("No Delivery charges applicable");
	                    }

	                    List<CustomerOrderReplica> customerOrderReplicas = new ArrayList<>();
	                    return customerOrderReplicas;
	                } else {
	                    return Collections.emptyList();
	                }
	            } else {
	                return null; // or an appropriate value
	            }
	        } else {
	            // Handle the case when the latest schedule is not active
	            return null; // or an appropriate value
	        }
	    } else {
	        // Handle the case when there is no latest schedule or its creation timestamp is null
	        return null; // or an appropriate value
	    }
	}

}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1003)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:799)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:743)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:666)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:658)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.lambda$0(LSJavaHoverProvider.java:68)
	at java.base/java.util.concurrent.CompletableFuture$AsyncRun.run(CompletableFuture.java:1804)
	at java.base/java.util.concurrent.CompletableFuture$AsyncRun.exec(CompletableFuture.java:1796)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:373)
	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1182)
	at java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1655)
	at java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1622)
	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:165)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-09-21 15:34:45.003
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1003)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:799)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:743)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:666)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:658)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.lambda$0(LSJavaHoverProvider.java:68)
	at java.base/java.util.concurrent.CompletableFuture$AsyncRun.run(CompletableFuture.java:1804)
	at java.base/java.util.concurrent.CompletableFuture$AsyncRun.exec(CompletableFuture.java:1796)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:373)
	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1182)
	at java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1655)
	at java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1622)
	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:165)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-09-21 15:34:45.004
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1003)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:799)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:743)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:666)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:658)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.lambda$0(LSJavaHoverProvider.java:68)
	at java.base/java.util.concurrent.CompletableFuture$AsyncRun.run(CompletableFuture.java:1804)
	at java.base/java.util.concurrent.CompletableFuture$AsyncRun.exec(CompletableFuture.java:1796)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:373)
	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1182)
	at java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1655)
	at java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1622)
	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:165)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-21 15:34:45.103
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.xyram.daydrop.serviceimpl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.transaction.Transactional;

import org.apache.commons.collections4.map.HashedMap;
import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.server.ResponseStatusException;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.xyram.daydrop.admin.model.CurrentUser;
import com.xyram.daydrop.basemodel.Base64Wrapper;
import com.xyram.daydrop.basemodel.MerchantTransactionIdGenerator;
import com.xyram.daydrop.basemodel.PhonepeSerializer;
import com.xyram.daydrop.dao.ApartmentDao;
import com.xyram.daydrop.dao.CustomerDetailsDao;
import com.xyram.daydrop.dao.CustomerOrderDao;
import com.xyram.daydrop.dao.CustomerOrderReplicaDoa;
import com.xyram.daydrop.dao.SheduleDao;
import com.xyram.daydrop.enumtypes.UserStatus;
import com.xyram.daydrop.model.Apartments;
import com.xyram.daydrop.model.CustomerOrder;
import com.xyram.daydrop.model.CustomerOrderReplica;
import com.xyram.daydrop.model.Customers;
import com.xyram.daydrop.model.Schedule;
import com.xyram.daydrop.modelMapper.PaymentInstrument;
import com.xyram.daydrop.modelMapper.PhonePePayModel;
import com.xyram.daydrop.request.CustomerOrderReplicaRequest;
import com.xyram.daydrop.response.RazorPayRequest;
import com.xyram.daydrop.service.CustomerOrderPriceService;
import com.xyram.daydrop.service.CustomerOrderReplicaService;
import com.xyram.daydrop.util.HashEncoder;
import com.xyram.daydrop.util.RazorPay;
import com.xyram.daydrop.service.ConsumerService;

@Transactional
@Service
public class CustomerOrderReplicaServiceImpl implements CustomerOrderReplicaService {

	@Autowired
	CustomerOrderReplicaDoa customerOrderReplicaDoa;

	@Autowired
	ApartmentDao apartmentDao;

	@Autowired
	SheduleDao scheduleDao;

	@Autowired
	CustomerDetailsDao customerDetailsDao;

	@Autowired
	ConsumerService consumerService;

	@Autowired
	CurrentUser currentUser;

	@Autowired
	PhonepeServiceImpl phonepeServiceImpl;

	@Value("${merchant_id}")
	private String merchantId;

	@Value("${salt_key}")
	private String saltKey;

	@Value("${salt_index}")
	private String saltIndex;

	@Override
	public Map createCustomerOrderReplicaService(CustomerOrderReplicaRequest customerOrderReplicaRequest,
			String contactNumber, Integer aparmentId)

	{

		Map response = new HashedMap<>();

		response.put("message", "success");
		CustomerOrderReplica customerOrderReplica = null;

		if (customerOrderReplicaRequest.getCartId() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "cartId is mandatory ");
		}
		long razorPayCount = 0;
		if (customerOrderReplicaRequest.getOrderId() != null) {

			razorPayCount = customerOrderReplicaDoa.getRazorPayExistByCartId(customerOrderReplicaRequest.getOrderId());
		}

		if (customerOrderReplicaRequest.getCustomerDetails() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Order Details  is mandatory ");
		}

		customerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(customerOrderReplicaRequest.getCartId(),
				contactNumber);

		if (customerOrderReplica != null) {
			customerOrderReplica.setCartId(customerOrderReplica.getCartId());

			if (customerOrderReplica.isOrdered()) {
				throw new ResponseStatusException(HttpStatus.CONFLICT, "Your Order is Placed With cart Details");
			}

//			if (razorPayCount >= 1 && !(customerOrderReplica.getRazorPayOrderId() != null
//					&& customerOrderReplica.getRazorPayOrderId().equals(customerOrderReplicaRequest.getOrderId()))) {
//				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
//			}

			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);

			customerOrderReplica.setAttempts(customerOrderReplica.getAttempts() + 1);
			customerOrderReplica.setUpdatedTime(new Date());

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		} else {

			customerOrderReplica = new CustomerOrderReplica();
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);
			customerOrderReplica.setCartId(customerOrderReplicaRequest.getCartId());
			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());

			if (razorPayCount > 0) {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
			}

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			Schedule schedule = scheduleDao.getlatestScheduleCustomers();

			if (schedule != null) {

				try {
					customerOrderReplica.setSchedule(schedule.getsId() != null ? schedule.getsId().toString() : null);
				} catch (Exception e) {
					e.printStackTrace();
				}
			} else {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
						"Sorry We Are Not Accepting Any Order Right now");

			}

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		}

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicas(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String schedule = null;

		Map filter = request.containsKey("filters") ? (Map) request.get("filters") : null;
		if (filter != null) {
			statusType = filter.containsKey("statusType") ? ((String) filter.get("statusType")).toLowerCase() : null;
			searchQuery = filter.containsKey("searchQuery") ? ((String) filter.get("searchQuery")).toLowerCase() : null;
			schedule = filter.containsKey("schedule") ? (String.valueOf(filter.get("schedule"))) : null;

		}

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplica(searchQuery, statusType, schedule);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");

				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setStreetName(
						customers.get("streetName") != null ? (String) customers.get("streetName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicasBySchedule(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String scheduleId = null;

		Schedule schedule = scheduleDao.getlatestScheduleCustomers();

		if (schedule != null) {

			try {
				scheduleId = schedule.getsId() != null ? schedule.getsId().toString() : null;
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

		statusType = request.containsKey("statusType") ? ((String) request.get("statusType")).toLowerCase() : "Success";

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplicaBySchdeule(statusType, scheduleId);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");
				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				System.out.println("customers" + customers.get("customerName"));

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public CustomerOrderReplica getCustomerOrderReplicaByCartId(String cartId) {

		CustomerOrderReplica CustomerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(cartId,
				currentUser.getContactNumber());

		ObjectMapper objectMapper = new ObjectMapper();
		try {

			// convert JSON string to Map
			Map<String, Object> customerOrderReplicaMap = objectMapper
					.readValue(CustomerOrderReplica.getCustomerOrderDetails(), Map.class);

			Object customerOrder = customerOrderReplicaMap.get("customerOrder");
			Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

			Object quanityList = items.get("quantity");
			Map customers = customerDetailsDao.getByContactNumberAndApartment(CustomerOrderReplica.getContactNumber(),
					CustomerOrderReplica.getApartmentId());

			System.out.println("customers" + customers.get("customerName"));

			// Apartments apartments =
			// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
			CustomerOrderReplica.setApartmentName(
					customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

			CustomerOrderReplica.setCustomerDetails(customers);

			CustomerOrderReplica.setCustomerOrder(customerOrder);
			CustomerOrderReplica.setQuatityList(quanityList);

		} catch (Exception e) {
			e.printStackTrace();
		}

		return CustomerOrderReplica;

	}

	@Override
	public Map createCustomerOrderReplica(CustomerOrderReplicaRequest customerOrderReplicaRequest, String contactNumber,
			Integer aparmentId) {

		if (customerOrderReplicaRequest.getRazorPayRequest() != null) {

//			Map razorPay = consumerService.createRazorPayOrder(customerOrderReplicaRequest.getRazorPayRequest());
//			customerOrderReplicaRequest.setOrderId(razorPay.get("order") != null ? (String)((RazorPay) razorPay.get("order")).getId() : null);	
//	
//			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);
//
//			razorPay.put("cartId", customerOrderReplicaRequest.getCartId());

			Map customerOrderReplicaMap = new HashMap<>();

			Map orderId = new HashMap<>();
			String transactionId = getMerchantTransactionId();
			orderId.put("id", transactionId);

			customerOrderReplicaMap.put("order", orderId);

			customerOrderReplicaRequest.setOrderId(transactionId);
			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);

			customerOrderReplicaMap.put("cartId", customerOrderReplicaRequest.getCartId());

			try {
				customerOrderReplicaMap.put("phonePeResponse",
						phonepeServiceImpl.initiatePhonepePayment(transactionId,
								Integer.valueOf(customerOrderReplicaRequest.getRazorPayRequest().getAmount()),
								contactNumber, customerOrderReplicaRequest.getRedirectUrl(), customerOrderReplicaRequest.getCallBackUrl()));

			} catch (Exception e) {
				e.printStackTrace();
				customerOrderReplicaMap.put("phonePeResponse", new HashedMap<>());
			}

			return customerOrderReplicaMap;

		} else {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
					"paymentDetails transcation Details are mandatory");
		}

	}

	private static String getMerchantTransactionId() {

		return "OD_" + MerchantTransactionIdGenerator.getRandomString();
	}


	@Override
	public List<CustomerOrderReplica> getCustomerOrderByMoblieNo(String contactNumber, Integer aid) {

	    Schedule latestSchedule = customerOrderReplicaDoa.getlatestschedule();

	    if (latestSchedule != null && latestSchedule.getCreationTimestamp() != null) {
	        if (latestSchedule.getStatus().equals(UserStatus.ACTIVE)) {
	            Customers customer = customerDetailsDao.getByContactNoAndApartment(contactNumber, aid);

	            if (customer != null) { // Ensure the customer exists
	                List<CustomerOrder> customerOrderList = customerOrderReplicaDoa.getListCustomerOrderByCustomerId(customer.getCtId());

	                double totalOrderAmount = 0.0;

	                if (customerOrderList != null && !customerOrderList.isEmpty()) {
	                    for (CustomerOrder customerOrder : customerOrderList) {
	                        Double orderAmount = customerOrder.getAmount();
	                        if (orderAmount != null) {
	                            totalOrderAmount += orderAmount;
	                            if(totalOrderAmount>200) {
	                            	totalOrderAmount+= customerOrder.getDelivaryCharges();
	                            }
	                            else{(totalOrderAmount<200){
	                            	totalOrderAmount-= customerOrder.getDelivaryCharges();
	                            }
	                        }
	                    }

	                    // Define the minimum order amount for applying delivery charges
	                    double minimumOrderAmount = 200.0;

	                    if (totalOrderAmount < minimumOrderAmount) {
	                        System.out.println("Delivery Charges will be applicable");
	                    } else {
	                        // No delivery charges applicable
	                        System.out.println("No Delivery charges applicable");
	                    }

	                    List<CustomerOrderReplica> customerOrderReplicas = new ArrayList<>();
	                    return customerOrderReplicas;
	                } else {
	                    return Collections.emptyList();
	                }
	            } else {
	                return null; // or an appropriate value
	            }
	        } else {
	            // Handle the case when the latest schedule is not active
	            return null; // or an appropriate value
	        }
	    } else {
	        // Handle the case when there is no latest schedule or its creation timestamp is null
	        return null; // or an appropriate value
	    }
	}

}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4035)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3635)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-09-21 15:34:45.105
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4035)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3635)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-09-21 15:34:45.106
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4035)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3635)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-21 15:34:45.158
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.xyram.daydrop.serviceimpl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.transaction.Transactional;

import org.apache.commons.collections4.map.HashedMap;
import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.server.ResponseStatusException;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.xyram.daydrop.admin.model.CurrentUser;
import com.xyram.daydrop.basemodel.Base64Wrapper;
import com.xyram.daydrop.basemodel.MerchantTransactionIdGenerator;
import com.xyram.daydrop.basemodel.PhonepeSerializer;
import com.xyram.daydrop.dao.ApartmentDao;
import com.xyram.daydrop.dao.CustomerDetailsDao;
import com.xyram.daydrop.dao.CustomerOrderDao;
import com.xyram.daydrop.dao.CustomerOrderReplicaDoa;
import com.xyram.daydrop.dao.SheduleDao;
import com.xyram.daydrop.enumtypes.UserStatus;
import com.xyram.daydrop.model.Apartments;
import com.xyram.daydrop.model.CustomerOrder;
import com.xyram.daydrop.model.CustomerOrderReplica;
import com.xyram.daydrop.model.Customers;
import com.xyram.daydrop.model.Schedule;
import com.xyram.daydrop.modelMapper.PaymentInstrument;
import com.xyram.daydrop.modelMapper.PhonePePayModel;
import com.xyram.daydrop.request.CustomerOrderReplicaRequest;
import com.xyram.daydrop.response.RazorPayRequest;
import com.xyram.daydrop.service.CustomerOrderPriceService;
import com.xyram.daydrop.service.CustomerOrderReplicaService;
import com.xyram.daydrop.util.HashEncoder;
import com.xyram.daydrop.util.RazorPay;
import com.xyram.daydrop.service.ConsumerService;

@Transactional
@Service
public class CustomerOrderReplicaServiceImpl implements CustomerOrderReplicaService {

	@Autowired
	CustomerOrderReplicaDoa customerOrderReplicaDoa;

	@Autowired
	ApartmentDao apartmentDao;

	@Autowired
	SheduleDao scheduleDao;

	@Autowired
	CustomerDetailsDao customerDetailsDao;

	@Autowired
	ConsumerService consumerService;

	@Autowired
	CurrentUser currentUser;

	@Autowired
	PhonepeServiceImpl phonepeServiceImpl;

	@Value("${merchant_id}")
	private String merchantId;

	@Value("${salt_key}")
	private String saltKey;

	@Value("${salt_index}")
	private String saltIndex;

	@Override
	public Map createCustomerOrderReplicaService(CustomerOrderReplicaRequest customerOrderReplicaRequest,
			String contactNumber, Integer aparmentId)

	{

		Map response = new HashedMap<>();

		response.put("message", "success");
		CustomerOrderReplica customerOrderReplica = null;

		if (customerOrderReplicaRequest.getCartId() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "cartId is mandatory ");
		}
		long razorPayCount = 0;
		if (customerOrderReplicaRequest.getOrderId() != null) {

			razorPayCount = customerOrderReplicaDoa.getRazorPayExistByCartId(customerOrderReplicaRequest.getOrderId());
		}

		if (customerOrderReplicaRequest.getCustomerDetails() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Order Details  is mandatory ");
		}

		customerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(customerOrderReplicaRequest.getCartId(),
				contactNumber);

		if (customerOrderReplica != null) {
			customerOrderReplica.setCartId(customerOrderReplica.getCartId());

			if (customerOrderReplica.isOrdered()) {
				throw new ResponseStatusException(HttpStatus.CONFLICT, "Your Order is Placed With cart Details");
			}

//			if (razorPayCount >= 1 && !(customerOrderReplica.getRazorPayOrderId() != null
//					&& customerOrderReplica.getRazorPayOrderId().equals(customerOrderReplicaRequest.getOrderId()))) {
//				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
//			}

			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);

			customerOrderReplica.setAttempts(customerOrderReplica.getAttempts() + 1);
			customerOrderReplica.setUpdatedTime(new Date());

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		} else {

			customerOrderReplica = new CustomerOrderReplica();
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);
			customerOrderReplica.setCartId(customerOrderReplicaRequest.getCartId());
			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());

			if (razorPayCount > 0) {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
			}

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			Schedule schedule = scheduleDao.getlatestScheduleCustomers();

			if (schedule != null) {

				try {
					customerOrderReplica.setSchedule(schedule.getsId() != null ? schedule.getsId().toString() : null);
				} catch (Exception e) {
					e.printStackTrace();
				}
			} else {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
						"Sorry We Are Not Accepting Any Order Right now");

			}

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		}

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicas(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String schedule = null;

		Map filter = request.containsKey("filters") ? (Map) request.get("filters") : null;
		if (filter != null) {
			statusType = filter.containsKey("statusType") ? ((String) filter.get("statusType")).toLowerCase() : null;
			searchQuery = filter.containsKey("searchQuery") ? ((String) filter.get("searchQuery")).toLowerCase() : null;
			schedule = filter.containsKey("schedule") ? (String.valueOf(filter.get("schedule"))) : null;

		}

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplica(searchQuery, statusType, schedule);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");

				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setStreetName(
						customers.get("streetName") != null ? (String) customers.get("streetName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicasBySchedule(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String scheduleId = null;

		Schedule schedule = scheduleDao.getlatestScheduleCustomers();

		if (schedule != null) {

			try {
				scheduleId = schedule.getsId() != null ? schedule.getsId().toString() : null;
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

		statusType = request.containsKey("statusType") ? ((String) request.get("statusType")).toLowerCase() : "Success";

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplicaBySchdeule(statusType, scheduleId);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");
				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				System.out.println("customers" + customers.get("customerName"));

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public CustomerOrderReplica getCustomerOrderReplicaByCartId(String cartId) {

		CustomerOrderReplica CustomerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(cartId,
				currentUser.getContactNumber());

		ObjectMapper objectMapper = new ObjectMapper();
		try {

			// convert JSON string to Map
			Map<String, Object> customerOrderReplicaMap = objectMapper
					.readValue(CustomerOrderReplica.getCustomerOrderDetails(), Map.class);

			Object customerOrder = customerOrderReplicaMap.get("customerOrder");
			Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

			Object quanityList = items.get("quantity");
			Map customers = customerDetailsDao.getByContactNumberAndApartment(CustomerOrderReplica.getContactNumber(),
					CustomerOrderReplica.getApartmentId());

			System.out.println("customers" + customers.get("customerName"));

			// Apartments apartments =
			// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
			CustomerOrderReplica.setApartmentName(
					customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

			CustomerOrderReplica.setCustomerDetails(customers);

			CustomerOrderReplica.setCustomerOrder(customerOrder);
			CustomerOrderReplica.setQuatityList(quanityList);

		} catch (Exception e) {
			e.printStackTrace();
		}

		return CustomerOrderReplica;

	}

	@Override
	public Map createCustomerOrderReplica(CustomerOrderReplicaRequest customerOrderReplicaRequest, String contactNumber,
			Integer aparmentId) {

		if (customerOrderReplicaRequest.getRazorPayRequest() != null) {

//			Map razorPay = consumerService.createRazorPayOrder(customerOrderReplicaRequest.getRazorPayRequest());
//			customerOrderReplicaRequest.setOrderId(razorPay.get("order") != null ? (String)((RazorPay) razorPay.get("order")).getId() : null);	
//	
//			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);
//
//			razorPay.put("cartId", customerOrderReplicaRequest.getCartId());

			Map customerOrderReplicaMap = new HashMap<>();

			Map orderId = new HashMap<>();
			String transactionId = getMerchantTransactionId();
			orderId.put("id", transactionId);

			customerOrderReplicaMap.put("order", orderId);

			customerOrderReplicaRequest.setOrderId(transactionId);
			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);

			customerOrderReplicaMap.put("cartId", customerOrderReplicaRequest.getCartId());

			try {
				customerOrderReplicaMap.put("phonePeResponse",
						phonepeServiceImpl.initiatePhonepePayment(transactionId,
								Integer.valueOf(customerOrderReplicaRequest.getRazorPayRequest().getAmount()),
								contactNumber, customerOrderReplicaRequest.getRedirectUrl(), customerOrderReplicaRequest.getCallBackUrl()));

			} catch (Exception e) {
				e.printStackTrace();
				customerOrderReplicaMap.put("phonePeResponse", new HashedMap<>());
			}

			return customerOrderReplicaMap;

		} else {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
					"paymentDetails transcation Details are mandatory");
		}

	}

	private static String getMerchantTransactionId() {

		return "OD_" + MerchantTransactionIdGenerator.getRandomString();
	}


	@Override
	public List<CustomerOrderReplica> getCustomerOrderByMoblieNo(String contactNumber, Integer aid) {

	    Schedule latestSchedule = customerOrderReplicaDoa.getlatestschedule();

	    if (latestSchedule != null && latestSchedule.getCreationTimestamp() != null) {
	        if (latestSchedule.getStatus().equals(UserStatus.ACTIVE)) {
	            Customers customer = customerDetailsDao.getByContactNoAndApartment(contactNumber, aid);

	            if (customer != null) { // Ensure the customer exists
	                List<CustomerOrder> customerOrderList = customerOrderReplicaDoa.getListCustomerOrderByCustomerId(customer.getCtId());

	                double totalOrderAmount = 0.0;

	                if (customerOrderList != null && !customerOrderList.isEmpty()) {
	                    for (CustomerOrder customerOrder : customerOrderList) {
	                        Double orderAmount = customerOrder.getAmount();
	                        if (orderAmount != null) {
	                            totalOrderAmount += orderAmount;
	                            if(totalOrderAmount>200) {
	                            	totalOrderAmount+= customerOrder.getDelivaryCharges();
	                            }
	                            else{(totalOrderAmount<200){
	                            	totalOrderAmount-= customerOrder.getDelivaryCharges();
	                            }
	                        }
	                    }

	                    // Define the minimum order amount for applying delivery charges
	                    double minimumOrderAmount = 200.0;

	                    if (totalOrderAmount < minimumOrderAmount) {
	                        System.out.println("Delivery Charges will be applicable");
	                    } else {
	                        // No delivery charges applicable
	                        System.out.println("No Delivery charges applicable");
	                    }

	                    List<CustomerOrderReplica> customerOrderReplicas = new ArrayList<>();
	                    return customerOrderReplicas;
	                } else {
	                    return Collections.emptyList();
	                }
	            } else {
	                return null; // or an appropriate value
	            }
	        } else {
	            // Handle the case when the latest schedule is not active
	            return null; // or an appropriate value
	        }
	    } else {
	        // Handle the case when there is no latest schedule or its creation timestamp is null
	        return null; // or an appropriate value
	    }
	}

}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.internal.core.manipulation.dom.ASTResolving.createQuickFixAST(ASTResolving.java:1052)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:131)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4035)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3635)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.ui 4 0 2023-09-21 15:34:45.160
!MESSAGE Unhandled event loop exception
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.internal.core.manipulation.dom.ASTResolving.createQuickFixAST(ASTResolving.java:1052)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:131)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4035)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3635)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-21 15:34:45.721
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.xyram.daydrop.serviceimpl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.transaction.Transactional;

import org.apache.commons.collections4.map.HashedMap;
import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.server.ResponseStatusException;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.xyram.daydrop.admin.model.CurrentUser;
import com.xyram.daydrop.basemodel.Base64Wrapper;
import com.xyram.daydrop.basemodel.MerchantTransactionIdGenerator;
import com.xyram.daydrop.basemodel.PhonepeSerializer;
import com.xyram.daydrop.dao.ApartmentDao;
import com.xyram.daydrop.dao.CustomerDetailsDao;
import com.xyram.daydrop.dao.CustomerOrderDao;
import com.xyram.daydrop.dao.CustomerOrderReplicaDoa;
import com.xyram.daydrop.dao.SheduleDao;
import com.xyram.daydrop.enumtypes.UserStatus;
import com.xyram.daydrop.model.Apartments;
import com.xyram.daydrop.model.CustomerOrder;
import com.xyram.daydrop.model.CustomerOrderReplica;
import com.xyram.daydrop.model.Customers;
import com.xyram.daydrop.model.Schedule;
import com.xyram.daydrop.modelMapper.PaymentInstrument;
import com.xyram.daydrop.modelMapper.PhonePePayModel;
import com.xyram.daydrop.request.CustomerOrderReplicaRequest;
import com.xyram.daydrop.response.RazorPayRequest;
import com.xyram.daydrop.service.CustomerOrderPriceService;
import com.xyram.daydrop.service.CustomerOrderReplicaService;
import com.xyram.daydrop.util.HashEncoder;
import com.xyram.daydrop.util.RazorPay;
import com.xyram.daydrop.service.ConsumerService;

@Transactional
@Service
public class CustomerOrderReplicaServiceImpl implements CustomerOrderReplicaService {

	@Autowired
	CustomerOrderReplicaDoa customerOrderReplicaDoa;

	@Autowired
	ApartmentDao apartmentDao;

	@Autowired
	SheduleDao scheduleDao;

	@Autowired
	CustomerDetailsDao customerDetailsDao;

	@Autowired
	ConsumerService consumerService;

	@Autowired
	CurrentUser currentUser;

	@Autowired
	PhonepeServiceImpl phonepeServiceImpl;

	@Value("${merchant_id}")
	private String merchantId;

	@Value("${salt_key}")
	private String saltKey;

	@Value("${salt_index}")
	private String saltIndex;

	@Override
	public Map createCustomerOrderReplicaService(CustomerOrderReplicaRequest customerOrderReplicaRequest,
			String contactNumber, Integer aparmentId)

	{

		Map response = new HashedMap<>();

		response.put("message", "success");
		CustomerOrderReplica customerOrderReplica = null;

		if (customerOrderReplicaRequest.getCartId() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "cartId is mandatory ");
		}
		long razorPayCount = 0;
		if (customerOrderReplicaRequest.getOrderId() != null) {

			razorPayCount = customerOrderReplicaDoa.getRazorPayExistByCartId(customerOrderReplicaRequest.getOrderId());
		}

		if (customerOrderReplicaRequest.getCustomerDetails() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Order Details  is mandatory ");
		}

		customerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(customerOrderReplicaRequest.getCartId(),
				contactNumber);

		if (customerOrderReplica != null) {
			customerOrderReplica.setCartId(customerOrderReplica.getCartId());

			if (customerOrderReplica.isOrdered()) {
				throw new ResponseStatusException(HttpStatus.CONFLICT, "Your Order is Placed With cart Details");
			}

//			if (razorPayCount >= 1 && !(customerOrderReplica.getRazorPayOrderId() != null
//					&& customerOrderReplica.getRazorPayOrderId().equals(customerOrderReplicaRequest.getOrderId()))) {
//				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
//			}

			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);

			customerOrderReplica.setAttempts(customerOrderReplica.getAttempts() + 1);
			customerOrderReplica.setUpdatedTime(new Date());

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		} else {

			customerOrderReplica = new CustomerOrderReplica();
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);
			customerOrderReplica.setCartId(customerOrderReplicaRequest.getCartId());
			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());

			if (razorPayCount > 0) {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
			}

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			Schedule schedule = scheduleDao.getlatestScheduleCustomers();

			if (schedule != null) {

				try {
					customerOrderReplica.setSchedule(schedule.getsId() != null ? schedule.getsId().toString() : null);
				} catch (Exception e) {
					e.printStackTrace();
				}
			} else {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
						"Sorry We Are Not Accepting Any Order Right now");

			}

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		}

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicas(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String schedule = null;

		Map filter = request.containsKey("filters") ? (Map) request.get("filters") : null;
		if (filter != null) {
			statusType = filter.containsKey("statusType") ? ((String) filter.get("statusType")).toLowerCase() : null;
			searchQuery = filter.containsKey("searchQuery") ? ((String) filter.get("searchQuery")).toLowerCase() : null;
			schedule = filter.containsKey("schedule") ? (String.valueOf(filter.get("schedule"))) : null;

		}

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplica(searchQuery, statusType, schedule);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");

				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setStreetName(
						customers.get("streetName") != null ? (String) customers.get("streetName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicasBySchedule(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String scheduleId = null;

		Schedule schedule = scheduleDao.getlatestScheduleCustomers();

		if (schedule != null) {

			try {
				scheduleId = schedule.getsId() != null ? schedule.getsId().toString() : null;
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

		statusType = request.containsKey("statusType") ? ((String) request.get("statusType")).toLowerCase() : "Success";

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplicaBySchdeule(statusType, scheduleId);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");
				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				System.out.println("customers" + customers.get("customerName"));

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public CustomerOrderReplica getCustomerOrderReplicaByCartId(String cartId) {

		CustomerOrderReplica CustomerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(cartId,
				currentUser.getContactNumber());

		ObjectMapper objectMapper = new ObjectMapper();
		try {

			// convert JSON string to Map
			Map<String, Object> customerOrderReplicaMap = objectMapper
					.readValue(CustomerOrderReplica.getCustomerOrderDetails(), Map.class);

			Object customerOrder = customerOrderReplicaMap.get("customerOrder");
			Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

			Object quanityList = items.get("quantity");
			Map customers = customerDetailsDao.getByContactNumberAndApartment(CustomerOrderReplica.getContactNumber(),
					CustomerOrderReplica.getApartmentId());

			System.out.println("customers" + customers.get("customerName"));

			// Apartments apartments =
			// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
			CustomerOrderReplica.setApartmentName(
					customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

			CustomerOrderReplica.setCustomerDetails(customers);

			CustomerOrderReplica.setCustomerOrder(customerOrder);
			CustomerOrderReplica.setQuatityList(quanityList);

		} catch (Exception e) {
			e.printStackTrace();
		}

		return CustomerOrderReplica;

	}

	@Override
	public Map createCustomerOrderReplica(CustomerOrderReplicaRequest customerOrderReplicaRequest, String contactNumber,
			Integer aparmentId) {

		if (customerOrderReplicaRequest.getRazorPayRequest() != null) {

//			Map razorPay = consumerService.createRazorPayOrder(customerOrderReplicaRequest.getRazorPayRequest());
//			customerOrderReplicaRequest.setOrderId(razorPay.get("order") != null ? (String)((RazorPay) razorPay.get("order")).getId() : null);	
//	
//			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);
//
//			razorPay.put("cartId", customerOrderReplicaRequest.getCartId());

			Map customerOrderReplicaMap = new HashMap<>();

			Map orderId = new HashMap<>();
			String transactionId = getMerchantTransactionId();
			orderId.put("id", transactionId);

			customerOrderReplicaMap.put("order", orderId);

			customerOrderReplicaRequest.setOrderId(transactionId);
			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);

			customerOrderReplicaMap.put("cartId", customerOrderReplicaRequest.getCartId());

			try {
				customerOrderReplicaMap.put("phonePeResponse",
						phonepeServiceImpl.initiatePhonepePayment(transactionId,
								Integer.valueOf(customerOrderReplicaRequest.getRazorPayRequest().getAmount()),
								contactNumber, customerOrderReplicaRequest.getRedirectUrl(), customerOrderReplicaRequest.getCallBackUrl()));

			} catch (Exception e) {
				e.printStackTrace();
				customerOrderReplicaMap.put("phonePeResponse", new HashedMap<>());
			}

			return customerOrderReplicaMap;

		} else {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
					"paymentDetails transcation Details are mandatory");
		}

	}

	private static String getMerchantTransactionId() {

		return "OD_" + MerchantTransactionIdGenerator.getRandomString();
	}


	@Override
	public List<CustomerOrderReplica> getCustomerOrderByMoblieNo(String contactNumber, Integer aid) {

	    Schedule latestSchedule = customerOrderReplicaDoa.getlatestschedule();

	    if (latestSchedule != null && latestSchedule.getCreationTimestamp() != null) {
	        if (latestSchedule.getStatus().equals(UserStatus.ACTIVE)) {
	            Customers customer = customerDetailsDao.getByContactNoAndApartment(contactNumber, aid);

	            if (customer != null) { // Ensure the customer exists
	                List<CustomerOrder> customerOrderList = customerOrderReplicaDoa.getListCustomerOrderByCustomerId(customer.getCtId());

	                double totalOrderAmount = 0.0;

	                if (customerOrderList != null && !customerOrderList.isEmpty()) {
	                    for (CustomerOrder customerOrder : customerOrderList) {
	                        Double orderAmount = customerOrder.getAmount();
	                        if (orderAmount != null) {
	                            totalOrderAmount += orderAmount;
	                            if(totalOrderAmount>200) {
	                            	totalOrderAmount+= customerOrder.getDelivaryCharges();
	                            }
	                            else{
	                            	
	                            }(totalOrderAmount<200){
	                            	totalOrderAmount-= customerOrder.getDelivaryCharges();
	                            }
	                        }
	                    }

	                    // Define the minimum order amount for applying delivery charges
	                    double minimumOrderAmount = 200.0;

	                    if (totalOrderAmount < minimumOrderAmount) {
	                        System.out.println("Delivery Charges will be applicable");
	                    } else {
	                        // No delivery charges applicable
	                        System.out.println("No Delivery charges applicable");
	                    }

	                    List<CustomerOrderReplica> customerOrderReplicas = new ArrayList<>();
	                    return customerOrderReplicas;
	                } else {
	                    return Collections.emptyList();
	                }
	            } else {
	                return null; // or an appropriate value
	            }
	        } else {
	            // Handle the case when the latest schedule is not active
	            return null; // or an appropriate value
	        }
	    } else {
	        // Handle the case when there is no latest schedule or its creation timestamp is null
	        return null; // or an appropriate value
	    }
	}

}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-09-21 15:34:45.724
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-09-21 15:34:45.726
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-21 15:34:45.815
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.xyram.daydrop.serviceimpl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.transaction.Transactional;

import org.apache.commons.collections4.map.HashedMap;
import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.server.ResponseStatusException;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.xyram.daydrop.admin.model.CurrentUser;
import com.xyram.daydrop.basemodel.Base64Wrapper;
import com.xyram.daydrop.basemodel.MerchantTransactionIdGenerator;
import com.xyram.daydrop.basemodel.PhonepeSerializer;
import com.xyram.daydrop.dao.ApartmentDao;
import com.xyram.daydrop.dao.CustomerDetailsDao;
import com.xyram.daydrop.dao.CustomerOrderDao;
import com.xyram.daydrop.dao.CustomerOrderReplicaDoa;
import com.xyram.daydrop.dao.SheduleDao;
import com.xyram.daydrop.enumtypes.UserStatus;
import com.xyram.daydrop.model.Apartments;
import com.xyram.daydrop.model.CustomerOrder;
import com.xyram.daydrop.model.CustomerOrderReplica;
import com.xyram.daydrop.model.Customers;
import com.xyram.daydrop.model.Schedule;
import com.xyram.daydrop.modelMapper.PaymentInstrument;
import com.xyram.daydrop.modelMapper.PhonePePayModel;
import com.xyram.daydrop.request.CustomerOrderReplicaRequest;
import com.xyram.daydrop.response.RazorPayRequest;
import com.xyram.daydrop.service.CustomerOrderPriceService;
import com.xyram.daydrop.service.CustomerOrderReplicaService;
import com.xyram.daydrop.util.HashEncoder;
import com.xyram.daydrop.util.RazorPay;
import com.xyram.daydrop.service.ConsumerService;

@Transactional
@Service
public class CustomerOrderReplicaServiceImpl implements CustomerOrderReplicaService {

	@Autowired
	CustomerOrderReplicaDoa customerOrderReplicaDoa;

	@Autowired
	ApartmentDao apartmentDao;

	@Autowired
	SheduleDao scheduleDao;

	@Autowired
	CustomerDetailsDao customerDetailsDao;

	@Autowired
	ConsumerService consumerService;

	@Autowired
	CurrentUser currentUser;

	@Autowired
	PhonepeServiceImpl phonepeServiceImpl;

	@Value("${merchant_id}")
	private String merchantId;

	@Value("${salt_key}")
	private String saltKey;

	@Value("${salt_index}")
	private String saltIndex;

	@Override
	public Map createCustomerOrderReplicaService(CustomerOrderReplicaRequest customerOrderReplicaRequest,
			String contactNumber, Integer aparmentId)

	{

		Map response = new HashedMap<>();

		response.put("message", "success");
		CustomerOrderReplica customerOrderReplica = null;

		if (customerOrderReplicaRequest.getCartId() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "cartId is mandatory ");
		}
		long razorPayCount = 0;
		if (customerOrderReplicaRequest.getOrderId() != null) {

			razorPayCount = customerOrderReplicaDoa.getRazorPayExistByCartId(customerOrderReplicaRequest.getOrderId());
		}

		if (customerOrderReplicaRequest.getCustomerDetails() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Order Details  is mandatory ");
		}

		customerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(customerOrderReplicaRequest.getCartId(),
				contactNumber);

		if (customerOrderReplica != null) {
			customerOrderReplica.setCartId(customerOrderReplica.getCartId());

			if (customerOrderReplica.isOrdered()) {
				throw new ResponseStatusException(HttpStatus.CONFLICT, "Your Order is Placed With cart Details");
			}

//			if (razorPayCount >= 1 && !(customerOrderReplica.getRazorPayOrderId() != null
//					&& customerOrderReplica.getRazorPayOrderId().equals(customerOrderReplicaRequest.getOrderId()))) {
//				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
//			}

			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);

			customerOrderReplica.setAttempts(customerOrderReplica.getAttempts() + 1);
			customerOrderReplica.setUpdatedTime(new Date());

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		} else {

			customerOrderReplica = new CustomerOrderReplica();
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);
			customerOrderReplica.setCartId(customerOrderReplicaRequest.getCartId());
			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());

			if (razorPayCount > 0) {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
			}

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			Schedule schedule = scheduleDao.getlatestScheduleCustomers();

			if (schedule != null) {

				try {
					customerOrderReplica.setSchedule(schedule.getsId() != null ? schedule.getsId().toString() : null);
				} catch (Exception e) {
					e.printStackTrace();
				}
			} else {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
						"Sorry We Are Not Accepting Any Order Right now");

			}

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		}

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicas(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String schedule = null;

		Map filter = request.containsKey("filters") ? (Map) request.get("filters") : null;
		if (filter != null) {
			statusType = filter.containsKey("statusType") ? ((String) filter.get("statusType")).toLowerCase() : null;
			searchQuery = filter.containsKey("searchQuery") ? ((String) filter.get("searchQuery")).toLowerCase() : null;
			schedule = filter.containsKey("schedule") ? (String.valueOf(filter.get("schedule"))) : null;

		}

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplica(searchQuery, statusType, schedule);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");

				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setStreetName(
						customers.get("streetName") != null ? (String) customers.get("streetName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicasBySchedule(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String scheduleId = null;

		Schedule schedule = scheduleDao.getlatestScheduleCustomers();

		if (schedule != null) {

			try {
				scheduleId = schedule.getsId() != null ? schedule.getsId().toString() : null;
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

		statusType = request.containsKey("statusType") ? ((String) request.get("statusType")).toLowerCase() : "Success";

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplicaBySchdeule(statusType, scheduleId);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");
				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				System.out.println("customers" + customers.get("customerName"));

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public CustomerOrderReplica getCustomerOrderReplicaByCartId(String cartId) {

		CustomerOrderReplica CustomerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(cartId,
				currentUser.getContactNumber());

		ObjectMapper objectMapper = new ObjectMapper();
		try {

			// convert JSON string to Map
			Map<String, Object> customerOrderReplicaMap = objectMapper
					.readValue(CustomerOrderReplica.getCustomerOrderDetails(), Map.class);

			Object customerOrder = customerOrderReplicaMap.get("customerOrder");
			Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

			Object quanityList = items.get("quantity");
			Map customers = customerDetailsDao.getByContactNumberAndApartment(CustomerOrderReplica.getContactNumber(),
					CustomerOrderReplica.getApartmentId());

			System.out.println("customers" + customers.get("customerName"));

			// Apartments apartments =
			// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
			CustomerOrderReplica.setApartmentName(
					customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

			CustomerOrderReplica.setCustomerDetails(customers);

			CustomerOrderReplica.setCustomerOrder(customerOrder);
			CustomerOrderReplica.setQuatityList(quanityList);

		} catch (Exception e) {
			e.printStackTrace();
		}

		return CustomerOrderReplica;

	}

	@Override
	public Map createCustomerOrderReplica(CustomerOrderReplicaRequest customerOrderReplicaRequest, String contactNumber,
			Integer aparmentId) {

		if (customerOrderReplicaRequest.getRazorPayRequest() != null) {

//			Map razorPay = consumerService.createRazorPayOrder(customerOrderReplicaRequest.getRazorPayRequest());
//			customerOrderReplicaRequest.setOrderId(razorPay.get("order") != null ? (String)((RazorPay) razorPay.get("order")).getId() : null);	
//	
//			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);
//
//			razorPay.put("cartId", customerOrderReplicaRequest.getCartId());

			Map customerOrderReplicaMap = new HashMap<>();

			Map orderId = new HashMap<>();
			String transactionId = getMerchantTransactionId();
			orderId.put("id", transactionId);

			customerOrderReplicaMap.put("order", orderId);

			customerOrderReplicaRequest.setOrderId(transactionId);
			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);

			customerOrderReplicaMap.put("cartId", customerOrderReplicaRequest.getCartId());

			try {
				customerOrderReplicaMap.put("phonePeResponse",
						phonepeServiceImpl.initiatePhonepePayment(transactionId,
								Integer.valueOf(customerOrderReplicaRequest.getRazorPayRequest().getAmount()),
								contactNumber, customerOrderReplicaRequest.getRedirectUrl(), customerOrderReplicaRequest.getCallBackUrl()));

			} catch (Exception e) {
				e.printStackTrace();
				customerOrderReplicaMap.put("phonePeResponse", new HashedMap<>());
			}

			return customerOrderReplicaMap;

		} else {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
					"paymentDetails transcation Details are mandatory");
		}

	}

	private static String getMerchantTransactionId() {

		return "OD_" + MerchantTransactionIdGenerator.getRandomString();
	}


	@Override
	public List<CustomerOrderReplica> getCustomerOrderByMoblieNo(String contactNumber, Integer aid) {

	    Schedule latestSchedule = customerOrderReplicaDoa.getlatestschedule();

	    if (latestSchedule != null && latestSchedule.getCreationTimestamp() != null) {
	        if (latestSchedule.getStatus().equals(UserStatus.ACTIVE)) {
	            Customers customer = customerDetailsDao.getByContactNoAndApartment(contactNumber, aid);

	            if (customer != null) { // Ensure the customer exists
	                List<CustomerOrder> customerOrderList = customerOrderReplicaDoa.getListCustomerOrderByCustomerId(customer.getCtId());

	                double totalOrderAmount = 0.0;

	                if (customerOrderList != null && !customerOrderList.isEmpty()) {
	                    for (CustomerOrder customerOrder : customerOrderList) {
	                        Double orderAmount = customerOrder.getAmount();
	                        if (orderAmount != null) {
	                            totalOrderAmount += orderAmount;
	                            if(totalOrderAmount>200) {
	                            	totalOrderAmount+= customerOrder.getDelivaryCharges();
	                            }
	                            else{
	                            	
	                            }(totalOrderAmount<200){
	                            	totalOrderAmount-= customerOrder.getDelivaryCharges();
	                            }
	                        }
	                    }

	                    // Define the minimum order amount for applying delivery charges
	                    double minimumOrderAmount = 200.0;

	                    if (totalOrderAmount < minimumOrderAmount) {
	                        System.out.println("Delivery Charges will be applicable");
	                    } else {
	                        // No delivery charges applicable
	                        System.out.println("No Delivery charges applicable");
	                    }

	                    List<CustomerOrderReplica> customerOrderReplicas = new ArrayList<>();
	                    return customerOrderReplicas;
	                } else {
	                    return Collections.emptyList();
	                }
	            } else {
	                return null; // or an appropriate value
	            }
	        } else {
	            // Handle the case when the latest schedule is not active
	            return null; // or an appropriate value
	        }
	    } else {
	        // Handle the case when there is no latest schedule or its creation timestamp is null
	        return null; // or an appropriate value
	    }
	}

}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-09-21 15:34:45.818
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-09-21 15:34:45.821
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-21 15:34:46.463
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.xyram.daydrop.serviceimpl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.transaction.Transactional;

import org.apache.commons.collections4.map.HashedMap;
import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.server.ResponseStatusException;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.xyram.daydrop.admin.model.CurrentUser;
import com.xyram.daydrop.basemodel.Base64Wrapper;
import com.xyram.daydrop.basemodel.MerchantTransactionIdGenerator;
import com.xyram.daydrop.basemodel.PhonepeSerializer;
import com.xyram.daydrop.dao.ApartmentDao;
import com.xyram.daydrop.dao.CustomerDetailsDao;
import com.xyram.daydrop.dao.CustomerOrderDao;
import com.xyram.daydrop.dao.CustomerOrderReplicaDoa;
import com.xyram.daydrop.dao.SheduleDao;
import com.xyram.daydrop.enumtypes.UserStatus;
import com.xyram.daydrop.model.Apartments;
import com.xyram.daydrop.model.CustomerOrder;
import com.xyram.daydrop.model.CustomerOrderReplica;
import com.xyram.daydrop.model.Customers;
import com.xyram.daydrop.model.Schedule;
import com.xyram.daydrop.modelMapper.PaymentInstrument;
import com.xyram.daydrop.modelMapper.PhonePePayModel;
import com.xyram.daydrop.request.CustomerOrderReplicaRequest;
import com.xyram.daydrop.response.RazorPayRequest;
import com.xyram.daydrop.service.CustomerOrderPriceService;
import com.xyram.daydrop.service.CustomerOrderReplicaService;
import com.xyram.daydrop.util.HashEncoder;
import com.xyram.daydrop.util.RazorPay;
import com.xyram.daydrop.service.ConsumerService;

@Transactional
@Service
public class CustomerOrderReplicaServiceImpl implements CustomerOrderReplicaService {

	@Autowired
	CustomerOrderReplicaDoa customerOrderReplicaDoa;

	@Autowired
	ApartmentDao apartmentDao;

	@Autowired
	SheduleDao scheduleDao;

	@Autowired
	CustomerDetailsDao customerDetailsDao;

	@Autowired
	ConsumerService consumerService;

	@Autowired
	CurrentUser currentUser;

	@Autowired
	PhonepeServiceImpl phonepeServiceImpl;

	@Value("${merchant_id}")
	private String merchantId;

	@Value("${salt_key}")
	private String saltKey;

	@Value("${salt_index}")
	private String saltIndex;

	@Override
	public Map createCustomerOrderReplicaService(CustomerOrderReplicaRequest customerOrderReplicaRequest,
			String contactNumber, Integer aparmentId)

	{

		Map response = new HashedMap<>();

		response.put("message", "success");
		CustomerOrderReplica customerOrderReplica = null;

		if (customerOrderReplicaRequest.getCartId() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "cartId is mandatory ");
		}
		long razorPayCount = 0;
		if (customerOrderReplicaRequest.getOrderId() != null) {

			razorPayCount = customerOrderReplicaDoa.getRazorPayExistByCartId(customerOrderReplicaRequest.getOrderId());
		}

		if (customerOrderReplicaRequest.getCustomerDetails() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Order Details  is mandatory ");
		}

		customerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(customerOrderReplicaRequest.getCartId(),
				contactNumber);

		if (customerOrderReplica != null) {
			customerOrderReplica.setCartId(customerOrderReplica.getCartId());

			if (customerOrderReplica.isOrdered()) {
				throw new ResponseStatusException(HttpStatus.CONFLICT, "Your Order is Placed With cart Details");
			}

//			if (razorPayCount >= 1 && !(customerOrderReplica.getRazorPayOrderId() != null
//					&& customerOrderReplica.getRazorPayOrderId().equals(customerOrderReplicaRequest.getOrderId()))) {
//				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
//			}

			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);

			customerOrderReplica.setAttempts(customerOrderReplica.getAttempts() + 1);
			customerOrderReplica.setUpdatedTime(new Date());

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		} else {

			customerOrderReplica = new CustomerOrderReplica();
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);
			customerOrderReplica.setCartId(customerOrderReplicaRequest.getCartId());
			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());

			if (razorPayCount > 0) {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
			}

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			Schedule schedule = scheduleDao.getlatestScheduleCustomers();

			if (schedule != null) {

				try {
					customerOrderReplica.setSchedule(schedule.getsId() != null ? schedule.getsId().toString() : null);
				} catch (Exception e) {
					e.printStackTrace();
				}
			} else {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
						"Sorry We Are Not Accepting Any Order Right now");

			}

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		}

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicas(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String schedule = null;

		Map filter = request.containsKey("filters") ? (Map) request.get("filters") : null;
		if (filter != null) {
			statusType = filter.containsKey("statusType") ? ((String) filter.get("statusType")).toLowerCase() : null;
			searchQuery = filter.containsKey("searchQuery") ? ((String) filter.get("searchQuery")).toLowerCase() : null;
			schedule = filter.containsKey("schedule") ? (String.valueOf(filter.get("schedule"))) : null;

		}

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplica(searchQuery, statusType, schedule);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");

				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setStreetName(
						customers.get("streetName") != null ? (String) customers.get("streetName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicasBySchedule(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String scheduleId = null;

		Schedule schedule = scheduleDao.getlatestScheduleCustomers();

		if (schedule != null) {

			try {
				scheduleId = schedule.getsId() != null ? schedule.getsId().toString() : null;
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

		statusType = request.containsKey("statusType") ? ((String) request.get("statusType")).toLowerCase() : "Success";

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplicaBySchdeule(statusType, scheduleId);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");
				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				System.out.println("customers" + customers.get("customerName"));

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public CustomerOrderReplica getCustomerOrderReplicaByCartId(String cartId) {

		CustomerOrderReplica CustomerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(cartId,
				currentUser.getContactNumber());

		ObjectMapper objectMapper = new ObjectMapper();
		try {

			// convert JSON string to Map
			Map<String, Object> customerOrderReplicaMap = objectMapper
					.readValue(CustomerOrderReplica.getCustomerOrderDetails(), Map.class);

			Object customerOrder = customerOrderReplicaMap.get("customerOrder");
			Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

			Object quanityList = items.get("quantity");
			Map customers = customerDetailsDao.getByContactNumberAndApartment(CustomerOrderReplica.getContactNumber(),
					CustomerOrderReplica.getApartmentId());

			System.out.println("customers" + customers.get("customerName"));

			// Apartments apartments =
			// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
			CustomerOrderReplica.setApartmentName(
					customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

			CustomerOrderReplica.setCustomerDetails(customers);

			CustomerOrderReplica.setCustomerOrder(customerOrder);
			CustomerOrderReplica.setQuatityList(quanityList);

		} catch (Exception e) {
			e.printStackTrace();
		}

		return CustomerOrderReplica;

	}

	@Override
	public Map createCustomerOrderReplica(CustomerOrderReplicaRequest customerOrderReplicaRequest, String contactNumber,
			Integer aparmentId) {

		if (customerOrderReplicaRequest.getRazorPayRequest() != null) {

//			Map razorPay = consumerService.createRazorPayOrder(customerOrderReplicaRequest.getRazorPayRequest());
//			customerOrderReplicaRequest.setOrderId(razorPay.get("order") != null ? (String)((RazorPay) razorPay.get("order")).getId() : null);	
//	
//			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);
//
//			razorPay.put("cartId", customerOrderReplicaRequest.getCartId());

			Map customerOrderReplicaMap = new HashMap<>();

			Map orderId = new HashMap<>();
			String transactionId = getMerchantTransactionId();
			orderId.put("id", transactionId);

			customerOrderReplicaMap.put("order", orderId);

			customerOrderReplicaRequest.setOrderId(transactionId);
			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);

			customerOrderReplicaMap.put("cartId", customerOrderReplicaRequest.getCartId());

			try {
				customerOrderReplicaMap.put("phonePeResponse",
						phonepeServiceImpl.initiatePhonepePayment(transactionId,
								Integer.valueOf(customerOrderReplicaRequest.getRazorPayRequest().getAmount()),
								contactNumber, customerOrderReplicaRequest.getRedirectUrl(), customerOrderReplicaRequest.getCallBackUrl()));

			} catch (Exception e) {
				e.printStackTrace();
				customerOrderReplicaMap.put("phonePeResponse", new HashedMap<>());
			}

			return customerOrderReplicaMap;

		} else {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
					"paymentDetails transcation Details are mandatory");
		}

	}

	private static String getMerchantTransactionId() {

		return "OD_" + MerchantTransactionIdGenerator.getRandomString();
	}


	@Override
	public List<CustomerOrderReplica> getCustomerOrderByMoblieNo(String contactNumber, Integer aid) {

	    Schedule latestSchedule = customerOrderReplicaDoa.getlatestschedule();

	    if (latestSchedule != null && latestSchedule.getCreationTimestamp() != null) {
	        if (latestSchedule.getStatus().equals(UserStatus.ACTIVE)) {
	            Customers customer = customerDetailsDao.getByContactNoAndApartment(contactNumber, aid);

	            if (customer != null) { // Ensure the customer exists
	                List<CustomerOrder> customerOrderList = customerOrderReplicaDoa.getListCustomerOrderByCustomerId(customer.getCtId());

	                double totalOrderAmount = 0.0;

	                if (customerOrderList != null && !customerOrderList.isEmpty()) {
	                    for (CustomerOrder customerOrder : customerOrderList) {
	                        Double orderAmount = customerOrder.getAmount();
	                        if (orderAmount != null) {
	                            totalOrderAmount += orderAmount;
	                            if(totalOrderAmount>200) {
	                            	totalOrderAmount+= customerOrder.getDelivaryCharges();
	                            }
	                            else{
	                            	
	                            }(totalOrderAmount<200){
	                            	totalOrderAmount-= customerOrder.getDelivaryCharges();
	                            }
	                        }
	                    }

	                    // Define the minimum order amount for applying delivery charges
	                    double minimumOrderAmount = 200.0;

	                    if (totalOrderAmount < minimumOrderAmount) {
	                        System.out.println("Delivery Charges will be applicable");
	                    } else {
	                        // No delivery charges applicable
	                        System.out.println("No Delivery charges applicable");
	                    }

	                    List<CustomerOrderReplica> customerOrderReplicas = new ArrayList<>();
	                    return customerOrderReplicas;
	                } else {
	                    return Collections.emptyList();
	                }
	            } else {
	                return null; // or an appropriate value
	            }
	        } else {
	            // Handle the case when the latest schedule is not active
	            return null; // or an appropriate value
	        }
	    } else {
	        // Handle the case when there is no latest schedule or its creation timestamp is null
	        return null; // or an appropriate value
	    }
	}

}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-09-21 15:34:46.465
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-09-21 15:34:46.466
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-21 15:34:47.467
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.xyram.daydrop.serviceimpl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.transaction.Transactional;

import org.apache.commons.collections4.map.HashedMap;
import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.server.ResponseStatusException;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.xyram.daydrop.admin.model.CurrentUser;
import com.xyram.daydrop.basemodel.Base64Wrapper;
import com.xyram.daydrop.basemodel.MerchantTransactionIdGenerator;
import com.xyram.daydrop.basemodel.PhonepeSerializer;
import com.xyram.daydrop.dao.ApartmentDao;
import com.xyram.daydrop.dao.CustomerDetailsDao;
import com.xyram.daydrop.dao.CustomerOrderDao;
import com.xyram.daydrop.dao.CustomerOrderReplicaDoa;
import com.xyram.daydrop.dao.SheduleDao;
import com.xyram.daydrop.enumtypes.UserStatus;
import com.xyram.daydrop.model.Apartments;
import com.xyram.daydrop.model.CustomerOrder;
import com.xyram.daydrop.model.CustomerOrderReplica;
import com.xyram.daydrop.model.Customers;
import com.xyram.daydrop.model.Schedule;
import com.xyram.daydrop.modelMapper.PaymentInstrument;
import com.xyram.daydrop.modelMapper.PhonePePayModel;
import com.xyram.daydrop.request.CustomerOrderReplicaRequest;
import com.xyram.daydrop.response.RazorPayRequest;
import com.xyram.daydrop.service.CustomerOrderPriceService;
import com.xyram.daydrop.service.CustomerOrderReplicaService;
import com.xyram.daydrop.util.HashEncoder;
import com.xyram.daydrop.util.RazorPay;
import com.xyram.daydrop.service.ConsumerService;

@Transactional
@Service
public class CustomerOrderReplicaServiceImpl implements CustomerOrderReplicaService {

	@Autowired
	CustomerOrderReplicaDoa customerOrderReplicaDoa;

	@Autowired
	ApartmentDao apartmentDao;

	@Autowired
	SheduleDao scheduleDao;

	@Autowired
	CustomerDetailsDao customerDetailsDao;

	@Autowired
	ConsumerService consumerService;

	@Autowired
	CurrentUser currentUser;

	@Autowired
	PhonepeServiceImpl phonepeServiceImpl;

	@Value("${merchant_id}")
	private String merchantId;

	@Value("${salt_key}")
	private String saltKey;

	@Value("${salt_index}")
	private String saltIndex;

	@Override
	public Map createCustomerOrderReplicaService(CustomerOrderReplicaRequest customerOrderReplicaRequest,
			String contactNumber, Integer aparmentId)

	{

		Map response = new HashedMap<>();

		response.put("message", "success");
		CustomerOrderReplica customerOrderReplica = null;

		if (customerOrderReplicaRequest.getCartId() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "cartId is mandatory ");
		}
		long razorPayCount = 0;
		if (customerOrderReplicaRequest.getOrderId() != null) {

			razorPayCount = customerOrderReplicaDoa.getRazorPayExistByCartId(customerOrderReplicaRequest.getOrderId());
		}

		if (customerOrderReplicaRequest.getCustomerDetails() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Order Details  is mandatory ");
		}

		customerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(customerOrderReplicaRequest.getCartId(),
				contactNumber);

		if (customerOrderReplica != null) {
			customerOrderReplica.setCartId(customerOrderReplica.getCartId());

			if (customerOrderReplica.isOrdered()) {
				throw new ResponseStatusException(HttpStatus.CONFLICT, "Your Order is Placed With cart Details");
			}

//			if (razorPayCount >= 1 && !(customerOrderReplica.getRazorPayOrderId() != null
//					&& customerOrderReplica.getRazorPayOrderId().equals(customerOrderReplicaRequest.getOrderId()))) {
//				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
//			}

			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);

			customerOrderReplica.setAttempts(customerOrderReplica.getAttempts() + 1);
			customerOrderReplica.setUpdatedTime(new Date());

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		} else {

			customerOrderReplica = new CustomerOrderReplica();
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);
			customerOrderReplica.setCartId(customerOrderReplicaRequest.getCartId());
			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());

			if (razorPayCount > 0) {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
			}

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			Schedule schedule = scheduleDao.getlatestScheduleCustomers();

			if (schedule != null) {

				try {
					customerOrderReplica.setSchedule(schedule.getsId() != null ? schedule.getsId().toString() : null);
				} catch (Exception e) {
					e.printStackTrace();
				}
			} else {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
						"Sorry We Are Not Accepting Any Order Right now");

			}

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		}

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicas(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String schedule = null;

		Map filter = request.containsKey("filters") ? (Map) request.get("filters") : null;
		if (filter != null) {
			statusType = filter.containsKey("statusType") ? ((String) filter.get("statusType")).toLowerCase() : null;
			searchQuery = filter.containsKey("searchQuery") ? ((String) filter.get("searchQuery")).toLowerCase() : null;
			schedule = filter.containsKey("schedule") ? (String.valueOf(filter.get("schedule"))) : null;

		}

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplica(searchQuery, statusType, schedule);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");

				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setStreetName(
						customers.get("streetName") != null ? (String) customers.get("streetName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicasBySchedule(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String scheduleId = null;

		Schedule schedule = scheduleDao.getlatestScheduleCustomers();

		if (schedule != null) {

			try {
				scheduleId = schedule.getsId() != null ? schedule.getsId().toString() : null;
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

		statusType = request.containsKey("statusType") ? ((String) request.get("statusType")).toLowerCase() : "Success";

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplicaBySchdeule(statusType, scheduleId);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");
				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				System.out.println("customers" + customers.get("customerName"));

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public CustomerOrderReplica getCustomerOrderReplicaByCartId(String cartId) {

		CustomerOrderReplica CustomerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(cartId,
				currentUser.getContactNumber());

		ObjectMapper objectMapper = new ObjectMapper();
		try {

			// convert JSON string to Map
			Map<String, Object> customerOrderReplicaMap = objectMapper
					.readValue(CustomerOrderReplica.getCustomerOrderDetails(), Map.class);

			Object customerOrder = customerOrderReplicaMap.get("customerOrder");
			Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

			Object quanityList = items.get("quantity");
			Map customers = customerDetailsDao.getByContactNumberAndApartment(CustomerOrderReplica.getContactNumber(),
					CustomerOrderReplica.getApartmentId());

			System.out.println("customers" + customers.get("customerName"));

			// Apartments apartments =
			// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
			CustomerOrderReplica.setApartmentName(
					customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

			CustomerOrderReplica.setCustomerDetails(customers);

			CustomerOrderReplica.setCustomerOrder(customerOrder);
			CustomerOrderReplica.setQuatityList(quanityList);

		} catch (Exception e) {
			e.printStackTrace();
		}

		return CustomerOrderReplica;

	}

	@Override
	public Map createCustomerOrderReplica(CustomerOrderReplicaRequest customerOrderReplicaRequest, String contactNumber,
			Integer aparmentId) {

		if (customerOrderReplicaRequest.getRazorPayRequest() != null) {

//			Map razorPay = consumerService.createRazorPayOrder(customerOrderReplicaRequest.getRazorPayRequest());
//			customerOrderReplicaRequest.setOrderId(razorPay.get("order") != null ? (String)((RazorPay) razorPay.get("order")).getId() : null);	
//	
//			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);
//
//			razorPay.put("cartId", customerOrderReplicaRequest.getCartId());

			Map customerOrderReplicaMap = new HashMap<>();

			Map orderId = new HashMap<>();
			String transactionId = getMerchantTransactionId();
			orderId.put("id", transactionId);

			customerOrderReplicaMap.put("order", orderId);

			customerOrderReplicaRequest.setOrderId(transactionId);
			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);

			customerOrderReplicaMap.put("cartId", customerOrderReplicaRequest.getCartId());

			try {
				customerOrderReplicaMap.put("phonePeResponse",
						phonepeServiceImpl.initiatePhonepePayment(transactionId,
								Integer.valueOf(customerOrderReplicaRequest.getRazorPayRequest().getAmount()),
								contactNumber, customerOrderReplicaRequest.getRedirectUrl(), customerOrderReplicaRequest.getCallBackUrl()));

			} catch (Exception e) {
				e.printStackTrace();
				customerOrderReplicaMap.put("phonePeResponse", new HashedMap<>());
			}

			return customerOrderReplicaMap;

		} else {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
					"paymentDetails transcation Details are mandatory");
		}

	}

	private static String getMerchantTransactionId() {

		return "OD_" + MerchantTransactionIdGenerator.getRandomString();
	}


	@Override
	public List<CustomerOrderReplica> getCustomerOrderByMoblieNo(String contactNumber, Integer aid) {

	    Schedule latestSchedule = customerOrderReplicaDoa.getlatestschedule();

	    if (latestSchedule != null && latestSchedule.getCreationTimestamp() != null) {
	        if (latestSchedule.getStatus().equals(UserStatus.ACTIVE)) {
	            Customers customer = customerDetailsDao.getByContactNoAndApartment(contactNumber, aid);

	            if (customer != null) { // Ensure the customer exists
	                List<CustomerOrder> customerOrderList = customerOrderReplicaDoa.getListCustomerOrderByCustomerId(customer.getCtId());

	                double totalOrderAmount = 0.0;

	                if (customerOrderList != null && !customerOrderList.isEmpty()) {
	                    for (CustomerOrder customerOrder : customerOrderList) {
	                        Double orderAmount = customerOrder.getAmount();
	                        if (orderAmount != null) {
	                            totalOrderAmount += orderAmount;
	                            if(totalOrderAmount>200) {
	                            	totalOrderAmount+= customerOrder.getDelivaryCharges();
	                            }
	                            else{
	                            	
	                            }(totalOrderAmount<200){
	                            	totalOrderAmount-= customerOrder.getDelivaryCharges();
	                            }
	                        }
	                    }

	                    // Define the minimum order amount for applying delivery charges
	                    double minimumOrderAmount = 200.0;

	                    if (totalOrderAmount < minimumOrderAmount) {
	                        System.out.println("Delivery Charges will be applicable");
	                    } else {
	                        // No delivery charges applicable
	                        System.out.println("No Delivery charges applicable");
	                    }

	                    List<CustomerOrderReplica> customerOrderReplicas = new ArrayList<>();
	                    return customerOrderReplicas;
	                } else {
	                    return Collections.emptyList();
	                }
	            } else {
	                return null; // or an appropriate value
	            }
	        } else {
	            // Handle the case when the latest schedule is not active
	            return null; // or an appropriate value
	        }
	    } else {
	        // Handle the case when there is no latest schedule or its creation timestamp is null
	        return null; // or an appropriate value
	    }
	}

}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4035)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3635)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-09-21 15:34:47.468
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4035)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3635)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-09-21 15:34:47.469
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4035)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3635)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-21 15:34:47.518
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.xyram.daydrop.serviceimpl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.transaction.Transactional;

import org.apache.commons.collections4.map.HashedMap;
import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.server.ResponseStatusException;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.xyram.daydrop.admin.model.CurrentUser;
import com.xyram.daydrop.basemodel.Base64Wrapper;
import com.xyram.daydrop.basemodel.MerchantTransactionIdGenerator;
import com.xyram.daydrop.basemodel.PhonepeSerializer;
import com.xyram.daydrop.dao.ApartmentDao;
import com.xyram.daydrop.dao.CustomerDetailsDao;
import com.xyram.daydrop.dao.CustomerOrderDao;
import com.xyram.daydrop.dao.CustomerOrderReplicaDoa;
import com.xyram.daydrop.dao.SheduleDao;
import com.xyram.daydrop.enumtypes.UserStatus;
import com.xyram.daydrop.model.Apartments;
import com.xyram.daydrop.model.CustomerOrder;
import com.xyram.daydrop.model.CustomerOrderReplica;
import com.xyram.daydrop.model.Customers;
import com.xyram.daydrop.model.Schedule;
import com.xyram.daydrop.modelMapper.PaymentInstrument;
import com.xyram.daydrop.modelMapper.PhonePePayModel;
import com.xyram.daydrop.request.CustomerOrderReplicaRequest;
import com.xyram.daydrop.response.RazorPayRequest;
import com.xyram.daydrop.service.CustomerOrderPriceService;
import com.xyram.daydrop.service.CustomerOrderReplicaService;
import com.xyram.daydrop.util.HashEncoder;
import com.xyram.daydrop.util.RazorPay;
import com.xyram.daydrop.service.ConsumerService;

@Transactional
@Service
public class CustomerOrderReplicaServiceImpl implements CustomerOrderReplicaService {

	@Autowired
	CustomerOrderReplicaDoa customerOrderReplicaDoa;

	@Autowired
	ApartmentDao apartmentDao;

	@Autowired
	SheduleDao scheduleDao;

	@Autowired
	CustomerDetailsDao customerDetailsDao;

	@Autowired
	ConsumerService consumerService;

	@Autowired
	CurrentUser currentUser;

	@Autowired
	PhonepeServiceImpl phonepeServiceImpl;

	@Value("${merchant_id}")
	private String merchantId;

	@Value("${salt_key}")
	private String saltKey;

	@Value("${salt_index}")
	private String saltIndex;

	@Override
	public Map createCustomerOrderReplicaService(CustomerOrderReplicaRequest customerOrderReplicaRequest,
			String contactNumber, Integer aparmentId)

	{

		Map response = new HashedMap<>();

		response.put("message", "success");
		CustomerOrderReplica customerOrderReplica = null;

		if (customerOrderReplicaRequest.getCartId() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "cartId is mandatory ");
		}
		long razorPayCount = 0;
		if (customerOrderReplicaRequest.getOrderId() != null) {

			razorPayCount = customerOrderReplicaDoa.getRazorPayExistByCartId(customerOrderReplicaRequest.getOrderId());
		}

		if (customerOrderReplicaRequest.getCustomerDetails() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Order Details  is mandatory ");
		}

		customerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(customerOrderReplicaRequest.getCartId(),
				contactNumber);

		if (customerOrderReplica != null) {
			customerOrderReplica.setCartId(customerOrderReplica.getCartId());

			if (customerOrderReplica.isOrdered()) {
				throw new ResponseStatusException(HttpStatus.CONFLICT, "Your Order is Placed With cart Details");
			}

//			if (razorPayCount >= 1 && !(customerOrderReplica.getRazorPayOrderId() != null
//					&& customerOrderReplica.getRazorPayOrderId().equals(customerOrderReplicaRequest.getOrderId()))) {
//				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
//			}

			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);

			customerOrderReplica.setAttempts(customerOrderReplica.getAttempts() + 1);
			customerOrderReplica.setUpdatedTime(new Date());

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		} else {

			customerOrderReplica = new CustomerOrderReplica();
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);
			customerOrderReplica.setCartId(customerOrderReplicaRequest.getCartId());
			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());

			if (razorPayCount > 0) {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
			}

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			Schedule schedule = scheduleDao.getlatestScheduleCustomers();

			if (schedule != null) {

				try {
					customerOrderReplica.setSchedule(schedule.getsId() != null ? schedule.getsId().toString() : null);
				} catch (Exception e) {
					e.printStackTrace();
				}
			} else {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
						"Sorry We Are Not Accepting Any Order Right now");

			}

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		}

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicas(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String schedule = null;

		Map filter = request.containsKey("filters") ? (Map) request.get("filters") : null;
		if (filter != null) {
			statusType = filter.containsKey("statusType") ? ((String) filter.get("statusType")).toLowerCase() : null;
			searchQuery = filter.containsKey("searchQuery") ? ((String) filter.get("searchQuery")).toLowerCase() : null;
			schedule = filter.containsKey("schedule") ? (String.valueOf(filter.get("schedule"))) : null;

		}

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplica(searchQuery, statusType, schedule);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");

				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setStreetName(
						customers.get("streetName") != null ? (String) customers.get("streetName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicasBySchedule(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String scheduleId = null;

		Schedule schedule = scheduleDao.getlatestScheduleCustomers();

		if (schedule != null) {

			try {
				scheduleId = schedule.getsId() != null ? schedule.getsId().toString() : null;
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

		statusType = request.containsKey("statusType") ? ((String) request.get("statusType")).toLowerCase() : "Success";

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplicaBySchdeule(statusType, scheduleId);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");
				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				System.out.println("customers" + customers.get("customerName"));

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public CustomerOrderReplica getCustomerOrderReplicaByCartId(String cartId) {

		CustomerOrderReplica CustomerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(cartId,
				currentUser.getContactNumber());

		ObjectMapper objectMapper = new ObjectMapper();
		try {

			// convert JSON string to Map
			Map<String, Object> customerOrderReplicaMap = objectMapper
					.readValue(CustomerOrderReplica.getCustomerOrderDetails(), Map.class);

			Object customerOrder = customerOrderReplicaMap.get("customerOrder");
			Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

			Object quanityList = items.get("quantity");
			Map customers = customerDetailsDao.getByContactNumberAndApartment(CustomerOrderReplica.getContactNumber(),
					CustomerOrderReplica.getApartmentId());

			System.out.println("customers" + customers.get("customerName"));

			// Apartments apartments =
			// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
			CustomerOrderReplica.setApartmentName(
					customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

			CustomerOrderReplica.setCustomerDetails(customers);

			CustomerOrderReplica.setCustomerOrder(customerOrder);
			CustomerOrderReplica.setQuatityList(quanityList);

		} catch (Exception e) {
			e.printStackTrace();
		}

		return CustomerOrderReplica;

	}

	@Override
	public Map createCustomerOrderReplica(CustomerOrderReplicaRequest customerOrderReplicaRequest, String contactNumber,
			Integer aparmentId) {

		if (customerOrderReplicaRequest.getRazorPayRequest() != null) {

//			Map razorPay = consumerService.createRazorPayOrder(customerOrderReplicaRequest.getRazorPayRequest());
//			customerOrderReplicaRequest.setOrderId(razorPay.get("order") != null ? (String)((RazorPay) razorPay.get("order")).getId() : null);	
//	
//			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);
//
//			razorPay.put("cartId", customerOrderReplicaRequest.getCartId());

			Map customerOrderReplicaMap = new HashMap<>();

			Map orderId = new HashMap<>();
			String transactionId = getMerchantTransactionId();
			orderId.put("id", transactionId);

			customerOrderReplicaMap.put("order", orderId);

			customerOrderReplicaRequest.setOrderId(transactionId);
			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);

			customerOrderReplicaMap.put("cartId", customerOrderReplicaRequest.getCartId());

			try {
				customerOrderReplicaMap.put("phonePeResponse",
						phonepeServiceImpl.initiatePhonepePayment(transactionId,
								Integer.valueOf(customerOrderReplicaRequest.getRazorPayRequest().getAmount()),
								contactNumber, customerOrderReplicaRequest.getRedirectUrl(), customerOrderReplicaRequest.getCallBackUrl()));

			} catch (Exception e) {
				e.printStackTrace();
				customerOrderReplicaMap.put("phonePeResponse", new HashedMap<>());
			}

			return customerOrderReplicaMap;

		} else {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
					"paymentDetails transcation Details are mandatory");
		}

	}

	private static String getMerchantTransactionId() {

		return "OD_" + MerchantTransactionIdGenerator.getRandomString();
	}


	@Override
	public List<CustomerOrderReplica> getCustomerOrderByMoblieNo(String contactNumber, Integer aid) {

	    Schedule latestSchedule = customerOrderReplicaDoa.getlatestschedule();

	    if (latestSchedule != null && latestSchedule.getCreationTimestamp() != null) {
	        if (latestSchedule.getStatus().equals(UserStatus.ACTIVE)) {
	            Customers customer = customerDetailsDao.getByContactNoAndApartment(contactNumber, aid);

	            if (customer != null) { // Ensure the customer exists
	                List<CustomerOrder> customerOrderList = customerOrderReplicaDoa.getListCustomerOrderByCustomerId(customer.getCtId());

	                double totalOrderAmount = 0.0;

	                if (customerOrderList != null && !customerOrderList.isEmpty()) {
	                    for (CustomerOrder customerOrder : customerOrderList) {
	                        Double orderAmount = customerOrder.getAmount();
	                        if (orderAmount != null) {
	                            totalOrderAmount += orderAmount;
	                            if(totalOrderAmount>200) {
	                            	totalOrderAmount+= customerOrder.getDelivaryCharges();
	                            }
	                            else{
	                            	
	                            }(totalOrderAmount<200){
	                            	totalOrderAmount-= customerOrder.getDelivaryCharges();
	                            }
	                        }
	                    }

	                    // Define the minimum order amount for applying delivery charges
	                    double minimumOrderAmount = 200.0;

	                    if (totalOrderAmount < minimumOrderAmount) {
	                        System.out.println("Delivery Charges will be applicable");
	                    } else {
	                        // No delivery charges applicable
	                        System.out.println("No Delivery charges applicable");
	                    }

	                    List<CustomerOrderReplica> customerOrderReplicas = new ArrayList<>();
	                    return customerOrderReplicas;
	                } else {
	                    return Collections.emptyList();
	                }
	            } else {
	                return null; // or an appropriate value
	            }
	        } else {
	            // Handle the case when the latest schedule is not active
	            return null; // or an appropriate value
	        }
	    } else {
	        // Handle the case when there is no latest schedule or its creation timestamp is null
	        return null; // or an appropriate value
	    }
	}

}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.internal.core.manipulation.dom.ASTResolving.createQuickFixAST(ASTResolving.java:1052)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:131)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4035)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3635)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.ui 4 0 2023-09-21 15:34:47.520
!MESSAGE Unhandled event loop exception
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.internal.core.manipulation.dom.ASTResolving.createQuickFixAST(ASTResolving.java:1052)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:131)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:101)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:79)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:304)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:190)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1151)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:884)
	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:237)
	at org.eclipse.jface.text.TextViewerHoverManager.lambda$3(TextViewerHoverManager.java:227)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4035)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3635)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-21 15:34:48.461
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.xyram.daydrop.serviceimpl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.transaction.Transactional;

import org.apache.commons.collections4.map.HashedMap;
import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.server.ResponseStatusException;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.xyram.daydrop.admin.model.CurrentUser;
import com.xyram.daydrop.basemodel.Base64Wrapper;
import com.xyram.daydrop.basemodel.MerchantTransactionIdGenerator;
import com.xyram.daydrop.basemodel.PhonepeSerializer;
import com.xyram.daydrop.dao.ApartmentDao;
import com.xyram.daydrop.dao.CustomerDetailsDao;
import com.xyram.daydrop.dao.CustomerOrderDao;
import com.xyram.daydrop.dao.CustomerOrderReplicaDoa;
import com.xyram.daydrop.dao.SheduleDao;
import com.xyram.daydrop.enumtypes.UserStatus;
import com.xyram.daydrop.model.Apartments;
import com.xyram.daydrop.model.CustomerOrder;
import com.xyram.daydrop.model.CustomerOrderReplica;
import com.xyram.daydrop.model.Customers;
import com.xyram.daydrop.model.Schedule;
import com.xyram.daydrop.modelMapper.PaymentInstrument;
import com.xyram.daydrop.modelMapper.PhonePePayModel;
import com.xyram.daydrop.request.CustomerOrderReplicaRequest;
import com.xyram.daydrop.response.RazorPayRequest;
import com.xyram.daydrop.service.CustomerOrderPriceService;
import com.xyram.daydrop.service.CustomerOrderReplicaService;
import com.xyram.daydrop.util.HashEncoder;
import com.xyram.daydrop.util.RazorPay;
import com.xyram.daydrop.service.ConsumerService;

@Transactional
@Service
public class CustomerOrderReplicaServiceImpl implements CustomerOrderReplicaService {

	@Autowired
	CustomerOrderReplicaDoa customerOrderReplicaDoa;

	@Autowired
	ApartmentDao apartmentDao;

	@Autowired
	SheduleDao scheduleDao;

	@Autowired
	CustomerDetailsDao customerDetailsDao;

	@Autowired
	ConsumerService consumerService;

	@Autowired
	CurrentUser currentUser;

	@Autowired
	PhonepeServiceImpl phonepeServiceImpl;

	@Value("${merchant_id}")
	private String merchantId;

	@Value("${salt_key}")
	private String saltKey;

	@Value("${salt_index}")
	private String saltIndex;

	@Override
	public Map createCustomerOrderReplicaService(CustomerOrderReplicaRequest customerOrderReplicaRequest,
			String contactNumber, Integer aparmentId)

	{

		Map response = new HashedMap<>();

		response.put("message", "success");
		CustomerOrderReplica customerOrderReplica = null;

		if (customerOrderReplicaRequest.getCartId() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "cartId is mandatory ");
		}
		long razorPayCount = 0;
		if (customerOrderReplicaRequest.getOrderId() != null) {

			razorPayCount = customerOrderReplicaDoa.getRazorPayExistByCartId(customerOrderReplicaRequest.getOrderId());
		}

		if (customerOrderReplicaRequest.getCustomerDetails() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Order Details  is mandatory ");
		}

		customerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(customerOrderReplicaRequest.getCartId(),
				contactNumber);

		if (customerOrderReplica != null) {
			customerOrderReplica.setCartId(customerOrderReplica.getCartId());

			if (customerOrderReplica.isOrdered()) {
				throw new ResponseStatusException(HttpStatus.CONFLICT, "Your Order is Placed With cart Details");
			}

//			if (razorPayCount >= 1 && !(customerOrderReplica.getRazorPayOrderId() != null
//					&& customerOrderReplica.getRazorPayOrderId().equals(customerOrderReplicaRequest.getOrderId()))) {
//				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
//			}

			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);

			customerOrderReplica.setAttempts(customerOrderReplica.getAttempts() + 1);
			customerOrderReplica.setUpdatedTime(new Date());

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		} else {

			customerOrderReplica = new CustomerOrderReplica();
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);
			customerOrderReplica.setCartId(customerOrderReplicaRequest.getCartId());
			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());

			if (razorPayCount > 0) {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
			}

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			Schedule schedule = scheduleDao.getlatestScheduleCustomers();

			if (schedule != null) {

				try {
					customerOrderReplica.setSchedule(schedule.getsId() != null ? schedule.getsId().toString() : null);
				} catch (Exception e) {
					e.printStackTrace();
				}
			} else {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
						"Sorry We Are Not Accepting Any Order Right now");

			}

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		}

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicas(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String schedule = null;

		Map filter = request.containsKey("filters") ? (Map) request.get("filters") : null;
		if (filter != null) {
			statusType = filter.containsKey("statusType") ? ((String) filter.get("statusType")).toLowerCase() : null;
			searchQuery = filter.containsKey("searchQuery") ? ((String) filter.get("searchQuery")).toLowerCase() : null;
			schedule = filter.containsKey("schedule") ? (String.valueOf(filter.get("schedule"))) : null;

		}

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplica(searchQuery, statusType, schedule);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");

				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setStreetName(
						customers.get("streetName") != null ? (String) customers.get("streetName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicasBySchedule(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String scheduleId = null;

		Schedule schedule = scheduleDao.getlatestScheduleCustomers();

		if (schedule != null) {

			try {
				scheduleId = schedule.getsId() != null ? schedule.getsId().toString() : null;
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

		statusType = request.containsKey("statusType") ? ((String) request.get("statusType")).toLowerCase() : "Success";

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplicaBySchdeule(statusType, scheduleId);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");
				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				System.out.println("customers" + customers.get("customerName"));

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public CustomerOrderReplica getCustomerOrderReplicaByCartId(String cartId) {

		CustomerOrderReplica CustomerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(cartId,
				currentUser.getContactNumber());

		ObjectMapper objectMapper = new ObjectMapper();
		try {

			// convert JSON string to Map
			Map<String, Object> customerOrderReplicaMap = objectMapper
					.readValue(CustomerOrderReplica.getCustomerOrderDetails(), Map.class);

			Object customerOrder = customerOrderReplicaMap.get("customerOrder");
			Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

			Object quanityList = items.get("quantity");
			Map customers = customerDetailsDao.getByContactNumberAndApartment(CustomerOrderReplica.getContactNumber(),
					CustomerOrderReplica.getApartmentId());

			System.out.println("customers" + customers.get("customerName"));

			// Apartments apartments =
			// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
			CustomerOrderReplica.setApartmentName(
					customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

			CustomerOrderReplica.setCustomerDetails(customers);

			CustomerOrderReplica.setCustomerOrder(customerOrder);
			CustomerOrderReplica.setQuatityList(quanityList);

		} catch (Exception e) {
			e.printStackTrace();
		}

		return CustomerOrderReplica;

	}

	@Override
	public Map createCustomerOrderReplica(CustomerOrderReplicaRequest customerOrderReplicaRequest, String contactNumber,
			Integer aparmentId) {

		if (customerOrderReplicaRequest.getRazorPayRequest() != null) {

//			Map razorPay = consumerService.createRazorPayOrder(customerOrderReplicaRequest.getRazorPayRequest());
//			customerOrderReplicaRequest.setOrderId(razorPay.get("order") != null ? (String)((RazorPay) razorPay.get("order")).getId() : null);	
//	
//			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);
//
//			razorPay.put("cartId", customerOrderReplicaRequest.getCartId());

			Map customerOrderReplicaMap = new HashMap<>();

			Map orderId = new HashMap<>();
			String transactionId = getMerchantTransactionId();
			orderId.put("id", transactionId);

			customerOrderReplicaMap.put("order", orderId);

			customerOrderReplicaRequest.setOrderId(transactionId);
			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);

			customerOrderReplicaMap.put("cartId", customerOrderReplicaRequest.getCartId());

			try {
				customerOrderReplicaMap.put("phonePeResponse",
						phonepeServiceImpl.initiatePhonepePayment(transactionId,
								Integer.valueOf(customerOrderReplicaRequest.getRazorPayRequest().getAmount()),
								contactNumber, customerOrderReplicaRequest.getRedirectUrl(), customerOrderReplicaRequest.getCallBackUrl()));

			} catch (Exception e) {
				e.printStackTrace();
				customerOrderReplicaMap.put("phonePeResponse", new HashedMap<>());
			}

			return customerOrderReplicaMap;

		} else {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
					"paymentDetails transcation Details are mandatory");
		}

	}

	private static String getMerchantTransactionId() {

		return "OD_" + MerchantTransactionIdGenerator.getRandomString();
	}


	@Override
	public List<CustomerOrderReplica> getCustomerOrderByMoblieNo(String contactNumber, Integer aid) {

	    Schedule latestSchedule = customerOrderReplicaDoa.getlatestschedule();

	    if (latestSchedule != null && latestSchedule.getCreationTimestamp() != null) {
	        if (latestSchedule.getStatus().equals(UserStatus.ACTIVE)) {
	            Customers customer = customerDetailsDao.getByContactNoAndApartment(contactNumber, aid);

	            if (customer != null) { // Ensure the customer exists
	                List<CustomerOrder> customerOrderList = customerOrderReplicaDoa.getListCustomerOrderByCustomerId(customer.getCtId());

	                double totalOrderAmount = 0.0;

	                if (customerOrderList != null && !customerOrderList.isEmpty()) {
	                    for (CustomerOrder customerOrder : customerOrderList) {
	                        Double orderAmount = customerOrder.getAmount();
	                        if (orderAmount != null) {
	                            totalOrderAmount += orderAmount;
	                            if(totalOrderAmount>200) {
	                            	totalOrderAmount+= customerOrder.getDelivaryCharges();
	                            }
	                            else{
	                            	
	                            }(totalOrderAmount<200){
	                            	totalOrderAmount-= customerOrder.getDelivaryCharges();
	                            }
	                        }
	                    }

	                    // Define the minimum order amount for applying delivery charges
	                    double minimumOrderAmount = 200.0;

	                    if (totalOrderAmount < minimumOrderAmount) {
	                        System.out.println("Delivery Charges will be applicable");
	                    } else {
	                        // No delivery charges applicable
	                        System.out.println("No Delivery charges applicable");
	                    }

	                    List<CustomerOrderReplica> customerOrderReplicas = new ArrayList<>();
	                    return customerOrderReplicas;
	                } else {
	                    return Collections.emptyList();
	                }
	            } else {
	                return null; // or an appropriate value
	            }
	        } else {
	            // Handle the case when the latest schedule is not active
	            return null; // or an appropriate value
	        }
	    } else {
	        // Handle the case when there is no latest schedule or its creation timestamp is null
	        return null; // or an appropriate value
	    }
	}

}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-09-21 15:34:48.464
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-09-21 15:34:48.465
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-21 15:34:49.045
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.xyram.daydrop.serviceimpl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.transaction.Transactional;

import org.apache.commons.collections4.map.HashedMap;
import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.server.ResponseStatusException;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.xyram.daydrop.admin.model.CurrentUser;
import com.xyram.daydrop.basemodel.Base64Wrapper;
import com.xyram.daydrop.basemodel.MerchantTransactionIdGenerator;
import com.xyram.daydrop.basemodel.PhonepeSerializer;
import com.xyram.daydrop.dao.ApartmentDao;
import com.xyram.daydrop.dao.CustomerDetailsDao;
import com.xyram.daydrop.dao.CustomerOrderDao;
import com.xyram.daydrop.dao.CustomerOrderReplicaDoa;
import com.xyram.daydrop.dao.SheduleDao;
import com.xyram.daydrop.enumtypes.UserStatus;
import com.xyram.daydrop.model.Apartments;
import com.xyram.daydrop.model.CustomerOrder;
import com.xyram.daydrop.model.CustomerOrderReplica;
import com.xyram.daydrop.model.Customers;
import com.xyram.daydrop.model.Schedule;
import com.xyram.daydrop.modelMapper.PaymentInstrument;
import com.xyram.daydrop.modelMapper.PhonePePayModel;
import com.xyram.daydrop.request.CustomerOrderReplicaRequest;
import com.xyram.daydrop.response.RazorPayRequest;
import com.xyram.daydrop.service.CustomerOrderPriceService;
import com.xyram.daydrop.service.CustomerOrderReplicaService;
import com.xyram.daydrop.util.HashEncoder;
import com.xyram.daydrop.util.RazorPay;
import com.xyram.daydrop.service.ConsumerService;

@Transactional
@Service
public class CustomerOrderReplicaServiceImpl implements CustomerOrderReplicaService {

	@Autowired
	CustomerOrderReplicaDoa customerOrderReplicaDoa;

	@Autowired
	ApartmentDao apartmentDao;

	@Autowired
	SheduleDao scheduleDao;

	@Autowired
	CustomerDetailsDao customerDetailsDao;

	@Autowired
	ConsumerService consumerService;

	@Autowired
	CurrentUser currentUser;

	@Autowired
	PhonepeServiceImpl phonepeServiceImpl;

	@Value("${merchant_id}")
	private String merchantId;

	@Value("${salt_key}")
	private String saltKey;

	@Value("${salt_index}")
	private String saltIndex;

	@Override
	public Map createCustomerOrderReplicaService(CustomerOrderReplicaRequest customerOrderReplicaRequest,
			String contactNumber, Integer aparmentId)

	{

		Map response = new HashedMap<>();

		response.put("message", "success");
		CustomerOrderReplica customerOrderReplica = null;

		if (customerOrderReplicaRequest.getCartId() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "cartId is mandatory ");
		}
		long razorPayCount = 0;
		if (customerOrderReplicaRequest.getOrderId() != null) {

			razorPayCount = customerOrderReplicaDoa.getRazorPayExistByCartId(customerOrderReplicaRequest.getOrderId());
		}

		if (customerOrderReplicaRequest.getCustomerDetails() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Order Details  is mandatory ");
		}

		customerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(customerOrderReplicaRequest.getCartId(),
				contactNumber);

		if (customerOrderReplica != null) {
			customerOrderReplica.setCartId(customerOrderReplica.getCartId());

			if (customerOrderReplica.isOrdered()) {
				throw new ResponseStatusException(HttpStatus.CONFLICT, "Your Order is Placed With cart Details");
			}

//			if (razorPayCount >= 1 && !(customerOrderReplica.getRazorPayOrderId() != null
//					&& customerOrderReplica.getRazorPayOrderId().equals(customerOrderReplicaRequest.getOrderId()))) {
//				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
//			}

			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);

			customerOrderReplica.setAttempts(customerOrderReplica.getAttempts() + 1);
			customerOrderReplica.setUpdatedTime(new Date());

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		} else {

			customerOrderReplica = new CustomerOrderReplica();
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);
			customerOrderReplica.setCartId(customerOrderReplicaRequest.getCartId());
			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());

			if (razorPayCount > 0) {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
			}

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			Schedule schedule = scheduleDao.getlatestScheduleCustomers();

			if (schedule != null) {

				try {
					customerOrderReplica.setSchedule(schedule.getsId() != null ? schedule.getsId().toString() : null);
				} catch (Exception e) {
					e.printStackTrace();
				}
			} else {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
						"Sorry We Are Not Accepting Any Order Right now");

			}

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		}

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicas(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String schedule = null;

		Map filter = request.containsKey("filters") ? (Map) request.get("filters") : null;
		if (filter != null) {
			statusType = filter.containsKey("statusType") ? ((String) filter.get("statusType")).toLowerCase() : null;
			searchQuery = filter.containsKey("searchQuery") ? ((String) filter.get("searchQuery")).toLowerCase() : null;
			schedule = filter.containsKey("schedule") ? (String.valueOf(filter.get("schedule"))) : null;

		}

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplica(searchQuery, statusType, schedule);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");

				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setStreetName(
						customers.get("streetName") != null ? (String) customers.get("streetName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicasBySchedule(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String scheduleId = null;

		Schedule schedule = scheduleDao.getlatestScheduleCustomers();

		if (schedule != null) {

			try {
				scheduleId = schedule.getsId() != null ? schedule.getsId().toString() : null;
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

		statusType = request.containsKey("statusType") ? ((String) request.get("statusType")).toLowerCase() : "Success";

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplicaBySchdeule(statusType, scheduleId);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");
				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				System.out.println("customers" + customers.get("customerName"));

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public CustomerOrderReplica getCustomerOrderReplicaByCartId(String cartId) {

		CustomerOrderReplica CustomerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(cartId,
				currentUser.getContactNumber());

		ObjectMapper objectMapper = new ObjectMapper();
		try {

			// convert JSON string to Map
			Map<String, Object> customerOrderReplicaMap = objectMapper
					.readValue(CustomerOrderReplica.getCustomerOrderDetails(), Map.class);

			Object customerOrder = customerOrderReplicaMap.get("customerOrder");
			Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

			Object quanityList = items.get("quantity");
			Map customers = customerDetailsDao.getByContactNumberAndApartment(CustomerOrderReplica.getContactNumber(),
					CustomerOrderReplica.getApartmentId());

			System.out.println("customers" + customers.get("customerName"));

			// Apartments apartments =
			// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
			CustomerOrderReplica.setApartmentName(
					customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

			CustomerOrderReplica.setCustomerDetails(customers);

			CustomerOrderReplica.setCustomerOrder(customerOrder);
			CustomerOrderReplica.setQuatityList(quanityList);

		} catch (Exception e) {
			e.printStackTrace();
		}

		return CustomerOrderReplica;

	}

	@Override
	public Map createCustomerOrderReplica(CustomerOrderReplicaRequest customerOrderReplicaRequest, String contactNumber,
			Integer aparmentId) {

		if (customerOrderReplicaRequest.getRazorPayRequest() != null) {

//			Map razorPay = consumerService.createRazorPayOrder(customerOrderReplicaRequest.getRazorPayRequest());
//			customerOrderReplicaRequest.setOrderId(razorPay.get("order") != null ? (String)((RazorPay) razorPay.get("order")).getId() : null);	
//	
//			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);
//
//			razorPay.put("cartId", customerOrderReplicaRequest.getCartId());

			Map customerOrderReplicaMap = new HashMap<>();

			Map orderId = new HashMap<>();
			String transactionId = getMerchantTransactionId();
			orderId.put("id", transactionId);

			customerOrderReplicaMap.put("order", orderId);

			customerOrderReplicaRequest.setOrderId(transactionId);
			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);

			customerOrderReplicaMap.put("cartId", customerOrderReplicaRequest.getCartId());

			try {
				customerOrderReplicaMap.put("phonePeResponse",
						phonepeServiceImpl.initiatePhonepePayment(transactionId,
								Integer.valueOf(customerOrderReplicaRequest.getRazorPayRequest().getAmount()),
								contactNumber, customerOrderReplicaRequest.getRedirectUrl(), customerOrderReplicaRequest.getCallBackUrl()));

			} catch (Exception e) {
				e.printStackTrace();
				customerOrderReplicaMap.put("phonePeResponse", new HashedMap<>());
			}

			return customerOrderReplicaMap;

		} else {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
					"paymentDetails transcation Details are mandatory");
		}

	}

	private static String getMerchantTransactionId() {

		return "OD_" + MerchantTransactionIdGenerator.getRandomString();
	}


	@Override
	public List<CustomerOrderReplica> getCustomerOrderByMoblieNo(String contactNumber, Integer aid) {

	    Schedule latestSchedule = customerOrderReplicaDoa.getlatestschedule();

	    if (latestSchedule != null && latestSchedule.getCreationTimestamp() != null) {
	        if (latestSchedule.getStatus().equals(UserStatus.ACTIVE)) {
	            Customers customer = customerDetailsDao.getByContactNoAndApartment(contactNumber, aid);

	            if (customer != null) { // Ensure the customer exists
	                List<CustomerOrder> customerOrderList = customerOrderReplicaDoa.getListCustomerOrderByCustomerId(customer.getCtId());

	                double totalOrderAmount = 0.0;

	                if (customerOrderList != null && !customerOrderList.isEmpty()) {
	                    for (CustomerOrder customerOrder : customerOrderList) {
	                        Double orderAmount = customerOrder.getAmount();
	                        if (orderAmount != null) {
	                            totalOrderAmount += orderAmount;
	                            if(totalOrderAmount>200) {
	                            	totalOrderAmount+= customerOrder.getDelivaryCharges();
	                            }
	                            else{
	                            	
	                            }(totalOrderAmount<200){
	                            	totalOrderAmount-= customerOrder.getDelivaryCharges();
	                            }
	                        }
	                    }

	                    // Define the minimum order amount for applying delivery charges
	                    double minimumOrderAmount = 200.0;

	                    if (totalOrderAmount < minimumOrderAmount) {
	                        System.out.println("Delivery Charges will be applicable");
	                    } else {
	                        // No delivery charges applicable
	                        System.out.println("No Delivery charges applicable");
	                    }

	                    List<CustomerOrderReplica> customerOrderReplicas = new ArrayList<>();
	                    return customerOrderReplicas;
	                } else {
	                    return Collections.emptyList();
	                }
	            } else {
	                return null; // or an appropriate value
	            }
	        } else {
	            // Handle the case when the latest schedule is not active
	            return null; // or an appropriate value
	        }
	    } else {
	        // Handle the case when there is no latest schedule or its creation timestamp is null
	        return null; // or an appropriate value
	    }
	}

}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-09-21 15:34:49.046
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-09-21 15:34:49.048
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-21 15:34:49.672
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.xyram.daydrop.serviceimpl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.transaction.Transactional;

import org.apache.commons.collections4.map.HashedMap;
import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.server.ResponseStatusException;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.xyram.daydrop.admin.model.CurrentUser;
import com.xyram.daydrop.basemodel.Base64Wrapper;
import com.xyram.daydrop.basemodel.MerchantTransactionIdGenerator;
import com.xyram.daydrop.basemodel.PhonepeSerializer;
import com.xyram.daydrop.dao.ApartmentDao;
import com.xyram.daydrop.dao.CustomerDetailsDao;
import com.xyram.daydrop.dao.CustomerOrderDao;
import com.xyram.daydrop.dao.CustomerOrderReplicaDoa;
import com.xyram.daydrop.dao.SheduleDao;
import com.xyram.daydrop.enumtypes.UserStatus;
import com.xyram.daydrop.model.Apartments;
import com.xyram.daydrop.model.CustomerOrder;
import com.xyram.daydrop.model.CustomerOrderReplica;
import com.xyram.daydrop.model.Customers;
import com.xyram.daydrop.model.Schedule;
import com.xyram.daydrop.modelMapper.PaymentInstrument;
import com.xyram.daydrop.modelMapper.PhonePePayModel;
import com.xyram.daydrop.request.CustomerOrderReplicaRequest;
import com.xyram.daydrop.response.RazorPayRequest;
import com.xyram.daydrop.service.CustomerOrderPriceService;
import com.xyram.daydrop.service.CustomerOrderReplicaService;
import com.xyram.daydrop.util.HashEncoder;
import com.xyram.daydrop.util.RazorPay;
import com.xyram.daydrop.service.ConsumerService;

@Transactional
@Service
public class CustomerOrderReplicaServiceImpl implements CustomerOrderReplicaService {

	@Autowired
	CustomerOrderReplicaDoa customerOrderReplicaDoa;

	@Autowired
	ApartmentDao apartmentDao;

	@Autowired
	SheduleDao scheduleDao;

	@Autowired
	CustomerDetailsDao customerDetailsDao;

	@Autowired
	ConsumerService consumerService;

	@Autowired
	CurrentUser currentUser;

	@Autowired
	PhonepeServiceImpl phonepeServiceImpl;

	@Value("${merchant_id}")
	private String merchantId;

	@Value("${salt_key}")
	private String saltKey;

	@Value("${salt_index}")
	private String saltIndex;

	@Override
	public Map createCustomerOrderReplicaService(CustomerOrderReplicaRequest customerOrderReplicaRequest,
			String contactNumber, Integer aparmentId)

	{

		Map response = new HashedMap<>();

		response.put("message", "success");
		CustomerOrderReplica customerOrderReplica = null;

		if (customerOrderReplicaRequest.getCartId() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "cartId is mandatory ");
		}
		long razorPayCount = 0;
		if (customerOrderReplicaRequest.getOrderId() != null) {

			razorPayCount = customerOrderReplicaDoa.getRazorPayExistByCartId(customerOrderReplicaRequest.getOrderId());
		}

		if (customerOrderReplicaRequest.getCustomerDetails() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Order Details  is mandatory ");
		}

		customerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(customerOrderReplicaRequest.getCartId(),
				contactNumber);

		if (customerOrderReplica != null) {
			customerOrderReplica.setCartId(customerOrderReplica.getCartId());

			if (customerOrderReplica.isOrdered()) {
				throw new ResponseStatusException(HttpStatus.CONFLICT, "Your Order is Placed With cart Details");
			}

//			if (razorPayCount >= 1 && !(customerOrderReplica.getRazorPayOrderId() != null
//					&& customerOrderReplica.getRazorPayOrderId().equals(customerOrderReplicaRequest.getOrderId()))) {
//				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
//			}

			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);

			customerOrderReplica.setAttempts(customerOrderReplica.getAttempts() + 1);
			customerOrderReplica.setUpdatedTime(new Date());

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		} else {

			customerOrderReplica = new CustomerOrderReplica();
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);
			customerOrderReplica.setCartId(customerOrderReplicaRequest.getCartId());
			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());

			if (razorPayCount > 0) {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
			}

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			Schedule schedule = scheduleDao.getlatestScheduleCustomers();

			if (schedule != null) {

				try {
					customerOrderReplica.setSchedule(schedule.getsId() != null ? schedule.getsId().toString() : null);
				} catch (Exception e) {
					e.printStackTrace();
				}
			} else {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
						"Sorry We Are Not Accepting Any Order Right now");

			}

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		}

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicas(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String schedule = null;

		Map filter = request.containsKey("filters") ? (Map) request.get("filters") : null;
		if (filter != null) {
			statusType = filter.containsKey("statusType") ? ((String) filter.get("statusType")).toLowerCase() : null;
			searchQuery = filter.containsKey("searchQuery") ? ((String) filter.get("searchQuery")).toLowerCase() : null;
			schedule = filter.containsKey("schedule") ? (String.valueOf(filter.get("schedule"))) : null;

		}

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplica(searchQuery, statusType, schedule);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");

				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setStreetName(
						customers.get("streetName") != null ? (String) customers.get("streetName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicasBySchedule(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String scheduleId = null;

		Schedule schedule = scheduleDao.getlatestScheduleCustomers();

		if (schedule != null) {

			try {
				scheduleId = schedule.getsId() != null ? schedule.getsId().toString() : null;
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

		statusType = request.containsKey("statusType") ? ((String) request.get("statusType")).toLowerCase() : "Success";

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplicaBySchdeule(statusType, scheduleId);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");
				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				System.out.println("customers" + customers.get("customerName"));

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public CustomerOrderReplica getCustomerOrderReplicaByCartId(String cartId) {

		CustomerOrderReplica CustomerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(cartId,
				currentUser.getContactNumber());

		ObjectMapper objectMapper = new ObjectMapper();
		try {

			// convert JSON string to Map
			Map<String, Object> customerOrderReplicaMap = objectMapper
					.readValue(CustomerOrderReplica.getCustomerOrderDetails(), Map.class);

			Object customerOrder = customerOrderReplicaMap.get("customerOrder");
			Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

			Object quanityList = items.get("quantity");
			Map customers = customerDetailsDao.getByContactNumberAndApartment(CustomerOrderReplica.getContactNumber(),
					CustomerOrderReplica.getApartmentId());

			System.out.println("customers" + customers.get("customerName"));

			// Apartments apartments =
			// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
			CustomerOrderReplica.setApartmentName(
					customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

			CustomerOrderReplica.setCustomerDetails(customers);

			CustomerOrderReplica.setCustomerOrder(customerOrder);
			CustomerOrderReplica.setQuatityList(quanityList);

		} catch (Exception e) {
			e.printStackTrace();
		}

		return CustomerOrderReplica;

	}

	@Override
	public Map createCustomerOrderReplica(CustomerOrderReplicaRequest customerOrderReplicaRequest, String contactNumber,
			Integer aparmentId) {

		if (customerOrderReplicaRequest.getRazorPayRequest() != null) {

//			Map razorPay = consumerService.createRazorPayOrder(customerOrderReplicaRequest.getRazorPayRequest());
//			customerOrderReplicaRequest.setOrderId(razorPay.get("order") != null ? (String)((RazorPay) razorPay.get("order")).getId() : null);	
//	
//			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);
//
//			razorPay.put("cartId", customerOrderReplicaRequest.getCartId());

			Map customerOrderReplicaMap = new HashMap<>();

			Map orderId = new HashMap<>();
			String transactionId = getMerchantTransactionId();
			orderId.put("id", transactionId);

			customerOrderReplicaMap.put("order", orderId);

			customerOrderReplicaRequest.setOrderId(transactionId);
			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);

			customerOrderReplicaMap.put("cartId", customerOrderReplicaRequest.getCartId());

			try {
				customerOrderReplicaMap.put("phonePeResponse",
						phonepeServiceImpl.initiatePhonepePayment(transactionId,
								Integer.valueOf(customerOrderReplicaRequest.getRazorPayRequest().getAmount()),
								contactNumber, customerOrderReplicaRequest.getRedirectUrl(), customerOrderReplicaRequest.getCallBackUrl()));

			} catch (Exception e) {
				e.printStackTrace();
				customerOrderReplicaMap.put("phonePeResponse", new HashedMap<>());
			}

			return customerOrderReplicaMap;

		} else {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
					"paymentDetails transcation Details are mandatory");
		}

	}

	private static String getMerchantTransactionId() {

		return "OD_" + MerchantTransactionIdGenerator.getRandomString();
	}


	@Override
	public List<CustomerOrderReplica> getCustomerOrderByMoblieNo(String contactNumber, Integer aid) {

	    Schedule latestSchedule = customerOrderReplicaDoa.getlatestschedule();

	    if (latestSchedule != null && latestSchedule.getCreationTimestamp() != null) {
	        if (latestSchedule.getStatus().equals(UserStatus.ACTIVE)) {
	            Customers customer = customerDetailsDao.getByContactNoAndApartment(contactNumber, aid);

	            if (customer != null) { // Ensure the customer exists
	                List<CustomerOrder> customerOrderList = customerOrderReplicaDoa.getListCustomerOrderByCustomerId(customer.getCtId());

	                double totalOrderAmount = 0.0;

	                if (customerOrderList != null && !customerOrderList.isEmpty()) {
	                    for (CustomerOrder customerOrder : customerOrderList) {
	                        Double orderAmount = customerOrder.getAmount();
	                        if (orderAmount != null) {
	                            totalOrderAmount += orderAmount;
	                            if(totalOrderAmount>200) {
	                            	totalOrderAmount+= customerOrder.getDelivaryCharges();
	                            }
	                            else{
	                            	
	                            }(totalOrderAmount<200){
	                            	totalOrderAmount-= customerOrder.getDelivaryCharges();
	                            }
	                        }
	                    }

	                    // Define the minimum order amount for applying delivery charges
	                    double minimumOrderAmount = 200.0;

	                    if (totalOrderAmount < minimumOrderAmount) {
	                        System.out.println("Delivery Charges will be applicable");
	                    } else {
	                        // No delivery charges applicable
	                        System.out.println("No Delivery charges applicable");
	                    }

	                    List<CustomerOrderReplica> customerOrderReplicas = new ArrayList<>();
	                    return customerOrderReplicas;
	                } else {
	                    return Collections.emptyList();
	                }
	            } else {
	                return null; // or an appropriate value
	            }
	        } else {
	            // Handle the case when the latest schedule is not active
	            return null; // or an appropriate value
	        }
	    } else {
	        // Handle the case when there is no latest schedule or its creation timestamp is null
	        return null; // or an appropriate value
	    }
	}

}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.getClipboardData(ClipboardOperationAction.java:479)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.doCutCopyWithImportsOperation(ClipboardOperationAction.java:406)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.internalDoOperation(ClipboardOperationAction.java:365)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.run(ClipboardOperationAction.java:286)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:121)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:97)
	at jdk.internal.reflect.GeneratedMethodAccessor79.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:317)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:251)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:173)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:156)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:488)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:487)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:213)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:308)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:580)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:647)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:439)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:96)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1280)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1062)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1087)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1072)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1114)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1110)
	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1539)
	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4868)
	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:345)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4746)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5015)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3630)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-09-21 15:34:49.674
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.getClipboardData(ClipboardOperationAction.java:479)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.doCutCopyWithImportsOperation(ClipboardOperationAction.java:406)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.internalDoOperation(ClipboardOperationAction.java:365)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.run(ClipboardOperationAction.java:286)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:121)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:97)
	at jdk.internal.reflect.GeneratedMethodAccessor79.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:317)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:251)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:173)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:156)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:488)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:487)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:213)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:308)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:580)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:647)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:439)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:96)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1280)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1062)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1087)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1072)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1114)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1110)
	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1539)
	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4868)
	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:345)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4746)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5015)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3630)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-09-21 15:34:49.676
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.getClipboardData(ClipboardOperationAction.java:479)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.doCutCopyWithImportsOperation(ClipboardOperationAction.java:406)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.internalDoOperation(ClipboardOperationAction.java:365)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.run(ClipboardOperationAction.java:286)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:121)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:97)
	at jdk.internal.reflect.GeneratedMethodAccessor79.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:317)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:251)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:173)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:156)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:488)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:487)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:213)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:308)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:580)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:647)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:439)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:96)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1280)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1062)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1087)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1072)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1114)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1110)
	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1539)
	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4868)
	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:345)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4746)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5015)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3630)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-21 15:34:51.175
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.xyram.daydrop.serviceimpl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.transaction.Transactional;

import org.apache.commons.collections4.map.HashedMap;
import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.server.ResponseStatusException;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.xyram.daydrop.admin.model.CurrentUser;
import com.xyram.daydrop.basemodel.Base64Wrapper;
import com.xyram.daydrop.basemodel.MerchantTransactionIdGenerator;
import com.xyram.daydrop.basemodel.PhonepeSerializer;
import com.xyram.daydrop.dao.ApartmentDao;
import com.xyram.daydrop.dao.CustomerDetailsDao;
import com.xyram.daydrop.dao.CustomerOrderDao;
import com.xyram.daydrop.dao.CustomerOrderReplicaDoa;
import com.xyram.daydrop.dao.SheduleDao;
import com.xyram.daydrop.enumtypes.UserStatus;
import com.xyram.daydrop.model.Apartments;
import com.xyram.daydrop.model.CustomerOrder;
import com.xyram.daydrop.model.CustomerOrderReplica;
import com.xyram.daydrop.model.Customers;
import com.xyram.daydrop.model.Schedule;
import com.xyram.daydrop.modelMapper.PaymentInstrument;
import com.xyram.daydrop.modelMapper.PhonePePayModel;
import com.xyram.daydrop.request.CustomerOrderReplicaRequest;
import com.xyram.daydrop.response.RazorPayRequest;
import com.xyram.daydrop.service.CustomerOrderPriceService;
import com.xyram.daydrop.service.CustomerOrderReplicaService;
import com.xyram.daydrop.util.HashEncoder;
import com.xyram.daydrop.util.RazorPay;
import com.xyram.daydrop.service.ConsumerService;

@Transactional
@Service
public class CustomerOrderReplicaServiceImpl implements CustomerOrderReplicaService {

	@Autowired
	CustomerOrderReplicaDoa customerOrderReplicaDoa;

	@Autowired
	ApartmentDao apartmentDao;

	@Autowired
	SheduleDao scheduleDao;

	@Autowired
	CustomerDetailsDao customerDetailsDao;

	@Autowired
	ConsumerService consumerService;

	@Autowired
	CurrentUser currentUser;

	@Autowired
	PhonepeServiceImpl phonepeServiceImpl;

	@Value("${merchant_id}")
	private String merchantId;

	@Value("${salt_key}")
	private String saltKey;

	@Value("${salt_index}")
	private String saltIndex;

	@Override
	public Map createCustomerOrderReplicaService(CustomerOrderReplicaRequest customerOrderReplicaRequest,
			String contactNumber, Integer aparmentId)

	{

		Map response = new HashedMap<>();

		response.put("message", "success");
		CustomerOrderReplica customerOrderReplica = null;

		if (customerOrderReplicaRequest.getCartId() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "cartId is mandatory ");
		}
		long razorPayCount = 0;
		if (customerOrderReplicaRequest.getOrderId() != null) {

			razorPayCount = customerOrderReplicaDoa.getRazorPayExistByCartId(customerOrderReplicaRequest.getOrderId());
		}

		if (customerOrderReplicaRequest.getCustomerDetails() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Order Details  is mandatory ");
		}

		customerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(customerOrderReplicaRequest.getCartId(),
				contactNumber);

		if (customerOrderReplica != null) {
			customerOrderReplica.setCartId(customerOrderReplica.getCartId());

			if (customerOrderReplica.isOrdered()) {
				throw new ResponseStatusException(HttpStatus.CONFLICT, "Your Order is Placed With cart Details");
			}

//			if (razorPayCount >= 1 && !(customerOrderReplica.getRazorPayOrderId() != null
//					&& customerOrderReplica.getRazorPayOrderId().equals(customerOrderReplicaRequest.getOrderId()))) {
//				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
//			}

			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);

			customerOrderReplica.setAttempts(customerOrderReplica.getAttempts() + 1);
			customerOrderReplica.setUpdatedTime(new Date());

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		} else {

			customerOrderReplica = new CustomerOrderReplica();
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);
			customerOrderReplica.setCartId(customerOrderReplicaRequest.getCartId());
			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());

			if (razorPayCount > 0) {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
			}

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			Schedule schedule = scheduleDao.getlatestScheduleCustomers();

			if (schedule != null) {

				try {
					customerOrderReplica.setSchedule(schedule.getsId() != null ? schedule.getsId().toString() : null);
				} catch (Exception e) {
					e.printStackTrace();
				}
			} else {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
						"Sorry We Are Not Accepting Any Order Right now");

			}

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		}

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicas(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String schedule = null;

		Map filter = request.containsKey("filters") ? (Map) request.get("filters") : null;
		if (filter != null) {
			statusType = filter.containsKey("statusType") ? ((String) filter.get("statusType")).toLowerCase() : null;
			searchQuery = filter.containsKey("searchQuery") ? ((String) filter.get("searchQuery")).toLowerCase() : null;
			schedule = filter.containsKey("schedule") ? (String.valueOf(filter.get("schedule"))) : null;

		}

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplica(searchQuery, statusType, schedule);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");

				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setStreetName(
						customers.get("streetName") != null ? (String) customers.get("streetName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicasBySchedule(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String scheduleId = null;

		Schedule schedule = scheduleDao.getlatestScheduleCustomers();

		if (schedule != null) {

			try {
				scheduleId = schedule.getsId() != null ? schedule.getsId().toString() : null;
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

		statusType = request.containsKey("statusType") ? ((String) request.get("statusType")).toLowerCase() : "Success";

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplicaBySchdeule(statusType, scheduleId);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");
				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				System.out.println("customers" + customers.get("customerName"));

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public CustomerOrderReplica getCustomerOrderReplicaByCartId(String cartId) {

		CustomerOrderReplica CustomerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(cartId,
				currentUser.getContactNumber());

		ObjectMapper objectMapper = new ObjectMapper();
		try {

			// convert JSON string to Map
			Map<String, Object> customerOrderReplicaMap = objectMapper
					.readValue(CustomerOrderReplica.getCustomerOrderDetails(), Map.class);

			Object customerOrder = customerOrderReplicaMap.get("customerOrder");
			Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

			Object quanityList = items.get("quantity");
			Map customers = customerDetailsDao.getByContactNumberAndApartment(CustomerOrderReplica.getContactNumber(),
					CustomerOrderReplica.getApartmentId());

			System.out.println("customers" + customers.get("customerName"));

			// Apartments apartments =
			// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
			CustomerOrderReplica.setApartmentName(
					customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

			CustomerOrderReplica.setCustomerDetails(customers);

			CustomerOrderReplica.setCustomerOrder(customerOrder);
			CustomerOrderReplica.setQuatityList(quanityList);

		} catch (Exception e) {
			e.printStackTrace();
		}

		return CustomerOrderReplica;

	}

	@Override
	public Map createCustomerOrderReplica(CustomerOrderReplicaRequest customerOrderReplicaRequest, String contactNumber,
			Integer aparmentId) {

		if (customerOrderReplicaRequest.getRazorPayRequest() != null) {

//			Map razorPay = consumerService.createRazorPayOrder(customerOrderReplicaRequest.getRazorPayRequest());
//			customerOrderReplicaRequest.setOrderId(razorPay.get("order") != null ? (String)((RazorPay) razorPay.get("order")).getId() : null);	
//	
//			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);
//
//			razorPay.put("cartId", customerOrderReplicaRequest.getCartId());

			Map customerOrderReplicaMap = new HashMap<>();

			Map orderId = new HashMap<>();
			String transactionId = getMerchantTransactionId();
			orderId.put("id", transactionId);

			customerOrderReplicaMap.put("order", orderId);

			customerOrderReplicaRequest.setOrderId(transactionId);
			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);

			customerOrderReplicaMap.put("cartId", customerOrderReplicaRequest.getCartId());

			try {
				customerOrderReplicaMap.put("phonePeResponse",
						phonepeServiceImpl.initiatePhonepePayment(transactionId,
								Integer.valueOf(customerOrderReplicaRequest.getRazorPayRequest().getAmount()),
								contactNumber, customerOrderReplicaRequest.getRedirectUrl(), customerOrderReplicaRequest.getCallBackUrl()));

			} catch (Exception e) {
				e.printStackTrace();
				customerOrderReplicaMap.put("phonePeResponse", new HashedMap<>());
			}

			return customerOrderReplicaMap;

		} else {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
					"paymentDetails transcation Details are mandatory");
		}

	}

	private static String getMerchantTransactionId() {

		return "OD_" + MerchantTransactionIdGenerator.getRandomString();
	}


	@Override
	public List<CustomerOrderReplica> getCustomerOrderByMoblieNo(String contactNumber, Integer aid) {

	    Schedule latestSchedule = customerOrderReplicaDoa.getlatestschedule();

	    if (latestSchedule != null && latestSchedule.getCreationTimestamp() != null) {
	        if (latestSchedule.getStatus().equals(UserStatus.ACTIVE)) {
	            Customers customer = customerDetailsDao.getByContactNoAndApartment(contactNumber, aid);

	            if (customer != null) { // Ensure the customer exists
	                List<CustomerOrder> customerOrderList = customerOrderReplicaDoa.getListCustomerOrderByCustomerId(customer.getCtId());

	                double totalOrderAmount = 0.0;

	                if (customerOrderList != null && !customerOrderList.isEmpty()) {
	                    for (CustomerOrder customerOrder : customerOrderList) {
	                        Double orderAmount = customerOrder.getAmount();
	                        if (orderAmount != null) {
	                            totalOrderAmount += orderAmount;
	                            if(totalOrderAmount>200) {
	                            	totalOrderAmount+= customerOrder.getDelivaryCharges();
	                            }
	                            else{
	                            	(totalOrderAmount<200)
	                            }{
	                            	totalOrderAmount-= customerOrder.getDelivaryCharges();
	                            }
	                        }
	                    }

	                    // Define the minimum order amount for applying delivery charges
	                    double minimumOrderAmount = 200.0;

	                    if (totalOrderAmount < minimumOrderAmount) {
	                        System.out.println("Delivery Charges will be applicable");
	                    } else {
	                        // No delivery charges applicable
	                        System.out.println("No Delivery charges applicable");
	                    }

	                    List<CustomerOrderReplica> customerOrderReplicas = new ArrayList<>();
	                    return customerOrderReplicas;
	                } else {
	                    return Collections.emptyList();
	                }
	            } else {
	                return null; // or an appropriate value
	            }
	        } else {
	            // Handle the case when the latest schedule is not active
	            return null; // or an appropriate value
	        }
	    } else {
	        // Handle the case when there is no latest schedule or its creation timestamp is null
	        return null; // or an appropriate value
	    }
	}

}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-09-21 15:34:51.177
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-09-21 15:34:51.179
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-21 15:34:51.251
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.xyram.daydrop.serviceimpl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.transaction.Transactional;

import org.apache.commons.collections4.map.HashedMap;
import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.server.ResponseStatusException;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.xyram.daydrop.admin.model.CurrentUser;
import com.xyram.daydrop.basemodel.Base64Wrapper;
import com.xyram.daydrop.basemodel.MerchantTransactionIdGenerator;
import com.xyram.daydrop.basemodel.PhonepeSerializer;
import com.xyram.daydrop.dao.ApartmentDao;
import com.xyram.daydrop.dao.CustomerDetailsDao;
import com.xyram.daydrop.dao.CustomerOrderDao;
import com.xyram.daydrop.dao.CustomerOrderReplicaDoa;
import com.xyram.daydrop.dao.SheduleDao;
import com.xyram.daydrop.enumtypes.UserStatus;
import com.xyram.daydrop.model.Apartments;
import com.xyram.daydrop.model.CustomerOrder;
import com.xyram.daydrop.model.CustomerOrderReplica;
import com.xyram.daydrop.model.Customers;
import com.xyram.daydrop.model.Schedule;
import com.xyram.daydrop.modelMapper.PaymentInstrument;
import com.xyram.daydrop.modelMapper.PhonePePayModel;
import com.xyram.daydrop.request.CustomerOrderReplicaRequest;
import com.xyram.daydrop.response.RazorPayRequest;
import com.xyram.daydrop.service.CustomerOrderPriceService;
import com.xyram.daydrop.service.CustomerOrderReplicaService;
import com.xyram.daydrop.util.HashEncoder;
import com.xyram.daydrop.util.RazorPay;
import com.xyram.daydrop.service.ConsumerService;

@Transactional
@Service
public class CustomerOrderReplicaServiceImpl implements CustomerOrderReplicaService {

	@Autowired
	CustomerOrderReplicaDoa customerOrderReplicaDoa;

	@Autowired
	ApartmentDao apartmentDao;

	@Autowired
	SheduleDao scheduleDao;

	@Autowired
	CustomerDetailsDao customerDetailsDao;

	@Autowired
	ConsumerService consumerService;

	@Autowired
	CurrentUser currentUser;

	@Autowired
	PhonepeServiceImpl phonepeServiceImpl;

	@Value("${merchant_id}")
	private String merchantId;

	@Value("${salt_key}")
	private String saltKey;

	@Value("${salt_index}")
	private String saltIndex;

	@Override
	public Map createCustomerOrderReplicaService(CustomerOrderReplicaRequest customerOrderReplicaRequest,
			String contactNumber, Integer aparmentId)

	{

		Map response = new HashedMap<>();

		response.put("message", "success");
		CustomerOrderReplica customerOrderReplica = null;

		if (customerOrderReplicaRequest.getCartId() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "cartId is mandatory ");
		}
		long razorPayCount = 0;
		if (customerOrderReplicaRequest.getOrderId() != null) {

			razorPayCount = customerOrderReplicaDoa.getRazorPayExistByCartId(customerOrderReplicaRequest.getOrderId());
		}

		if (customerOrderReplicaRequest.getCustomerDetails() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Order Details  is mandatory ");
		}

		customerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(customerOrderReplicaRequest.getCartId(),
				contactNumber);

		if (customerOrderReplica != null) {
			customerOrderReplica.setCartId(customerOrderReplica.getCartId());

			if (customerOrderReplica.isOrdered()) {
				throw new ResponseStatusException(HttpStatus.CONFLICT, "Your Order is Placed With cart Details");
			}

//			if (razorPayCount >= 1 && !(customerOrderReplica.getRazorPayOrderId() != null
//					&& customerOrderReplica.getRazorPayOrderId().equals(customerOrderReplicaRequest.getOrderId()))) {
//				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
//			}

			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);

			customerOrderReplica.setAttempts(customerOrderReplica.getAttempts() + 1);
			customerOrderReplica.setUpdatedTime(new Date());

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		} else {

			customerOrderReplica = new CustomerOrderReplica();
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);
			customerOrderReplica.setCartId(customerOrderReplicaRequest.getCartId());
			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());

			if (razorPayCount > 0) {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
			}

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			Schedule schedule = scheduleDao.getlatestScheduleCustomers();

			if (schedule != null) {

				try {
					customerOrderReplica.setSchedule(schedule.getsId() != null ? schedule.getsId().toString() : null);
				} catch (Exception e) {
					e.printStackTrace();
				}
			} else {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
						"Sorry We Are Not Accepting Any Order Right now");

			}

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		}

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicas(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String schedule = null;

		Map filter = request.containsKey("filters") ? (Map) request.get("filters") : null;
		if (filter != null) {
			statusType = filter.containsKey("statusType") ? ((String) filter.get("statusType")).toLowerCase() : null;
			searchQuery = filter.containsKey("searchQuery") ? ((String) filter.get("searchQuery")).toLowerCase() : null;
			schedule = filter.containsKey("schedule") ? (String.valueOf(filter.get("schedule"))) : null;

		}

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplica(searchQuery, statusType, schedule);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");

				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setStreetName(
						customers.get("streetName") != null ? (String) customers.get("streetName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicasBySchedule(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String scheduleId = null;

		Schedule schedule = scheduleDao.getlatestScheduleCustomers();

		if (schedule != null) {

			try {
				scheduleId = schedule.getsId() != null ? schedule.getsId().toString() : null;
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

		statusType = request.containsKey("statusType") ? ((String) request.get("statusType")).toLowerCase() : "Success";

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplicaBySchdeule(statusType, scheduleId);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");
				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				System.out.println("customers" + customers.get("customerName"));

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public CustomerOrderReplica getCustomerOrderReplicaByCartId(String cartId) {

		CustomerOrderReplica CustomerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(cartId,
				currentUser.getContactNumber());

		ObjectMapper objectMapper = new ObjectMapper();
		try {

			// convert JSON string to Map
			Map<String, Object> customerOrderReplicaMap = objectMapper
					.readValue(CustomerOrderReplica.getCustomerOrderDetails(), Map.class);

			Object customerOrder = customerOrderReplicaMap.get("customerOrder");
			Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

			Object quanityList = items.get("quantity");
			Map customers = customerDetailsDao.getByContactNumberAndApartment(CustomerOrderReplica.getContactNumber(),
					CustomerOrderReplica.getApartmentId());

			System.out.println("customers" + customers.get("customerName"));

			// Apartments apartments =
			// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
			CustomerOrderReplica.setApartmentName(
					customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

			CustomerOrderReplica.setCustomerDetails(customers);

			CustomerOrderReplica.setCustomerOrder(customerOrder);
			CustomerOrderReplica.setQuatityList(quanityList);

		} catch (Exception e) {
			e.printStackTrace();
		}

		return CustomerOrderReplica;

	}

	@Override
	public Map createCustomerOrderReplica(CustomerOrderReplicaRequest customerOrderReplicaRequest, String contactNumber,
			Integer aparmentId) {

		if (customerOrderReplicaRequest.getRazorPayRequest() != null) {

//			Map razorPay = consumerService.createRazorPayOrder(customerOrderReplicaRequest.getRazorPayRequest());
//			customerOrderReplicaRequest.setOrderId(razorPay.get("order") != null ? (String)((RazorPay) razorPay.get("order")).getId() : null);	
//	
//			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);
//
//			razorPay.put("cartId", customerOrderReplicaRequest.getCartId());

			Map customerOrderReplicaMap = new HashMap<>();

			Map orderId = new HashMap<>();
			String transactionId = getMerchantTransactionId();
			orderId.put("id", transactionId);

			customerOrderReplicaMap.put("order", orderId);

			customerOrderReplicaRequest.setOrderId(transactionId);
			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);

			customerOrderReplicaMap.put("cartId", customerOrderReplicaRequest.getCartId());

			try {
				customerOrderReplicaMap.put("phonePeResponse",
						phonepeServiceImpl.initiatePhonepePayment(transactionId,
								Integer.valueOf(customerOrderReplicaRequest.getRazorPayRequest().getAmount()),
								contactNumber, customerOrderReplicaRequest.getRedirectUrl(), customerOrderReplicaRequest.getCallBackUrl()));

			} catch (Exception e) {
				e.printStackTrace();
				customerOrderReplicaMap.put("phonePeResponse", new HashedMap<>());
			}

			return customerOrderReplicaMap;

		} else {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
					"paymentDetails transcation Details are mandatory");
		}

	}

	private static String getMerchantTransactionId() {

		return "OD_" + MerchantTransactionIdGenerator.getRandomString();
	}


	@Override
	public List<CustomerOrderReplica> getCustomerOrderByMoblieNo(String contactNumber, Integer aid) {

	    Schedule latestSchedule = customerOrderReplicaDoa.getlatestschedule();

	    if (latestSchedule != null && latestSchedule.getCreationTimestamp() != null) {
	        if (latestSchedule.getStatus().equals(UserStatus.ACTIVE)) {
	            Customers customer = customerDetailsDao.getByContactNoAndApartment(contactNumber, aid);

	            if (customer != null) { // Ensure the customer exists
	                List<CustomerOrder> customerOrderList = customerOrderReplicaDoa.getListCustomerOrderByCustomerId(customer.getCtId());

	                double totalOrderAmount = 0.0;

	                if (customerOrderList != null && !customerOrderList.isEmpty()) {
	                    for (CustomerOrder customerOrder : customerOrderList) {
	                        Double orderAmount = customerOrder.getAmount();
	                        if (orderAmount != null) {
	                            totalOrderAmount += orderAmount;
	                            if(totalOrderAmount>200) {
	                            	totalOrderAmount+= customerOrder.getDelivaryCharges();
	                            }
	                            else{
	                            	(totalOrderAmount<200)
	                            }{
	                            	totalOrderAmount-= customerOrder.getDelivaryCharges();
	                            }
	                        }
	                    }

	                    // Define the minimum order amount for applying delivery charges
	                    double minimumOrderAmount = 200.0;

	                    if (totalOrderAmount < minimumOrderAmount) {
	                        System.out.println("Delivery Charges will be applicable");
	                    } else {
	                        // No delivery charges applicable
	                        System.out.println("No Delivery charges applicable");
	                    }

	                    List<CustomerOrderReplica> customerOrderReplicas = new ArrayList<>();
	                    return customerOrderReplicas;
	                } else {
	                    return Collections.emptyList();
	                }
	            } else {
	                return null; // or an appropriate value
	            }
	        } else {
	            // Handle the case when the latest schedule is not active
	            return null; // or an appropriate value
	        }
	    } else {
	        // Handle the case when there is no latest schedule or its creation timestamp is null
	        return null; // or an appropriate value
	    }
	}

}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-09-21 15:34:51.254
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-09-21 15:34:51.256
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-21 15:34:55.779
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.xyram.daydrop.serviceimpl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.transaction.Transactional;

import org.apache.commons.collections4.map.HashedMap;
import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.server.ResponseStatusException;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.xyram.daydrop.admin.model.CurrentUser;
import com.xyram.daydrop.basemodel.Base64Wrapper;
import com.xyram.daydrop.basemodel.MerchantTransactionIdGenerator;
import com.xyram.daydrop.basemodel.PhonepeSerializer;
import com.xyram.daydrop.dao.ApartmentDao;
import com.xyram.daydrop.dao.CustomerDetailsDao;
import com.xyram.daydrop.dao.CustomerOrderDao;
import com.xyram.daydrop.dao.CustomerOrderReplicaDoa;
import com.xyram.daydrop.dao.SheduleDao;
import com.xyram.daydrop.enumtypes.UserStatus;
import com.xyram.daydrop.model.Apartments;
import com.xyram.daydrop.model.CustomerOrder;
import com.xyram.daydrop.model.CustomerOrderReplica;
import com.xyram.daydrop.model.Customers;
import com.xyram.daydrop.model.Schedule;
import com.xyram.daydrop.modelMapper.PaymentInstrument;
import com.xyram.daydrop.modelMapper.PhonePePayModel;
import com.xyram.daydrop.request.CustomerOrderReplicaRequest;
import com.xyram.daydrop.response.RazorPayRequest;
import com.xyram.daydrop.service.CustomerOrderPriceService;
import com.xyram.daydrop.service.CustomerOrderReplicaService;
import com.xyram.daydrop.util.HashEncoder;
import com.xyram.daydrop.util.RazorPay;
import com.xyram.daydrop.service.ConsumerService;

@Transactional
@Service
public class CustomerOrderReplicaServiceImpl implements CustomerOrderReplicaService {

	@Autowired
	CustomerOrderReplicaDoa customerOrderReplicaDoa;

	@Autowired
	ApartmentDao apartmentDao;

	@Autowired
	SheduleDao scheduleDao;

	@Autowired
	CustomerDetailsDao customerDetailsDao;

	@Autowired
	ConsumerService consumerService;

	@Autowired
	CurrentUser currentUser;

	@Autowired
	PhonepeServiceImpl phonepeServiceImpl;

	@Value("${merchant_id}")
	private String merchantId;

	@Value("${salt_key}")
	private String saltKey;

	@Value("${salt_index}")
	private String saltIndex;

	@Override
	public Map createCustomerOrderReplicaService(CustomerOrderReplicaRequest customerOrderReplicaRequest,
			String contactNumber, Integer aparmentId)

	{

		Map response = new HashedMap<>();

		response.put("message", "success");
		CustomerOrderReplica customerOrderReplica = null;

		if (customerOrderReplicaRequest.getCartId() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "cartId is mandatory ");
		}
		long razorPayCount = 0;
		if (customerOrderReplicaRequest.getOrderId() != null) {

			razorPayCount = customerOrderReplicaDoa.getRazorPayExistByCartId(customerOrderReplicaRequest.getOrderId());
		}

		if (customerOrderReplicaRequest.getCustomerDetails() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Order Details  is mandatory ");
		}

		customerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(customerOrderReplicaRequest.getCartId(),
				contactNumber);

		if (customerOrderReplica != null) {
			customerOrderReplica.setCartId(customerOrderReplica.getCartId());

			if (customerOrderReplica.isOrdered()) {
				throw new ResponseStatusException(HttpStatus.CONFLICT, "Your Order is Placed With cart Details");
			}

//			if (razorPayCount >= 1 && !(customerOrderReplica.getRazorPayOrderId() != null
//					&& customerOrderReplica.getRazorPayOrderId().equals(customerOrderReplicaRequest.getOrderId()))) {
//				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
//			}

			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);

			customerOrderReplica.setAttempts(customerOrderReplica.getAttempts() + 1);
			customerOrderReplica.setUpdatedTime(new Date());

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		} else {

			customerOrderReplica = new CustomerOrderReplica();
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);
			customerOrderReplica.setCartId(customerOrderReplicaRequest.getCartId());
			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());

			if (razorPayCount > 0) {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
			}

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			Schedule schedule = scheduleDao.getlatestScheduleCustomers();

			if (schedule != null) {

				try {
					customerOrderReplica.setSchedule(schedule.getsId() != null ? schedule.getsId().toString() : null);
				} catch (Exception e) {
					e.printStackTrace();
				}
			} else {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
						"Sorry We Are Not Accepting Any Order Right now");

			}

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		}

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicas(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String schedule = null;

		Map filter = request.containsKey("filters") ? (Map) request.get("filters") : null;
		if (filter != null) {
			statusType = filter.containsKey("statusType") ? ((String) filter.get("statusType")).toLowerCase() : null;
			searchQuery = filter.containsKey("searchQuery") ? ((String) filter.get("searchQuery")).toLowerCase() : null;
			schedule = filter.containsKey("schedule") ? (String.valueOf(filter.get("schedule"))) : null;

		}

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplica(searchQuery, statusType, schedule);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");

				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setStreetName(
						customers.get("streetName") != null ? (String) customers.get("streetName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicasBySchedule(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String scheduleId = null;

		Schedule schedule = scheduleDao.getlatestScheduleCustomers();

		if (schedule != null) {

			try {
				scheduleId = schedule.getsId() != null ? schedule.getsId().toString() : null;
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

		statusType = request.containsKey("statusType") ? ((String) request.get("statusType")).toLowerCase() : "Success";

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplicaBySchdeule(statusType, scheduleId);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");
				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				System.out.println("customers" + customers.get("customerName"));

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public CustomerOrderReplica getCustomerOrderReplicaByCartId(String cartId) {

		CustomerOrderReplica CustomerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(cartId,
				currentUser.getContactNumber());

		ObjectMapper objectMapper = new ObjectMapper();
		try {

			// convert JSON string to Map
			Map<String, Object> customerOrderReplicaMap = objectMapper
					.readValue(CustomerOrderReplica.getCustomerOrderDetails(), Map.class);

			Object customerOrder = customerOrderReplicaMap.get("customerOrder");
			Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

			Object quanityList = items.get("quantity");
			Map customers = customerDetailsDao.getByContactNumberAndApartment(CustomerOrderReplica.getContactNumber(),
					CustomerOrderReplica.getApartmentId());

			System.out.println("customers" + customers.get("customerName"));

			// Apartments apartments =
			// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
			CustomerOrderReplica.setApartmentName(
					customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

			CustomerOrderReplica.setCustomerDetails(customers);

			CustomerOrderReplica.setCustomerOrder(customerOrder);
			CustomerOrderReplica.setQuatityList(quanityList);

		} catch (Exception e) {
			e.printStackTrace();
		}

		return CustomerOrderReplica;

	}

	@Override
	public Map createCustomerOrderReplica(CustomerOrderReplicaRequest customerOrderReplicaRequest, String contactNumber,
			Integer aparmentId) {

		if (customerOrderReplicaRequest.getRazorPayRequest() != null) {

//			Map razorPay = consumerService.createRazorPayOrder(customerOrderReplicaRequest.getRazorPayRequest());
//			customerOrderReplicaRequest.setOrderId(razorPay.get("order") != null ? (String)((RazorPay) razorPay.get("order")).getId() : null);	
//	
//			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);
//
//			razorPay.put("cartId", customerOrderReplicaRequest.getCartId());

			Map customerOrderReplicaMap = new HashMap<>();

			Map orderId = new HashMap<>();
			String transactionId = getMerchantTransactionId();
			orderId.put("id", transactionId);

			customerOrderReplicaMap.put("order", orderId);

			customerOrderReplicaRequest.setOrderId(transactionId);
			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);

			customerOrderReplicaMap.put("cartId", customerOrderReplicaRequest.getCartId());

			try {
				customerOrderReplicaMap.put("phonePeResponse",
						phonepeServiceImpl.initiatePhonepePayment(transactionId,
								Integer.valueOf(customerOrderReplicaRequest.getRazorPayRequest().getAmount()),
								contactNumber, customerOrderReplicaRequest.getRedirectUrl(), customerOrderReplicaRequest.getCallBackUrl()));

			} catch (Exception e) {
				e.printStackTrace();
				customerOrderReplicaMap.put("phonePeResponse", new HashedMap<>());
			}

			return customerOrderReplicaMap;

		} else {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
					"paymentDetails transcation Details are mandatory");
		}

	}

	private static String getMerchantTransactionId() {

		return "OD_" + MerchantTransactionIdGenerator.getRandomString();
	}


	@Override
	public List<CustomerOrderReplica> getCustomerOrderByMoblieNo(String contactNumber, Integer aid) {

	    Schedule latestSchedule = customerOrderReplicaDoa.getlatestschedule();

	    if (latestSchedule != null && latestSchedule.getCreationTimestamp() != null) {
	        if (latestSchedule.getStatus().equals(UserStatus.ACTIVE)) {
	            Customers customer = customerDetailsDao.getByContactNoAndApartment(contactNumber, aid);

	            if (customer != null) { // Ensure the customer exists
	                List<CustomerOrder> customerOrderList = customerOrderReplicaDoa.getListCustomerOrderByCustomerId(customer.getCtId());

	                double totalOrderAmount = 0.0;

	                if (customerOrderList != null && !customerOrderList.isEmpty()) {
	                    for (CustomerOrder customerOrder : customerOrderList) {
	                        Double orderAmount = customerOrder.getAmount();
	                        if (orderAmount != null) {
	                            totalOrderAmount += orderAmount;
	                            if(totalOrderAmount>200) {
	                            	totalOrderAmount+= customerOrder.getDelivaryCharges();
	                            }
	                            else{
	                            	(totalOrderAmount<200)
	                            }{
	                            	totalOrderAmount-= customerOrder.getDelivaryCharges();
	                            }
	                        }
	                    }

	                    // Define the minimum order amount for applying delivery charges
	                    double minimumOrderAmount = 200.0;

	                    if (totalOrderAmount < minimumOrderAmount) {
	                        System.out.println("Delivery Charges will be applicable");
	                    } else {
	                        // No delivery charges applicable
	                        System.out.println("No Delivery charges applicable");
	                    }

	                    List<CustomerOrderReplica> customerOrderReplicas = new ArrayList<>();
	                    return customerOrderReplicas;
	                } else {
	                    return Collections.emptyList();
	                }
	            } else {
	                return null; // or an appropriate value
	            }
	        } else {
	            // Handle the case when the latest schedule is not active
	            return null; // or an appropriate value
	        }
	    } else {
	        // Handle the case when there is no latest schedule or its creation timestamp is null
	        return null; // or an appropriate value
	    }
	}

}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1003)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:799)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:743)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:666)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:658)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.lambda$0(LSJavaHoverProvider.java:68)
	at java.base/java.util.concurrent.CompletableFuture$AsyncRun.run(CompletableFuture.java:1804)
	at java.base/java.util.concurrent.CompletableFuture$AsyncRun.exec(CompletableFuture.java:1796)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:373)
	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1182)
	at java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1655)
	at java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1622)
	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:165)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-09-21 15:34:55.782
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1003)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:799)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:743)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:666)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:658)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.lambda$0(LSJavaHoverProvider.java:68)
	at java.base/java.util.concurrent.CompletableFuture$AsyncRun.run(CompletableFuture.java:1804)
	at java.base/java.util.concurrent.CompletableFuture$AsyncRun.exec(CompletableFuture.java:1796)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:373)
	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1182)
	at java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1655)
	at java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1622)
	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:165)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-09-21 15:34:55.784
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1003)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:799)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:743)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:666)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:658)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.lambda$0(LSJavaHoverProvider.java:68)
	at java.base/java.util.concurrent.CompletableFuture$AsyncRun.run(CompletableFuture.java:1804)
	at java.base/java.util.concurrent.CompletableFuture$AsyncRun.exec(CompletableFuture.java:1796)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:373)
	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1182)
	at java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1655)
	at java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1622)
	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:165)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-21 15:34:55.855
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.xyram.daydrop.serviceimpl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.transaction.Transactional;

import org.apache.commons.collections4.map.HashedMap;
import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.server.ResponseStatusException;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.xyram.daydrop.admin.model.CurrentUser;
import com.xyram.daydrop.basemodel.Base64Wrapper;
import com.xyram.daydrop.basemodel.MerchantTransactionIdGenerator;
import com.xyram.daydrop.basemodel.PhonepeSerializer;
import com.xyram.daydrop.dao.ApartmentDao;
import com.xyram.daydrop.dao.CustomerDetailsDao;
import com.xyram.daydrop.dao.CustomerOrderDao;
import com.xyram.daydrop.dao.CustomerOrderReplicaDoa;
import com.xyram.daydrop.dao.SheduleDao;
import com.xyram.daydrop.enumtypes.UserStatus;
import com.xyram.daydrop.model.Apartments;
import com.xyram.daydrop.model.CustomerOrder;
import com.xyram.daydrop.model.CustomerOrderReplica;
import com.xyram.daydrop.model.Customers;
import com.xyram.daydrop.model.Schedule;
import com.xyram.daydrop.modelMapper.PaymentInstrument;
import com.xyram.daydrop.modelMapper.PhonePePayModel;
import com.xyram.daydrop.request.CustomerOrderReplicaRequest;
import com.xyram.daydrop.response.RazorPayRequest;
import com.xyram.daydrop.service.CustomerOrderPriceService;
import com.xyram.daydrop.service.CustomerOrderReplicaService;
import com.xyram.daydrop.util.HashEncoder;
import com.xyram.daydrop.util.RazorPay;
import com.xyram.daydrop.service.ConsumerService;

@Transactional
@Service
public class CustomerOrderReplicaServiceImpl implements CustomerOrderReplicaService {

	@Autowired
	CustomerOrderReplicaDoa customerOrderReplicaDoa;

	@Autowired
	ApartmentDao apartmentDao;

	@Autowired
	SheduleDao scheduleDao;

	@Autowired
	CustomerDetailsDao customerDetailsDao;

	@Autowired
	ConsumerService consumerService;

	@Autowired
	CurrentUser currentUser;

	@Autowired
	PhonepeServiceImpl phonepeServiceImpl;

	@Value("${merchant_id}")
	private String merchantId;

	@Value("${salt_key}")
	private String saltKey;

	@Value("${salt_index}")
	private String saltIndex;

	@Override
	public Map createCustomerOrderReplicaService(CustomerOrderReplicaRequest customerOrderReplicaRequest,
			String contactNumber, Integer aparmentId)

	{

		Map response = new HashedMap<>();

		response.put("message", "success");
		CustomerOrderReplica customerOrderReplica = null;

		if (customerOrderReplicaRequest.getCartId() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "cartId is mandatory ");
		}
		long razorPayCount = 0;
		if (customerOrderReplicaRequest.getOrderId() != null) {

			razorPayCount = customerOrderReplicaDoa.getRazorPayExistByCartId(customerOrderReplicaRequest.getOrderId());
		}

		if (customerOrderReplicaRequest.getCustomerDetails() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Order Details  is mandatory ");
		}

		customerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(customerOrderReplicaRequest.getCartId(),
				contactNumber);

		if (customerOrderReplica != null) {
			customerOrderReplica.setCartId(customerOrderReplica.getCartId());

			if (customerOrderReplica.isOrdered()) {
				throw new ResponseStatusException(HttpStatus.CONFLICT, "Your Order is Placed With cart Details");
			}

//			if (razorPayCount >= 1 && !(customerOrderReplica.getRazorPayOrderId() != null
//					&& customerOrderReplica.getRazorPayOrderId().equals(customerOrderReplicaRequest.getOrderId()))) {
//				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
//			}

			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);

			customerOrderReplica.setAttempts(customerOrderReplica.getAttempts() + 1);
			customerOrderReplica.setUpdatedTime(new Date());

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		} else {

			customerOrderReplica = new CustomerOrderReplica();
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);
			customerOrderReplica.setCartId(customerOrderReplicaRequest.getCartId());
			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());

			if (razorPayCount > 0) {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
			}

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			Schedule schedule = scheduleDao.getlatestScheduleCustomers();

			if (schedule != null) {

				try {
					customerOrderReplica.setSchedule(schedule.getsId() != null ? schedule.getsId().toString() : null);
				} catch (Exception e) {
					e.printStackTrace();
				}
			} else {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
						"Sorry We Are Not Accepting Any Order Right now");

			}

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		}

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicas(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String schedule = null;

		Map filter = request.containsKey("filters") ? (Map) request.get("filters") : null;
		if (filter != null) {
			statusType = filter.containsKey("statusType") ? ((String) filter.get("statusType")).toLowerCase() : null;
			searchQuery = filter.containsKey("searchQuery") ? ((String) filter.get("searchQuery")).toLowerCase() : null;
			schedule = filter.containsKey("schedule") ? (String.valueOf(filter.get("schedule"))) : null;

		}

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplica(searchQuery, statusType, schedule);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");

				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setStreetName(
						customers.get("streetName") != null ? (String) customers.get("streetName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicasBySchedule(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String scheduleId = null;

		Schedule schedule = scheduleDao.getlatestScheduleCustomers();

		if (schedule != null) {

			try {
				scheduleId = schedule.getsId() != null ? schedule.getsId().toString() : null;
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

		statusType = request.containsKey("statusType") ? ((String) request.get("statusType")).toLowerCase() : "Success";

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplicaBySchdeule(statusType, scheduleId);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");
				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				System.out.println("customers" + customers.get("customerName"));

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public CustomerOrderReplica getCustomerOrderReplicaByCartId(String cartId) {

		CustomerOrderReplica CustomerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(cartId,
				currentUser.getContactNumber());

		ObjectMapper objectMapper = new ObjectMapper();
		try {

			// convert JSON string to Map
			Map<String, Object> customerOrderReplicaMap = objectMapper
					.readValue(CustomerOrderReplica.getCustomerOrderDetails(), Map.class);

			Object customerOrder = customerOrderReplicaMap.get("customerOrder");
			Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

			Object quanityList = items.get("quantity");
			Map customers = customerDetailsDao.getByContactNumberAndApartment(CustomerOrderReplica.getContactNumber(),
					CustomerOrderReplica.getApartmentId());

			System.out.println("customers" + customers.get("customerName"));

			// Apartments apartments =
			// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
			CustomerOrderReplica.setApartmentName(
					customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

			CustomerOrderReplica.setCustomerDetails(customers);

			CustomerOrderReplica.setCustomerOrder(customerOrder);
			CustomerOrderReplica.setQuatityList(quanityList);

		} catch (Exception e) {
			e.printStackTrace();
		}

		return CustomerOrderReplica;

	}

	@Override
	public Map createCustomerOrderReplica(CustomerOrderReplicaRequest customerOrderReplicaRequest, String contactNumber,
			Integer aparmentId) {

		if (customerOrderReplicaRequest.getRazorPayRequest() != null) {

//			Map razorPay = consumerService.createRazorPayOrder(customerOrderReplicaRequest.getRazorPayRequest());
//			customerOrderReplicaRequest.setOrderId(razorPay.get("order") != null ? (String)((RazorPay) razorPay.get("order")).getId() : null);	
//	
//			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);
//
//			razorPay.put("cartId", customerOrderReplicaRequest.getCartId());

			Map customerOrderReplicaMap = new HashMap<>();

			Map orderId = new HashMap<>();
			String transactionId = getMerchantTransactionId();
			orderId.put("id", transactionId);

			customerOrderReplicaMap.put("order", orderId);

			customerOrderReplicaRequest.setOrderId(transactionId);
			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);

			customerOrderReplicaMap.put("cartId", customerOrderReplicaRequest.getCartId());

			try {
				customerOrderReplicaMap.put("phonePeResponse",
						phonepeServiceImpl.initiatePhonepePayment(transactionId,
								Integer.valueOf(customerOrderReplicaRequest.getRazorPayRequest().getAmount()),
								contactNumber, customerOrderReplicaRequest.getRedirectUrl(), customerOrderReplicaRequest.getCallBackUrl()));

			} catch (Exception e) {
				e.printStackTrace();
				customerOrderReplicaMap.put("phonePeResponse", new HashedMap<>());
			}

			return customerOrderReplicaMap;

		} else {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
					"paymentDetails transcation Details are mandatory");
		}

	}

	private static String getMerchantTransactionId() {

		return "OD_" + MerchantTransactionIdGenerator.getRandomString();
	}


	@Override
	public List<CustomerOrderReplica> getCustomerOrderByMoblieNo(String contactNumber, Integer aid) {

	    Schedule latestSchedule = customerOrderReplicaDoa.getlatestschedule();

	    if (latestSchedule != null && latestSchedule.getCreationTimestamp() != null) {
	        if (latestSchedule.getStatus().equals(UserStatus.ACTIVE)) {
	            Customers customer = customerDetailsDao.getByContactNoAndApartment(contactNumber, aid);

	            if (customer != null) { // Ensure the customer exists
	                List<CustomerOrder> customerOrderList = customerOrderReplicaDoa.getListCustomerOrderByCustomerId(customer.getCtId());

	                double totalOrderAmount = 0.0;

	                if (customerOrderList != null && !customerOrderList.isEmpty()) {
	                    for (CustomerOrder customerOrder : customerOrderList) {
	                        Double orderAmount = customerOrder.getAmount();
	                        if (orderAmount != null) {
	                            totalOrderAmount += orderAmount;
	                            if(totalOrderAmount>200) {
	                            	totalOrderAmount+= customerOrder.getDelivaryCharges();
	                            }
	                            else{
	                            	(totalOrderAmount<200)
	                            }{
	                            	totalOrderAmount-= customerOrder.getDelivaryCharges();
	                            }
	                        }
	                    }

	                    // Define the minimum order amount for applying delivery charges
	                    double minimumOrderAmount = 200.0;

	                    if (totalOrderAmount < minimumOrderAmount) {
	                        System.out.println("Delivery Charges will be applicable");
	                    } else {
	                        // No delivery charges applicable
	                        System.out.println("No Delivery charges applicable");
	                    }

	                    List<CustomerOrderReplica> customerOrderReplicas = new ArrayList<>();
	                    return customerOrderReplicas;
	                } else {
	                    return Collections.emptyList();
	                }
	            } else {
	                return null; // or an appropriate value
	            }
	        } else {
	            // Handle the case when the latest schedule is not active
	            return null; // or an appropriate value
	        }
	    } else {
	        // Handle the case when there is no latest schedule or its creation timestamp is null
	        return null; // or an appropriate value
	    }
	}

}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-09-21 15:34:55.857
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-09-21 15:34:55.859
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-21 15:34:55.937
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.xyram.daydrop.serviceimpl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.transaction.Transactional;

import org.apache.commons.collections4.map.HashedMap;
import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.server.ResponseStatusException;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.xyram.daydrop.admin.model.CurrentUser;
import com.xyram.daydrop.basemodel.Base64Wrapper;
import com.xyram.daydrop.basemodel.MerchantTransactionIdGenerator;
import com.xyram.daydrop.basemodel.PhonepeSerializer;
import com.xyram.daydrop.dao.ApartmentDao;
import com.xyram.daydrop.dao.CustomerDetailsDao;
import com.xyram.daydrop.dao.CustomerOrderDao;
import com.xyram.daydrop.dao.CustomerOrderReplicaDoa;
import com.xyram.daydrop.dao.SheduleDao;
import com.xyram.daydrop.enumtypes.UserStatus;
import com.xyram.daydrop.model.Apartments;
import com.xyram.daydrop.model.CustomerOrder;
import com.xyram.daydrop.model.CustomerOrderReplica;
import com.xyram.daydrop.model.Customers;
import com.xyram.daydrop.model.Schedule;
import com.xyram.daydrop.modelMapper.PaymentInstrument;
import com.xyram.daydrop.modelMapper.PhonePePayModel;
import com.xyram.daydrop.request.CustomerOrderReplicaRequest;
import com.xyram.daydrop.response.RazorPayRequest;
import com.xyram.daydrop.service.CustomerOrderPriceService;
import com.xyram.daydrop.service.CustomerOrderReplicaService;
import com.xyram.daydrop.util.HashEncoder;
import com.xyram.daydrop.util.RazorPay;
import com.xyram.daydrop.service.ConsumerService;

@Transactional
@Service
public class CustomerOrderReplicaServiceImpl implements CustomerOrderReplicaService {

	@Autowired
	CustomerOrderReplicaDoa customerOrderReplicaDoa;

	@Autowired
	ApartmentDao apartmentDao;

	@Autowired
	SheduleDao scheduleDao;

	@Autowired
	CustomerDetailsDao customerDetailsDao;

	@Autowired
	ConsumerService consumerService;

	@Autowired
	CurrentUser currentUser;

	@Autowired
	PhonepeServiceImpl phonepeServiceImpl;

	@Value("${merchant_id}")
	private String merchantId;

	@Value("${salt_key}")
	private String saltKey;

	@Value("${salt_index}")
	private String saltIndex;

	@Override
	public Map createCustomerOrderReplicaService(CustomerOrderReplicaRequest customerOrderReplicaRequest,
			String contactNumber, Integer aparmentId)

	{

		Map response = new HashedMap<>();

		response.put("message", "success");
		CustomerOrderReplica customerOrderReplica = null;

		if (customerOrderReplicaRequest.getCartId() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "cartId is mandatory ");
		}
		long razorPayCount = 0;
		if (customerOrderReplicaRequest.getOrderId() != null) {

			razorPayCount = customerOrderReplicaDoa.getRazorPayExistByCartId(customerOrderReplicaRequest.getOrderId());
		}

		if (customerOrderReplicaRequest.getCustomerDetails() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Order Details  is mandatory ");
		}

		customerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(customerOrderReplicaRequest.getCartId(),
				contactNumber);

		if (customerOrderReplica != null) {
			customerOrderReplica.setCartId(customerOrderReplica.getCartId());

			if (customerOrderReplica.isOrdered()) {
				throw new ResponseStatusException(HttpStatus.CONFLICT, "Your Order is Placed With cart Details");
			}

//			if (razorPayCount >= 1 && !(customerOrderReplica.getRazorPayOrderId() != null
//					&& customerOrderReplica.getRazorPayOrderId().equals(customerOrderReplicaRequest.getOrderId()))) {
//				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
//			}

			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);

			customerOrderReplica.setAttempts(customerOrderReplica.getAttempts() + 1);
			customerOrderReplica.setUpdatedTime(new Date());

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		} else {

			customerOrderReplica = new CustomerOrderReplica();
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);
			customerOrderReplica.setCartId(customerOrderReplicaRequest.getCartId());
			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());

			if (razorPayCount > 0) {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
			}

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			Schedule schedule = scheduleDao.getlatestScheduleCustomers();

			if (schedule != null) {

				try {
					customerOrderReplica.setSchedule(schedule.getsId() != null ? schedule.getsId().toString() : null);
				} catch (Exception e) {
					e.printStackTrace();
				}
			} else {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
						"Sorry We Are Not Accepting Any Order Right now");

			}

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		}

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicas(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String schedule = null;

		Map filter = request.containsKey("filters") ? (Map) request.get("filters") : null;
		if (filter != null) {
			statusType = filter.containsKey("statusType") ? ((String) filter.get("statusType")).toLowerCase() : null;
			searchQuery = filter.containsKey("searchQuery") ? ((String) filter.get("searchQuery")).toLowerCase() : null;
			schedule = filter.containsKey("schedule") ? (String.valueOf(filter.get("schedule"))) : null;

		}

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplica(searchQuery, statusType, schedule);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");

				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setStreetName(
						customers.get("streetName") != null ? (String) customers.get("streetName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicasBySchedule(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String scheduleId = null;

		Schedule schedule = scheduleDao.getlatestScheduleCustomers();

		if (schedule != null) {

			try {
				scheduleId = schedule.getsId() != null ? schedule.getsId().toString() : null;
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

		statusType = request.containsKey("statusType") ? ((String) request.get("statusType")).toLowerCase() : "Success";

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplicaBySchdeule(statusType, scheduleId);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");
				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				System.out.println("customers" + customers.get("customerName"));

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public CustomerOrderReplica getCustomerOrderReplicaByCartId(String cartId) {

		CustomerOrderReplica CustomerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(cartId,
				currentUser.getContactNumber());

		ObjectMapper objectMapper = new ObjectMapper();
		try {

			// convert JSON string to Map
			Map<String, Object> customerOrderReplicaMap = objectMapper
					.readValue(CustomerOrderReplica.getCustomerOrderDetails(), Map.class);

			Object customerOrder = customerOrderReplicaMap.get("customerOrder");
			Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

			Object quanityList = items.get("quantity");
			Map customers = customerDetailsDao.getByContactNumberAndApartment(CustomerOrderReplica.getContactNumber(),
					CustomerOrderReplica.getApartmentId());

			System.out.println("customers" + customers.get("customerName"));

			// Apartments apartments =
			// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
			CustomerOrderReplica.setApartmentName(
					customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

			CustomerOrderReplica.setCustomerDetails(customers);

			CustomerOrderReplica.setCustomerOrder(customerOrder);
			CustomerOrderReplica.setQuatityList(quanityList);

		} catch (Exception e) {
			e.printStackTrace();
		}

		return CustomerOrderReplica;

	}

	@Override
	public Map createCustomerOrderReplica(CustomerOrderReplicaRequest customerOrderReplicaRequest, String contactNumber,
			Integer aparmentId) {

		if (customerOrderReplicaRequest.getRazorPayRequest() != null) {

//			Map razorPay = consumerService.createRazorPayOrder(customerOrderReplicaRequest.getRazorPayRequest());
//			customerOrderReplicaRequest.setOrderId(razorPay.get("order") != null ? (String)((RazorPay) razorPay.get("order")).getId() : null);	
//	
//			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);
//
//			razorPay.put("cartId", customerOrderReplicaRequest.getCartId());

			Map customerOrderReplicaMap = new HashMap<>();

			Map orderId = new HashMap<>();
			String transactionId = getMerchantTransactionId();
			orderId.put("id", transactionId);

			customerOrderReplicaMap.put("order", orderId);

			customerOrderReplicaRequest.setOrderId(transactionId);
			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);

			customerOrderReplicaMap.put("cartId", customerOrderReplicaRequest.getCartId());

			try {
				customerOrderReplicaMap.put("phonePeResponse",
						phonepeServiceImpl.initiatePhonepePayment(transactionId,
								Integer.valueOf(customerOrderReplicaRequest.getRazorPayRequest().getAmount()),
								contactNumber, customerOrderReplicaRequest.getRedirectUrl(), customerOrderReplicaRequest.getCallBackUrl()));

			} catch (Exception e) {
				e.printStackTrace();
				customerOrderReplicaMap.put("phonePeResponse", new HashedMap<>());
			}

			return customerOrderReplicaMap;

		} else {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
					"paymentDetails transcation Details are mandatory");
		}

	}

	private static String getMerchantTransactionId() {

		return "OD_" + MerchantTransactionIdGenerator.getRandomString();
	}


	@Override
	public List<CustomerOrderReplica> getCustomerOrderByMoblieNo(String contactNumber, Integer aid) {

	    Schedule latestSchedule = customerOrderReplicaDoa.getlatestschedule();

	    if (latestSchedule != null && latestSchedule.getCreationTimestamp() != null) {
	        if (latestSchedule.getStatus().equals(UserStatus.ACTIVE)) {
	            Customers customer = customerDetailsDao.getByContactNoAndApartment(contactNumber, aid);

	            if (customer != null) { // Ensure the customer exists
	                List<CustomerOrder> customerOrderList = customerOrderReplicaDoa.getListCustomerOrderByCustomerId(customer.getCtId());

	                double totalOrderAmount = 0.0;

	                if (customerOrderList != null && !customerOrderList.isEmpty()) {
	                    for (CustomerOrder customerOrder : customerOrderList) {
	                        Double orderAmount = customerOrder.getAmount();
	                        if (orderAmount != null) {
	                            totalOrderAmount += orderAmount;
	                            if(totalOrderAmount>200) {
	                            	totalOrderAmount+= customerOrder.getDelivaryCharges();
	                            }
	                            else{
	                            	(totalOrderAmount<200)
	                            }{
	                            	totalOrderAmount-= customerOrder.getDelivaryCharges();
	                            }
	                        }
	                    }

	                    // Define the minimum order amount for applying delivery charges
	                    double minimumOrderAmount = 200.0;

	                    if (totalOrderAmount < minimumOrderAmount) {
	                        System.out.println("Delivery Charges will be applicable");
	                    } else {
	                        // No delivery charges applicable
	                        System.out.println("No Delivery charges applicable");
	                    }

	                    List<CustomerOrderReplica> customerOrderReplicas = new ArrayList<>();
	                    return customerOrderReplicas;
	                } else {
	                    return Collections.emptyList();
	                }
	            } else {
	                return null; // or an appropriate value
	            }
	        } else {
	            // Handle the case when the latest schedule is not active
	            return null; // or an appropriate value
	        }
	    } else {
	        // Handle the case when there is no latest schedule or its creation timestamp is null
	        return null; // or an appropriate value
	    }
	}

}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1003)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:799)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:743)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:666)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:658)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-09-21 15:34:55.939
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1003)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:799)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:743)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:666)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:658)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-09-21 15:34:55.941
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1003)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:799)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:743)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:666)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:658)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-21 15:34:56.643
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.xyram.daydrop.serviceimpl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.transaction.Transactional;

import org.apache.commons.collections4.map.HashedMap;
import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.server.ResponseStatusException;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.xyram.daydrop.admin.model.CurrentUser;
import com.xyram.daydrop.basemodel.Base64Wrapper;
import com.xyram.daydrop.basemodel.MerchantTransactionIdGenerator;
import com.xyram.daydrop.basemodel.PhonepeSerializer;
import com.xyram.daydrop.dao.ApartmentDao;
import com.xyram.daydrop.dao.CustomerDetailsDao;
import com.xyram.daydrop.dao.CustomerOrderDao;
import com.xyram.daydrop.dao.CustomerOrderReplicaDoa;
import com.xyram.daydrop.dao.SheduleDao;
import com.xyram.daydrop.enumtypes.UserStatus;
import com.xyram.daydrop.model.Apartments;
import com.xyram.daydrop.model.CustomerOrder;
import com.xyram.daydrop.model.CustomerOrderReplica;
import com.xyram.daydrop.model.Customers;
import com.xyram.daydrop.model.Schedule;
import com.xyram.daydrop.modelMapper.PaymentInstrument;
import com.xyram.daydrop.modelMapper.PhonePePayModel;
import com.xyram.daydrop.request.CustomerOrderReplicaRequest;
import com.xyram.daydrop.response.RazorPayRequest;
import com.xyram.daydrop.service.CustomerOrderPriceService;
import com.xyram.daydrop.service.CustomerOrderReplicaService;
import com.xyram.daydrop.util.HashEncoder;
import com.xyram.daydrop.util.RazorPay;
import com.xyram.daydrop.service.ConsumerService;

@Transactional
@Service
public class CustomerOrderReplicaServiceImpl implements CustomerOrderReplicaService {

	@Autowired
	CustomerOrderReplicaDoa customerOrderReplicaDoa;

	@Autowired
	ApartmentDao apartmentDao;

	@Autowired
	SheduleDao scheduleDao;

	@Autowired
	CustomerDetailsDao customerDetailsDao;

	@Autowired
	ConsumerService consumerService;

	@Autowired
	CurrentUser currentUser;

	@Autowired
	PhonepeServiceImpl phonepeServiceImpl;

	@Value("${merchant_id}")
	private String merchantId;

	@Value("${salt_key}")
	private String saltKey;

	@Value("${salt_index}")
	private String saltIndex;

	@Override
	public Map createCustomerOrderReplicaService(CustomerOrderReplicaRequest customerOrderReplicaRequest,
			String contactNumber, Integer aparmentId)

	{

		Map response = new HashedMap<>();

		response.put("message", "success");
		CustomerOrderReplica customerOrderReplica = null;

		if (customerOrderReplicaRequest.getCartId() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "cartId is mandatory ");
		}
		long razorPayCount = 0;
		if (customerOrderReplicaRequest.getOrderId() != null) {

			razorPayCount = customerOrderReplicaDoa.getRazorPayExistByCartId(customerOrderReplicaRequest.getOrderId());
		}

		if (customerOrderReplicaRequest.getCustomerDetails() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Order Details  is mandatory ");
		}

		customerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(customerOrderReplicaRequest.getCartId(),
				contactNumber);

		if (customerOrderReplica != null) {
			customerOrderReplica.setCartId(customerOrderReplica.getCartId());

			if (customerOrderReplica.isOrdered()) {
				throw new ResponseStatusException(HttpStatus.CONFLICT, "Your Order is Placed With cart Details");
			}

//			if (razorPayCount >= 1 && !(customerOrderReplica.getRazorPayOrderId() != null
//					&& customerOrderReplica.getRazorPayOrderId().equals(customerOrderReplicaRequest.getOrderId()))) {
//				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
//			}

			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);

			customerOrderReplica.setAttempts(customerOrderReplica.getAttempts() + 1);
			customerOrderReplica.setUpdatedTime(new Date());

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		} else {

			customerOrderReplica = new CustomerOrderReplica();
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);
			customerOrderReplica.setCartId(customerOrderReplicaRequest.getCartId());
			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());

			if (razorPayCount > 0) {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
			}

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			Schedule schedule = scheduleDao.getlatestScheduleCustomers();

			if (schedule != null) {

				try {
					customerOrderReplica.setSchedule(schedule.getsId() != null ? schedule.getsId().toString() : null);
				} catch (Exception e) {
					e.printStackTrace();
				}
			} else {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
						"Sorry We Are Not Accepting Any Order Right now");

			}

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		}

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicas(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String schedule = null;

		Map filter = request.containsKey("filters") ? (Map) request.get("filters") : null;
		if (filter != null) {
			statusType = filter.containsKey("statusType") ? ((String) filter.get("statusType")).toLowerCase() : null;
			searchQuery = filter.containsKey("searchQuery") ? ((String) filter.get("searchQuery")).toLowerCase() : null;
			schedule = filter.containsKey("schedule") ? (String.valueOf(filter.get("schedule"))) : null;

		}

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplica(searchQuery, statusType, schedule);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");

				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setStreetName(
						customers.get("streetName") != null ? (String) customers.get("streetName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicasBySchedule(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String scheduleId = null;

		Schedule schedule = scheduleDao.getlatestScheduleCustomers();

		if (schedule != null) {

			try {
				scheduleId = schedule.getsId() != null ? schedule.getsId().toString() : null;
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

		statusType = request.containsKey("statusType") ? ((String) request.get("statusType")).toLowerCase() : "Success";

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplicaBySchdeule(statusType, scheduleId);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");
				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				System.out.println("customers" + customers.get("customerName"));

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public CustomerOrderReplica getCustomerOrderReplicaByCartId(String cartId) {

		CustomerOrderReplica CustomerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(cartId,
				currentUser.getContactNumber());

		ObjectMapper objectMapper = new ObjectMapper();
		try {

			// convert JSON string to Map
			Map<String, Object> customerOrderReplicaMap = objectMapper
					.readValue(CustomerOrderReplica.getCustomerOrderDetails(), Map.class);

			Object customerOrder = customerOrderReplicaMap.get("customerOrder");
			Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

			Object quanityList = items.get("quantity");
			Map customers = customerDetailsDao.getByContactNumberAndApartment(CustomerOrderReplica.getContactNumber(),
					CustomerOrderReplica.getApartmentId());

			System.out.println("customers" + customers.get("customerName"));

			// Apartments apartments =
			// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
			CustomerOrderReplica.setApartmentName(
					customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

			CustomerOrderReplica.setCustomerDetails(customers);

			CustomerOrderReplica.setCustomerOrder(customerOrder);
			CustomerOrderReplica.setQuatityList(quanityList);

		} catch (Exception e) {
			e.printStackTrace();
		}

		return CustomerOrderReplica;

	}

	@Override
	public Map createCustomerOrderReplica(CustomerOrderReplicaRequest customerOrderReplicaRequest, String contactNumber,
			Integer aparmentId) {

		if (customerOrderReplicaRequest.getRazorPayRequest() != null) {

//			Map razorPay = consumerService.createRazorPayOrder(customerOrderReplicaRequest.getRazorPayRequest());
//			customerOrderReplicaRequest.setOrderId(razorPay.get("order") != null ? (String)((RazorPay) razorPay.get("order")).getId() : null);	
//	
//			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);
//
//			razorPay.put("cartId", customerOrderReplicaRequest.getCartId());

			Map customerOrderReplicaMap = new HashMap<>();

			Map orderId = new HashMap<>();
			String transactionId = getMerchantTransactionId();
			orderId.put("id", transactionId);

			customerOrderReplicaMap.put("order", orderId);

			customerOrderReplicaRequest.setOrderId(transactionId);
			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);

			customerOrderReplicaMap.put("cartId", customerOrderReplicaRequest.getCartId());

			try {
				customerOrderReplicaMap.put("phonePeResponse",
						phonepeServiceImpl.initiatePhonepePayment(transactionId,
								Integer.valueOf(customerOrderReplicaRequest.getRazorPayRequest().getAmount()),
								contactNumber, customerOrderReplicaRequest.getRedirectUrl(), customerOrderReplicaRequest.getCallBackUrl()));

			} catch (Exception e) {
				e.printStackTrace();
				customerOrderReplicaMap.put("phonePeResponse", new HashedMap<>());
			}

			return customerOrderReplicaMap;

		} else {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
					"paymentDetails transcation Details are mandatory");
		}

	}

	private static String getMerchantTransactionId() {

		return "OD_" + MerchantTransactionIdGenerator.getRandomString();
	}


	@Override
	public List<CustomerOrderReplica> getCustomerOrderByMoblieNo(String contactNumber, Integer aid) {

	    Schedule latestSchedule = customerOrderReplicaDoa.getlatestschedule();

	    if (latestSchedule != null && latestSchedule.getCreationTimestamp() != null) {
	        if (latestSchedule.getStatus().equals(UserStatus.ACTIVE)) {
	            Customers customer = customerDetailsDao.getByContactNoAndApartment(contactNumber, aid);

	            if (customer != null) { // Ensure the customer exists
	                List<CustomerOrder> customerOrderList = customerOrderReplicaDoa.getListCustomerOrderByCustomerId(customer.getCtId());

	                double totalOrderAmount = 0.0;

	                if (customerOrderList != null && !customerOrderList.isEmpty()) {
	                    for (CustomerOrder customerOrder : customerOrderList) {
	                        Double orderAmount = customerOrder.getAmount();
	                        if (orderAmount != null) {
	                            totalOrderAmount += orderAmount;
	                            if(totalOrderAmount>200) {
	                            	totalOrderAmount+= customerOrder.getDelivaryCharges();
	                            }
	                            else{
	                            	(totalOrderAmount<200)
	                            }{
	                            	totalOrderAmount-= customerOrder.getDelivaryCharges();
	                            }
	                        }
	                    }

	                    // Define the minimum order amount for applying delivery charges
	                    double minimumOrderAmount = 200.0;

	                    if (totalOrderAmount < minimumOrderAmount) {
	                        System.out.println("Delivery Charges will be applicable");
	                    } else {
	                        // No delivery charges applicable
	                        System.out.println("No Delivery charges applicable");
	                    }

	                    List<CustomerOrderReplica> customerOrderReplicas = new ArrayList<>();
	                    return customerOrderReplicas;
	                } else {
	                    return Collections.emptyList();
	                }
	            } else {
	                return null; // or an appropriate value
	            }
	        } else {
	            // Handle the case when the latest schedule is not active
	            return null; // or an appropriate value
	        }
	    } else {
	        // Handle the case when there is no latest schedule or its creation timestamp is null
	        return null; // or an appropriate value
	    }
	}

}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-09-21 15:34:56.646
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-09-21 15:34:56.647
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-21 15:34:57.270
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.xyram.daydrop.serviceimpl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.transaction.Transactional;

import org.apache.commons.collections4.map.HashedMap;
import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.server.ResponseStatusException;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.xyram.daydrop.admin.model.CurrentUser;
import com.xyram.daydrop.basemodel.Base64Wrapper;
import com.xyram.daydrop.basemodel.MerchantTransactionIdGenerator;
import com.xyram.daydrop.basemodel.PhonepeSerializer;
import com.xyram.daydrop.dao.ApartmentDao;
import com.xyram.daydrop.dao.CustomerDetailsDao;
import com.xyram.daydrop.dao.CustomerOrderDao;
import com.xyram.daydrop.dao.CustomerOrderReplicaDoa;
import com.xyram.daydrop.dao.SheduleDao;
import com.xyram.daydrop.enumtypes.UserStatus;
import com.xyram.daydrop.model.Apartments;
import com.xyram.daydrop.model.CustomerOrder;
import com.xyram.daydrop.model.CustomerOrderReplica;
import com.xyram.daydrop.model.Customers;
import com.xyram.daydrop.model.Schedule;
import com.xyram.daydrop.modelMapper.PaymentInstrument;
import com.xyram.daydrop.modelMapper.PhonePePayModel;
import com.xyram.daydrop.request.CustomerOrderReplicaRequest;
import com.xyram.daydrop.response.RazorPayRequest;
import com.xyram.daydrop.service.CustomerOrderPriceService;
import com.xyram.daydrop.service.CustomerOrderReplicaService;
import com.xyram.daydrop.util.HashEncoder;
import com.xyram.daydrop.util.RazorPay;
import com.xyram.daydrop.service.ConsumerService;

@Transactional
@Service
public class CustomerOrderReplicaServiceImpl implements CustomerOrderReplicaService {

	@Autowired
	CustomerOrderReplicaDoa customerOrderReplicaDoa;

	@Autowired
	ApartmentDao apartmentDao;

	@Autowired
	SheduleDao scheduleDao;

	@Autowired
	CustomerDetailsDao customerDetailsDao;

	@Autowired
	ConsumerService consumerService;

	@Autowired
	CurrentUser currentUser;

	@Autowired
	PhonepeServiceImpl phonepeServiceImpl;

	@Value("${merchant_id}")
	private String merchantId;

	@Value("${salt_key}")
	private String saltKey;

	@Value("${salt_index}")
	private String saltIndex;

	@Override
	public Map createCustomerOrderReplicaService(CustomerOrderReplicaRequest customerOrderReplicaRequest,
			String contactNumber, Integer aparmentId)

	{

		Map response = new HashedMap<>();

		response.put("message", "success");
		CustomerOrderReplica customerOrderReplica = null;

		if (customerOrderReplicaRequest.getCartId() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "cartId is mandatory ");
		}
		long razorPayCount = 0;
		if (customerOrderReplicaRequest.getOrderId() != null) {

			razorPayCount = customerOrderReplicaDoa.getRazorPayExistByCartId(customerOrderReplicaRequest.getOrderId());
		}

		if (customerOrderReplicaRequest.getCustomerDetails() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Order Details  is mandatory ");
		}

		customerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(customerOrderReplicaRequest.getCartId(),
				contactNumber);

		if (customerOrderReplica != null) {
			customerOrderReplica.setCartId(customerOrderReplica.getCartId());

			if (customerOrderReplica.isOrdered()) {
				throw new ResponseStatusException(HttpStatus.CONFLICT, "Your Order is Placed With cart Details");
			}

//			if (razorPayCount >= 1 && !(customerOrderReplica.getRazorPayOrderId() != null
//					&& customerOrderReplica.getRazorPayOrderId().equals(customerOrderReplicaRequest.getOrderId()))) {
//				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
//			}

			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);

			customerOrderReplica.setAttempts(customerOrderReplica.getAttempts() + 1);
			customerOrderReplica.setUpdatedTime(new Date());

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		} else {

			customerOrderReplica = new CustomerOrderReplica();
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);
			customerOrderReplica.setCartId(customerOrderReplicaRequest.getCartId());
			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());

			if (razorPayCount > 0) {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
			}

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			Schedule schedule = scheduleDao.getlatestScheduleCustomers();

			if (schedule != null) {

				try {
					customerOrderReplica.setSchedule(schedule.getsId() != null ? schedule.getsId().toString() : null);
				} catch (Exception e) {
					e.printStackTrace();
				}
			} else {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
						"Sorry We Are Not Accepting Any Order Right now");

			}

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		}

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicas(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String schedule = null;

		Map filter = request.containsKey("filters") ? (Map) request.get("filters") : null;
		if (filter != null) {
			statusType = filter.containsKey("statusType") ? ((String) filter.get("statusType")).toLowerCase() : null;
			searchQuery = filter.containsKey("searchQuery") ? ((String) filter.get("searchQuery")).toLowerCase() : null;
			schedule = filter.containsKey("schedule") ? (String.valueOf(filter.get("schedule"))) : null;

		}

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplica(searchQuery, statusType, schedule);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");

				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setStreetName(
						customers.get("streetName") != null ? (String) customers.get("streetName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicasBySchedule(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String scheduleId = null;

		Schedule schedule = scheduleDao.getlatestScheduleCustomers();

		if (schedule != null) {

			try {
				scheduleId = schedule.getsId() != null ? schedule.getsId().toString() : null;
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

		statusType = request.containsKey("statusType") ? ((String) request.get("statusType")).toLowerCase() : "Success";

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplicaBySchdeule(statusType, scheduleId);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");
				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				System.out.println("customers" + customers.get("customerName"));

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public CustomerOrderReplica getCustomerOrderReplicaByCartId(String cartId) {

		CustomerOrderReplica CustomerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(cartId,
				currentUser.getContactNumber());

		ObjectMapper objectMapper = new ObjectMapper();
		try {

			// convert JSON string to Map
			Map<String, Object> customerOrderReplicaMap = objectMapper
					.readValue(CustomerOrderReplica.getCustomerOrderDetails(), Map.class);

			Object customerOrder = customerOrderReplicaMap.get("customerOrder");
			Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

			Object quanityList = items.get("quantity");
			Map customers = customerDetailsDao.getByContactNumberAndApartment(CustomerOrderReplica.getContactNumber(),
					CustomerOrderReplica.getApartmentId());

			System.out.println("customers" + customers.get("customerName"));

			// Apartments apartments =
			// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
			CustomerOrderReplica.setApartmentName(
					customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

			CustomerOrderReplica.setCustomerDetails(customers);

			CustomerOrderReplica.setCustomerOrder(customerOrder);
			CustomerOrderReplica.setQuatityList(quanityList);

		} catch (Exception e) {
			e.printStackTrace();
		}

		return CustomerOrderReplica;

	}

	@Override
	public Map createCustomerOrderReplica(CustomerOrderReplicaRequest customerOrderReplicaRequest, String contactNumber,
			Integer aparmentId) {

		if (customerOrderReplicaRequest.getRazorPayRequest() != null) {

//			Map razorPay = consumerService.createRazorPayOrder(customerOrderReplicaRequest.getRazorPayRequest());
//			customerOrderReplicaRequest.setOrderId(razorPay.get("order") != null ? (String)((RazorPay) razorPay.get("order")).getId() : null);	
//	
//			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);
//
//			razorPay.put("cartId", customerOrderReplicaRequest.getCartId());

			Map customerOrderReplicaMap = new HashMap<>();

			Map orderId = new HashMap<>();
			String transactionId = getMerchantTransactionId();
			orderId.put("id", transactionId);

			customerOrderReplicaMap.put("order", orderId);

			customerOrderReplicaRequest.setOrderId(transactionId);
			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);

			customerOrderReplicaMap.put("cartId", customerOrderReplicaRequest.getCartId());

			try {
				customerOrderReplicaMap.put("phonePeResponse",
						phonepeServiceImpl.initiatePhonepePayment(transactionId,
								Integer.valueOf(customerOrderReplicaRequest.getRazorPayRequest().getAmount()),
								contactNumber, customerOrderReplicaRequest.getRedirectUrl(), customerOrderReplicaRequest.getCallBackUrl()));

			} catch (Exception e) {
				e.printStackTrace();
				customerOrderReplicaMap.put("phonePeResponse", new HashedMap<>());
			}

			return customerOrderReplicaMap;

		} else {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
					"paymentDetails transcation Details are mandatory");
		}

	}

	private static String getMerchantTransactionId() {

		return "OD_" + MerchantTransactionIdGenerator.getRandomString();
	}


	@Override
	public List<CustomerOrderReplica> getCustomerOrderByMoblieNo(String contactNumber, Integer aid) {

	    Schedule latestSchedule = customerOrderReplicaDoa.getlatestschedule();

	    if (latestSchedule != null && latestSchedule.getCreationTimestamp() != null) {
	        if (latestSchedule.getStatus().equals(UserStatus.ACTIVE)) {
	            Customers customer = customerDetailsDao.getByContactNoAndApartment(contactNumber, aid);

	            if (customer != null) { // Ensure the customer exists
	                List<CustomerOrder> customerOrderList = customerOrderReplicaDoa.getListCustomerOrderByCustomerId(customer.getCtId());

	                double totalOrderAmount = 0.0;

	                if (customerOrderList != null && !customerOrderList.isEmpty()) {
	                    for (CustomerOrder customerOrder : customerOrderList) {
	                        Double orderAmount = customerOrder.getAmount();
	                        if (orderAmount != null) {
	                            totalOrderAmount += orderAmount;
	                            if(totalOrderAmount>200) {
	                            	totalOrderAmount+= customerOrder.getDelivaryCharges();
	                            }
	                            else{
	                            	(totalOrderAmount<200)
	                            }{
	                            	totalOrderAmount-= customerOrder.getDelivaryCharges();
	                            }
	                        }
	                    }

	                    // Define the minimum order amount for applying delivery charges
	                    double minimumOrderAmount = 200.0;

	                    if (totalOrderAmount < minimumOrderAmount) {
	                        System.out.println("Delivery Charges will be applicable");
	                    } else {
	                        // No delivery charges applicable
	                        System.out.println("No Delivery charges applicable");
	                    }

	                    List<CustomerOrderReplica> customerOrderReplicas = new ArrayList<>();
	                    return customerOrderReplicas;
	                } else {
	                    return Collections.emptyList();
	                }
	            } else {
	                return null; // or an appropriate value
	            }
	        } else {
	            // Handle the case when the latest schedule is not active
	            return null; // or an appropriate value
	        }
	    } else {
	        // Handle the case when there is no latest schedule or its creation timestamp is null
	        return null; // or an appropriate value
	    }
	}

}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-09-21 15:34:57.272
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-09-21 15:34:57.273
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-21 15:34:57.648
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.xyram.daydrop.serviceimpl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.transaction.Transactional;

import org.apache.commons.collections4.map.HashedMap;
import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.server.ResponseStatusException;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.xyram.daydrop.admin.model.CurrentUser;
import com.xyram.daydrop.basemodel.Base64Wrapper;
import com.xyram.daydrop.basemodel.MerchantTransactionIdGenerator;
import com.xyram.daydrop.basemodel.PhonepeSerializer;
import com.xyram.daydrop.dao.ApartmentDao;
import com.xyram.daydrop.dao.CustomerDetailsDao;
import com.xyram.daydrop.dao.CustomerOrderDao;
import com.xyram.daydrop.dao.CustomerOrderReplicaDoa;
import com.xyram.daydrop.dao.SheduleDao;
import com.xyram.daydrop.enumtypes.UserStatus;
import com.xyram.daydrop.model.Apartments;
import com.xyram.daydrop.model.CustomerOrder;
import com.xyram.daydrop.model.CustomerOrderReplica;
import com.xyram.daydrop.model.Customers;
import com.xyram.daydrop.model.Schedule;
import com.xyram.daydrop.modelMapper.PaymentInstrument;
import com.xyram.daydrop.modelMapper.PhonePePayModel;
import com.xyram.daydrop.request.CustomerOrderReplicaRequest;
import com.xyram.daydrop.response.RazorPayRequest;
import com.xyram.daydrop.service.CustomerOrderPriceService;
import com.xyram.daydrop.service.CustomerOrderReplicaService;
import com.xyram.daydrop.util.HashEncoder;
import com.xyram.daydrop.util.RazorPay;
import com.xyram.daydrop.service.ConsumerService;

@Transactional
@Service
public class CustomerOrderReplicaServiceImpl implements CustomerOrderReplicaService {

	@Autowired
	CustomerOrderReplicaDoa customerOrderReplicaDoa;

	@Autowired
	ApartmentDao apartmentDao;

	@Autowired
	SheduleDao scheduleDao;

	@Autowired
	CustomerDetailsDao customerDetailsDao;

	@Autowired
	ConsumerService consumerService;

	@Autowired
	CurrentUser currentUser;

	@Autowired
	PhonepeServiceImpl phonepeServiceImpl;

	@Value("${merchant_id}")
	private String merchantId;

	@Value("${salt_key}")
	private String saltKey;

	@Value("${salt_index}")
	private String saltIndex;

	@Override
	public Map createCustomerOrderReplicaService(CustomerOrderReplicaRequest customerOrderReplicaRequest,
			String contactNumber, Integer aparmentId)

	{

		Map response = new HashedMap<>();

		response.put("message", "success");
		CustomerOrderReplica customerOrderReplica = null;

		if (customerOrderReplicaRequest.getCartId() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "cartId is mandatory ");
		}
		long razorPayCount = 0;
		if (customerOrderReplicaRequest.getOrderId() != null) {

			razorPayCount = customerOrderReplicaDoa.getRazorPayExistByCartId(customerOrderReplicaRequest.getOrderId());
		}

		if (customerOrderReplicaRequest.getCustomerDetails() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Order Details  is mandatory ");
		}

		customerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(customerOrderReplicaRequest.getCartId(),
				contactNumber);

		if (customerOrderReplica != null) {
			customerOrderReplica.setCartId(customerOrderReplica.getCartId());

			if (customerOrderReplica.isOrdered()) {
				throw new ResponseStatusException(HttpStatus.CONFLICT, "Your Order is Placed With cart Details");
			}

//			if (razorPayCount >= 1 && !(customerOrderReplica.getRazorPayOrderId() != null
//					&& customerOrderReplica.getRazorPayOrderId().equals(customerOrderReplicaRequest.getOrderId()))) {
//				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
//			}

			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);

			customerOrderReplica.setAttempts(customerOrderReplica.getAttempts() + 1);
			customerOrderReplica.setUpdatedTime(new Date());

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		} else {

			customerOrderReplica = new CustomerOrderReplica();
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);
			customerOrderReplica.setCartId(customerOrderReplicaRequest.getCartId());
			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());

			if (razorPayCount > 0) {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
			}

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			Schedule schedule = scheduleDao.getlatestScheduleCustomers();

			if (schedule != null) {

				try {
					customerOrderReplica.setSchedule(schedule.getsId() != null ? schedule.getsId().toString() : null);
				} catch (Exception e) {
					e.printStackTrace();
				}
			} else {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
						"Sorry We Are Not Accepting Any Order Right now");

			}

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		}

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicas(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String schedule = null;

		Map filter = request.containsKey("filters") ? (Map) request.get("filters") : null;
		if (filter != null) {
			statusType = filter.containsKey("statusType") ? ((String) filter.get("statusType")).toLowerCase() : null;
			searchQuery = filter.containsKey("searchQuery") ? ((String) filter.get("searchQuery")).toLowerCase() : null;
			schedule = filter.containsKey("schedule") ? (String.valueOf(filter.get("schedule"))) : null;

		}

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplica(searchQuery, statusType, schedule);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");

				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setStreetName(
						customers.get("streetName") != null ? (String) customers.get("streetName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicasBySchedule(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String scheduleId = null;

		Schedule schedule = scheduleDao.getlatestScheduleCustomers();

		if (schedule != null) {

			try {
				scheduleId = schedule.getsId() != null ? schedule.getsId().toString() : null;
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

		statusType = request.containsKey("statusType") ? ((String) request.get("statusType")).toLowerCase() : "Success";

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplicaBySchdeule(statusType, scheduleId);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");
				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				System.out.println("customers" + customers.get("customerName"));

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public CustomerOrderReplica getCustomerOrderReplicaByCartId(String cartId) {

		CustomerOrderReplica CustomerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(cartId,
				currentUser.getContactNumber());

		ObjectMapper objectMapper = new ObjectMapper();
		try {

			// convert JSON string to Map
			Map<String, Object> customerOrderReplicaMap = objectMapper
					.readValue(CustomerOrderReplica.getCustomerOrderDetails(), Map.class);

			Object customerOrder = customerOrderReplicaMap.get("customerOrder");
			Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

			Object quanityList = items.get("quantity");
			Map customers = customerDetailsDao.getByContactNumberAndApartment(CustomerOrderReplica.getContactNumber(),
					CustomerOrderReplica.getApartmentId());

			System.out.println("customers" + customers.get("customerName"));

			// Apartments apartments =
			// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
			CustomerOrderReplica.setApartmentName(
					customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

			CustomerOrderReplica.setCustomerDetails(customers);

			CustomerOrderReplica.setCustomerOrder(customerOrder);
			CustomerOrderReplica.setQuatityList(quanityList);

		} catch (Exception e) {
			e.printStackTrace();
		}

		return CustomerOrderReplica;

	}

	@Override
	public Map createCustomerOrderReplica(CustomerOrderReplicaRequest customerOrderReplicaRequest, String contactNumber,
			Integer aparmentId) {

		if (customerOrderReplicaRequest.getRazorPayRequest() != null) {

//			Map razorPay = consumerService.createRazorPayOrder(customerOrderReplicaRequest.getRazorPayRequest());
//			customerOrderReplicaRequest.setOrderId(razorPay.get("order") != null ? (String)((RazorPay) razorPay.get("order")).getId() : null);	
//	
//			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);
//
//			razorPay.put("cartId", customerOrderReplicaRequest.getCartId());

			Map customerOrderReplicaMap = new HashMap<>();

			Map orderId = new HashMap<>();
			String transactionId = getMerchantTransactionId();
			orderId.put("id", transactionId);

			customerOrderReplicaMap.put("order", orderId);

			customerOrderReplicaRequest.setOrderId(transactionId);
			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);

			customerOrderReplicaMap.put("cartId", customerOrderReplicaRequest.getCartId());

			try {
				customerOrderReplicaMap.put("phonePeResponse",
						phonepeServiceImpl.initiatePhonepePayment(transactionId,
								Integer.valueOf(customerOrderReplicaRequest.getRazorPayRequest().getAmount()),
								contactNumber, customerOrderReplicaRequest.getRedirectUrl(), customerOrderReplicaRequest.getCallBackUrl()));

			} catch (Exception e) {
				e.printStackTrace();
				customerOrderReplicaMap.put("phonePeResponse", new HashedMap<>());
			}

			return customerOrderReplicaMap;

		} else {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
					"paymentDetails transcation Details are mandatory");
		}

	}

	private static String getMerchantTransactionId() {

		return "OD_" + MerchantTransactionIdGenerator.getRandomString();
	}


	@Override
	public List<CustomerOrderReplica> getCustomerOrderByMoblieNo(String contactNumber, Integer aid) {

	    Schedule latestSchedule = customerOrderReplicaDoa.getlatestschedule();

	    if (latestSchedule != null && latestSchedule.getCreationTimestamp() != null) {
	        if (latestSchedule.getStatus().equals(UserStatus.ACTIVE)) {
	            Customers customer = customerDetailsDao.getByContactNoAndApartment(contactNumber, aid);

	            if (customer != null) { // Ensure the customer exists
	                List<CustomerOrder> customerOrderList = customerOrderReplicaDoa.getListCustomerOrderByCustomerId(customer.getCtId());

	                double totalOrderAmount = 0.0;

	                if (customerOrderList != null && !customerOrderList.isEmpty()) {
	                    for (CustomerOrder customerOrder : customerOrderList) {
	                        Double orderAmount = customerOrder.getAmount();
	                        if (orderAmount != null) {
	                            totalOrderAmount += orderAmount;
	                            if(totalOrderAmount>200) {
	                            	totalOrderAmount+= customerOrder.getDelivaryCharges();
	                            }
	                            else{
	                            	(totalOrderAmount<200)
	                            }{
	                            	totalOrderAmount-= customerOrder.getDelivaryCharges();
	                            }
	                        }
	                    }

	                    // Define the minimum order amount for applying delivery charges
	                    double minimumOrderAmount = 200.0;

	                    if (totalOrderAmount < minimumOrderAmount) {
	                        System.out.println("Delivery Charges will be applicable");
	                    } else {
	                        // No delivery charges applicable
	                        System.out.println("No Delivery charges applicable");
	                    }

	                    List<CustomerOrderReplica> customerOrderReplicas = new ArrayList<>();
	                    return customerOrderReplicas;
	                } else {
	                    return Collections.emptyList();
	                }
	            } else {
	                return null; // or an appropriate value
	            }
	        } else {
	            // Handle the case when the latest schedule is not active
	            return null; // or an appropriate value
	        }
	    } else {
	        // Handle the case when there is no latest schedule or its creation timestamp is null
	        return null; // or an appropriate value
	    }
	}

}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-09-21 15:34:57.649
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-09-21 15:34:57.651
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-21 15:34:58.740
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.xyram.daydrop.serviceimpl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.transaction.Transactional;

import org.apache.commons.collections4.map.HashedMap;
import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.server.ResponseStatusException;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.xyram.daydrop.admin.model.CurrentUser;
import com.xyram.daydrop.basemodel.Base64Wrapper;
import com.xyram.daydrop.basemodel.MerchantTransactionIdGenerator;
import com.xyram.daydrop.basemodel.PhonepeSerializer;
import com.xyram.daydrop.dao.ApartmentDao;
import com.xyram.daydrop.dao.CustomerDetailsDao;
import com.xyram.daydrop.dao.CustomerOrderDao;
import com.xyram.daydrop.dao.CustomerOrderReplicaDoa;
import com.xyram.daydrop.dao.SheduleDao;
import com.xyram.daydrop.enumtypes.UserStatus;
import com.xyram.daydrop.model.Apartments;
import com.xyram.daydrop.model.CustomerOrder;
import com.xyram.daydrop.model.CustomerOrderReplica;
import com.xyram.daydrop.model.Customers;
import com.xyram.daydrop.model.Schedule;
import com.xyram.daydrop.modelMapper.PaymentInstrument;
import com.xyram.daydrop.modelMapper.PhonePePayModel;
import com.xyram.daydrop.request.CustomerOrderReplicaRequest;
import com.xyram.daydrop.response.RazorPayRequest;
import com.xyram.daydrop.service.CustomerOrderPriceService;
import com.xyram.daydrop.service.CustomerOrderReplicaService;
import com.xyram.daydrop.util.HashEncoder;
import com.xyram.daydrop.util.RazorPay;
import com.xyram.daydrop.service.ConsumerService;

@Transactional
@Service
public class CustomerOrderReplicaServiceImpl implements CustomerOrderReplicaService {

	@Autowired
	CustomerOrderReplicaDoa customerOrderReplicaDoa;

	@Autowired
	ApartmentDao apartmentDao;

	@Autowired
	SheduleDao scheduleDao;

	@Autowired
	CustomerDetailsDao customerDetailsDao;

	@Autowired
	ConsumerService consumerService;

	@Autowired
	CurrentUser currentUser;

	@Autowired
	PhonepeServiceImpl phonepeServiceImpl;

	@Value("${merchant_id}")
	private String merchantId;

	@Value("${salt_key}")
	private String saltKey;

	@Value("${salt_index}")
	private String saltIndex;

	@Override
	public Map createCustomerOrderReplicaService(CustomerOrderReplicaRequest customerOrderReplicaRequest,
			String contactNumber, Integer aparmentId)

	{

		Map response = new HashedMap<>();

		response.put("message", "success");
		CustomerOrderReplica customerOrderReplica = null;

		if (customerOrderReplicaRequest.getCartId() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "cartId is mandatory ");
		}
		long razorPayCount = 0;
		if (customerOrderReplicaRequest.getOrderId() != null) {

			razorPayCount = customerOrderReplicaDoa.getRazorPayExistByCartId(customerOrderReplicaRequest.getOrderId());
		}

		if (customerOrderReplicaRequest.getCustomerDetails() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Order Details  is mandatory ");
		}

		customerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(customerOrderReplicaRequest.getCartId(),
				contactNumber);

		if (customerOrderReplica != null) {
			customerOrderReplica.setCartId(customerOrderReplica.getCartId());

			if (customerOrderReplica.isOrdered()) {
				throw new ResponseStatusException(HttpStatus.CONFLICT, "Your Order is Placed With cart Details");
			}

//			if (razorPayCount >= 1 && !(customerOrderReplica.getRazorPayOrderId() != null
//					&& customerOrderReplica.getRazorPayOrderId().equals(customerOrderReplicaRequest.getOrderId()))) {
//				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
//			}

			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);

			customerOrderReplica.setAttempts(customerOrderReplica.getAttempts() + 1);
			customerOrderReplica.setUpdatedTime(new Date());

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		} else {

			customerOrderReplica = new CustomerOrderReplica();
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);
			customerOrderReplica.setCartId(customerOrderReplicaRequest.getCartId());
			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());

			if (razorPayCount > 0) {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
			}

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			Schedule schedule = scheduleDao.getlatestScheduleCustomers();

			if (schedule != null) {

				try {
					customerOrderReplica.setSchedule(schedule.getsId() != null ? schedule.getsId().toString() : null);
				} catch (Exception e) {
					e.printStackTrace();
				}
			} else {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
						"Sorry We Are Not Accepting Any Order Right now");

			}

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		}

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicas(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String schedule = null;

		Map filter = request.containsKey("filters") ? (Map) request.get("filters") : null;
		if (filter != null) {
			statusType = filter.containsKey("statusType") ? ((String) filter.get("statusType")).toLowerCase() : null;
			searchQuery = filter.containsKey("searchQuery") ? ((String) filter.get("searchQuery")).toLowerCase() : null;
			schedule = filter.containsKey("schedule") ? (String.valueOf(filter.get("schedule"))) : null;

		}

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplica(searchQuery, statusType, schedule);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");

				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setStreetName(
						customers.get("streetName") != null ? (String) customers.get("streetName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicasBySchedule(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String scheduleId = null;

		Schedule schedule = scheduleDao.getlatestScheduleCustomers();

		if (schedule != null) {

			try {
				scheduleId = schedule.getsId() != null ? schedule.getsId().toString() : null;
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

		statusType = request.containsKey("statusType") ? ((String) request.get("statusType")).toLowerCase() : "Success";

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplicaBySchdeule(statusType, scheduleId);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");
				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				System.out.println("customers" + customers.get("customerName"));

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public CustomerOrderReplica getCustomerOrderReplicaByCartId(String cartId) {

		CustomerOrderReplica CustomerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(cartId,
				currentUser.getContactNumber());

		ObjectMapper objectMapper = new ObjectMapper();
		try {

			// convert JSON string to Map
			Map<String, Object> customerOrderReplicaMap = objectMapper
					.readValue(CustomerOrderReplica.getCustomerOrderDetails(), Map.class);

			Object customerOrder = customerOrderReplicaMap.get("customerOrder");
			Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

			Object quanityList = items.get("quantity");
			Map customers = customerDetailsDao.getByContactNumberAndApartment(CustomerOrderReplica.getContactNumber(),
					CustomerOrderReplica.getApartmentId());

			System.out.println("customers" + customers.get("customerName"));

			// Apartments apartments =
			// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
			CustomerOrderReplica.setApartmentName(
					customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

			CustomerOrderReplica.setCustomerDetails(customers);

			CustomerOrderReplica.setCustomerOrder(customerOrder);
			CustomerOrderReplica.setQuatityList(quanityList);

		} catch (Exception e) {
			e.printStackTrace();
		}

		return CustomerOrderReplica;

	}

	@Override
	public Map createCustomerOrderReplica(CustomerOrderReplicaRequest customerOrderReplicaRequest, String contactNumber,
			Integer aparmentId) {

		if (customerOrderReplicaRequest.getRazorPayRequest() != null) {

//			Map razorPay = consumerService.createRazorPayOrder(customerOrderReplicaRequest.getRazorPayRequest());
//			customerOrderReplicaRequest.setOrderId(razorPay.get("order") != null ? (String)((RazorPay) razorPay.get("order")).getId() : null);	
//	
//			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);
//
//			razorPay.put("cartId", customerOrderReplicaRequest.getCartId());

			Map customerOrderReplicaMap = new HashMap<>();

			Map orderId = new HashMap<>();
			String transactionId = getMerchantTransactionId();
			orderId.put("id", transactionId);

			customerOrderReplicaMap.put("order", orderId);

			customerOrderReplicaRequest.setOrderId(transactionId);
			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);

			customerOrderReplicaMap.put("cartId", customerOrderReplicaRequest.getCartId());

			try {
				customerOrderReplicaMap.put("phonePeResponse",
						phonepeServiceImpl.initiatePhonepePayment(transactionId,
								Integer.valueOf(customerOrderReplicaRequest.getRazorPayRequest().getAmount()),
								contactNumber, customerOrderReplicaRequest.getRedirectUrl(), customerOrderReplicaRequest.getCallBackUrl()));

			} catch (Exception e) {
				e.printStackTrace();
				customerOrderReplicaMap.put("phonePeResponse", new HashedMap<>());
			}

			return customerOrderReplicaMap;

		} else {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
					"paymentDetails transcation Details are mandatory");
		}

	}

	private static String getMerchantTransactionId() {

		return "OD_" + MerchantTransactionIdGenerator.getRandomString();
	}


	@Override
	public List<CustomerOrderReplica> getCustomerOrderByMoblieNo(String contactNumber, Integer aid) {

	    Schedule latestSchedule = customerOrderReplicaDoa.getlatestschedule();

	    if (latestSchedule != null && latestSchedule.getCreationTimestamp() != null) {
	        if (latestSchedule.getStatus().equals(UserStatus.ACTIVE)) {
	            Customers customer = customerDetailsDao.getByContactNoAndApartment(contactNumber, aid);

	            if (customer != null) { // Ensure the customer exists
	                List<CustomerOrder> customerOrderList = customerOrderReplicaDoa.getListCustomerOrderByCustomerId(customer.getCtId());

	                double totalOrderAmount = 0.0;

	                if (customerOrderList != null && !customerOrderList.isEmpty()) {
	                    for (CustomerOrder customerOrder : customerOrderList) {
	                        Double orderAmount = customerOrder.getAmount();
	                        if (orderAmount != null) {
	                            totalOrderAmount += orderAmount;
	                            if(totalOrderAmount>200) {
	                            	totalOrderAmount+= customerOrder.getDelivaryCharges();
	                            }
	                            else{
	                            	(totalOrderAmount<200)
	                            }{
	                            	totalOrderAmount-= customerOrder.getDelivaryCharges();
	                            }
	                        }
	                    }

	                    // Define the minimum order amount for applying delivery charges
	                    double minimumOrderAmount = 200.0;

	                    if (totalOrderAmount < minimumOrderAmount) {
	                        System.out.println("Delivery Charges will be applicable");
	                    } else {
	                        // No delivery charges applicable
	                        System.out.println("No Delivery charges applicable");
	                    }

	                    List<CustomerOrderReplica> customerOrderReplicas = new ArrayList<>();
	                    return customerOrderReplicas;
	                } else {
	                    return Collections.emptyList();
	                }
	            } else {
	                return null; // or an appropriate value
	            }
	        } else {
	            // Handle the case when the latest schedule is not active
	            return null; // or an appropriate value
	        }
	    } else {
	        // Handle the case when there is no latest schedule or its creation timestamp is null
	        return null; // or an appropriate value
	    }
	}

}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-09-21 15:34:58.742
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-09-21 15:34:58.743
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-21 15:35:01.020
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.xyram.daydrop.serviceimpl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.transaction.Transactional;

import org.apache.commons.collections4.map.HashedMap;
import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.server.ResponseStatusException;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.xyram.daydrop.admin.model.CurrentUser;
import com.xyram.daydrop.basemodel.Base64Wrapper;
import com.xyram.daydrop.basemodel.MerchantTransactionIdGenerator;
import com.xyram.daydrop.basemodel.PhonepeSerializer;
import com.xyram.daydrop.dao.ApartmentDao;
import com.xyram.daydrop.dao.CustomerDetailsDao;
import com.xyram.daydrop.dao.CustomerOrderDao;
import com.xyram.daydrop.dao.CustomerOrderReplicaDoa;
import com.xyram.daydrop.dao.SheduleDao;
import com.xyram.daydrop.enumtypes.UserStatus;
import com.xyram.daydrop.model.Apartments;
import com.xyram.daydrop.model.CustomerOrder;
import com.xyram.daydrop.model.CustomerOrderReplica;
import com.xyram.daydrop.model.Customers;
import com.xyram.daydrop.model.Schedule;
import com.xyram.daydrop.modelMapper.PaymentInstrument;
import com.xyram.daydrop.modelMapper.PhonePePayModel;
import com.xyram.daydrop.request.CustomerOrderReplicaRequest;
import com.xyram.daydrop.response.RazorPayRequest;
import com.xyram.daydrop.service.CustomerOrderPriceService;
import com.xyram.daydrop.service.CustomerOrderReplicaService;
import com.xyram.daydrop.util.HashEncoder;
import com.xyram.daydrop.util.RazorPay;
import com.xyram.daydrop.service.ConsumerService;

@Transactional
@Service
public class CustomerOrderReplicaServiceImpl implements CustomerOrderReplicaService {

	@Autowired
	CustomerOrderReplicaDoa customerOrderReplicaDoa;

	@Autowired
	ApartmentDao apartmentDao;

	@Autowired
	SheduleDao scheduleDao;

	@Autowired
	CustomerDetailsDao customerDetailsDao;

	@Autowired
	ConsumerService consumerService;

	@Autowired
	CurrentUser currentUser;

	@Autowired
	PhonepeServiceImpl phonepeServiceImpl;

	@Value("${merchant_id}")
	private String merchantId;

	@Value("${salt_key}")
	private String saltKey;

	@Value("${salt_index}")
	private String saltIndex;

	@Override
	public Map createCustomerOrderReplicaService(CustomerOrderReplicaRequest customerOrderReplicaRequest,
			String contactNumber, Integer aparmentId)

	{

		Map response = new HashedMap<>();

		response.put("message", "success");
		CustomerOrderReplica customerOrderReplica = null;

		if (customerOrderReplicaRequest.getCartId() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "cartId is mandatory ");
		}
		long razorPayCount = 0;
		if (customerOrderReplicaRequest.getOrderId() != null) {

			razorPayCount = customerOrderReplicaDoa.getRazorPayExistByCartId(customerOrderReplicaRequest.getOrderId());
		}

		if (customerOrderReplicaRequest.getCustomerDetails() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Order Details  is mandatory ");
		}

		customerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(customerOrderReplicaRequest.getCartId(),
				contactNumber);

		if (customerOrderReplica != null) {
			customerOrderReplica.setCartId(customerOrderReplica.getCartId());

			if (customerOrderReplica.isOrdered()) {
				throw new ResponseStatusException(HttpStatus.CONFLICT, "Your Order is Placed With cart Details");
			}

//			if (razorPayCount >= 1 && !(customerOrderReplica.getRazorPayOrderId() != null
//					&& customerOrderReplica.getRazorPayOrderId().equals(customerOrderReplicaRequest.getOrderId()))) {
//				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
//			}

			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);

			customerOrderReplica.setAttempts(customerOrderReplica.getAttempts() + 1);
			customerOrderReplica.setUpdatedTime(new Date());

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		} else {

			customerOrderReplica = new CustomerOrderReplica();
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);
			customerOrderReplica.setCartId(customerOrderReplicaRequest.getCartId());
			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());

			if (razorPayCount > 0) {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
			}

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			Schedule schedule = scheduleDao.getlatestScheduleCustomers();

			if (schedule != null) {

				try {
					customerOrderReplica.setSchedule(schedule.getsId() != null ? schedule.getsId().toString() : null);
				} catch (Exception e) {
					e.printStackTrace();
				}
			} else {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
						"Sorry We Are Not Accepting Any Order Right now");

			}

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		}

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicas(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String schedule = null;

		Map filter = request.containsKey("filters") ? (Map) request.get("filters") : null;
		if (filter != null) {
			statusType = filter.containsKey("statusType") ? ((String) filter.get("statusType")).toLowerCase() : null;
			searchQuery = filter.containsKey("searchQuery") ? ((String) filter.get("searchQuery")).toLowerCase() : null;
			schedule = filter.containsKey("schedule") ? (String.valueOf(filter.get("schedule"))) : null;

		}

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplica(searchQuery, statusType, schedule);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");

				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setStreetName(
						customers.get("streetName") != null ? (String) customers.get("streetName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicasBySchedule(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String scheduleId = null;

		Schedule schedule = scheduleDao.getlatestScheduleCustomers();

		if (schedule != null) {

			try {
				scheduleId = schedule.getsId() != null ? schedule.getsId().toString() : null;
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

		statusType = request.containsKey("statusType") ? ((String) request.get("statusType")).toLowerCase() : "Success";

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplicaBySchdeule(statusType, scheduleId);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");
				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				System.out.println("customers" + customers.get("customerName"));

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public CustomerOrderReplica getCustomerOrderReplicaByCartId(String cartId) {

		CustomerOrderReplica CustomerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(cartId,
				currentUser.getContactNumber());

		ObjectMapper objectMapper = new ObjectMapper();
		try {

			// convert JSON string to Map
			Map<String, Object> customerOrderReplicaMap = objectMapper
					.readValue(CustomerOrderReplica.getCustomerOrderDetails(), Map.class);

			Object customerOrder = customerOrderReplicaMap.get("customerOrder");
			Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

			Object quanityList = items.get("quantity");
			Map customers = customerDetailsDao.getByContactNumberAndApartment(CustomerOrderReplica.getContactNumber(),
					CustomerOrderReplica.getApartmentId());

			System.out.println("customers" + customers.get("customerName"));

			// Apartments apartments =
			// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
			CustomerOrderReplica.setApartmentName(
					customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

			CustomerOrderReplica.setCustomerDetails(customers);

			CustomerOrderReplica.setCustomerOrder(customerOrder);
			CustomerOrderReplica.setQuatityList(quanityList);

		} catch (Exception e) {
			e.printStackTrace();
		}

		return CustomerOrderReplica;

	}

	@Override
	public Map createCustomerOrderReplica(CustomerOrderReplicaRequest customerOrderReplicaRequest, String contactNumber,
			Integer aparmentId) {

		if (customerOrderReplicaRequest.getRazorPayRequest() != null) {

//			Map razorPay = consumerService.createRazorPayOrder(customerOrderReplicaRequest.getRazorPayRequest());
//			customerOrderReplicaRequest.setOrderId(razorPay.get("order") != null ? (String)((RazorPay) razorPay.get("order")).getId() : null);	
//	
//			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);
//
//			razorPay.put("cartId", customerOrderReplicaRequest.getCartId());

			Map customerOrderReplicaMap = new HashMap<>();

			Map orderId = new HashMap<>();
			String transactionId = getMerchantTransactionId();
			orderId.put("id", transactionId);

			customerOrderReplicaMap.put("order", orderId);

			customerOrderReplicaRequest.setOrderId(transactionId);
			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);

			customerOrderReplicaMap.put("cartId", customerOrderReplicaRequest.getCartId());

			try {
				customerOrderReplicaMap.put("phonePeResponse",
						phonepeServiceImpl.initiatePhonepePayment(transactionId,
								Integer.valueOf(customerOrderReplicaRequest.getRazorPayRequest().getAmount()),
								contactNumber, customerOrderReplicaRequest.getRedirectUrl(), customerOrderReplicaRequest.getCallBackUrl()));

			} catch (Exception e) {
				e.printStackTrace();
				customerOrderReplicaMap.put("phonePeResponse", new HashedMap<>());
			}

			return customerOrderReplicaMap;

		} else {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
					"paymentDetails transcation Details are mandatory");
		}

	}

	private static String getMerchantTransactionId() {

		return "OD_" + MerchantTransactionIdGenerator.getRandomString();
	}


	@Override
	public List<CustomerOrderReplica> getCustomerOrderByMoblieNo(String contactNumber, Integer aid) {

	    Schedule latestSchedule = customerOrderReplicaDoa.getlatestschedule();

	    if (latestSchedule != null && latestSchedule.getCreationTimestamp() != null) {
	        if (latestSchedule.getStatus().equals(UserStatus.ACTIVE)) {
	            Customers customer = customerDetailsDao.getByContactNoAndApartment(contactNumber, aid);

	            if (customer != null) { // Ensure the customer exists
	                List<CustomerOrder> customerOrderList = customerOrderReplicaDoa.getListCustomerOrderByCustomerId(customer.getCtId());

	                double totalOrderAmount = 0.0;

	                if (customerOrderList != null && !customerOrderList.isEmpty()) {
	                    for (CustomerOrder customerOrder : customerOrderList) {
	                        Double orderAmount = customerOrder.getAmount();
	                        if (orderAmount != null) {
	                            totalOrderAmount += orderAmount;
	                            if(totalOrderAmount>200) {
	                            	totalOrderAmount+= customerOrder.getDelivaryCharges();
	                            }
	                            else{
	                            	(totalOrderAmount<200)
	                            }{
	                            	totalOrderAmount-= customerOrder.getDelivaryCharges();
	                            }
	                        }
	                    }

	                    // Define the minimum order amount for applying delivery charges
	                    double minimumOrderAmount = 200.0;

	                    if (totalOrderAmount < minimumOrderAmount) {
	                        System.out.println("Delivery Charges will be applicable");
	                    } else {
	                        // No delivery charges applicable
	                        System.out.println("No Delivery charges applicable");
	                    }

	                    List<CustomerOrderReplica> customerOrderReplicas = new ArrayList<>();
	                    return customerOrderReplicas;
	                } else {
	                    return Collections.emptyList();
	                }
	            } else {
	                return null; // or an appropriate value
	            }
	        } else {
	            // Handle the case when the latest schedule is not active
	            return null; // or an appropriate value
	        }
	    } else {
	        // Handle the case when there is no latest schedule or its creation timestamp is null
	        return null; // or an appropriate value
	    }
	}

}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.getClipboardData(ClipboardOperationAction.java:479)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.doCutCopyWithImportsOperation(ClipboardOperationAction.java:406)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.internalDoOperation(ClipboardOperationAction.java:365)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.run(ClipboardOperationAction.java:286)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:121)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:97)
	at jdk.internal.reflect.GeneratedMethodAccessor79.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:317)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:251)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:173)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:156)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:488)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:487)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:213)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:308)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:580)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:647)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:439)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:96)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1280)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1062)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1087)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1072)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1114)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1110)
	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1539)
	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4868)
	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:345)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4746)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5015)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3630)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-09-21 15:35:01.022
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.getClipboardData(ClipboardOperationAction.java:479)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.doCutCopyWithImportsOperation(ClipboardOperationAction.java:406)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.internalDoOperation(ClipboardOperationAction.java:365)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.run(ClipboardOperationAction.java:286)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:121)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:97)
	at jdk.internal.reflect.GeneratedMethodAccessor79.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:317)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:251)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:173)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:156)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:488)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:487)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:213)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:308)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:580)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:647)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:439)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:96)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1280)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1062)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1087)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1072)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1114)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1110)
	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1539)
	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4868)
	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:345)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4746)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5015)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3630)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-09-21 15:35:01.024
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.getClipboardData(ClipboardOperationAction.java:479)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.doCutCopyWithImportsOperation(ClipboardOperationAction.java:406)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.internalDoOperation(ClipboardOperationAction.java:365)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.run(ClipboardOperationAction.java:286)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:121)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:97)
	at jdk.internal.reflect.GeneratedMethodAccessor79.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:317)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:251)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:173)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:156)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:488)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:487)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:213)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:308)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:580)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:647)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:439)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:96)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1280)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1062)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1087)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1072)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1114)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1110)
	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1539)
	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4868)
	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:345)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4746)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5015)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3630)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-21 15:35:01.581
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.xyram.daydrop.serviceimpl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.transaction.Transactional;

import org.apache.commons.collections4.map.HashedMap;
import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.server.ResponseStatusException;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.xyram.daydrop.admin.model.CurrentUser;
import com.xyram.daydrop.basemodel.Base64Wrapper;
import com.xyram.daydrop.basemodel.MerchantTransactionIdGenerator;
import com.xyram.daydrop.basemodel.PhonepeSerializer;
import com.xyram.daydrop.dao.ApartmentDao;
import com.xyram.daydrop.dao.CustomerDetailsDao;
import com.xyram.daydrop.dao.CustomerOrderDao;
import com.xyram.daydrop.dao.CustomerOrderReplicaDoa;
import com.xyram.daydrop.dao.SheduleDao;
import com.xyram.daydrop.enumtypes.UserStatus;
import com.xyram.daydrop.model.Apartments;
import com.xyram.daydrop.model.CustomerOrder;
import com.xyram.daydrop.model.CustomerOrderReplica;
import com.xyram.daydrop.model.Customers;
import com.xyram.daydrop.model.Schedule;
import com.xyram.daydrop.modelMapper.PaymentInstrument;
import com.xyram.daydrop.modelMapper.PhonePePayModel;
import com.xyram.daydrop.request.CustomerOrderReplicaRequest;
import com.xyram.daydrop.response.RazorPayRequest;
import com.xyram.daydrop.service.CustomerOrderPriceService;
import com.xyram.daydrop.service.CustomerOrderReplicaService;
import com.xyram.daydrop.util.HashEncoder;
import com.xyram.daydrop.util.RazorPay;
import com.xyram.daydrop.service.ConsumerService;

@Transactional
@Service
public class CustomerOrderReplicaServiceImpl implements CustomerOrderReplicaService {

	@Autowired
	CustomerOrderReplicaDoa customerOrderReplicaDoa;

	@Autowired
	ApartmentDao apartmentDao;

	@Autowired
	SheduleDao scheduleDao;

	@Autowired
	CustomerDetailsDao customerDetailsDao;

	@Autowired
	ConsumerService consumerService;

	@Autowired
	CurrentUser currentUser;

	@Autowired
	PhonepeServiceImpl phonepeServiceImpl;

	@Value("${merchant_id}")
	private String merchantId;

	@Value("${salt_key}")
	private String saltKey;

	@Value("${salt_index}")
	private String saltIndex;

	@Override
	public Map createCustomerOrderReplicaService(CustomerOrderReplicaRequest customerOrderReplicaRequest,
			String contactNumber, Integer aparmentId)

	{

		Map response = new HashedMap<>();

		response.put("message", "success");
		CustomerOrderReplica customerOrderReplica = null;

		if (customerOrderReplicaRequest.getCartId() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "cartId is mandatory ");
		}
		long razorPayCount = 0;
		if (customerOrderReplicaRequest.getOrderId() != null) {

			razorPayCount = customerOrderReplicaDoa.getRazorPayExistByCartId(customerOrderReplicaRequest.getOrderId());
		}

		if (customerOrderReplicaRequest.getCustomerDetails() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Order Details  is mandatory ");
		}

		customerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(customerOrderReplicaRequest.getCartId(),
				contactNumber);

		if (customerOrderReplica != null) {
			customerOrderReplica.setCartId(customerOrderReplica.getCartId());

			if (customerOrderReplica.isOrdered()) {
				throw new ResponseStatusException(HttpStatus.CONFLICT, "Your Order is Placed With cart Details");
			}

//			if (razorPayCount >= 1 && !(customerOrderReplica.getRazorPayOrderId() != null
//					&& customerOrderReplica.getRazorPayOrderId().equals(customerOrderReplicaRequest.getOrderId()))) {
//				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
//			}

			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);

			customerOrderReplica.setAttempts(customerOrderReplica.getAttempts() + 1);
			customerOrderReplica.setUpdatedTime(new Date());

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		} else {

			customerOrderReplica = new CustomerOrderReplica();
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);
			customerOrderReplica.setCartId(customerOrderReplicaRequest.getCartId());
			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());

			if (razorPayCount > 0) {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
			}

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			Schedule schedule = scheduleDao.getlatestScheduleCustomers();

			if (schedule != null) {

				try {
					customerOrderReplica.setSchedule(schedule.getsId() != null ? schedule.getsId().toString() : null);
				} catch (Exception e) {
					e.printStackTrace();
				}
			} else {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
						"Sorry We Are Not Accepting Any Order Right now");

			}

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		}

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicas(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String schedule = null;

		Map filter = request.containsKey("filters") ? (Map) request.get("filters") : null;
		if (filter != null) {
			statusType = filter.containsKey("statusType") ? ((String) filter.get("statusType")).toLowerCase() : null;
			searchQuery = filter.containsKey("searchQuery") ? ((String) filter.get("searchQuery")).toLowerCase() : null;
			schedule = filter.containsKey("schedule") ? (String.valueOf(filter.get("schedule"))) : null;

		}

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplica(searchQuery, statusType, schedule);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");

				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setStreetName(
						customers.get("streetName") != null ? (String) customers.get("streetName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicasBySchedule(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String scheduleId = null;

		Schedule schedule = scheduleDao.getlatestScheduleCustomers();

		if (schedule != null) {

			try {
				scheduleId = schedule.getsId() != null ? schedule.getsId().toString() : null;
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

		statusType = request.containsKey("statusType") ? ((String) request.get("statusType")).toLowerCase() : "Success";

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplicaBySchdeule(statusType, scheduleId);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");
				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				System.out.println("customers" + customers.get("customerName"));

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public CustomerOrderReplica getCustomerOrderReplicaByCartId(String cartId) {

		CustomerOrderReplica CustomerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(cartId,
				currentUser.getContactNumber());

		ObjectMapper objectMapper = new ObjectMapper();
		try {

			// convert JSON string to Map
			Map<String, Object> customerOrderReplicaMap = objectMapper
					.readValue(CustomerOrderReplica.getCustomerOrderDetails(), Map.class);

			Object customerOrder = customerOrderReplicaMap.get("customerOrder");
			Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

			Object quanityList = items.get("quantity");
			Map customers = customerDetailsDao.getByContactNumberAndApartment(CustomerOrderReplica.getContactNumber(),
					CustomerOrderReplica.getApartmentId());

			System.out.println("customers" + customers.get("customerName"));

			// Apartments apartments =
			// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
			CustomerOrderReplica.setApartmentName(
					customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

			CustomerOrderReplica.setCustomerDetails(customers);

			CustomerOrderReplica.setCustomerOrder(customerOrder);
			CustomerOrderReplica.setQuatityList(quanityList);

		} catch (Exception e) {
			e.printStackTrace();
		}

		return CustomerOrderReplica;

	}

	@Override
	public Map createCustomerOrderReplica(CustomerOrderReplicaRequest customerOrderReplicaRequest, String contactNumber,
			Integer aparmentId) {

		if (customerOrderReplicaRequest.getRazorPayRequest() != null) {

//			Map razorPay = consumerService.createRazorPayOrder(customerOrderReplicaRequest.getRazorPayRequest());
//			customerOrderReplicaRequest.setOrderId(razorPay.get("order") != null ? (String)((RazorPay) razorPay.get("order")).getId() : null);	
//	
//			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);
//
//			razorPay.put("cartId", customerOrderReplicaRequest.getCartId());

			Map customerOrderReplicaMap = new HashMap<>();

			Map orderId = new HashMap<>();
			String transactionId = getMerchantTransactionId();
			orderId.put("id", transactionId);

			customerOrderReplicaMap.put("order", orderId);

			customerOrderReplicaRequest.setOrderId(transactionId);
			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);

			customerOrderReplicaMap.put("cartId", customerOrderReplicaRequest.getCartId());

			try {
				customerOrderReplicaMap.put("phonePeResponse",
						phonepeServiceImpl.initiatePhonepePayment(transactionId,
								Integer.valueOf(customerOrderReplicaRequest.getRazorPayRequest().getAmount()),
								contactNumber, customerOrderReplicaRequest.getRedirectUrl(), customerOrderReplicaRequest.getCallBackUrl()));

			} catch (Exception e) {
				e.printStackTrace();
				customerOrderReplicaMap.put("phonePeResponse", new HashedMap<>());
			}

			return customerOrderReplicaMap;

		} else {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
					"paymentDetails transcation Details are mandatory");
		}

	}

	private static String getMerchantTransactionId() {

		return "OD_" + MerchantTransactionIdGenerator.getRandomString();
	}


	@Override
	public List<CustomerOrderReplica> getCustomerOrderByMoblieNo(String contactNumber, Integer aid) {

	    Schedule latestSchedule = customerOrderReplicaDoa.getlatestschedule();

	    if (latestSchedule != null && latestSchedule.getCreationTimestamp() != null) {
	        if (latestSchedule.getStatus().equals(UserStatus.ACTIVE)) {
	            Customers customer = customerDetailsDao.getByContactNoAndApartment(contactNumber, aid);

	            if (customer != null) { // Ensure the customer exists
	                List<CustomerOrder> customerOrderList = customerOrderReplicaDoa.getListCustomerOrderByCustomerId(customer.getCtId());

	                double totalOrderAmount = 0.0;

	                if (customerOrderList != null && !customerOrderList.isEmpty()) {
	                    for (CustomerOrder customerOrder : customerOrderList) {
	                        Double orderAmount = customerOrder.getAmount();
	                        if (orderAmount != null) {
	                            totalOrderAmount += orderAmount;
	                            if(totalOrderAmount>200) {
	                            	totalOrderAmount+= customerOrder.getDelivaryCharges();
	                            }
	                            else{
	                            	(totalOrderAmount<200)
	                            }{
	                            	
	                            }
	                        }
	                    }

	                    // Define the minimum order amount for applying delivery charges
	                    double minimumOrderAmount = 200.0;

	                    if (totalOrderAmount < minimumOrderAmount) {
	                        System.out.println("Delivery Charges will be applicable");
	                    } else {
	                        // No delivery charges applicable
	                        System.out.println("No Delivery charges applicable");
	                    }

	                    List<CustomerOrderReplica> customerOrderReplicas = new ArrayList<>();
	                    return customerOrderReplicas;
	                } else {
	                    return Collections.emptyList();
	                }
	            } else {
	                return null; // or an appropriate value
	            }
	        } else {
	            // Handle the case when the latest schedule is not active
	            return null; // or an appropriate value
	        }
	    } else {
	        // Handle the case when there is no latest schedule or its creation timestamp is null
	        return null; // or an appropriate value
	    }
	}

}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-09-21 15:35:01.584
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-09-21 15:35:01.586
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-21 15:35:01.795
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.xyram.daydrop.serviceimpl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.transaction.Transactional;

import org.apache.commons.collections4.map.HashedMap;
import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.server.ResponseStatusException;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.xyram.daydrop.admin.model.CurrentUser;
import com.xyram.daydrop.basemodel.Base64Wrapper;
import com.xyram.daydrop.basemodel.MerchantTransactionIdGenerator;
import com.xyram.daydrop.basemodel.PhonepeSerializer;
import com.xyram.daydrop.dao.ApartmentDao;
import com.xyram.daydrop.dao.CustomerDetailsDao;
import com.xyram.daydrop.dao.CustomerOrderDao;
import com.xyram.daydrop.dao.CustomerOrderReplicaDoa;
import com.xyram.daydrop.dao.SheduleDao;
import com.xyram.daydrop.enumtypes.UserStatus;
import com.xyram.daydrop.model.Apartments;
import com.xyram.daydrop.model.CustomerOrder;
import com.xyram.daydrop.model.CustomerOrderReplica;
import com.xyram.daydrop.model.Customers;
import com.xyram.daydrop.model.Schedule;
import com.xyram.daydrop.modelMapper.PaymentInstrument;
import com.xyram.daydrop.modelMapper.PhonePePayModel;
import com.xyram.daydrop.request.CustomerOrderReplicaRequest;
import com.xyram.daydrop.response.RazorPayRequest;
import com.xyram.daydrop.service.CustomerOrderPriceService;
import com.xyram.daydrop.service.CustomerOrderReplicaService;
import com.xyram.daydrop.util.HashEncoder;
import com.xyram.daydrop.util.RazorPay;
import com.xyram.daydrop.service.ConsumerService;

@Transactional
@Service
public class CustomerOrderReplicaServiceImpl implements CustomerOrderReplicaService {

	@Autowired
	CustomerOrderReplicaDoa customerOrderReplicaDoa;

	@Autowired
	ApartmentDao apartmentDao;

	@Autowired
	SheduleDao scheduleDao;

	@Autowired
	CustomerDetailsDao customerDetailsDao;

	@Autowired
	ConsumerService consumerService;

	@Autowired
	CurrentUser currentUser;

	@Autowired
	PhonepeServiceImpl phonepeServiceImpl;

	@Value("${merchant_id}")
	private String merchantId;

	@Value("${salt_key}")
	private String saltKey;

	@Value("${salt_index}")
	private String saltIndex;

	@Override
	public Map createCustomerOrderReplicaService(CustomerOrderReplicaRequest customerOrderReplicaRequest,
			String contactNumber, Integer aparmentId)

	{

		Map response = new HashedMap<>();

		response.put("message", "success");
		CustomerOrderReplica customerOrderReplica = null;

		if (customerOrderReplicaRequest.getCartId() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "cartId is mandatory ");
		}
		long razorPayCount = 0;
		if (customerOrderReplicaRequest.getOrderId() != null) {

			razorPayCount = customerOrderReplicaDoa.getRazorPayExistByCartId(customerOrderReplicaRequest.getOrderId());
		}

		if (customerOrderReplicaRequest.getCustomerDetails() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Order Details  is mandatory ");
		}

		customerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(customerOrderReplicaRequest.getCartId(),
				contactNumber);

		if (customerOrderReplica != null) {
			customerOrderReplica.setCartId(customerOrderReplica.getCartId());

			if (customerOrderReplica.isOrdered()) {
				throw new ResponseStatusException(HttpStatus.CONFLICT, "Your Order is Placed With cart Details");
			}

//			if (razorPayCount >= 1 && !(customerOrderReplica.getRazorPayOrderId() != null
//					&& customerOrderReplica.getRazorPayOrderId().equals(customerOrderReplicaRequest.getOrderId()))) {
//				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
//			}

			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);

			customerOrderReplica.setAttempts(customerOrderReplica.getAttempts() + 1);
			customerOrderReplica.setUpdatedTime(new Date());

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		} else {

			customerOrderReplica = new CustomerOrderReplica();
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);
			customerOrderReplica.setCartId(customerOrderReplicaRequest.getCartId());
			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());

			if (razorPayCount > 0) {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
			}

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			Schedule schedule = scheduleDao.getlatestScheduleCustomers();

			if (schedule != null) {

				try {
					customerOrderReplica.setSchedule(schedule.getsId() != null ? schedule.getsId().toString() : null);
				} catch (Exception e) {
					e.printStackTrace();
				}
			} else {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
						"Sorry We Are Not Accepting Any Order Right now");

			}

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		}

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicas(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String schedule = null;

		Map filter = request.containsKey("filters") ? (Map) request.get("filters") : null;
		if (filter != null) {
			statusType = filter.containsKey("statusType") ? ((String) filter.get("statusType")).toLowerCase() : null;
			searchQuery = filter.containsKey("searchQuery") ? ((String) filter.get("searchQuery")).toLowerCase() : null;
			schedule = filter.containsKey("schedule") ? (String.valueOf(filter.get("schedule"))) : null;

		}

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplica(searchQuery, statusType, schedule);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");

				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setStreetName(
						customers.get("streetName") != null ? (String) customers.get("streetName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicasBySchedule(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String scheduleId = null;

		Schedule schedule = scheduleDao.getlatestScheduleCustomers();

		if (schedule != null) {

			try {
				scheduleId = schedule.getsId() != null ? schedule.getsId().toString() : null;
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

		statusType = request.containsKey("statusType") ? ((String) request.get("statusType")).toLowerCase() : "Success";

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplicaBySchdeule(statusType, scheduleId);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");
				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				System.out.println("customers" + customers.get("customerName"));

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public CustomerOrderReplica getCustomerOrderReplicaByCartId(String cartId) {

		CustomerOrderReplica CustomerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(cartId,
				currentUser.getContactNumber());

		ObjectMapper objectMapper = new ObjectMapper();
		try {

			// convert JSON string to Map
			Map<String, Object> customerOrderReplicaMap = objectMapper
					.readValue(CustomerOrderReplica.getCustomerOrderDetails(), Map.class);

			Object customerOrder = customerOrderReplicaMap.get("customerOrder");
			Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

			Object quanityList = items.get("quantity");
			Map customers = customerDetailsDao.getByContactNumberAndApartment(CustomerOrderReplica.getContactNumber(),
					CustomerOrderReplica.getApartmentId());

			System.out.println("customers" + customers.get("customerName"));

			// Apartments apartments =
			// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
			CustomerOrderReplica.setApartmentName(
					customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

			CustomerOrderReplica.setCustomerDetails(customers);

			CustomerOrderReplica.setCustomerOrder(customerOrder);
			CustomerOrderReplica.setQuatityList(quanityList);

		} catch (Exception e) {
			e.printStackTrace();
		}

		return CustomerOrderReplica;

	}

	@Override
	public Map createCustomerOrderReplica(CustomerOrderReplicaRequest customerOrderReplicaRequest, String contactNumber,
			Integer aparmentId) {

		if (customerOrderReplicaRequest.getRazorPayRequest() != null) {

//			Map razorPay = consumerService.createRazorPayOrder(customerOrderReplicaRequest.getRazorPayRequest());
//			customerOrderReplicaRequest.setOrderId(razorPay.get("order") != null ? (String)((RazorPay) razorPay.get("order")).getId() : null);	
//	
//			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);
//
//			razorPay.put("cartId", customerOrderReplicaRequest.getCartId());

			Map customerOrderReplicaMap = new HashMap<>();

			Map orderId = new HashMap<>();
			String transactionId = getMerchantTransactionId();
			orderId.put("id", transactionId);

			customerOrderReplicaMap.put("order", orderId);

			customerOrderReplicaRequest.setOrderId(transactionId);
			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);

			customerOrderReplicaMap.put("cartId", customerOrderReplicaRequest.getCartId());

			try {
				customerOrderReplicaMap.put("phonePeResponse",
						phonepeServiceImpl.initiatePhonepePayment(transactionId,
								Integer.valueOf(customerOrderReplicaRequest.getRazorPayRequest().getAmount()),
								contactNumber, customerOrderReplicaRequest.getRedirectUrl(), customerOrderReplicaRequest.getCallBackUrl()));

			} catch (Exception e) {
				e.printStackTrace();
				customerOrderReplicaMap.put("phonePeResponse", new HashedMap<>());
			}

			return customerOrderReplicaMap;

		} else {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
					"paymentDetails transcation Details are mandatory");
		}

	}

	private static String getMerchantTransactionId() {

		return "OD_" + MerchantTransactionIdGenerator.getRandomString();
	}


	@Override
	public List<CustomerOrderReplica> getCustomerOrderByMoblieNo(String contactNumber, Integer aid) {

	    Schedule latestSchedule = customerOrderReplicaDoa.getlatestschedule();

	    if (latestSchedule != null && latestSchedule.getCreationTimestamp() != null) {
	        if (latestSchedule.getStatus().equals(UserStatus.ACTIVE)) {
	            Customers customer = customerDetailsDao.getByContactNoAndApartment(contactNumber, aid);

	            if (customer != null) { // Ensure the customer exists
	                List<CustomerOrder> customerOrderList = customerOrderReplicaDoa.getListCustomerOrderByCustomerId(customer.getCtId());

	                double totalOrderAmount = 0.0;

	                if (customerOrderList != null && !customerOrderList.isEmpty()) {
	                    for (CustomerOrder customerOrder : customerOrderList) {
	                        Double orderAmount = customerOrder.getAmount();
	                        if (orderAmount != null) {
	                            totalOrderAmount += orderAmount;
	                            if(totalOrderAmount>200) {
	                            	totalOrderAmount+= customerOrder.getDelivaryCharges();
	                            }
	                            else{
	                            	(totalOrderAmount<200)
	                            }{
	                            	
	                            }
	                        }
	                    }

	                    // Define the minimum order amount for applying delivery charges
	                    double minimumOrderAmount = 200.0;

	                    if (totalOrderAmount < minimumOrderAmount) {
	                        System.out.println("Delivery Charges will be applicable");
	                    } else {
	                        // No delivery charges applicable
	                        System.out.println("No Delivery charges applicable");
	                    }

	                    List<CustomerOrderReplica> customerOrderReplicas = new ArrayList<>();
	                    return customerOrderReplicas;
	                } else {
	                    return Collections.emptyList();
	                }
	            } else {
	                return null; // or an appropriate value
	            }
	        } else {
	            // Handle the case when the latest schedule is not active
	            return null; // or an appropriate value
	        }
	    } else {
	        // Handle the case when there is no latest schedule or its creation timestamp is null
	        return null; // or an appropriate value
	    }
	}

}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-09-21 15:35:01.799
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-09-21 15:35:01.801
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-21 15:35:03.230
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.xyram.daydrop.serviceimpl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.transaction.Transactional;

import org.apache.commons.collections4.map.HashedMap;
import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.server.ResponseStatusException;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.xyram.daydrop.admin.model.CurrentUser;
import com.xyram.daydrop.basemodel.Base64Wrapper;
import com.xyram.daydrop.basemodel.MerchantTransactionIdGenerator;
import com.xyram.daydrop.basemodel.PhonepeSerializer;
import com.xyram.daydrop.dao.ApartmentDao;
import com.xyram.daydrop.dao.CustomerDetailsDao;
import com.xyram.daydrop.dao.CustomerOrderDao;
import com.xyram.daydrop.dao.CustomerOrderReplicaDoa;
import com.xyram.daydrop.dao.SheduleDao;
import com.xyram.daydrop.enumtypes.UserStatus;
import com.xyram.daydrop.model.Apartments;
import com.xyram.daydrop.model.CustomerOrder;
import com.xyram.daydrop.model.CustomerOrderReplica;
import com.xyram.daydrop.model.Customers;
import com.xyram.daydrop.model.Schedule;
import com.xyram.daydrop.modelMapper.PaymentInstrument;
import com.xyram.daydrop.modelMapper.PhonePePayModel;
import com.xyram.daydrop.request.CustomerOrderReplicaRequest;
import com.xyram.daydrop.response.RazorPayRequest;
import com.xyram.daydrop.service.CustomerOrderPriceService;
import com.xyram.daydrop.service.CustomerOrderReplicaService;
import com.xyram.daydrop.util.HashEncoder;
import com.xyram.daydrop.util.RazorPay;
import com.xyram.daydrop.service.ConsumerService;

@Transactional
@Service
public class CustomerOrderReplicaServiceImpl implements CustomerOrderReplicaService {

	@Autowired
	CustomerOrderReplicaDoa customerOrderReplicaDoa;

	@Autowired
	ApartmentDao apartmentDao;

	@Autowired
	SheduleDao scheduleDao;

	@Autowired
	CustomerDetailsDao customerDetailsDao;

	@Autowired
	ConsumerService consumerService;

	@Autowired
	CurrentUser currentUser;

	@Autowired
	PhonepeServiceImpl phonepeServiceImpl;

	@Value("${merchant_id}")
	private String merchantId;

	@Value("${salt_key}")
	private String saltKey;

	@Value("${salt_index}")
	private String saltIndex;

	@Override
	public Map createCustomerOrderReplicaService(CustomerOrderReplicaRequest customerOrderReplicaRequest,
			String contactNumber, Integer aparmentId)

	{

		Map response = new HashedMap<>();

		response.put("message", "success");
		CustomerOrderReplica customerOrderReplica = null;

		if (customerOrderReplicaRequest.getCartId() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "cartId is mandatory ");
		}
		long razorPayCount = 0;
		if (customerOrderReplicaRequest.getOrderId() != null) {

			razorPayCount = customerOrderReplicaDoa.getRazorPayExistByCartId(customerOrderReplicaRequest.getOrderId());
		}

		if (customerOrderReplicaRequest.getCustomerDetails() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Order Details  is mandatory ");
		}

		customerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(customerOrderReplicaRequest.getCartId(),
				contactNumber);

		if (customerOrderReplica != null) {
			customerOrderReplica.setCartId(customerOrderReplica.getCartId());

			if (customerOrderReplica.isOrdered()) {
				throw new ResponseStatusException(HttpStatus.CONFLICT, "Your Order is Placed With cart Details");
			}

//			if (razorPayCount >= 1 && !(customerOrderReplica.getRazorPayOrderId() != null
//					&& customerOrderReplica.getRazorPayOrderId().equals(customerOrderReplicaRequest.getOrderId()))) {
//				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
//			}

			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);

			customerOrderReplica.setAttempts(customerOrderReplica.getAttempts() + 1);
			customerOrderReplica.setUpdatedTime(new Date());

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		} else {

			customerOrderReplica = new CustomerOrderReplica();
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);
			customerOrderReplica.setCartId(customerOrderReplicaRequest.getCartId());
			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());

			if (razorPayCount > 0) {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
			}

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			Schedule schedule = scheduleDao.getlatestScheduleCustomers();

			if (schedule != null) {

				try {
					customerOrderReplica.setSchedule(schedule.getsId() != null ? schedule.getsId().toString() : null);
				} catch (Exception e) {
					e.printStackTrace();
				}
			} else {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
						"Sorry We Are Not Accepting Any Order Right now");

			}

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		}

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicas(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String schedule = null;

		Map filter = request.containsKey("filters") ? (Map) request.get("filters") : null;
		if (filter != null) {
			statusType = filter.containsKey("statusType") ? ((String) filter.get("statusType")).toLowerCase() : null;
			searchQuery = filter.containsKey("searchQuery") ? ((String) filter.get("searchQuery")).toLowerCase() : null;
			schedule = filter.containsKey("schedule") ? (String.valueOf(filter.get("schedule"))) : null;

		}

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplica(searchQuery, statusType, schedule);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");

				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setStreetName(
						customers.get("streetName") != null ? (String) customers.get("streetName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicasBySchedule(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String scheduleId = null;

		Schedule schedule = scheduleDao.getlatestScheduleCustomers();

		if (schedule != null) {

			try {
				scheduleId = schedule.getsId() != null ? schedule.getsId().toString() : null;
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

		statusType = request.containsKey("statusType") ? ((String) request.get("statusType")).toLowerCase() : "Success";

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplicaBySchdeule(statusType, scheduleId);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");
				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				System.out.println("customers" + customers.get("customerName"));

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public CustomerOrderReplica getCustomerOrderReplicaByCartId(String cartId) {

		CustomerOrderReplica CustomerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(cartId,
				currentUser.getContactNumber());

		ObjectMapper objectMapper = new ObjectMapper();
		try {

			// convert JSON string to Map
			Map<String, Object> customerOrderReplicaMap = objectMapper
					.readValue(CustomerOrderReplica.getCustomerOrderDetails(), Map.class);

			Object customerOrder = customerOrderReplicaMap.get("customerOrder");
			Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

			Object quanityList = items.get("quantity");
			Map customers = customerDetailsDao.getByContactNumberAndApartment(CustomerOrderReplica.getContactNumber(),
					CustomerOrderReplica.getApartmentId());

			System.out.println("customers" + customers.get("customerName"));

			// Apartments apartments =
			// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
			CustomerOrderReplica.setApartmentName(
					customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

			CustomerOrderReplica.setCustomerDetails(customers);

			CustomerOrderReplica.setCustomerOrder(customerOrder);
			CustomerOrderReplica.setQuatityList(quanityList);

		} catch (Exception e) {
			e.printStackTrace();
		}

		return CustomerOrderReplica;

	}

	@Override
	public Map createCustomerOrderReplica(CustomerOrderReplicaRequest customerOrderReplicaRequest, String contactNumber,
			Integer aparmentId) {

		if (customerOrderReplicaRequest.getRazorPayRequest() != null) {

//			Map razorPay = consumerService.createRazorPayOrder(customerOrderReplicaRequest.getRazorPayRequest());
//			customerOrderReplicaRequest.setOrderId(razorPay.get("order") != null ? (String)((RazorPay) razorPay.get("order")).getId() : null);	
//	
//			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);
//
//			razorPay.put("cartId", customerOrderReplicaRequest.getCartId());

			Map customerOrderReplicaMap = new HashMap<>();

			Map orderId = new HashMap<>();
			String transactionId = getMerchantTransactionId();
			orderId.put("id", transactionId);

			customerOrderReplicaMap.put("order", orderId);

			customerOrderReplicaRequest.setOrderId(transactionId);
			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);

			customerOrderReplicaMap.put("cartId", customerOrderReplicaRequest.getCartId());

			try {
				customerOrderReplicaMap.put("phonePeResponse",
						phonepeServiceImpl.initiatePhonepePayment(transactionId,
								Integer.valueOf(customerOrderReplicaRequest.getRazorPayRequest().getAmount()),
								contactNumber, customerOrderReplicaRequest.getRedirectUrl(), customerOrderReplicaRequest.getCallBackUrl()));

			} catch (Exception e) {
				e.printStackTrace();
				customerOrderReplicaMap.put("phonePeResponse", new HashedMap<>());
			}

			return customerOrderReplicaMap;

		} else {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
					"paymentDetails transcation Details are mandatory");
		}

	}

	private static String getMerchantTransactionId() {

		return "OD_" + MerchantTransactionIdGenerator.getRandomString();
	}


	@Override
	public List<CustomerOrderReplica> getCustomerOrderByMoblieNo(String contactNumber, Integer aid) {

	    Schedule latestSchedule = customerOrderReplicaDoa.getlatestschedule();

	    if (latestSchedule != null && latestSchedule.getCreationTimestamp() != null) {
	        if (latestSchedule.getStatus().equals(UserStatus.ACTIVE)) {
	            Customers customer = customerDetailsDao.getByContactNoAndApartment(contactNumber, aid);

	            if (customer != null) { // Ensure the customer exists
	                List<CustomerOrder> customerOrderList = customerOrderReplicaDoa.getListCustomerOrderByCustomerId(customer.getCtId());

	                double totalOrderAmount = 0.0;

	                if (customerOrderList != null && !customerOrderList.isEmpty()) {
	                    for (CustomerOrder customerOrder : customerOrderList) {
	                        Double orderAmount = customerOrder.getAmount();
	                        if (orderAmount != null) {
	                            totalOrderAmount += orderAmount;
	                            if(totalOrderAmount>200) {
	                            	totalOrderAmount+= customerOrder.getDelivaryCharges();
	                            }
	                            else{
	                            	(totalOrderAmount<200)
	                            }{
	                            	
	                            }
	                        }
	                    }

	                    // Define the minimum order amount for applying delivery charges
	                    double minimumOrderAmount = 200.0;

	                    if (totalOrderAmount < minimumOrderAmount) {
	                        System.out.println("Delivery Charges will be applicable");
	                    } else {
	                        // No delivery charges applicable
	                        System.out.println("No Delivery charges applicable");
	                    }

	                    List<CustomerOrderReplica> customerOrderReplicas = new ArrayList<>();
	                    return customerOrderReplicas;
	                } else {
	                    return Collections.emptyList();
	                }
	            } else {
	                return null; // or an appropriate value
	            }
	        } else {
	            // Handle the case when the latest schedule is not active
	            return null; // or an appropriate value
	        }
	    } else {
	        // Handle the case when there is no latest schedule or its creation timestamp is null
	        return null; // or an appropriate value
	    }
	}

}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-09-21 15:35:03.233
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-09-21 15:35:03.234
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2248)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.lsp4e 2 0 2023-09-21 16:11:18.404
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:386)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2096)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2023-09-21 17:18:39.207
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:386)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2096)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2023-09-21 17:20:32.770
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:386)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2096)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2023-09-21 18:10:56.860
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:386)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2096)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.e4.ui.workbench 4 2 2023-09-21 19:19:43.127
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.e4.ui.workbench".
!STACK 0
java.lang.NullPointerException: Cannot invoke "org.eclipse.core.expressions.IEvaluationContext.getDefaultVariable()" because "this.evalContext" is null
	at org.eclipse.ui.internal.handlers.LegacyHandlerService.getCurrentState(LegacyHandlerService.java:572)
	at org.eclipse.egit.ui.internal.selection.SelectionUtils.getEvaluationContext(SelectionUtils.java:534)
	at org.eclipse.egit.ui.internal.selection.SelectionUtils.getStructuredSelection(SelectionUtils.java:237)
	at org.eclipse.egit.ui.internal.selection.RepositorySourceProvider.selectionChanged(RepositorySourceProvider.java:90)
	at org.eclipse.ui.internal.e4.compatibility.SelectionService.notifyListeners(SelectionService.java:266)
	at org.eclipse.ui.internal.e4.compatibility.SelectionService.handleSelectionChanged(SelectionService.java:98)
	at org.eclipse.ui.internal.e4.compatibility.SelectionService.lambda$0(SelectionService.java:72)
	at org.eclipse.e4.ui.internal.workbench.SelectionAggregator$1.run(SelectionAggregator.java:123)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.SelectionAggregator.notifyListeners(SelectionAggregator.java:120)
	at org.eclipse.e4.ui.internal.workbench.SelectionAggregator$5.lambda$0(SelectionAggregator.java:220)
	at org.eclipse.e4.core.contexts.RunAndTrack.runExternalCode(RunAndTrack.java:59)
	at org.eclipse.e4.ui.internal.workbench.SelectionAggregator$5.changed(SelectionAggregator.java:220)
	at org.eclipse.e4.core.internal.contexts.TrackableComputationExt.update(TrackableComputationExt.java:105)
	at org.eclipse.e4.core.internal.contexts.EclipseContext.runAndTrack(EclipseContext.java:338)
	at org.eclipse.e4.ui.internal.workbench.SelectionAggregator.track(SelectionAggregator.java:205)
	at org.eclipse.e4.ui.internal.workbench.SelectionAggregator.setPart(SelectionAggregator.java:114)
	at jdk.internal.reflect.GeneratedMethodAccessor76.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.contexts.ContextObjectSupplier$ContextInjectionListener.update(ContextObjectSupplier.java:95)
	at org.eclipse.e4.core.internal.contexts.TrackableComputationExt.update(TrackableComputationExt.java:103)
	at org.eclipse.e4.core.internal.contexts.EclipseContext.processScheduled(EclipseContext.java:356)
	at org.eclipse.e4.core.internal.contexts.EclipseContext.dispose(EclipseContext.java:180)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.clearContext(PartRenderingEngine.java:986)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:959)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:861)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:845)
	at org.eclipse.e4.ui.workbench.renderers.swt.ContributedPartRenderer.disposeWidget(ContributedPartRenderer.java:274)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:938)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:861)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:845)
	at org.eclipse.e4.ui.workbench.renderers.swt.ElementReferenceRenderer.disposeWidget(ElementReferenceRenderer.java:113)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:938)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:861)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:845)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:893)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:861)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:845)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:893)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:861)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:845)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:900)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:861)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:845)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:900)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:861)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:845)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:900)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:861)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:845)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:900)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:861)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:845)
	at org.eclipse.ui.internal.WorkbenchWindow.hardClose(WorkbenchWindow.java:2087)
	at org.eclipse.ui.internal.WorkbenchWindow.busyClose(WorkbenchWindow.java:1719)
	at org.eclipse.ui.internal.WorkbenchWindow.lambda$5(WorkbenchWindow.java:1743)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.ui.internal.WorkbenchWindow.close(WorkbenchWindow.java:1743)
	at org.eclipse.ui.internal.Workbench$11.run(Workbench.java:1108)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.Workbench.busyClose(Workbench.java:1091)
	at org.eclipse.ui.internal.Workbench.lambda$4(Workbench.java:1392)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.ui.internal.Workbench.close(Workbench.java:1392)
	at org.eclipse.ui.internal.Workbench.close(Workbench.java:1368)
	at org.eclipse.ui.internal.WorkbenchWindow.busyClose(WorkbenchWindow.java:1716)
	at org.eclipse.ui.internal.WorkbenchWindow.lambda$5(WorkbenchWindow.java:1743)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.ui.internal.WorkbenchWindow.close(WorkbenchWindow.java:1743)
	at org.eclipse.ui.internal.WorkbenchWindow.close(WorkbenchWindow.java:1752)
	at org.eclipse.ui.internal.WorkbenchWindow.lambda$2(WorkbenchWindow.java:503)
	at org.eclipse.e4.ui.workbench.renderers.swt.WBWRenderer.lambda$4(WBWRenderer.java:570)
	at org.eclipse.swt.events.ShellListener$2.shellClosed(ShellListener.java:102)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:102)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4243)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1063)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1087)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1072)
	at org.eclipse.swt.widgets.Decorations.closeWidget(Decorations.java:269)
	at org.eclipse.swt.widgets.Decorations.WM_CLOSE(Decorations.java:1552)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4748)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1480)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2286)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5015)
	at org.eclipse.swt.internal.win32.OS.DefWindowProc(Native Method)
	at org.eclipse.swt.widgets.Shell.callWindowProc(Shell.java:508)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4847)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1480)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2286)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5015)
	at org.eclipse.swt.internal.win32.OS.DefWindowProc(Native Method)
	at org.eclipse.swt.widgets.Shell.callWindowProc(Shell.java:508)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4847)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1480)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2286)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5015)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3630)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.e4.ui.workbench 4 0 2023-09-21 19:19:43.130
!MESSAGE Cannot invoke "org.eclipse.core.expressions.IEvaluationContext.getDefaultVariable()" because "this.evalContext" is null
!STACK 0
java.lang.NullPointerException: Cannot invoke "org.eclipse.core.expressions.IEvaluationContext.getDefaultVariable()" because "this.evalContext" is null
	at org.eclipse.ui.internal.handlers.LegacyHandlerService.getCurrentState(LegacyHandlerService.java:572)
	at org.eclipse.egit.ui.internal.selection.SelectionUtils.getEvaluationContext(SelectionUtils.java:534)
	at org.eclipse.egit.ui.internal.selection.SelectionUtils.getStructuredSelection(SelectionUtils.java:237)
	at org.eclipse.egit.ui.internal.selection.RepositorySourceProvider.selectionChanged(RepositorySourceProvider.java:90)
	at org.eclipse.ui.internal.e4.compatibility.SelectionService.notifyListeners(SelectionService.java:266)
	at org.eclipse.ui.internal.e4.compatibility.SelectionService.handleSelectionChanged(SelectionService.java:98)
	at org.eclipse.ui.internal.e4.compatibility.SelectionService.lambda$0(SelectionService.java:72)
	at org.eclipse.e4.ui.internal.workbench.SelectionAggregator$1.run(SelectionAggregator.java:123)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.SelectionAggregator.notifyListeners(SelectionAggregator.java:120)
	at org.eclipse.e4.ui.internal.workbench.SelectionAggregator$5.lambda$0(SelectionAggregator.java:220)
	at org.eclipse.e4.core.contexts.RunAndTrack.runExternalCode(RunAndTrack.java:59)
	at org.eclipse.e4.ui.internal.workbench.SelectionAggregator$5.changed(SelectionAggregator.java:220)
	at org.eclipse.e4.core.internal.contexts.TrackableComputationExt.update(TrackableComputationExt.java:105)
	at org.eclipse.e4.core.internal.contexts.EclipseContext.runAndTrack(EclipseContext.java:338)
	at org.eclipse.e4.ui.internal.workbench.SelectionAggregator.track(SelectionAggregator.java:205)
	at org.eclipse.e4.ui.internal.workbench.SelectionAggregator.setPart(SelectionAggregator.java:114)
	at jdk.internal.reflect.GeneratedMethodAccessor76.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.contexts.ContextObjectSupplier$ContextInjectionListener.update(ContextObjectSupplier.java:95)
	at org.eclipse.e4.core.internal.contexts.TrackableComputationExt.update(TrackableComputationExt.java:103)
	at org.eclipse.e4.core.internal.contexts.EclipseContext.processScheduled(EclipseContext.java:356)
	at org.eclipse.e4.core.internal.contexts.EclipseContext.dispose(EclipseContext.java:180)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.clearContext(PartRenderingEngine.java:986)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:959)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:861)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:845)
	at org.eclipse.e4.ui.workbench.renderers.swt.ContributedPartRenderer.disposeWidget(ContributedPartRenderer.java:274)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:938)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:861)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:845)
	at org.eclipse.e4.ui.workbench.renderers.swt.ElementReferenceRenderer.disposeWidget(ElementReferenceRenderer.java:113)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:938)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:861)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:845)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:893)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:861)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:845)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:893)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:861)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:845)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:900)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:861)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:845)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:900)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:861)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:845)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:900)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:861)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:845)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:900)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:861)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:845)
	at org.eclipse.ui.internal.WorkbenchWindow.hardClose(WorkbenchWindow.java:2087)
	at org.eclipse.ui.internal.WorkbenchWindow.busyClose(WorkbenchWindow.java:1719)
	at org.eclipse.ui.internal.WorkbenchWindow.lambda$5(WorkbenchWindow.java:1743)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.ui.internal.WorkbenchWindow.close(WorkbenchWindow.java:1743)
	at org.eclipse.ui.internal.Workbench$11.run(Workbench.java:1108)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.Workbench.busyClose(Workbench.java:1091)
	at org.eclipse.ui.internal.Workbench.lambda$4(Workbench.java:1392)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.ui.internal.Workbench.close(Workbench.java:1392)
	at org.eclipse.ui.internal.Workbench.close(Workbench.java:1368)
	at org.eclipse.ui.internal.WorkbenchWindow.busyClose(WorkbenchWindow.java:1716)
	at org.eclipse.ui.internal.WorkbenchWindow.lambda$5(WorkbenchWindow.java:1743)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.ui.internal.WorkbenchWindow.close(WorkbenchWindow.java:1743)
	at org.eclipse.ui.internal.WorkbenchWindow.close(WorkbenchWindow.java:1752)
	at org.eclipse.ui.internal.WorkbenchWindow.lambda$2(WorkbenchWindow.java:503)
	at org.eclipse.e4.ui.workbench.renderers.swt.WBWRenderer.lambda$4(WBWRenderer.java:570)
	at org.eclipse.swt.events.ShellListener$2.shellClosed(ShellListener.java:102)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:102)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4243)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1063)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1087)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1072)
	at org.eclipse.swt.widgets.Decorations.closeWidget(Decorations.java:269)
	at org.eclipse.swt.widgets.Decorations.WM_CLOSE(Decorations.java:1552)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4748)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1480)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2286)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5015)
	at org.eclipse.swt.internal.win32.OS.DefWindowProc(Native Method)
	at org.eclipse.swt.widgets.Shell.callWindowProc(Shell.java:508)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4847)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1480)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2286)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5015)
	at org.eclipse.swt.internal.win32.OS.DefWindowProc(Native Method)
	at org.eclipse.swt.widgets.Shell.callWindowProc(Shell.java:508)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4847)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1480)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2286)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5015)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3630)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2023-09-21 19:19:44.510
!MESSAGE ClasspathListenerHandler removeClasspathListener sts4.classpath.UVOXPptz

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2023-09-21 19:19:44.512
!MESSAGE unsubscribing from classpath changes: sts4.classpath.UVOXPptz

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2023-09-21 19:19:44.514
!MESSAGE subsribers = {}

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2023-09-21 19:19:44.520
!MESSAGE ClasspathListenerHandler removeClasspathListener sts4.classpath.UVOXPptz => OK

!ENTRY org.eclipse.ui 4 0 2023-09-21 19:19:45.364
!MESSAGE Exceptions during shutdown
!STACK 0
org.eclipse.swt.SWTException: Widget is disposed
	at org.eclipse.swt.SWT.error(SWT.java:4918)
	at org.eclipse.swt.SWT.error(SWT.java:4833)
	at org.eclipse.swt.SWT.error(SWT.java:4804)
	at org.eclipse.swt.widgets.Widget.error(Widget.java:447)
	at org.eclipse.swt.widgets.Widget.checkWidget(Widget.java:366)
	at org.eclipse.swt.custom.StyledText.getCharCount(StyledText.java:4022)
	at org.eclipse.swt.custom.StyledText$7.getCharacterCount(StyledText.java:6824)
	at org.eclipse.swt.accessibility.Accessible.getCharacterCount(Accessible.java:5016)
	at org.eclipse.swt.accessibility.Accessible.get_nCharacters(Accessible.java:4649)
	at org.eclipse.swt.accessibility.Accessible$5.method17(Accessible.java:375)
	at org.eclipse.swt.internal.ole.win32.COMObject.callback17(COMObject.java:219)
	at org.eclipse.swt.internal.win32.OS.ShowWindow(Native Method)
	at org.eclipse.swt.widgets.Decorations.setVisible(Decorations.java:1267)
	at org.eclipse.swt.widgets.Shell.setVisible(Shell.java:2064)
	at org.eclipse.swt.widgets.Shell.open(Shell.java:1295)
	at org.eclipse.jface.window.Window.open(Window.java:795)
	at org.eclipse.jface.dialogs.ProgressMonitorDialog.open(ProgressMonitorDialog.java:633)
	at org.eclipse.jface.dialogs.ProgressMonitorDialog.aboutToRun(ProgressMonitorDialog.java:542)
	at org.eclipse.jface.dialogs.ProgressMonitorDialog.run(ProgressMonitorDialog.java:467)
	at org.eclipse.ui.internal.progress.ProgressMonitorJobsDialog.run(ProgressMonitorJobsDialog.java:230)
	at org.eclipse.ui.internal.ide.application.IDEWorkbenchAdvisor.disconnectFromWorkspace(IDEWorkbenchAdvisor.java:560)
	at org.eclipse.ui.internal.ide.application.IDEWorkbenchAdvisor$2.run(IDEWorkbenchAdvisor.java:367)
	at org.eclipse.ui.internal.ide.application.IDEWorkbenchAdvisor.postShutdown(IDEWorkbenchAdvisor.java:388)
	at org.eclipse.ui.internal.Workbench.shutdown(Workbench.java:2942)
	at org.eclipse.ui.internal.Workbench.busyClose(Workbench.java:1124)
	at org.eclipse.ui.internal.Workbench.lambda$4(Workbench.java:1392)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.ui.internal.Workbench.close(Workbench.java:1392)
	at org.eclipse.ui.internal.Workbench.close(Workbench.java:1368)
	at org.eclipse.ui.internal.WorkbenchWindow.busyClose(WorkbenchWindow.java:1716)
	at org.eclipse.ui.internal.WorkbenchWindow.lambda$5(WorkbenchWindow.java:1743)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.ui.internal.WorkbenchWindow.close(WorkbenchWindow.java:1743)
	at org.eclipse.ui.internal.WorkbenchWindow.close(WorkbenchWindow.java:1752)
	at org.eclipse.ui.internal.WorkbenchWindow.lambda$2(WorkbenchWindow.java:503)
	at org.eclipse.e4.ui.workbench.renderers.swt.WBWRenderer.lambda$4(WBWRenderer.java:570)
	at org.eclipse.swt.events.ShellListener$2.shellClosed(ShellListener.java:102)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:102)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4243)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1063)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1087)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1072)
	at org.eclipse.swt.widgets.Decorations.closeWidget(Decorations.java:269)
	at org.eclipse.swt.widgets.Decorations.WM_CLOSE(Decorations.java:1552)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4748)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1480)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2286)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5015)
	at org.eclipse.swt.internal.win32.OS.DefWindowProc(Native Method)
	at org.eclipse.swt.widgets.Shell.callWindowProc(Shell.java:508)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4847)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1480)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2286)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5015)
	at org.eclipse.swt.internal.win32.OS.DefWindowProc(Native Method)
	at org.eclipse.swt.widgets.Shell.callWindowProc(Shell.java:508)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4847)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1480)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2286)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5015)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3630)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.core.resources 2 10035 2023-09-21 19:19:49.883
!MESSAGE The workspace will exit with unsaved changes in this session.
!SESSION 2023-09-22 09:36:12.673 -----------------------------------------------
eclipse.buildId=4.14.1.202204250734
java.version=17.0.2
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.springframework.boot.ide.branding.sts4
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.springframework.boot.ide.branding.sts4

!ENTRY org.eclipse.core.resources 2 10035 2023-09-22 09:36:25.333
!MESSAGE The workspace exited with unsaved changes in the previous session; refreshing workspace to recover changes.

!ENTRY org.eclipse.jface 2 0 2023-09-22 09:36:36.396
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-09-22 09:36:36.396
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@489b7559,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4028aab2,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-09-22 09:36:36.396
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@37aea657,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3ca9d3b2,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2023-09-22 09:36:46.210
!MESSAGE Entering DelegatingStreamConnectionProvider()

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2023-09-22 09:36:46.218
!MESSAGE DelegatingStreamConnectionProvider classloader = org.eclipse.osgi.internal.loader.EquinoxClassLoader@5bd4e763[org.springframework.tooling.boot.ls:1.33.0.202204250653(id=569)]

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2023-09-22 09:36:46.248
!MESSAGE SpringBootLanguageServer exists!

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2023-09-22 09:36:46.755
!MESSAGE Instantiating ReusableClasspathListenerHandler

!ENTRY org.eclipse.egit.ui 2 0 2023-09-22 09:36:51.518
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\HARISHBABU'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2023-09-22 09:37:09.723
!MESSAGE Boot LS startup time from start to initialized: 23318ms

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2023-09-22 09:37:11.906
!MESSAGE ClasspathListenerHandler addClasspathListener sts4.classpath.PtEKHuwXisBatched = true

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2023-09-22 09:37:11.933
!MESSAGE Setting up ClasspathListenerManager

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2023-09-22 09:37:11.938
!MESSAGE Scheduling initial event for all projects ...

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2023-09-22 09:37:11.952
!MESSAGE Scheduling initial event for all projects DONE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2023-09-22 09:37:11.974
!MESSAGE ClasspathListenerHandler addClasspathListener sts4.classpath.PtEKHuwX => OK

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2023-09-22 09:37:11.980
!MESSAGE exists = true open = true => deleted = false

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2023-09-22 09:37:12.127
!MESSAGE classpath=163 entries

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2023-09-22 09:37:12.316
!MESSAGE buffering callback sts4.classpath.PtEKHuwX daydrop-dev false 163

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2023-09-22 09:37:12.418
!MESSAGE executing callback sts4.classpath.PtEKHuwX 1 batched events
