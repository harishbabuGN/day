!SESSION 2023-09-21 10:32:03.159 -----------------------------------------------
eclipse.buildId=4.14.1.202204250734
java.version=17.0.2
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_IN
Framework arguments:  -product org.springframework.boot.ide.branding.sts4
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.springframework.boot.ide.branding.sts4

This is a continuation of log file D:\DaydropDEV\.metadata\.bak_6.log
Created Time: 2023-09-21 15:04:37.845

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-09-21 15:04:37.846
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-09-21 15:04:37.848
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-21 15:04:37.965
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.xyram.daydrop.serviceimpl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.transaction.Transactional;

import org.apache.commons.collections4.map.HashedMap;
import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.server.ResponseStatusException;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.xyram.daydrop.admin.model.CurrentUser;
import com.xyram.daydrop.basemodel.Base64Wrapper;
import com.xyram.daydrop.basemodel.MerchantTransactionIdGenerator;
import com.xyram.daydrop.basemodel.PhonepeSerializer;
import com.xyram.daydrop.dao.ApartmentDao;
import com.xyram.daydrop.dao.CustomerDetailsDao;
import com.xyram.daydrop.dao.CustomerOrderDao;
import com.xyram.daydrop.dao.CustomerOrderReplicaDoa;
import com.xyram.daydrop.dao.SheduleDao;
import com.xyram.daydrop.enumtypes.UserStatus;
import com.xyram.daydrop.model.Apartments;
import com.xyram.daydrop.model.CustomerOrder;
import com.xyram.daydrop.model.CustomerOrderReplica;
import com.xyram.daydrop.model.Customers;
import com.xyram.daydrop.model.Schedule;
import com.xyram.daydrop.modelMapper.PaymentInstrument;
import com.xyram.daydrop.modelMapper.PhonePePayModel;
import com.xyram.daydrop.request.CustomerOrderReplicaRequest;
import com.xyram.daydrop.response.RazorPayRequest;
import com.xyram.daydrop.service.CustomerOrderPriceService;
import com.xyram.daydrop.service.CustomerOrderReplicaService;
import com.xyram.daydrop.util.HashEncoder;
import com.xyram.daydrop.util.RazorPay;
import com.xyram.daydrop.service.ConsumerService;

@Transactional
@Service
public class CustomerOrderReplicaServiceImpl implements CustomerOrderReplicaService {

	@Autowired
	CustomerOrderReplicaDoa customerOrderReplicaDoa;

	@Autowired
	ApartmentDao apartmentDao;

	@Autowired
	SheduleDao scheduleDao;

	@Autowired
	CustomerDetailsDao customerDetailsDao;

	@Autowired
	ConsumerService consumerService;

	@Autowired
	CurrentUser currentUser;

	@Autowired
	PhonepeServiceImpl phonepeServiceImpl;

	@Value("${merchant_id}")
	private String merchantId;

	@Value("${salt_key}")
	private String saltKey;

	@Value("${salt_index}")
	private String saltIndex;

	@Override
	public Map createCustomerOrderReplicaService(CustomerOrderReplicaRequest customerOrderReplicaRequest,
			String contactNumber, Integer aparmentId)

	{

		Map response = new HashedMap<>();

		response.put("message", "success");
		CustomerOrderReplica customerOrderReplica = null;

		if (customerOrderReplicaRequest.getCartId() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "cartId is mandatory ");
		}
		long razorPayCount = 0;
		if (customerOrderReplicaRequest.getOrderId() != null) {

			razorPayCount = customerOrderReplicaDoa.getRazorPayExistByCartId(customerOrderReplicaRequest.getOrderId());
		}

		if (customerOrderReplicaRequest.getCustomerDetails() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Order Details  is mandatory ");
		}

		customerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(customerOrderReplicaRequest.getCartId(),
				contactNumber);

		if (customerOrderReplica != null) {
			customerOrderReplica.setCartId(customerOrderReplica.getCartId());

			if (customerOrderReplica.isOrdered()) {
				throw new ResponseStatusException(HttpStatus.CONFLICT, "Your Order is Placed With cart Details");
			}

//			if (razorPayCount >= 1 && !(customerOrderReplica.getRazorPayOrderId() != null
//					&& customerOrderReplica.getRazorPayOrderId().equals(customerOrderReplicaRequest.getOrderId()))) {
//				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
//			}

			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);

			customerOrderReplica.setAttempts(customerOrderReplica.getAttempts() + 1);
			customerOrderReplica.setUpdatedTime(new Date());

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		} else {

			customerOrderReplica = new CustomerOrderReplica();
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);
			customerOrderReplica.setCartId(customerOrderReplicaRequest.getCartId());
			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());

			if (razorPayCount > 0) {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
			}

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			Schedule schedule = scheduleDao.getlatestScheduleCustomers();

			if (schedule != null) {

				try {
					customerOrderReplica.setSchedule(schedule.getsId() != null ? schedule.getsId().toString() : null);
				} catch (Exception e) {
					e.printStackTrace();
				}
			} else {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
						"Sorry We Are Not Accepting Any Order Right now");

			}

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		}

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicas(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String schedule = null;

		Map filter = request.containsKey("filters") ? (Map) request.get("filters") : null;
		if (filter != null) {
			statusType = filter.containsKey("statusType") ? ((String) filter.get("statusType")).toLowerCase() : null;
			searchQuery = filter.containsKey("searchQuery") ? ((String) filter.get("searchQuery")).toLowerCase() : null;
			schedule = filter.containsKey("schedule") ? (String.valueOf(filter.get("schedule"))) : null;

		}

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplica(searchQuery, statusType, schedule);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");

				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setStreetName(
						customers.get("streetName") != null ? (String) customers.get("streetName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicasBySchedule(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String scheduleId = null;

		Schedule schedule = scheduleDao.getlatestScheduleCustomers();

		if (schedule != null) {

			try {
				scheduleId = schedule.getsId() != null ? schedule.getsId().toString() : null;
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

		statusType = request.containsKey("statusType") ? ((String) request.get("statusType")).toLowerCase() : "Success";

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplicaBySchdeule(statusType, scheduleId);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");
				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				System.out.println("customers" + customers.get("customerName"));

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public CustomerOrderReplica getCustomerOrderReplicaByCartId(String cartId) {

		CustomerOrderReplica CustomerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(cartId,
				currentUser.getContactNumber());

		ObjectMapper objectMapper = new ObjectMapper();
		try {

			// convert JSON string to Map
			Map<String, Object> customerOrderReplicaMap = objectMapper
					.readValue(CustomerOrderReplica.getCustomerOrderDetails(), Map.class);

			Object customerOrder = customerOrderReplicaMap.get("customerOrder");
			Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

			Object quanityList = items.get("quantity");
			Map customers = customerDetailsDao.getByContactNumberAndApartment(CustomerOrderReplica.getContactNumber(),
					CustomerOrderReplica.getApartmentId());

			System.out.println("customers" + customers.get("customerName"));

			// Apartments apartments =
			// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
			CustomerOrderReplica.setApartmentName(
					customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

			CustomerOrderReplica.setCustomerDetails(customers);

			CustomerOrderReplica.setCustomerOrder(customerOrder);
			CustomerOrderReplica.setQuatityList(quanityList);

		} catch (Exception e) {
			e.printStackTrace();
		}

		return CustomerOrderReplica;

	}

	@Override
	public Map createCustomerOrderReplica(CustomerOrderReplicaRequest customerOrderReplicaRequest, String contactNumber,
			Integer aparmentId) {

		if (customerOrderReplicaRequest.getRazorPayRequest() != null) {

//			Map razorPay = consumerService.createRazorPayOrder(customerOrderReplicaRequest.getRazorPayRequest());
//			customerOrderReplicaRequest.setOrderId(razorPay.get("order") != null ? (String)((RazorPay) razorPay.get("order")).getId() : null);	
//	
//			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);
//
//			razorPay.put("cartId", customerOrderReplicaRequest.getCartId());

			Map customerOrderReplicaMap = new HashMap<>();

			Map orderId = new HashMap<>();
			String transactionId = getMerchantTransactionId();
			orderId.put("id", transactionId);

			customerOrderReplicaMap.put("order", orderId);

			customerOrderReplicaRequest.setOrderId(transactionId);
			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);

			customerOrderReplicaMap.put("cartId", customerOrderReplicaRequest.getCartId());

			try {
				customerOrderReplicaMap.put("phonePeResponse",
						phonepeServiceImpl.initiatePhonepePayment(transactionId,
								Integer.valueOf(customerOrderReplicaRequest.getRazorPayRequest().getAmount()),
								contactNumber, customerOrderReplicaRequest.getRedirectUrl(), customerOrderReplicaRequest.getCallBackUrl()));

			} catch (Exception e) {
				e.printStackTrace();
				customerOrderReplicaMap.put("phonePeResponse", new HashedMap<>());
			}

			return customerOrderReplicaMap;

		} else {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
					"paymentDetails transcation Details are mandatory");
		}

	}

	private static String getMerchantTransactionId() {

		return "OD_" + MerchantTransactionIdGenerator.getRandomString();
	}


	@Override
	public List<CustomerOrderReplica> getCustomerOrderByMoblieNo(String contactNumber,Integer aid) {
		
		Schedule latestschedule = customerOrderReplicaDoa.getlatestschedule();
		
		if (latestschedule != null && latestschedule.getCreationTimestamp()!=null) {
			
	        if (latestschedule.getStatus().equals(UserStatus.ACTIVE)) {
	        	
	        	Customers customer = customerDetailsDao.getByContactNoAndApartment(contactNumber, aid);
	        	if (customer != null) { // Ensure the customer exists
	        		List<CustomerOrder> customerOrderList = customerOrderReplicaDoa.getListCustomerOrderByCustomerId(customer.getCtid());
	        		
	                double totalOrderAmount = 0.0;
	       
                if (customerOrderList != null && !customerOrderList.isEmpty() && customerOrderList.add(customerOrder). {
                    for (CustomerOrder customerOrder : customerOrderList) {
                        Double orderAmount = customerOrder.getAmount();
                        
                        if(orderAmount>200) {
                        	
                        }
                        if (orderAmount != null) {
                            totalOrderAmount += orderAmount;
                            if(totalOrderAmount>200) {
                            	totalOrderAmount+customerOrder
                            }
                        }
                    }
                    System.out.println("Total Order Amount: " + totalOrderAmount);
                    List<CustomerOrderReplica> customerOrderReplicas = new ArrayList<>();
                    return customerOrderReplicas;
                } else {
                    return Collections.emptyList(); // or return null or an appropriate value
                }
            } else {
              
                return null; // or an appropriate value
            }
        } else {
            // Handle the case when the latest schedule is not active
            return null; // or an appropriate value
        }
    } else {
        // Handle the case when there is no latest schedule or its creation timestamp is null
        return null; // or an appropriate value
    }
	}
}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1003)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:799)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:743)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:666)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:658)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.lambda$0(LSJavaHoverProvider.java:68)
	at java.base/java.util.concurrent.CompletableFuture$AsyncRun.run(CompletableFuture.java:1804)
	at java.base/java.util.concurrent.CompletableFuture$AsyncRun.exec(CompletableFuture.java:1796)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:373)
	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1182)
	at java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1655)
	at java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1622)
	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:165)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-09-21 15:04:37.967
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1003)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:799)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:743)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:666)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:658)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.lambda$0(LSJavaHoverProvider.java:68)
	at java.base/java.util.concurrent.CompletableFuture$AsyncRun.run(CompletableFuture.java:1804)
	at java.base/java.util.concurrent.CompletableFuture$AsyncRun.exec(CompletableFuture.java:1796)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:373)
	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1182)
	at java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1655)
	at java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1622)
	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:165)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-09-21 15:04:37.969
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1003)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:799)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:743)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:666)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:658)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.lambda$0(LSJavaHoverProvider.java:68)
	at java.base/java.util.concurrent.CompletableFuture$AsyncRun.run(CompletableFuture.java:1804)
	at java.base/java.util.concurrent.CompletableFuture$AsyncRun.exec(CompletableFuture.java:1796)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:373)
	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1182)
	at java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1655)
	at java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1622)
	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:165)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-21 15:04:38.032
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.xyram.daydrop.serviceimpl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.transaction.Transactional;

import org.apache.commons.collections4.map.HashedMap;
import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.server.ResponseStatusException;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.xyram.daydrop.admin.model.CurrentUser;
import com.xyram.daydrop.basemodel.Base64Wrapper;
import com.xyram.daydrop.basemodel.MerchantTransactionIdGenerator;
import com.xyram.daydrop.basemodel.PhonepeSerializer;
import com.xyram.daydrop.dao.ApartmentDao;
import com.xyram.daydrop.dao.CustomerDetailsDao;
import com.xyram.daydrop.dao.CustomerOrderDao;
import com.xyram.daydrop.dao.CustomerOrderReplicaDoa;
import com.xyram.daydrop.dao.SheduleDao;
import com.xyram.daydrop.enumtypes.UserStatus;
import com.xyram.daydrop.model.Apartments;
import com.xyram.daydrop.model.CustomerOrder;
import com.xyram.daydrop.model.CustomerOrderReplica;
import com.xyram.daydrop.model.Customers;
import com.xyram.daydrop.model.Schedule;
import com.xyram.daydrop.modelMapper.PaymentInstrument;
import com.xyram.daydrop.modelMapper.PhonePePayModel;
import com.xyram.daydrop.request.CustomerOrderReplicaRequest;
import com.xyram.daydrop.response.RazorPayRequest;
import com.xyram.daydrop.service.CustomerOrderPriceService;
import com.xyram.daydrop.service.CustomerOrderReplicaService;
import com.xyram.daydrop.util.HashEncoder;
import com.xyram.daydrop.util.RazorPay;
import com.xyram.daydrop.service.ConsumerService;

@Transactional
@Service
public class CustomerOrderReplicaServiceImpl implements CustomerOrderReplicaService {

	@Autowired
	CustomerOrderReplicaDoa customerOrderReplicaDoa;

	@Autowired
	ApartmentDao apartmentDao;

	@Autowired
	SheduleDao scheduleDao;

	@Autowired
	CustomerDetailsDao customerDetailsDao;

	@Autowired
	ConsumerService consumerService;

	@Autowired
	CurrentUser currentUser;

	@Autowired
	PhonepeServiceImpl phonepeServiceImpl;

	@Value("${merchant_id}")
	private String merchantId;

	@Value("${salt_key}")
	private String saltKey;

	@Value("${salt_index}")
	private String saltIndex;

	@Override
	public Map createCustomerOrderReplicaService(CustomerOrderReplicaRequest customerOrderReplicaRequest,
			String contactNumber, Integer aparmentId)

	{

		Map response = new HashedMap<>();

		response.put("message", "success");
		CustomerOrderReplica customerOrderReplica = null;

		if (customerOrderReplicaRequest.getCartId() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "cartId is mandatory ");
		}
		long razorPayCount = 0;
		if (customerOrderReplicaRequest.getOrderId() != null) {

			razorPayCount = customerOrderReplicaDoa.getRazorPayExistByCartId(customerOrderReplicaRequest.getOrderId());
		}

		if (customerOrderReplicaRequest.getCustomerDetails() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Order Details  is mandatory ");
		}

		customerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(customerOrderReplicaRequest.getCartId(),
				contactNumber);

		if (customerOrderReplica != null) {
			customerOrderReplica.setCartId(customerOrderReplica.getCartId());

			if (customerOrderReplica.isOrdered()) {
				throw new ResponseStatusException(HttpStatus.CONFLICT, "Your Order is Placed With cart Details");
			}

//			if (razorPayCount >= 1 && !(customerOrderReplica.getRazorPayOrderId() != null
//					&& customerOrderReplica.getRazorPayOrderId().equals(customerOrderReplicaRequest.getOrderId()))) {
//				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
//			}

			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);

			customerOrderReplica.setAttempts(customerOrderReplica.getAttempts() + 1);
			customerOrderReplica.setUpdatedTime(new Date());

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		} else {

			customerOrderReplica = new CustomerOrderReplica();
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);
			customerOrderReplica.setCartId(customerOrderReplicaRequest.getCartId());
			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());

			if (razorPayCount > 0) {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
			}

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			Schedule schedule = scheduleDao.getlatestScheduleCustomers();

			if (schedule != null) {

				try {
					customerOrderReplica.setSchedule(schedule.getsId() != null ? schedule.getsId().toString() : null);
				} catch (Exception e) {
					e.printStackTrace();
				}
			} else {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
						"Sorry We Are Not Accepting Any Order Right now");

			}

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		}

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicas(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String schedule = null;

		Map filter = request.containsKey("filters") ? (Map) request.get("filters") : null;
		if (filter != null) {
			statusType = filter.containsKey("statusType") ? ((String) filter.get("statusType")).toLowerCase() : null;
			searchQuery = filter.containsKey("searchQuery") ? ((String) filter.get("searchQuery")).toLowerCase() : null;
			schedule = filter.containsKey("schedule") ? (String.valueOf(filter.get("schedule"))) : null;

		}

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplica(searchQuery, statusType, schedule);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");

				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setStreetName(
						customers.get("streetName") != null ? (String) customers.get("streetName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicasBySchedule(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String scheduleId = null;

		Schedule schedule = scheduleDao.getlatestScheduleCustomers();

		if (schedule != null) {

			try {
				scheduleId = schedule.getsId() != null ? schedule.getsId().toString() : null;
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

		statusType = request.containsKey("statusType") ? ((String) request.get("statusType")).toLowerCase() : "Success";

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplicaBySchdeule(statusType, scheduleId);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");
				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				System.out.println("customers" + customers.get("customerName"));

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public CustomerOrderReplica getCustomerOrderReplicaByCartId(String cartId) {

		CustomerOrderReplica CustomerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(cartId,
				currentUser.getContactNumber());

		ObjectMapper objectMapper = new ObjectMapper();
		try {

			// convert JSON string to Map
			Map<String, Object> customerOrderReplicaMap = objectMapper
					.readValue(CustomerOrderReplica.getCustomerOrderDetails(), Map.class);

			Object customerOrder = customerOrderReplicaMap.get("customerOrder");
			Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

			Object quanityList = items.get("quantity");
			Map customers = customerDetailsDao.getByContactNumberAndApartment(CustomerOrderReplica.getContactNumber(),
					CustomerOrderReplica.getApartmentId());

			System.out.println("customers" + customers.get("customerName"));

			// Apartments apartments =
			// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
			CustomerOrderReplica.setApartmentName(
					customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

			CustomerOrderReplica.setCustomerDetails(customers);

			CustomerOrderReplica.setCustomerOrder(customerOrder);
			CustomerOrderReplica.setQuatityList(quanityList);

		} catch (Exception e) {
			e.printStackTrace();
		}

		return CustomerOrderReplica;

	}

	@Override
	public Map createCustomerOrderReplica(CustomerOrderReplicaRequest customerOrderReplicaRequest, String contactNumber,
			Integer aparmentId) {

		if (customerOrderReplicaRequest.getRazorPayRequest() != null) {

//			Map razorPay = consumerService.createRazorPayOrder(customerOrderReplicaRequest.getRazorPayRequest());
//			customerOrderReplicaRequest.setOrderId(razorPay.get("order") != null ? (String)((RazorPay) razorPay.get("order")).getId() : null);	
//	
//			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);
//
//			razorPay.put("cartId", customerOrderReplicaRequest.getCartId());

			Map customerOrderReplicaMap = new HashMap<>();

			Map orderId = new HashMap<>();
			String transactionId = getMerchantTransactionId();
			orderId.put("id", transactionId);

			customerOrderReplicaMap.put("order", orderId);

			customerOrderReplicaRequest.setOrderId(transactionId);
			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);

			customerOrderReplicaMap.put("cartId", customerOrderReplicaRequest.getCartId());

			try {
				customerOrderReplicaMap.put("phonePeResponse",
						phonepeServiceImpl.initiatePhonepePayment(transactionId,
								Integer.valueOf(customerOrderReplicaRequest.getRazorPayRequest().getAmount()),
								contactNumber, customerOrderReplicaRequest.getRedirectUrl(), customerOrderReplicaRequest.getCallBackUrl()));

			} catch (Exception e) {
				e.printStackTrace();
				customerOrderReplicaMap.put("phonePeResponse", new HashedMap<>());
			}

			return customerOrderReplicaMap;

		} else {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
					"paymentDetails transcation Details are mandatory");
		}

	}

	private static String getMerchantTransactionId() {

		return "OD_" + MerchantTransactionIdGenerator.getRandomString();
	}


	@Override
	public List<CustomerOrderReplica> getCustomerOrderByMoblieNo(String contactNumber,Integer aid) {
		
		Schedule latestschedule = customerOrderReplicaDoa.getlatestschedule();
		
		if (latestschedule != null && latestschedule.getCreationTimestamp()!=null) {
			
	        if (latestschedule.getStatus().equals(UserStatus.ACTIVE)) {
	        	
	        	Customers customer = customerDetailsDao.getByContactNoAndApartment(contactNumber, aid);
	        	if (customer != null) { // Ensure the customer exists
	        		List<CustomerOrder> customerOrderList = customerOrderReplicaDoa.getListCustomerOrderByCustomerId(customer.getCtid());
	        		
	                double totalOrderAmount = 0.0;
	       
                if (customerOrderList != null && !customerOrderList.isEmpty() && customerOrderList.add(customerOrder). {
                    for (CustomerOrder customerOrder : customerOrderList) {
                        Double orderAmount = customerOrder.getAmount();
                        
                        if(orderAmount>200) {
                        	
                        }
                        if (orderAmount != null) {
                            totalOrderAmount += orderAmount;
                            if(totalOrderAmount>200) {
                            	totalOrderAmount+customerOrder
                            }
                        }
                    }
                    System.out.println("Total Order Amount: " + totalOrderAmount);
                    List<CustomerOrderReplica> customerOrderReplicas = new ArrayList<>();
                    return customerOrderReplicas;
                } else {
                    return Collections.emptyList(); // or return null or an appropriate value
                }
            } else {
              
                return null; // or an appropriate value
            }
        } else {
            // Handle the case when the latest schedule is not active
            return null; // or an appropriate value
        }
    } else {
        // Handle the case when there is no latest schedule or its creation timestamp is null
        return null; // or an appropriate value
    }
	}
}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-09-21 15:04:38.033
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-09-21 15:04:38.034
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-21 15:04:38.099
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.xyram.daydrop.serviceimpl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.transaction.Transactional;

import org.apache.commons.collections4.map.HashedMap;
import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.server.ResponseStatusException;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.xyram.daydrop.admin.model.CurrentUser;
import com.xyram.daydrop.basemodel.Base64Wrapper;
import com.xyram.daydrop.basemodel.MerchantTransactionIdGenerator;
import com.xyram.daydrop.basemodel.PhonepeSerializer;
import com.xyram.daydrop.dao.ApartmentDao;
import com.xyram.daydrop.dao.CustomerDetailsDao;
import com.xyram.daydrop.dao.CustomerOrderDao;
import com.xyram.daydrop.dao.CustomerOrderReplicaDoa;
import com.xyram.daydrop.dao.SheduleDao;
import com.xyram.daydrop.enumtypes.UserStatus;
import com.xyram.daydrop.model.Apartments;
import com.xyram.daydrop.model.CustomerOrder;
import com.xyram.daydrop.model.CustomerOrderReplica;
import com.xyram.daydrop.model.Customers;
import com.xyram.daydrop.model.Schedule;
import com.xyram.daydrop.modelMapper.PaymentInstrument;
import com.xyram.daydrop.modelMapper.PhonePePayModel;
import com.xyram.daydrop.request.CustomerOrderReplicaRequest;
import com.xyram.daydrop.response.RazorPayRequest;
import com.xyram.daydrop.service.CustomerOrderPriceService;
import com.xyram.daydrop.service.CustomerOrderReplicaService;
import com.xyram.daydrop.util.HashEncoder;
import com.xyram.daydrop.util.RazorPay;
import com.xyram.daydrop.service.ConsumerService;

@Transactional
@Service
public class CustomerOrderReplicaServiceImpl implements CustomerOrderReplicaService {

	@Autowired
	CustomerOrderReplicaDoa customerOrderReplicaDoa;

	@Autowired
	ApartmentDao apartmentDao;

	@Autowired
	SheduleDao scheduleDao;

	@Autowired
	CustomerDetailsDao customerDetailsDao;

	@Autowired
	ConsumerService consumerService;

	@Autowired
	CurrentUser currentUser;

	@Autowired
	PhonepeServiceImpl phonepeServiceImpl;

	@Value("${merchant_id}")
	private String merchantId;

	@Value("${salt_key}")
	private String saltKey;

	@Value("${salt_index}")
	private String saltIndex;

	@Override
	public Map createCustomerOrderReplicaService(CustomerOrderReplicaRequest customerOrderReplicaRequest,
			String contactNumber, Integer aparmentId)

	{

		Map response = new HashedMap<>();

		response.put("message", "success");
		CustomerOrderReplica customerOrderReplica = null;

		if (customerOrderReplicaRequest.getCartId() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "cartId is mandatory ");
		}
		long razorPayCount = 0;
		if (customerOrderReplicaRequest.getOrderId() != null) {

			razorPayCount = customerOrderReplicaDoa.getRazorPayExistByCartId(customerOrderReplicaRequest.getOrderId());
		}

		if (customerOrderReplicaRequest.getCustomerDetails() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Order Details  is mandatory ");
		}

		customerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(customerOrderReplicaRequest.getCartId(),
				contactNumber);

		if (customerOrderReplica != null) {
			customerOrderReplica.setCartId(customerOrderReplica.getCartId());

			if (customerOrderReplica.isOrdered()) {
				throw new ResponseStatusException(HttpStatus.CONFLICT, "Your Order is Placed With cart Details");
			}

//			if (razorPayCount >= 1 && !(customerOrderReplica.getRazorPayOrderId() != null
//					&& customerOrderReplica.getRazorPayOrderId().equals(customerOrderReplicaRequest.getOrderId()))) {
//				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
//			}

			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);

			customerOrderReplica.setAttempts(customerOrderReplica.getAttempts() + 1);
			customerOrderReplica.setUpdatedTime(new Date());

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		} else {

			customerOrderReplica = new CustomerOrderReplica();
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);
			customerOrderReplica.setCartId(customerOrderReplicaRequest.getCartId());
			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());

			if (razorPayCount > 0) {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
			}

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			Schedule schedule = scheduleDao.getlatestScheduleCustomers();

			if (schedule != null) {

				try {
					customerOrderReplica.setSchedule(schedule.getsId() != null ? schedule.getsId().toString() : null);
				} catch (Exception e) {
					e.printStackTrace();
				}
			} else {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
						"Sorry We Are Not Accepting Any Order Right now");

			}

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		}

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicas(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String schedule = null;

		Map filter = request.containsKey("filters") ? (Map) request.get("filters") : null;
		if (filter != null) {
			statusType = filter.containsKey("statusType") ? ((String) filter.get("statusType")).toLowerCase() : null;
			searchQuery = filter.containsKey("searchQuery") ? ((String) filter.get("searchQuery")).toLowerCase() : null;
			schedule = filter.containsKey("schedule") ? (String.valueOf(filter.get("schedule"))) : null;

		}

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplica(searchQuery, statusType, schedule);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");

				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setStreetName(
						customers.get("streetName") != null ? (String) customers.get("streetName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicasBySchedule(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String scheduleId = null;

		Schedule schedule = scheduleDao.getlatestScheduleCustomers();

		if (schedule != null) {

			try {
				scheduleId = schedule.getsId() != null ? schedule.getsId().toString() : null;
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

		statusType = request.containsKey("statusType") ? ((String) request.get("statusType")).toLowerCase() : "Success";

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplicaBySchdeule(statusType, scheduleId);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");
				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				System.out.println("customers" + customers.get("customerName"));

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public CustomerOrderReplica getCustomerOrderReplicaByCartId(String cartId) {

		CustomerOrderReplica CustomerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(cartId,
				currentUser.getContactNumber());

		ObjectMapper objectMapper = new ObjectMapper();
		try {

			// convert JSON string to Map
			Map<String, Object> customerOrderReplicaMap = objectMapper
					.readValue(CustomerOrderReplica.getCustomerOrderDetails(), Map.class);

			Object customerOrder = customerOrderReplicaMap.get("customerOrder");
			Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

			Object quanityList = items.get("quantity");
			Map customers = customerDetailsDao.getByContactNumberAndApartment(CustomerOrderReplica.getContactNumber(),
					CustomerOrderReplica.getApartmentId());

			System.out.println("customers" + customers.get("customerName"));

			// Apartments apartments =
			// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
			CustomerOrderReplica.setApartmentName(
					customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

			CustomerOrderReplica.setCustomerDetails(customers);

			CustomerOrderReplica.setCustomerOrder(customerOrder);
			CustomerOrderReplica.setQuatityList(quanityList);

		} catch (Exception e) {
			e.printStackTrace();
		}

		return CustomerOrderReplica;

	}

	@Override
	public Map createCustomerOrderReplica(CustomerOrderReplicaRequest customerOrderReplicaRequest, String contactNumber,
			Integer aparmentId) {

		if (customerOrderReplicaRequest.getRazorPayRequest() != null) {

//			Map razorPay = consumerService.createRazorPayOrder(customerOrderReplicaRequest.getRazorPayRequest());
//			customerOrderReplicaRequest.setOrderId(razorPay.get("order") != null ? (String)((RazorPay) razorPay.get("order")).getId() : null);	
//	
//			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);
//
//			razorPay.put("cartId", customerOrderReplicaRequest.getCartId());

			Map customerOrderReplicaMap = new HashMap<>();

			Map orderId = new HashMap<>();
			String transactionId = getMerchantTransactionId();
			orderId.put("id", transactionId);

			customerOrderReplicaMap.put("order", orderId);

			customerOrderReplicaRequest.setOrderId(transactionId);
			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);

			customerOrderReplicaMap.put("cartId", customerOrderReplicaRequest.getCartId());

			try {
				customerOrderReplicaMap.put("phonePeResponse",
						phonepeServiceImpl.initiatePhonepePayment(transactionId,
								Integer.valueOf(customerOrderReplicaRequest.getRazorPayRequest().getAmount()),
								contactNumber, customerOrderReplicaRequest.getRedirectUrl(), customerOrderReplicaRequest.getCallBackUrl()));

			} catch (Exception e) {
				e.printStackTrace();
				customerOrderReplicaMap.put("phonePeResponse", new HashedMap<>());
			}

			return customerOrderReplicaMap;

		} else {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
					"paymentDetails transcation Details are mandatory");
		}

	}

	private static String getMerchantTransactionId() {

		return "OD_" + MerchantTransactionIdGenerator.getRandomString();
	}


	@Override
	public List<CustomerOrderReplica> getCustomerOrderByMoblieNo(String contactNumber,Integer aid) {
		
		Schedule latestschedule = customerOrderReplicaDoa.getlatestschedule();
		
		if (latestschedule != null && latestschedule.getCreationTimestamp()!=null) {
			
	        if (latestschedule.getStatus().equals(UserStatus.ACTIVE)) {
	        	
	        	Customers customer = customerDetailsDao.getByContactNoAndApartment(contactNumber, aid);
	        	if (customer != null) { // Ensure the customer exists
	        		List<CustomerOrder> customerOrderList = customerOrderReplicaDoa.getListCustomerOrderByCustomerId(customer.getCtid());
	        		
	                double totalOrderAmount = 0.0;
	       
                if (customerOrderList != null && !customerOrderList.isEmpty() && customerOrderList.add(customerOrder). {
                    for (CustomerOrder customerOrder : customerOrderList) {
                        Double orderAmount = customerOrder.getAmount();
                        
                        if(orderAmount>200) {
                        	
                        }
                        if (orderAmount != null) {
                            totalOrderAmount += orderAmount;
                            if(totalOrderAmount>200) {
                            	totalOrderAmount+customerOrder
                            }
                        }
                    }
                    System.out.println("Total Order Amount: " + totalOrderAmount);
                    List<CustomerOrderReplica> customerOrderReplicas = new ArrayList<>();
                    return customerOrderReplicas;
                } else {
                    return Collections.emptyList(); // or return null or an appropriate value
                }
            } else {
              
                return null; // or an appropriate value
            }
        } else {
            // Handle the case when the latest schedule is not active
            return null; // or an appropriate value
        }
    } else {
        // Handle the case when there is no latest schedule or its creation timestamp is null
        return null; // or an appropriate value
    }
	}
}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1003)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:799)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:743)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:666)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:658)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-09-21 15:04:38.100
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1003)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:799)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:743)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:666)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:658)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-09-21 15:04:38.102
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1003)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:799)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:743)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:666)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:658)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-21 15:05:24.892
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.xyram.daydrop.serviceimpl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.transaction.Transactional;

import org.apache.commons.collections4.map.HashedMap;
import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.server.ResponseStatusException;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.xyram.daydrop.admin.model.CurrentUser;
import com.xyram.daydrop.basemodel.Base64Wrapper;
import com.xyram.daydrop.basemodel.MerchantTransactionIdGenerator;
import com.xyram.daydrop.basemodel.PhonepeSerializer;
import com.xyram.daydrop.dao.ApartmentDao;
import com.xyram.daydrop.dao.CustomerDetailsDao;
import com.xyram.daydrop.dao.CustomerOrderDao;
import com.xyram.daydrop.dao.CustomerOrderReplicaDoa;
import com.xyram.daydrop.dao.SheduleDao;
import com.xyram.daydrop.enumtypes.UserStatus;
import com.xyram.daydrop.model.Apartments;
import com.xyram.daydrop.model.CustomerOrder;
import com.xyram.daydrop.model.CustomerOrderReplica;
import com.xyram.daydrop.model.Customers;
import com.xyram.daydrop.model.Schedule;
import com.xyram.daydrop.modelMapper.PaymentInstrument;
import com.xyram.daydrop.modelMapper.PhonePePayModel;
import com.xyram.daydrop.request.CustomerOrderReplicaRequest;
import com.xyram.daydrop.response.RazorPayRequest;
import com.xyram.daydrop.service.CustomerOrderPriceService;
import com.xyram.daydrop.service.CustomerOrderReplicaService;
import com.xyram.daydrop.util.HashEncoder;
import com.xyram.daydrop.util.RazorPay;
import com.xyram.daydrop.service.ConsumerService;

@Transactional
@Service
public class CustomerOrderReplicaServiceImpl implements CustomerOrderReplicaService {

	@Autowired
	CustomerOrderReplicaDoa customerOrderReplicaDoa;

	@Autowired
	ApartmentDao apartmentDao;

	@Autowired
	SheduleDao scheduleDao;

	@Autowired
	CustomerDetailsDao customerDetailsDao;

	@Autowired
	ConsumerService consumerService;

	@Autowired
	CurrentUser currentUser;

	@Autowired
	PhonepeServiceImpl phonepeServiceImpl;

	@Value("${merchant_id}")
	private String merchantId;

	@Value("${salt_key}")
	private String saltKey;

	@Value("${salt_index}")
	private String saltIndex;

	@Override
	public Map createCustomerOrderReplicaService(CustomerOrderReplicaRequest customerOrderReplicaRequest,
			String contactNumber, Integer aparmentId)

	{

		Map response = new HashedMap<>();

		response.put("message", "success");
		CustomerOrderReplica customerOrderReplica = null;

		if (customerOrderReplicaRequest.getCartId() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "cartId is mandatory ");
		}
		long razorPayCount = 0;
		if (customerOrderReplicaRequest.getOrderId() != null) {

			razorPayCount = customerOrderReplicaDoa.getRazorPayExistByCartId(customerOrderReplicaRequest.getOrderId());
		}

		if (customerOrderReplicaRequest.getCustomerDetails() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Order Details  is mandatory ");
		}

		customerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(customerOrderReplicaRequest.getCartId(),
				contactNumber);

		if (customerOrderReplica != null) {
			customerOrderReplica.setCartId(customerOrderReplica.getCartId());

			if (customerOrderReplica.isOrdered()) {
				throw new ResponseStatusException(HttpStatus.CONFLICT, "Your Order is Placed With cart Details");
			}

//			if (razorPayCount >= 1 && !(customerOrderReplica.getRazorPayOrderId() != null
//					&& customerOrderReplica.getRazorPayOrderId().equals(customerOrderReplicaRequest.getOrderId()))) {
//				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
//			}

			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);

			customerOrderReplica.setAttempts(customerOrderReplica.getAttempts() + 1);
			customerOrderReplica.setUpdatedTime(new Date());

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		} else {

			customerOrderReplica = new CustomerOrderReplica();
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);
			customerOrderReplica.setCartId(customerOrderReplicaRequest.getCartId());
			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());

			if (razorPayCount > 0) {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
			}

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			Schedule schedule = scheduleDao.getlatestScheduleCustomers();

			if (schedule != null) {

				try {
					customerOrderReplica.setSchedule(schedule.getsId() != null ? schedule.getsId().toString() : null);
				} catch (Exception e) {
					e.printStackTrace();
				}
			} else {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
						"Sorry We Are Not Accepting Any Order Right now");

			}

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		}

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicas(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String schedule = null;

		Map filter = request.containsKey("filters") ? (Map) request.get("filters") : null;
		if (filter != null) {
			statusType = filter.containsKey("statusType") ? ((String) filter.get("statusType")).toLowerCase() : null;
			searchQuery = filter.containsKey("searchQuery") ? ((String) filter.get("searchQuery")).toLowerCase() : null;
			schedule = filter.containsKey("schedule") ? (String.valueOf(filter.get("schedule"))) : null;

		}

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplica(searchQuery, statusType, schedule);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");

				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setStreetName(
						customers.get("streetName") != null ? (String) customers.get("streetName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicasBySchedule(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String scheduleId = null;

		Schedule schedule = scheduleDao.getlatestScheduleCustomers();

		if (schedule != null) {

			try {
				scheduleId = schedule.getsId() != null ? schedule.getsId().toString() : null;
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

		statusType = request.containsKey("statusType") ? ((String) request.get("statusType")).toLowerCase() : "Success";

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplicaBySchdeule(statusType, scheduleId);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");
				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				System.out.println("customers" + customers.get("customerName"));

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public CustomerOrderReplica getCustomerOrderReplicaByCartId(String cartId) {

		CustomerOrderReplica CustomerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(cartId,
				currentUser.getContactNumber());

		ObjectMapper objectMapper = new ObjectMapper();
		try {

			// convert JSON string to Map
			Map<String, Object> customerOrderReplicaMap = objectMapper
					.readValue(CustomerOrderReplica.getCustomerOrderDetails(), Map.class);

			Object customerOrder = customerOrderReplicaMap.get("customerOrder");
			Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

			Object quanityList = items.get("quantity");
			Map customers = customerDetailsDao.getByContactNumberAndApartment(CustomerOrderReplica.getContactNumber(),
					CustomerOrderReplica.getApartmentId());

			System.out.println("customers" + customers.get("customerName"));

			// Apartments apartments =
			// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
			CustomerOrderReplica.setApartmentName(
					customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

			CustomerOrderReplica.setCustomerDetails(customers);

			CustomerOrderReplica.setCustomerOrder(customerOrder);
			CustomerOrderReplica.setQuatityList(quanityList);

		} catch (Exception e) {
			e.printStackTrace();
		}

		return CustomerOrderReplica;

	}

	@Override
	public Map createCustomerOrderReplica(CustomerOrderReplicaRequest customerOrderReplicaRequest, String contactNumber,
			Integer aparmentId) {

		if (customerOrderReplicaRequest.getRazorPayRequest() != null) {

//			Map razorPay = consumerService.createRazorPayOrder(customerOrderReplicaRequest.getRazorPayRequest());
//			customerOrderReplicaRequest.setOrderId(razorPay.get("order") != null ? (String)((RazorPay) razorPay.get("order")).getId() : null);	
//	
//			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);
//
//			razorPay.put("cartId", customerOrderReplicaRequest.getCartId());

			Map customerOrderReplicaMap = new HashMap<>();

			Map orderId = new HashMap<>();
			String transactionId = getMerchantTransactionId();
			orderId.put("id", transactionId);

			customerOrderReplicaMap.put("order", orderId);

			customerOrderReplicaRequest.setOrderId(transactionId);
			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);

			customerOrderReplicaMap.put("cartId", customerOrderReplicaRequest.getCartId());

			try {
				customerOrderReplicaMap.put("phonePeResponse",
						phonepeServiceImpl.initiatePhonepePayment(transactionId,
								Integer.valueOf(customerOrderReplicaRequest.getRazorPayRequest().getAmount()),
								contactNumber, customerOrderReplicaRequest.getRedirectUrl(), customerOrderReplicaRequest.getCallBackUrl()));

			} catch (Exception e) {
				e.printStackTrace();
				customerOrderReplicaMap.put("phonePeResponse", new HashedMap<>());
			}

			return customerOrderReplicaMap;

		} else {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
					"paymentDetails transcation Details are mandatory");
		}

	}

	private static String getMerchantTransactionId() {

		return "OD_" + MerchantTransactionIdGenerator.getRandomString();
	}


	@Override
	public List<CustomerOrderReplica> getCustomerOrderByMoblieNo(String contactNumber,Integer aid) {
		
		Schedule latestschedule = customerOrderReplicaDoa.getlatestschedule();
		
		if (latestschedule != null && latestschedule.getCreationTimestamp()!=null) {
			
	        if (latestschedule.getStatus().equals(UserStatus.ACTIVE)) {
	        	
	        	Customers customer = customerDetailsDao.getByContactNoAndApartment(contactNumber, aid);
	        	if (customer != null) { // Ensure the customer exists
	        		List<CustomerOrder> customerOrderList = customerOrderReplicaDoa.getListCustomerOrderByCustomerId(customer.getCtid());
	        		
	                double totalOrderAmount = 0.0;
	       
                if (customerOrderList != null && !customerOrderList.isEmpty() && customerOrderList.add(customerOrder). {
                    for (CustomerOrder customerOrder : customerOrderList) {
                        Double orderAmount = customerOrder.getAmount();
                        
                        if(orderAmount>200) {
                        	
                        }
                        if (orderAmount != null) {
                            totalOrderAmount += orderAmount;
                            if(totalOrderAmount>200) {
                            	totalOrderAmount+customerOrder
                            }
                        }
                    }
                    System.out.println("Total Order Amount: " + totalOrderAmount);
                    List<CustomerOrderReplica> customerOrderReplicas = new ArrayList<>();
                    return customerOrderReplicas;
                } else {
                    return Collections.emptyList(); // or return null or an appropriate value
                }
            } else {
              
                return null; // or an appropriate value
            }
        } else {
            // Handle the case when the latest schedule is not active
            return null; // or an appropriate value
        }
    } else {
        // Handle the case when there is no latest schedule or its creation timestamp is null
        return null; // or an appropriate value
    }
	}
}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1003)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:799)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:743)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:666)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:658)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.lambda$0(LSJavaHoverProvider.java:68)
	at java.base/java.util.concurrent.CompletableFuture$AsyncRun.run(CompletableFuture.java:1804)
	at java.base/java.util.concurrent.CompletableFuture$AsyncRun.exec(CompletableFuture.java:1796)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:373)
	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1182)
	at java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1655)
	at java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1622)
	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:165)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-09-21 15:05:24.895
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1003)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:799)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:743)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:666)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:658)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.lambda$0(LSJavaHoverProvider.java:68)
	at java.base/java.util.concurrent.CompletableFuture$AsyncRun.run(CompletableFuture.java:1804)
	at java.base/java.util.concurrent.CompletableFuture$AsyncRun.exec(CompletableFuture.java:1796)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:373)
	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1182)
	at java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1655)
	at java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1622)
	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:165)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-09-21 15:05:24.896
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1003)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:799)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:743)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:666)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:658)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.lambda$0(LSJavaHoverProvider.java:68)
	at java.base/java.util.concurrent.CompletableFuture$AsyncRun.run(CompletableFuture.java:1804)
	at java.base/java.util.concurrent.CompletableFuture$AsyncRun.exec(CompletableFuture.java:1796)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:373)
	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1182)
	at java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1655)
	at java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1622)
	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:165)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-21 15:05:24.982
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.xyram.daydrop.serviceimpl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.transaction.Transactional;

import org.apache.commons.collections4.map.HashedMap;
import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.server.ResponseStatusException;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.xyram.daydrop.admin.model.CurrentUser;
import com.xyram.daydrop.basemodel.Base64Wrapper;
import com.xyram.daydrop.basemodel.MerchantTransactionIdGenerator;
import com.xyram.daydrop.basemodel.PhonepeSerializer;
import com.xyram.daydrop.dao.ApartmentDao;
import com.xyram.daydrop.dao.CustomerDetailsDao;
import com.xyram.daydrop.dao.CustomerOrderDao;
import com.xyram.daydrop.dao.CustomerOrderReplicaDoa;
import com.xyram.daydrop.dao.SheduleDao;
import com.xyram.daydrop.enumtypes.UserStatus;
import com.xyram.daydrop.model.Apartments;
import com.xyram.daydrop.model.CustomerOrder;
import com.xyram.daydrop.model.CustomerOrderReplica;
import com.xyram.daydrop.model.Customers;
import com.xyram.daydrop.model.Schedule;
import com.xyram.daydrop.modelMapper.PaymentInstrument;
import com.xyram.daydrop.modelMapper.PhonePePayModel;
import com.xyram.daydrop.request.CustomerOrderReplicaRequest;
import com.xyram.daydrop.response.RazorPayRequest;
import com.xyram.daydrop.service.CustomerOrderPriceService;
import com.xyram.daydrop.service.CustomerOrderReplicaService;
import com.xyram.daydrop.util.HashEncoder;
import com.xyram.daydrop.util.RazorPay;
import com.xyram.daydrop.service.ConsumerService;

@Transactional
@Service
public class CustomerOrderReplicaServiceImpl implements CustomerOrderReplicaService {

	@Autowired
	CustomerOrderReplicaDoa customerOrderReplicaDoa;

	@Autowired
	ApartmentDao apartmentDao;

	@Autowired
	SheduleDao scheduleDao;

	@Autowired
	CustomerDetailsDao customerDetailsDao;

	@Autowired
	ConsumerService consumerService;

	@Autowired
	CurrentUser currentUser;

	@Autowired
	PhonepeServiceImpl phonepeServiceImpl;

	@Value("${merchant_id}")
	private String merchantId;

	@Value("${salt_key}")
	private String saltKey;

	@Value("${salt_index}")
	private String saltIndex;

	@Override
	public Map createCustomerOrderReplicaService(CustomerOrderReplicaRequest customerOrderReplicaRequest,
			String contactNumber, Integer aparmentId)

	{

		Map response = new HashedMap<>();

		response.put("message", "success");
		CustomerOrderReplica customerOrderReplica = null;

		if (customerOrderReplicaRequest.getCartId() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "cartId is mandatory ");
		}
		long razorPayCount = 0;
		if (customerOrderReplicaRequest.getOrderId() != null) {

			razorPayCount = customerOrderReplicaDoa.getRazorPayExistByCartId(customerOrderReplicaRequest.getOrderId());
		}

		if (customerOrderReplicaRequest.getCustomerDetails() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Order Details  is mandatory ");
		}

		customerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(customerOrderReplicaRequest.getCartId(),
				contactNumber);

		if (customerOrderReplica != null) {
			customerOrderReplica.setCartId(customerOrderReplica.getCartId());

			if (customerOrderReplica.isOrdered()) {
				throw new ResponseStatusException(HttpStatus.CONFLICT, "Your Order is Placed With cart Details");
			}

//			if (razorPayCount >= 1 && !(customerOrderReplica.getRazorPayOrderId() != null
//					&& customerOrderReplica.getRazorPayOrderId().equals(customerOrderReplicaRequest.getOrderId()))) {
//				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
//			}

			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);

			customerOrderReplica.setAttempts(customerOrderReplica.getAttempts() + 1);
			customerOrderReplica.setUpdatedTime(new Date());

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		} else {

			customerOrderReplica = new CustomerOrderReplica();
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);
			customerOrderReplica.setCartId(customerOrderReplicaRequest.getCartId());
			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());

			if (razorPayCount > 0) {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
			}

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			Schedule schedule = scheduleDao.getlatestScheduleCustomers();

			if (schedule != null) {

				try {
					customerOrderReplica.setSchedule(schedule.getsId() != null ? schedule.getsId().toString() : null);
				} catch (Exception e) {
					e.printStackTrace();
				}
			} else {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
						"Sorry We Are Not Accepting Any Order Right now");

			}

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		}

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicas(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String schedule = null;

		Map filter = request.containsKey("filters") ? (Map) request.get("filters") : null;
		if (filter != null) {
			statusType = filter.containsKey("statusType") ? ((String) filter.get("statusType")).toLowerCase() : null;
			searchQuery = filter.containsKey("searchQuery") ? ((String) filter.get("searchQuery")).toLowerCase() : null;
			schedule = filter.containsKey("schedule") ? (String.valueOf(filter.get("schedule"))) : null;

		}

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplica(searchQuery, statusType, schedule);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");

				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setStreetName(
						customers.get("streetName") != null ? (String) customers.get("streetName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicasBySchedule(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String scheduleId = null;

		Schedule schedule = scheduleDao.getlatestScheduleCustomers();

		if (schedule != null) {

			try {
				scheduleId = schedule.getsId() != null ? schedule.getsId().toString() : null;
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

		statusType = request.containsKey("statusType") ? ((String) request.get("statusType")).toLowerCase() : "Success";

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplicaBySchdeule(statusType, scheduleId);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");
				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				System.out.println("customers" + customers.get("customerName"));

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public CustomerOrderReplica getCustomerOrderReplicaByCartId(String cartId) {

		CustomerOrderReplica CustomerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(cartId,
				currentUser.getContactNumber());

		ObjectMapper objectMapper = new ObjectMapper();
		try {

			// convert JSON string to Map
			Map<String, Object> customerOrderReplicaMap = objectMapper
					.readValue(CustomerOrderReplica.getCustomerOrderDetails(), Map.class);

			Object customerOrder = customerOrderReplicaMap.get("customerOrder");
			Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

			Object quanityList = items.get("quantity");
			Map customers = customerDetailsDao.getByContactNumberAndApartment(CustomerOrderReplica.getContactNumber(),
					CustomerOrderReplica.getApartmentId());

			System.out.println("customers" + customers.get("customerName"));

			// Apartments apartments =
			// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
			CustomerOrderReplica.setApartmentName(
					customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

			CustomerOrderReplica.setCustomerDetails(customers);

			CustomerOrderReplica.setCustomerOrder(customerOrder);
			CustomerOrderReplica.setQuatityList(quanityList);

		} catch (Exception e) {
			e.printStackTrace();
		}

		return CustomerOrderReplica;

	}

	@Override
	public Map createCustomerOrderReplica(CustomerOrderReplicaRequest customerOrderReplicaRequest, String contactNumber,
			Integer aparmentId) {

		if (customerOrderReplicaRequest.getRazorPayRequest() != null) {

//			Map razorPay = consumerService.createRazorPayOrder(customerOrderReplicaRequest.getRazorPayRequest());
//			customerOrderReplicaRequest.setOrderId(razorPay.get("order") != null ? (String)((RazorPay) razorPay.get("order")).getId() : null);	
//	
//			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);
//
//			razorPay.put("cartId", customerOrderReplicaRequest.getCartId());

			Map customerOrderReplicaMap = new HashMap<>();

			Map orderId = new HashMap<>();
			String transactionId = getMerchantTransactionId();
			orderId.put("id", transactionId);

			customerOrderReplicaMap.put("order", orderId);

			customerOrderReplicaRequest.setOrderId(transactionId);
			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);

			customerOrderReplicaMap.put("cartId", customerOrderReplicaRequest.getCartId());

			try {
				customerOrderReplicaMap.put("phonePeResponse",
						phonepeServiceImpl.initiatePhonepePayment(transactionId,
								Integer.valueOf(customerOrderReplicaRequest.getRazorPayRequest().getAmount()),
								contactNumber, customerOrderReplicaRequest.getRedirectUrl(), customerOrderReplicaRequest.getCallBackUrl()));

			} catch (Exception e) {
				e.printStackTrace();
				customerOrderReplicaMap.put("phonePeResponse", new HashedMap<>());
			}

			return customerOrderReplicaMap;

		} else {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
					"paymentDetails transcation Details are mandatory");
		}

	}

	private static String getMerchantTransactionId() {

		return "OD_" + MerchantTransactionIdGenerator.getRandomString();
	}


	@Override
	public List<CustomerOrderReplica> getCustomerOrderByMoblieNo(String contactNumber,Integer aid) {
		
		Schedule latestschedule = customerOrderReplicaDoa.getlatestschedule();
		
		if (latestschedule != null && latestschedule.getCreationTimestamp()!=null) {
			
	        if (latestschedule.getStatus().equals(UserStatus.ACTIVE)) {
	        	
	        	Customers customer = customerDetailsDao.getByContactNoAndApartment(contactNumber, aid);
	        	if (customer != null) { // Ensure the customer exists
	        		List<CustomerOrder> customerOrderList = customerOrderReplicaDoa.getListCustomerOrderByCustomerId(customer.getCtid());
	        		
	                double totalOrderAmount = 0.0;
	       
                if (customerOrderList != null && !customerOrderList.isEmpty() && customerOrderList.add(customerOrder). {
                    for (CustomerOrder customerOrder : customerOrderList) {
                        Double orderAmount = customerOrder.getAmount();
                        
                        if(orderAmount>200) {
                        	
                        }
                        if (orderAmount != null) {
                            totalOrderAmount += orderAmount;
                            if(totalOrderAmount>200) {
                            	totalOrderAmount+customerOrder
                            }
                        }
                    }
                    System.out.println("Total Order Amount: " + totalOrderAmount);
                    List<CustomerOrderReplica> customerOrderReplicas = new ArrayList<>();
                    return customerOrderReplicas;
                } else {
                    return Collections.emptyList(); // or return null or an appropriate value
                }
            } else {
              
                return null; // or an appropriate value
            }
        } else {
            // Handle the case when the latest schedule is not active
            return null; // or an appropriate value
        }
    } else {
        // Handle the case when there is no latest schedule or its creation timestamp is null
        return null; // or an appropriate value
    }
	}
}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-09-21 15:05:24.984
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-09-21 15:05:24.986
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-21 15:05:25.067
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.xyram.daydrop.serviceimpl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.transaction.Transactional;

import org.apache.commons.collections4.map.HashedMap;
import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.server.ResponseStatusException;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.xyram.daydrop.admin.model.CurrentUser;
import com.xyram.daydrop.basemodel.Base64Wrapper;
import com.xyram.daydrop.basemodel.MerchantTransactionIdGenerator;
import com.xyram.daydrop.basemodel.PhonepeSerializer;
import com.xyram.daydrop.dao.ApartmentDao;
import com.xyram.daydrop.dao.CustomerDetailsDao;
import com.xyram.daydrop.dao.CustomerOrderDao;
import com.xyram.daydrop.dao.CustomerOrderReplicaDoa;
import com.xyram.daydrop.dao.SheduleDao;
import com.xyram.daydrop.enumtypes.UserStatus;
import com.xyram.daydrop.model.Apartments;
import com.xyram.daydrop.model.CustomerOrder;
import com.xyram.daydrop.model.CustomerOrderReplica;
import com.xyram.daydrop.model.Customers;
import com.xyram.daydrop.model.Schedule;
import com.xyram.daydrop.modelMapper.PaymentInstrument;
import com.xyram.daydrop.modelMapper.PhonePePayModel;
import com.xyram.daydrop.request.CustomerOrderReplicaRequest;
import com.xyram.daydrop.response.RazorPayRequest;
import com.xyram.daydrop.service.CustomerOrderPriceService;
import com.xyram.daydrop.service.CustomerOrderReplicaService;
import com.xyram.daydrop.util.HashEncoder;
import com.xyram.daydrop.util.RazorPay;
import com.xyram.daydrop.service.ConsumerService;

@Transactional
@Service
public class CustomerOrderReplicaServiceImpl implements CustomerOrderReplicaService {

	@Autowired
	CustomerOrderReplicaDoa customerOrderReplicaDoa;

	@Autowired
	ApartmentDao apartmentDao;

	@Autowired
	SheduleDao scheduleDao;

	@Autowired
	CustomerDetailsDao customerDetailsDao;

	@Autowired
	ConsumerService consumerService;

	@Autowired
	CurrentUser currentUser;

	@Autowired
	PhonepeServiceImpl phonepeServiceImpl;

	@Value("${merchant_id}")
	private String merchantId;

	@Value("${salt_key}")
	private String saltKey;

	@Value("${salt_index}")
	private String saltIndex;

	@Override
	public Map createCustomerOrderReplicaService(CustomerOrderReplicaRequest customerOrderReplicaRequest,
			String contactNumber, Integer aparmentId)

	{

		Map response = new HashedMap<>();

		response.put("message", "success");
		CustomerOrderReplica customerOrderReplica = null;

		if (customerOrderReplicaRequest.getCartId() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "cartId is mandatory ");
		}
		long razorPayCount = 0;
		if (customerOrderReplicaRequest.getOrderId() != null) {

			razorPayCount = customerOrderReplicaDoa.getRazorPayExistByCartId(customerOrderReplicaRequest.getOrderId());
		}

		if (customerOrderReplicaRequest.getCustomerDetails() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Order Details  is mandatory ");
		}

		customerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(customerOrderReplicaRequest.getCartId(),
				contactNumber);

		if (customerOrderReplica != null) {
			customerOrderReplica.setCartId(customerOrderReplica.getCartId());

			if (customerOrderReplica.isOrdered()) {
				throw new ResponseStatusException(HttpStatus.CONFLICT, "Your Order is Placed With cart Details");
			}

//			if (razorPayCount >= 1 && !(customerOrderReplica.getRazorPayOrderId() != null
//					&& customerOrderReplica.getRazorPayOrderId().equals(customerOrderReplicaRequest.getOrderId()))) {
//				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
//			}

			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);

			customerOrderReplica.setAttempts(customerOrderReplica.getAttempts() + 1);
			customerOrderReplica.setUpdatedTime(new Date());

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		} else {

			customerOrderReplica = new CustomerOrderReplica();
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);
			customerOrderReplica.setCartId(customerOrderReplicaRequest.getCartId());
			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());

			if (razorPayCount > 0) {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
			}

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			Schedule schedule = scheduleDao.getlatestScheduleCustomers();

			if (schedule != null) {

				try {
					customerOrderReplica.setSchedule(schedule.getsId() != null ? schedule.getsId().toString() : null);
				} catch (Exception e) {
					e.printStackTrace();
				}
			} else {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
						"Sorry We Are Not Accepting Any Order Right now");

			}

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		}

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicas(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String schedule = null;

		Map filter = request.containsKey("filters") ? (Map) request.get("filters") : null;
		if (filter != null) {
			statusType = filter.containsKey("statusType") ? ((String) filter.get("statusType")).toLowerCase() : null;
			searchQuery = filter.containsKey("searchQuery") ? ((String) filter.get("searchQuery")).toLowerCase() : null;
			schedule = filter.containsKey("schedule") ? (String.valueOf(filter.get("schedule"))) : null;

		}

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplica(searchQuery, statusType, schedule);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");

				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setStreetName(
						customers.get("streetName") != null ? (String) customers.get("streetName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicasBySchedule(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String scheduleId = null;

		Schedule schedule = scheduleDao.getlatestScheduleCustomers();

		if (schedule != null) {

			try {
				scheduleId = schedule.getsId() != null ? schedule.getsId().toString() : null;
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

		statusType = request.containsKey("statusType") ? ((String) request.get("statusType")).toLowerCase() : "Success";

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplicaBySchdeule(statusType, scheduleId);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");
				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				System.out.println("customers" + customers.get("customerName"));

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public CustomerOrderReplica getCustomerOrderReplicaByCartId(String cartId) {

		CustomerOrderReplica CustomerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(cartId,
				currentUser.getContactNumber());

		ObjectMapper objectMapper = new ObjectMapper();
		try {

			// convert JSON string to Map
			Map<String, Object> customerOrderReplicaMap = objectMapper
					.readValue(CustomerOrderReplica.getCustomerOrderDetails(), Map.class);

			Object customerOrder = customerOrderReplicaMap.get("customerOrder");
			Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

			Object quanityList = items.get("quantity");
			Map customers = customerDetailsDao.getByContactNumberAndApartment(CustomerOrderReplica.getContactNumber(),
					CustomerOrderReplica.getApartmentId());

			System.out.println("customers" + customers.get("customerName"));

			// Apartments apartments =
			// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
			CustomerOrderReplica.setApartmentName(
					customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

			CustomerOrderReplica.setCustomerDetails(customers);

			CustomerOrderReplica.setCustomerOrder(customerOrder);
			CustomerOrderReplica.setQuatityList(quanityList);

		} catch (Exception e) {
			e.printStackTrace();
		}

		return CustomerOrderReplica;

	}

	@Override
	public Map createCustomerOrderReplica(CustomerOrderReplicaRequest customerOrderReplicaRequest, String contactNumber,
			Integer aparmentId) {

		if (customerOrderReplicaRequest.getRazorPayRequest() != null) {

//			Map razorPay = consumerService.createRazorPayOrder(customerOrderReplicaRequest.getRazorPayRequest());
//			customerOrderReplicaRequest.setOrderId(razorPay.get("order") != null ? (String)((RazorPay) razorPay.get("order")).getId() : null);	
//	
//			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);
//
//			razorPay.put("cartId", customerOrderReplicaRequest.getCartId());

			Map customerOrderReplicaMap = new HashMap<>();

			Map orderId = new HashMap<>();
			String transactionId = getMerchantTransactionId();
			orderId.put("id", transactionId);

			customerOrderReplicaMap.put("order", orderId);

			customerOrderReplicaRequest.setOrderId(transactionId);
			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);

			customerOrderReplicaMap.put("cartId", customerOrderReplicaRequest.getCartId());

			try {
				customerOrderReplicaMap.put("phonePeResponse",
						phonepeServiceImpl.initiatePhonepePayment(transactionId,
								Integer.valueOf(customerOrderReplicaRequest.getRazorPayRequest().getAmount()),
								contactNumber, customerOrderReplicaRequest.getRedirectUrl(), customerOrderReplicaRequest.getCallBackUrl()));

			} catch (Exception e) {
				e.printStackTrace();
				customerOrderReplicaMap.put("phonePeResponse", new HashedMap<>());
			}

			return customerOrderReplicaMap;

		} else {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
					"paymentDetails transcation Details are mandatory");
		}

	}

	private static String getMerchantTransactionId() {

		return "OD_" + MerchantTransactionIdGenerator.getRandomString();
	}


	@Override
	public List<CustomerOrderReplica> getCustomerOrderByMoblieNo(String contactNumber,Integer aid) {
		
		Schedule latestschedule = customerOrderReplicaDoa.getlatestschedule();
		
		if (latestschedule != null && latestschedule.getCreationTimestamp()!=null) {
			
	        if (latestschedule.getStatus().equals(UserStatus.ACTIVE)) {
	        	
	        	Customers customer = customerDetailsDao.getByContactNoAndApartment(contactNumber, aid);
	        	if (customer != null) { // Ensure the customer exists
	        		List<CustomerOrder> customerOrderList = customerOrderReplicaDoa.getListCustomerOrderByCustomerId(customer.getCtid());
	        		
	                double totalOrderAmount = 0.0;
	       
                if (customerOrderList != null && !customerOrderList.isEmpty() && customerOrderList.add(customerOrder). {
                    for (CustomerOrder customerOrder : customerOrderList) {
                        Double orderAmount = customerOrder.getAmount();
                        
                        if(orderAmount>200) {
                        	
                        }
                        if (orderAmount != null) {
                            totalOrderAmount += orderAmount;
                            if(totalOrderAmount>200) {
                            	totalOrderAmount+customerOrder
                            }
                        }
                    }
                    System.out.println("Total Order Amount: " + totalOrderAmount);
                    List<CustomerOrderReplica> customerOrderReplicas = new ArrayList<>();
                    return customerOrderReplicas;
                } else {
                    return Collections.emptyList(); // or return null or an appropriate value
                }
            } else {
              
                return null; // or an appropriate value
            }
        } else {
            // Handle the case when the latest schedule is not active
            return null; // or an appropriate value
        }
    } else {
        // Handle the case when there is no latest schedule or its creation timestamp is null
        return null; // or an appropriate value
    }
	}
}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1003)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:799)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:743)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:666)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:658)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-09-21 15:05:25.069
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1003)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:799)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:743)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:666)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:658)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-09-21 15:05:25.071
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1003)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:799)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:743)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:666)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:658)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-21 15:05:27.192
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.xyram.daydrop.serviceimpl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.transaction.Transactional;

import org.apache.commons.collections4.map.HashedMap;
import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.server.ResponseStatusException;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.xyram.daydrop.admin.model.CurrentUser;
import com.xyram.daydrop.basemodel.Base64Wrapper;
import com.xyram.daydrop.basemodel.MerchantTransactionIdGenerator;
import com.xyram.daydrop.basemodel.PhonepeSerializer;
import com.xyram.daydrop.dao.ApartmentDao;
import com.xyram.daydrop.dao.CustomerDetailsDao;
import com.xyram.daydrop.dao.CustomerOrderDao;
import com.xyram.daydrop.dao.CustomerOrderReplicaDoa;
import com.xyram.daydrop.dao.SheduleDao;
import com.xyram.daydrop.enumtypes.UserStatus;
import com.xyram.daydrop.model.Apartments;
import com.xyram.daydrop.model.CustomerOrder;
import com.xyram.daydrop.model.CustomerOrderReplica;
import com.xyram.daydrop.model.Customers;
import com.xyram.daydrop.model.Schedule;
import com.xyram.daydrop.modelMapper.PaymentInstrument;
import com.xyram.daydrop.modelMapper.PhonePePayModel;
import com.xyram.daydrop.request.CustomerOrderReplicaRequest;
import com.xyram.daydrop.response.RazorPayRequest;
import com.xyram.daydrop.service.CustomerOrderPriceService;
import com.xyram.daydrop.service.CustomerOrderReplicaService;
import com.xyram.daydrop.util.HashEncoder;
import com.xyram.daydrop.util.RazorPay;
import com.xyram.daydrop.service.ConsumerService;

@Transactional
@Service
public class CustomerOrderReplicaServiceImpl implements CustomerOrderReplicaService {

	@Autowired
	CustomerOrderReplicaDoa customerOrderReplicaDoa;

	@Autowired
	ApartmentDao apartmentDao;

	@Autowired
	SheduleDao scheduleDao;

	@Autowired
	CustomerDetailsDao customerDetailsDao;

	@Autowired
	ConsumerService consumerService;

	@Autowired
	CurrentUser currentUser;

	@Autowired
	PhonepeServiceImpl phonepeServiceImpl;

	@Value("${merchant_id}")
	private String merchantId;

	@Value("${salt_key}")
	private String saltKey;

	@Value("${salt_index}")
	private String saltIndex;

	@Override
	public Map createCustomerOrderReplicaService(CustomerOrderReplicaRequest customerOrderReplicaRequest,
			String contactNumber, Integer aparmentId)

	{

		Map response = new HashedMap<>();

		response.put("message", "success");
		CustomerOrderReplica customerOrderReplica = null;

		if (customerOrderReplicaRequest.getCartId() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "cartId is mandatory ");
		}
		long razorPayCount = 0;
		if (customerOrderReplicaRequest.getOrderId() != null) {

			razorPayCount = customerOrderReplicaDoa.getRazorPayExistByCartId(customerOrderReplicaRequest.getOrderId());
		}

		if (customerOrderReplicaRequest.getCustomerDetails() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Order Details  is mandatory ");
		}

		customerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(customerOrderReplicaRequest.getCartId(),
				contactNumber);

		if (customerOrderReplica != null) {
			customerOrderReplica.setCartId(customerOrderReplica.getCartId());

			if (customerOrderReplica.isOrdered()) {
				throw new ResponseStatusException(HttpStatus.CONFLICT, "Your Order is Placed With cart Details");
			}

//			if (razorPayCount >= 1 && !(customerOrderReplica.getRazorPayOrderId() != null
//					&& customerOrderReplica.getRazorPayOrderId().equals(customerOrderReplicaRequest.getOrderId()))) {
//				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
//			}

			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);

			customerOrderReplica.setAttempts(customerOrderReplica.getAttempts() + 1);
			customerOrderReplica.setUpdatedTime(new Date());

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		} else {

			customerOrderReplica = new CustomerOrderReplica();
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);
			customerOrderReplica.setCartId(customerOrderReplicaRequest.getCartId());
			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());

			if (razorPayCount > 0) {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
			}

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			Schedule schedule = scheduleDao.getlatestScheduleCustomers();

			if (schedule != null) {

				try {
					customerOrderReplica.setSchedule(schedule.getsId() != null ? schedule.getsId().toString() : null);
				} catch (Exception e) {
					e.printStackTrace();
				}
			} else {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
						"Sorry We Are Not Accepting Any Order Right now");

			}

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		}

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicas(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String schedule = null;

		Map filter = request.containsKey("filters") ? (Map) request.get("filters") : null;
		if (filter != null) {
			statusType = filter.containsKey("statusType") ? ((String) filter.get("statusType")).toLowerCase() : null;
			searchQuery = filter.containsKey("searchQuery") ? ((String) filter.get("searchQuery")).toLowerCase() : null;
			schedule = filter.containsKey("schedule") ? (String.valueOf(filter.get("schedule"))) : null;

		}

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplica(searchQuery, statusType, schedule);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");

				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setStreetName(
						customers.get("streetName") != null ? (String) customers.get("streetName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicasBySchedule(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String scheduleId = null;

		Schedule schedule = scheduleDao.getlatestScheduleCustomers();

		if (schedule != null) {

			try {
				scheduleId = schedule.getsId() != null ? schedule.getsId().toString() : null;
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

		statusType = request.containsKey("statusType") ? ((String) request.get("statusType")).toLowerCase() : "Success";

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplicaBySchdeule(statusType, scheduleId);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");
				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				System.out.println("customers" + customers.get("customerName"));

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public CustomerOrderReplica getCustomerOrderReplicaByCartId(String cartId) {

		CustomerOrderReplica CustomerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(cartId,
				currentUser.getContactNumber());

		ObjectMapper objectMapper = new ObjectMapper();
		try {

			// convert JSON string to Map
			Map<String, Object> customerOrderReplicaMap = objectMapper
					.readValue(CustomerOrderReplica.getCustomerOrderDetails(), Map.class);

			Object customerOrder = customerOrderReplicaMap.get("customerOrder");
			Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

			Object quanityList = items.get("quantity");
			Map customers = customerDetailsDao.getByContactNumberAndApartment(CustomerOrderReplica.getContactNumber(),
					CustomerOrderReplica.getApartmentId());

			System.out.println("customers" + customers.get("customerName"));

			// Apartments apartments =
			// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
			CustomerOrderReplica.setApartmentName(
					customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

			CustomerOrderReplica.setCustomerDetails(customers);

			CustomerOrderReplica.setCustomerOrder(customerOrder);
			CustomerOrderReplica.setQuatityList(quanityList);

		} catch (Exception e) {
			e.printStackTrace();
		}

		return CustomerOrderReplica;

	}

	@Override
	public Map createCustomerOrderReplica(CustomerOrderReplicaRequest customerOrderReplicaRequest, String contactNumber,
			Integer aparmentId) {

		if (customerOrderReplicaRequest.getRazorPayRequest() != null) {

//			Map razorPay = consumerService.createRazorPayOrder(customerOrderReplicaRequest.getRazorPayRequest());
//			customerOrderReplicaRequest.setOrderId(razorPay.get("order") != null ? (String)((RazorPay) razorPay.get("order")).getId() : null);	
//	
//			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);
//
//			razorPay.put("cartId", customerOrderReplicaRequest.getCartId());

			Map customerOrderReplicaMap = new HashMap<>();

			Map orderId = new HashMap<>();
			String transactionId = getMerchantTransactionId();
			orderId.put("id", transactionId);

			customerOrderReplicaMap.put("order", orderId);

			customerOrderReplicaRequest.setOrderId(transactionId);
			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);

			customerOrderReplicaMap.put("cartId", customerOrderReplicaRequest.getCartId());

			try {
				customerOrderReplicaMap.put("phonePeResponse",
						phonepeServiceImpl.initiatePhonepePayment(transactionId,
								Integer.valueOf(customerOrderReplicaRequest.getRazorPayRequest().getAmount()),
								contactNumber, customerOrderReplicaRequest.getRedirectUrl(), customerOrderReplicaRequest.getCallBackUrl()));

			} catch (Exception e) {
				e.printStackTrace();
				customerOrderReplicaMap.put("phonePeResponse", new HashedMap<>());
			}

			return customerOrderReplicaMap;

		} else {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
					"paymentDetails transcation Details are mandatory");
		}

	}

	private static String getMerchantTransactionId() {

		return "OD_" + MerchantTransactionIdGenerator.getRandomString();
	}


	@Override
	public List<CustomerOrderReplica> getCustomerOrderByMoblieNo(String contactNumber,Integer aid) {
		
		Schedule latestschedule = customerOrderReplicaDoa.getlatestschedule();
		
		if (latestschedule != null && latestschedule.getCreationTimestamp()!=null) {
			
	        if (latestschedule.getStatus().equals(UserStatus.ACTIVE)) {
	        	
	        	Customers customer = customerDetailsDao.getByContactNoAndApartment(contactNumber, aid);
	        	if (customer != null) { // Ensure the customer exists
	        		List<CustomerOrder> customerOrderList = customerOrderReplicaDoa.getListCustomerOrderByCustomerId(customer.getCtid());
	        		
	                double totalOrderAmount = 0.0;
	       
                if (customerOrderList != null && !customerOrderList.isEmpty() && customerOrderList.add(customerOrder). {
                    for (CustomerOrder customerOrder : customerOrderList) {
                        Double orderAmount = customerOrder.getAmount();
                        
                        if(orderAmount>200) {
                        	
                        }
                        if (orderAmount != null) {
                            totalOrderAmount += orderAmount;
                            if(totalOrderAmount>200) {
                            	totalOrderAmount+customerOrder
                            }
                        }
                    }
                    System.out.println("Total Order Amount: " + totalOrderAmount);
                    List<CustomerOrderReplica> customerOrderReplicas = new ArrayList<>();
                    return customerOrderReplicas;
                } else {
                    return Collections.emptyList(); // or return null or an appropriate value
                }
            } else {
              
                return null; // or an appropriate value
            }
        } else {
            // Handle the case when the latest schedule is not active
            return null; // or an appropriate value
        }
    } else {
        // Handle the case when there is no latest schedule or its creation timestamp is null
        return null; // or an appropriate value
    }
	}
}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-09-21 15:05:27.193
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-09-21 15:05:27.195
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-21 15:05:29.218
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.xyram.daydrop.serviceimpl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.transaction.Transactional;

import org.apache.commons.collections4.map.HashedMap;
import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.server.ResponseStatusException;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.xyram.daydrop.admin.model.CurrentUser;
import com.xyram.daydrop.basemodel.Base64Wrapper;
import com.xyram.daydrop.basemodel.MerchantTransactionIdGenerator;
import com.xyram.daydrop.basemodel.PhonepeSerializer;
import com.xyram.daydrop.dao.ApartmentDao;
import com.xyram.daydrop.dao.CustomerDetailsDao;
import com.xyram.daydrop.dao.CustomerOrderDao;
import com.xyram.daydrop.dao.CustomerOrderReplicaDoa;
import com.xyram.daydrop.dao.SheduleDao;
import com.xyram.daydrop.enumtypes.UserStatus;
import com.xyram.daydrop.model.Apartments;
import com.xyram.daydrop.model.CustomerOrder;
import com.xyram.daydrop.model.CustomerOrderReplica;
import com.xyram.daydrop.model.Customers;
import com.xyram.daydrop.model.Schedule;
import com.xyram.daydrop.modelMapper.PaymentInstrument;
import com.xyram.daydrop.modelMapper.PhonePePayModel;
import com.xyram.daydrop.request.CustomerOrderReplicaRequest;
import com.xyram.daydrop.response.RazorPayRequest;
import com.xyram.daydrop.service.CustomerOrderPriceService;
import com.xyram.daydrop.service.CustomerOrderReplicaService;
import com.xyram.daydrop.util.HashEncoder;
import com.xyram.daydrop.util.RazorPay;
import com.xyram.daydrop.service.ConsumerService;

@Transactional
@Service
public class CustomerOrderReplicaServiceImpl implements CustomerOrderReplicaService {

	@Autowired
	CustomerOrderReplicaDoa customerOrderReplicaDoa;

	@Autowired
	ApartmentDao apartmentDao;

	@Autowired
	SheduleDao scheduleDao;

	@Autowired
	CustomerDetailsDao customerDetailsDao;

	@Autowired
	ConsumerService consumerService;

	@Autowired
	CurrentUser currentUser;

	@Autowired
	PhonepeServiceImpl phonepeServiceImpl;

	@Value("${merchant_id}")
	private String merchantId;

	@Value("${salt_key}")
	private String saltKey;

	@Value("${salt_index}")
	private String saltIndex;

	@Override
	public Map createCustomerOrderReplicaService(CustomerOrderReplicaRequest customerOrderReplicaRequest,
			String contactNumber, Integer aparmentId)

	{

		Map response = new HashedMap<>();

		response.put("message", "success");
		CustomerOrderReplica customerOrderReplica = null;

		if (customerOrderReplicaRequest.getCartId() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "cartId is mandatory ");
		}
		long razorPayCount = 0;
		if (customerOrderReplicaRequest.getOrderId() != null) {

			razorPayCount = customerOrderReplicaDoa.getRazorPayExistByCartId(customerOrderReplicaRequest.getOrderId());
		}

		if (customerOrderReplicaRequest.getCustomerDetails() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Order Details  is mandatory ");
		}

		customerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(customerOrderReplicaRequest.getCartId(),
				contactNumber);

		if (customerOrderReplica != null) {
			customerOrderReplica.setCartId(customerOrderReplica.getCartId());

			if (customerOrderReplica.isOrdered()) {
				throw new ResponseStatusException(HttpStatus.CONFLICT, "Your Order is Placed With cart Details");
			}

//			if (razorPayCount >= 1 && !(customerOrderReplica.getRazorPayOrderId() != null
//					&& customerOrderReplica.getRazorPayOrderId().equals(customerOrderReplicaRequest.getOrderId()))) {
//				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
//			}

			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);

			customerOrderReplica.setAttempts(customerOrderReplica.getAttempts() + 1);
			customerOrderReplica.setUpdatedTime(new Date());

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		} else {

			customerOrderReplica = new CustomerOrderReplica();
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);
			customerOrderReplica.setCartId(customerOrderReplicaRequest.getCartId());
			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());

			if (razorPayCount > 0) {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
			}

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			Schedule schedule = scheduleDao.getlatestScheduleCustomers();

			if (schedule != null) {

				try {
					customerOrderReplica.setSchedule(schedule.getsId() != null ? schedule.getsId().toString() : null);
				} catch (Exception e) {
					e.printStackTrace();
				}
			} else {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
						"Sorry We Are Not Accepting Any Order Right now");

			}

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		}

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicas(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String schedule = null;

		Map filter = request.containsKey("filters") ? (Map) request.get("filters") : null;
		if (filter != null) {
			statusType = filter.containsKey("statusType") ? ((String) filter.get("statusType")).toLowerCase() : null;
			searchQuery = filter.containsKey("searchQuery") ? ((String) filter.get("searchQuery")).toLowerCase() : null;
			schedule = filter.containsKey("schedule") ? (String.valueOf(filter.get("schedule"))) : null;

		}

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplica(searchQuery, statusType, schedule);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");

				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setStreetName(
						customers.get("streetName") != null ? (String) customers.get("streetName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicasBySchedule(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String scheduleId = null;

		Schedule schedule = scheduleDao.getlatestScheduleCustomers();

		if (schedule != null) {

			try {
				scheduleId = schedule.getsId() != null ? schedule.getsId().toString() : null;
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

		statusType = request.containsKey("statusType") ? ((String) request.get("statusType")).toLowerCase() : "Success";

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplicaBySchdeule(statusType, scheduleId);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");
				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				System.out.println("customers" + customers.get("customerName"));

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public CustomerOrderReplica getCustomerOrderReplicaByCartId(String cartId) {

		CustomerOrderReplica CustomerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(cartId,
				currentUser.getContactNumber());

		ObjectMapper objectMapper = new ObjectMapper();
		try {

			// convert JSON string to Map
			Map<String, Object> customerOrderReplicaMap = objectMapper
					.readValue(CustomerOrderReplica.getCustomerOrderDetails(), Map.class);

			Object customerOrder = customerOrderReplicaMap.get("customerOrder");
			Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

			Object quanityList = items.get("quantity");
			Map customers = customerDetailsDao.getByContactNumberAndApartment(CustomerOrderReplica.getContactNumber(),
					CustomerOrderReplica.getApartmentId());

			System.out.println("customers" + customers.get("customerName"));

			// Apartments apartments =
			// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
			CustomerOrderReplica.setApartmentName(
					customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

			CustomerOrderReplica.setCustomerDetails(customers);

			CustomerOrderReplica.setCustomerOrder(customerOrder);
			CustomerOrderReplica.setQuatityList(quanityList);

		} catch (Exception e) {
			e.printStackTrace();
		}

		return CustomerOrderReplica;

	}

	@Override
	public Map createCustomerOrderReplica(CustomerOrderReplicaRequest customerOrderReplicaRequest, String contactNumber,
			Integer aparmentId) {

		if (customerOrderReplicaRequest.getRazorPayRequest() != null) {

//			Map razorPay = consumerService.createRazorPayOrder(customerOrderReplicaRequest.getRazorPayRequest());
//			customerOrderReplicaRequest.setOrderId(razorPay.get("order") != null ? (String)((RazorPay) razorPay.get("order")).getId() : null);	
//	
//			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);
//
//			razorPay.put("cartId", customerOrderReplicaRequest.getCartId());

			Map customerOrderReplicaMap = new HashMap<>();

			Map orderId = new HashMap<>();
			String transactionId = getMerchantTransactionId();
			orderId.put("id", transactionId);

			customerOrderReplicaMap.put("order", orderId);

			customerOrderReplicaRequest.setOrderId(transactionId);
			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);

			customerOrderReplicaMap.put("cartId", customerOrderReplicaRequest.getCartId());

			try {
				customerOrderReplicaMap.put("phonePeResponse",
						phonepeServiceImpl.initiatePhonepePayment(transactionId,
								Integer.valueOf(customerOrderReplicaRequest.getRazorPayRequest().getAmount()),
								contactNumber, customerOrderReplicaRequest.getRedirectUrl(), customerOrderReplicaRequest.getCallBackUrl()));

			} catch (Exception e) {
				e.printStackTrace();
				customerOrderReplicaMap.put("phonePeResponse", new HashedMap<>());
			}

			return customerOrderReplicaMap;

		} else {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
					"paymentDetails transcation Details are mandatory");
		}

	}

	private static String getMerchantTransactionId() {

		return "OD_" + MerchantTransactionIdGenerator.getRandomString();
	}


	@Override
	public List<CustomerOrderReplica> getCustomerOrderByMoblieNo(String contactNumber,Integer aid) {
		
		Schedule latestschedule = customerOrderReplicaDoa.getlatestschedule();
		
		if (latestschedule != null && latestschedule.getCreationTimestamp()!=null) {
			
	        if (latestschedule.getStatus().equals(UserStatus.ACTIVE)) {
	        	
	        	Customers customer = customerDetailsDao.getByContactNoAndApartment(contactNumber, aid);
	        	if (customer != null) { // Ensure the customer exists
	        		List<CustomerOrder> customerOrderList = customerOrderReplicaDoa.getListCustomerOrderByCustomerId(customer.getCtid());
	        		
	                double totalOrderAmount = 0.0;
	       
                if (customerOrderList != null && !customerOrderList.isEmpty() && customerOrderList.add(customerOrder). {
                    for (CustomerOrder customerOrder : customerOrderList) {
                        Double orderAmount = customerOrder.getAmount();
                        
                        if(orderAmount>200) {
                        	
                        }
                        if (orderAmount != null) {
                            totalOrderAmount += orderAmount;
                            if(totalOrderAmount>200) {
                            	totalOrderAmount+customerOrder
                            }
                        }
                    }
                    System.out.println("Total Order Amount: " + totalOrderAmount);
                    List<CustomerOrderReplica> customerOrderReplicas = new ArrayList<>();
                    return customerOrderReplicas;
                } else {
                    return Collections.emptyList(); // or return null or an appropriate value
                }
            } else {
              
                return null; // or an appropriate value
            }
        } else {
            // Handle the case when the latest schedule is not active
            return null; // or an appropriate value
        }
    } else {
        // Handle the case when there is no latest schedule or its creation timestamp is null
        return null; // or an appropriate value
    }
	}
}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1003)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:799)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:743)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:666)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:658)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.lambda$0(LSJavaHoverProvider.java:68)
	at java.base/java.util.concurrent.CompletableFuture$AsyncRun.run(CompletableFuture.java:1804)
	at java.base/java.util.concurrent.CompletableFuture$AsyncRun.exec(CompletableFuture.java:1796)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:373)
	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1182)
	at java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1655)
	at java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1622)
	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:165)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-09-21 15:05:29.221
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1003)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:799)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:743)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:666)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:658)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.lambda$0(LSJavaHoverProvider.java:68)
	at java.base/java.util.concurrent.CompletableFuture$AsyncRun.run(CompletableFuture.java:1804)
	at java.base/java.util.concurrent.CompletableFuture$AsyncRun.exec(CompletableFuture.java:1796)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:373)
	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1182)
	at java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1655)
	at java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1622)
	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:165)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-09-21 15:05:29.225
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1003)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:799)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:743)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:666)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:658)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.lambda$0(LSJavaHoverProvider.java:68)
	at java.base/java.util.concurrent.CompletableFuture$AsyncRun.run(CompletableFuture.java:1804)
	at java.base/java.util.concurrent.CompletableFuture$AsyncRun.exec(CompletableFuture.java:1796)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:373)
	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1182)
	at java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1655)
	at java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1622)
	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:165)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-21 15:05:29.324
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.xyram.daydrop.serviceimpl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.transaction.Transactional;

import org.apache.commons.collections4.map.HashedMap;
import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.server.ResponseStatusException;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.xyram.daydrop.admin.model.CurrentUser;
import com.xyram.daydrop.basemodel.Base64Wrapper;
import com.xyram.daydrop.basemodel.MerchantTransactionIdGenerator;
import com.xyram.daydrop.basemodel.PhonepeSerializer;
import com.xyram.daydrop.dao.ApartmentDao;
import com.xyram.daydrop.dao.CustomerDetailsDao;
import com.xyram.daydrop.dao.CustomerOrderDao;
import com.xyram.daydrop.dao.CustomerOrderReplicaDoa;
import com.xyram.daydrop.dao.SheduleDao;
import com.xyram.daydrop.enumtypes.UserStatus;
import com.xyram.daydrop.model.Apartments;
import com.xyram.daydrop.model.CustomerOrder;
import com.xyram.daydrop.model.CustomerOrderReplica;
import com.xyram.daydrop.model.Customers;
import com.xyram.daydrop.model.Schedule;
import com.xyram.daydrop.modelMapper.PaymentInstrument;
import com.xyram.daydrop.modelMapper.PhonePePayModel;
import com.xyram.daydrop.request.CustomerOrderReplicaRequest;
import com.xyram.daydrop.response.RazorPayRequest;
import com.xyram.daydrop.service.CustomerOrderPriceService;
import com.xyram.daydrop.service.CustomerOrderReplicaService;
import com.xyram.daydrop.util.HashEncoder;
import com.xyram.daydrop.util.RazorPay;
import com.xyram.daydrop.service.ConsumerService;

@Transactional
@Service
public class CustomerOrderReplicaServiceImpl implements CustomerOrderReplicaService {

	@Autowired
	CustomerOrderReplicaDoa customerOrderReplicaDoa;

	@Autowired
	ApartmentDao apartmentDao;

	@Autowired
	SheduleDao scheduleDao;

	@Autowired
	CustomerDetailsDao customerDetailsDao;

	@Autowired
	ConsumerService consumerService;

	@Autowired
	CurrentUser currentUser;

	@Autowired
	PhonepeServiceImpl phonepeServiceImpl;

	@Value("${merchant_id}")
	private String merchantId;

	@Value("${salt_key}")
	private String saltKey;

	@Value("${salt_index}")
	private String saltIndex;

	@Override
	public Map createCustomerOrderReplicaService(CustomerOrderReplicaRequest customerOrderReplicaRequest,
			String contactNumber, Integer aparmentId)

	{

		Map response = new HashedMap<>();

		response.put("message", "success");
		CustomerOrderReplica customerOrderReplica = null;

		if (customerOrderReplicaRequest.getCartId() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "cartId is mandatory ");
		}
		long razorPayCount = 0;
		if (customerOrderReplicaRequest.getOrderId() != null) {

			razorPayCount = customerOrderReplicaDoa.getRazorPayExistByCartId(customerOrderReplicaRequest.getOrderId());
		}

		if (customerOrderReplicaRequest.getCustomerDetails() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Order Details  is mandatory ");
		}

		customerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(customerOrderReplicaRequest.getCartId(),
				contactNumber);

		if (customerOrderReplica != null) {
			customerOrderReplica.setCartId(customerOrderReplica.getCartId());

			if (customerOrderReplica.isOrdered()) {
				throw new ResponseStatusException(HttpStatus.CONFLICT, "Your Order is Placed With cart Details");
			}

//			if (razorPayCount >= 1 && !(customerOrderReplica.getRazorPayOrderId() != null
//					&& customerOrderReplica.getRazorPayOrderId().equals(customerOrderReplicaRequest.getOrderId()))) {
//				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
//			}

			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);

			customerOrderReplica.setAttempts(customerOrderReplica.getAttempts() + 1);
			customerOrderReplica.setUpdatedTime(new Date());

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		} else {

			customerOrderReplica = new CustomerOrderReplica();
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);
			customerOrderReplica.setCartId(customerOrderReplicaRequest.getCartId());
			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());

			if (razorPayCount > 0) {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
			}

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			Schedule schedule = scheduleDao.getlatestScheduleCustomers();

			if (schedule != null) {

				try {
					customerOrderReplica.setSchedule(schedule.getsId() != null ? schedule.getsId().toString() : null);
				} catch (Exception e) {
					e.printStackTrace();
				}
			} else {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
						"Sorry We Are Not Accepting Any Order Right now");

			}

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		}

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicas(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String schedule = null;

		Map filter = request.containsKey("filters") ? (Map) request.get("filters") : null;
		if (filter != null) {
			statusType = filter.containsKey("statusType") ? ((String) filter.get("statusType")).toLowerCase() : null;
			searchQuery = filter.containsKey("searchQuery") ? ((String) filter.get("searchQuery")).toLowerCase() : null;
			schedule = filter.containsKey("schedule") ? (String.valueOf(filter.get("schedule"))) : null;

		}

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplica(searchQuery, statusType, schedule);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");

				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setStreetName(
						customers.get("streetName") != null ? (String) customers.get("streetName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicasBySchedule(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String scheduleId = null;

		Schedule schedule = scheduleDao.getlatestScheduleCustomers();

		if (schedule != null) {

			try {
				scheduleId = schedule.getsId() != null ? schedule.getsId().toString() : null;
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

		statusType = request.containsKey("statusType") ? ((String) request.get("statusType")).toLowerCase() : "Success";

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplicaBySchdeule(statusType, scheduleId);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");
				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				System.out.println("customers" + customers.get("customerName"));

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public CustomerOrderReplica getCustomerOrderReplicaByCartId(String cartId) {

		CustomerOrderReplica CustomerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(cartId,
				currentUser.getContactNumber());

		ObjectMapper objectMapper = new ObjectMapper();
		try {

			// convert JSON string to Map
			Map<String, Object> customerOrderReplicaMap = objectMapper
					.readValue(CustomerOrderReplica.getCustomerOrderDetails(), Map.class);

			Object customerOrder = customerOrderReplicaMap.get("customerOrder");
			Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

			Object quanityList = items.get("quantity");
			Map customers = customerDetailsDao.getByContactNumberAndApartment(CustomerOrderReplica.getContactNumber(),
					CustomerOrderReplica.getApartmentId());

			System.out.println("customers" + customers.get("customerName"));

			// Apartments apartments =
			// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
			CustomerOrderReplica.setApartmentName(
					customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

			CustomerOrderReplica.setCustomerDetails(customers);

			CustomerOrderReplica.setCustomerOrder(customerOrder);
			CustomerOrderReplica.setQuatityList(quanityList);

		} catch (Exception e) {
			e.printStackTrace();
		}

		return CustomerOrderReplica;

	}

	@Override
	public Map createCustomerOrderReplica(CustomerOrderReplicaRequest customerOrderReplicaRequest, String contactNumber,
			Integer aparmentId) {

		if (customerOrderReplicaRequest.getRazorPayRequest() != null) {

//			Map razorPay = consumerService.createRazorPayOrder(customerOrderReplicaRequest.getRazorPayRequest());
//			customerOrderReplicaRequest.setOrderId(razorPay.get("order") != null ? (String)((RazorPay) razorPay.get("order")).getId() : null);	
//	
//			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);
//
//			razorPay.put("cartId", customerOrderReplicaRequest.getCartId());

			Map customerOrderReplicaMap = new HashMap<>();

			Map orderId = new HashMap<>();
			String transactionId = getMerchantTransactionId();
			orderId.put("id", transactionId);

			customerOrderReplicaMap.put("order", orderId);

			customerOrderReplicaRequest.setOrderId(transactionId);
			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);

			customerOrderReplicaMap.put("cartId", customerOrderReplicaRequest.getCartId());

			try {
				customerOrderReplicaMap.put("phonePeResponse",
						phonepeServiceImpl.initiatePhonepePayment(transactionId,
								Integer.valueOf(customerOrderReplicaRequest.getRazorPayRequest().getAmount()),
								contactNumber, customerOrderReplicaRequest.getRedirectUrl(), customerOrderReplicaRequest.getCallBackUrl()));

			} catch (Exception e) {
				e.printStackTrace();
				customerOrderReplicaMap.put("phonePeResponse", new HashedMap<>());
			}

			return customerOrderReplicaMap;

		} else {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
					"paymentDetails transcation Details are mandatory");
		}

	}

	private static String getMerchantTransactionId() {

		return "OD_" + MerchantTransactionIdGenerator.getRandomString();
	}


	@Override
	public List<CustomerOrderReplica> getCustomerOrderByMoblieNo(String contactNumber,Integer aid) {
		
		Schedule latestschedule = customerOrderReplicaDoa.getlatestschedule();
		
		if (latestschedule != null && latestschedule.getCreationTimestamp()!=null) {
			
	        if (latestschedule.getStatus().equals(UserStatus.ACTIVE)) {
	        	
	        	Customers customer = customerDetailsDao.getByContactNoAndApartment(contactNumber, aid);
	        	if (customer != null) { // Ensure the customer exists
	        		List<CustomerOrder> customerOrderList = customerOrderReplicaDoa.getListCustomerOrderByCustomerId(customer.getCtid());
	        		
	                double totalOrderAmount = 0.0;
	       
                if (customerOrderList != null && !customerOrderList.isEmpty() && customerOrderList.add(customerOrder). {
                    for (CustomerOrder customerOrder : customerOrderList) {
                        Double orderAmount = customerOrder.getAmount();
                        
                        if(orderAmount>200) {
                        	
                        }
                        if (orderAmount != null) {
                            totalOrderAmount += orderAmount;
                            if(totalOrderAmount>200) {
                            	totalOrderAmount+customerOrder
                            }
                        }
                    }
                    System.out.println("Total Order Amount: " + totalOrderAmount);
                    List<CustomerOrderReplica> customerOrderReplicas = new ArrayList<>();
                    return customerOrderReplicas;
                } else {
                    return Collections.emptyList(); // or return null or an appropriate value
                }
            } else {
              
                return null; // or an appropriate value
            }
        } else {
            // Handle the case when the latest schedule is not active
            return null; // or an appropriate value
        }
    } else {
        // Handle the case when there is no latest schedule or its creation timestamp is null
        return null; // or an appropriate value
    }
	}
}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-09-21 15:05:29.326
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-09-21 15:05:29.328
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-21 15:05:29.459
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.xyram.daydrop.serviceimpl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.transaction.Transactional;

import org.apache.commons.collections4.map.HashedMap;
import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.server.ResponseStatusException;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.xyram.daydrop.admin.model.CurrentUser;
import com.xyram.daydrop.basemodel.Base64Wrapper;
import com.xyram.daydrop.basemodel.MerchantTransactionIdGenerator;
import com.xyram.daydrop.basemodel.PhonepeSerializer;
import com.xyram.daydrop.dao.ApartmentDao;
import com.xyram.daydrop.dao.CustomerDetailsDao;
import com.xyram.daydrop.dao.CustomerOrderDao;
import com.xyram.daydrop.dao.CustomerOrderReplicaDoa;
import com.xyram.daydrop.dao.SheduleDao;
import com.xyram.daydrop.enumtypes.UserStatus;
import com.xyram.daydrop.model.Apartments;
import com.xyram.daydrop.model.CustomerOrder;
import com.xyram.daydrop.model.CustomerOrderReplica;
import com.xyram.daydrop.model.Customers;
import com.xyram.daydrop.model.Schedule;
import com.xyram.daydrop.modelMapper.PaymentInstrument;
import com.xyram.daydrop.modelMapper.PhonePePayModel;
import com.xyram.daydrop.request.CustomerOrderReplicaRequest;
import com.xyram.daydrop.response.RazorPayRequest;
import com.xyram.daydrop.service.CustomerOrderPriceService;
import com.xyram.daydrop.service.CustomerOrderReplicaService;
import com.xyram.daydrop.util.HashEncoder;
import com.xyram.daydrop.util.RazorPay;
import com.xyram.daydrop.service.ConsumerService;

@Transactional
@Service
public class CustomerOrderReplicaServiceImpl implements CustomerOrderReplicaService {

	@Autowired
	CustomerOrderReplicaDoa customerOrderReplicaDoa;

	@Autowired
	ApartmentDao apartmentDao;

	@Autowired
	SheduleDao scheduleDao;

	@Autowired
	CustomerDetailsDao customerDetailsDao;

	@Autowired
	ConsumerService consumerService;

	@Autowired
	CurrentUser currentUser;

	@Autowired
	PhonepeServiceImpl phonepeServiceImpl;

	@Value("${merchant_id}")
	private String merchantId;

	@Value("${salt_key}")
	private String saltKey;

	@Value("${salt_index}")
	private String saltIndex;

	@Override
	public Map createCustomerOrderReplicaService(CustomerOrderReplicaRequest customerOrderReplicaRequest,
			String contactNumber, Integer aparmentId)

	{

		Map response = new HashedMap<>();

		response.put("message", "success");
		CustomerOrderReplica customerOrderReplica = null;

		if (customerOrderReplicaRequest.getCartId() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "cartId is mandatory ");
		}
		long razorPayCount = 0;
		if (customerOrderReplicaRequest.getOrderId() != null) {

			razorPayCount = customerOrderReplicaDoa.getRazorPayExistByCartId(customerOrderReplicaRequest.getOrderId());
		}

		if (customerOrderReplicaRequest.getCustomerDetails() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Order Details  is mandatory ");
		}

		customerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(customerOrderReplicaRequest.getCartId(),
				contactNumber);

		if (customerOrderReplica != null) {
			customerOrderReplica.setCartId(customerOrderReplica.getCartId());

			if (customerOrderReplica.isOrdered()) {
				throw new ResponseStatusException(HttpStatus.CONFLICT, "Your Order is Placed With cart Details");
			}

//			if (razorPayCount >= 1 && !(customerOrderReplica.getRazorPayOrderId() != null
//					&& customerOrderReplica.getRazorPayOrderId().equals(customerOrderReplicaRequest.getOrderId()))) {
//				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
//			}

			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);

			customerOrderReplica.setAttempts(customerOrderReplica.getAttempts() + 1);
			customerOrderReplica.setUpdatedTime(new Date());

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		} else {

			customerOrderReplica = new CustomerOrderReplica();
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);
			customerOrderReplica.setCartId(customerOrderReplicaRequest.getCartId());
			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());

			if (razorPayCount > 0) {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
			}

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			Schedule schedule = scheduleDao.getlatestScheduleCustomers();

			if (schedule != null) {

				try {
					customerOrderReplica.setSchedule(schedule.getsId() != null ? schedule.getsId().toString() : null);
				} catch (Exception e) {
					e.printStackTrace();
				}
			} else {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
						"Sorry We Are Not Accepting Any Order Right now");

			}

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		}

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicas(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String schedule = null;

		Map filter = request.containsKey("filters") ? (Map) request.get("filters") : null;
		if (filter != null) {
			statusType = filter.containsKey("statusType") ? ((String) filter.get("statusType")).toLowerCase() : null;
			searchQuery = filter.containsKey("searchQuery") ? ((String) filter.get("searchQuery")).toLowerCase() : null;
			schedule = filter.containsKey("schedule") ? (String.valueOf(filter.get("schedule"))) : null;

		}

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplica(searchQuery, statusType, schedule);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");

				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setStreetName(
						customers.get("streetName") != null ? (String) customers.get("streetName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicasBySchedule(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String scheduleId = null;

		Schedule schedule = scheduleDao.getlatestScheduleCustomers();

		if (schedule != null) {

			try {
				scheduleId = schedule.getsId() != null ? schedule.getsId().toString() : null;
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

		statusType = request.containsKey("statusType") ? ((String) request.get("statusType")).toLowerCase() : "Success";

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplicaBySchdeule(statusType, scheduleId);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");
				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				System.out.println("customers" + customers.get("customerName"));

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public CustomerOrderReplica getCustomerOrderReplicaByCartId(String cartId) {

		CustomerOrderReplica CustomerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(cartId,
				currentUser.getContactNumber());

		ObjectMapper objectMapper = new ObjectMapper();
		try {

			// convert JSON string to Map
			Map<String, Object> customerOrderReplicaMap = objectMapper
					.readValue(CustomerOrderReplica.getCustomerOrderDetails(), Map.class);

			Object customerOrder = customerOrderReplicaMap.get("customerOrder");
			Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

			Object quanityList = items.get("quantity");
			Map customers = customerDetailsDao.getByContactNumberAndApartment(CustomerOrderReplica.getContactNumber(),
					CustomerOrderReplica.getApartmentId());

			System.out.println("customers" + customers.get("customerName"));

			// Apartments apartments =
			// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
			CustomerOrderReplica.setApartmentName(
					customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

			CustomerOrderReplica.setCustomerDetails(customers);

			CustomerOrderReplica.setCustomerOrder(customerOrder);
			CustomerOrderReplica.setQuatityList(quanityList);

		} catch (Exception e) {
			e.printStackTrace();
		}

		return CustomerOrderReplica;

	}

	@Override
	public Map createCustomerOrderReplica(CustomerOrderReplicaRequest customerOrderReplicaRequest, String contactNumber,
			Integer aparmentId) {

		if (customerOrderReplicaRequest.getRazorPayRequest() != null) {

//			Map razorPay = consumerService.createRazorPayOrder(customerOrderReplicaRequest.getRazorPayRequest());
//			customerOrderReplicaRequest.setOrderId(razorPay.get("order") != null ? (String)((RazorPay) razorPay.get("order")).getId() : null);	
//	
//			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);
//
//			razorPay.put("cartId", customerOrderReplicaRequest.getCartId());

			Map customerOrderReplicaMap = new HashMap<>();

			Map orderId = new HashMap<>();
			String transactionId = getMerchantTransactionId();
			orderId.put("id", transactionId);

			customerOrderReplicaMap.put("order", orderId);

			customerOrderReplicaRequest.setOrderId(transactionId);
			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);

			customerOrderReplicaMap.put("cartId", customerOrderReplicaRequest.getCartId());

			try {
				customerOrderReplicaMap.put("phonePeResponse",
						phonepeServiceImpl.initiatePhonepePayment(transactionId,
								Integer.valueOf(customerOrderReplicaRequest.getRazorPayRequest().getAmount()),
								contactNumber, customerOrderReplicaRequest.getRedirectUrl(), customerOrderReplicaRequest.getCallBackUrl()));

			} catch (Exception e) {
				e.printStackTrace();
				customerOrderReplicaMap.put("phonePeResponse", new HashedMap<>());
			}

			return customerOrderReplicaMap;

		} else {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
					"paymentDetails transcation Details are mandatory");
		}

	}

	private static String getMerchantTransactionId() {

		return "OD_" + MerchantTransactionIdGenerator.getRandomString();
	}


	@Override
	public List<CustomerOrderReplica> getCustomerOrderByMoblieNo(String contactNumber,Integer aid) {
		
		Schedule latestschedule = customerOrderReplicaDoa.getlatestschedule();
		
		if (latestschedule != null && latestschedule.getCreationTimestamp()!=null) {
			
	        if (latestschedule.getStatus().equals(UserStatus.ACTIVE)) {
	        	
	        	Customers customer = customerDetailsDao.getByContactNoAndApartment(contactNumber, aid);
	        	if (customer != null) { // Ensure the customer exists
	        		List<CustomerOrder> customerOrderList = customerOrderReplicaDoa.getListCustomerOrderByCustomerId(customer.getCtid());
	        		
	                double totalOrderAmount = 0.0;
	       
                if (customerOrderList != null && !customerOrderList.isEmpty() && customerOrderList.add(customerOrder). {
                    for (CustomerOrder customerOrder : customerOrderList) {
                        Double orderAmount = customerOrder.getAmount();
                        
                        if(orderAmount>200) {
                        	
                        }
                        if (orderAmount != null) {
                            totalOrderAmount += orderAmount;
                            if(totalOrderAmount>200) {
                            	totalOrderAmount+customerOrder
                            }
                        }
                    }
                    System.out.println("Total Order Amount: " + totalOrderAmount);
                    List<CustomerOrderReplica> customerOrderReplicas = new ArrayList<>();
                    return customerOrderReplicas;
                } else {
                    return Collections.emptyList(); // or return null or an appropriate value
                }
            } else {
              
                return null; // or an appropriate value
            }
        } else {
            // Handle the case when the latest schedule is not active
            return null; // or an appropriate value
        }
    } else {
        // Handle the case when there is no latest schedule or its creation timestamp is null
        return null; // or an appropriate value
    }
	}
}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1003)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:799)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:743)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:666)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:658)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-09-21 15:05:29.461
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1003)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:799)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:743)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:666)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:658)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-09-21 15:05:29.463
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1003)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:799)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:743)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:666)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:658)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-21 15:05:32.767
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.xyram.daydrop.serviceimpl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.transaction.Transactional;

import org.apache.commons.collections4.map.HashedMap;
import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.server.ResponseStatusException;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.xyram.daydrop.admin.model.CurrentUser;
import com.xyram.daydrop.basemodel.Base64Wrapper;
import com.xyram.daydrop.basemodel.MerchantTransactionIdGenerator;
import com.xyram.daydrop.basemodel.PhonepeSerializer;
import com.xyram.daydrop.dao.ApartmentDao;
import com.xyram.daydrop.dao.CustomerDetailsDao;
import com.xyram.daydrop.dao.CustomerOrderDao;
import com.xyram.daydrop.dao.CustomerOrderReplicaDoa;
import com.xyram.daydrop.dao.SheduleDao;
import com.xyram.daydrop.enumtypes.UserStatus;
import com.xyram.daydrop.model.Apartments;
import com.xyram.daydrop.model.CustomerOrder;
import com.xyram.daydrop.model.CustomerOrderReplica;
import com.xyram.daydrop.model.Customers;
import com.xyram.daydrop.model.Schedule;
import com.xyram.daydrop.modelMapper.PaymentInstrument;
import com.xyram.daydrop.modelMapper.PhonePePayModel;
import com.xyram.daydrop.request.CustomerOrderReplicaRequest;
import com.xyram.daydrop.response.RazorPayRequest;
import com.xyram.daydrop.service.CustomerOrderPriceService;
import com.xyram.daydrop.service.CustomerOrderReplicaService;
import com.xyram.daydrop.util.HashEncoder;
import com.xyram.daydrop.util.RazorPay;
import com.xyram.daydrop.service.ConsumerService;

@Transactional
@Service
public class CustomerOrderReplicaServiceImpl implements CustomerOrderReplicaService {

	@Autowired
	CustomerOrderReplicaDoa customerOrderReplicaDoa;

	@Autowired
	ApartmentDao apartmentDao;

	@Autowired
	SheduleDao scheduleDao;

	@Autowired
	CustomerDetailsDao customerDetailsDao;

	@Autowired
	ConsumerService consumerService;

	@Autowired
	CurrentUser currentUser;

	@Autowired
	PhonepeServiceImpl phonepeServiceImpl;

	@Value("${merchant_id}")
	private String merchantId;

	@Value("${salt_key}")
	private String saltKey;

	@Value("${salt_index}")
	private String saltIndex;

	@Override
	public Map createCustomerOrderReplicaService(CustomerOrderReplicaRequest customerOrderReplicaRequest,
			String contactNumber, Integer aparmentId)

	{

		Map response = new HashedMap<>();

		response.put("message", "success");
		CustomerOrderReplica customerOrderReplica = null;

		if (customerOrderReplicaRequest.getCartId() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "cartId is mandatory ");
		}
		long razorPayCount = 0;
		if (customerOrderReplicaRequest.getOrderId() != null) {

			razorPayCount = customerOrderReplicaDoa.getRazorPayExistByCartId(customerOrderReplicaRequest.getOrderId());
		}

		if (customerOrderReplicaRequest.getCustomerDetails() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Order Details  is mandatory ");
		}

		customerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(customerOrderReplicaRequest.getCartId(),
				contactNumber);

		if (customerOrderReplica != null) {
			customerOrderReplica.setCartId(customerOrderReplica.getCartId());

			if (customerOrderReplica.isOrdered()) {
				throw new ResponseStatusException(HttpStatus.CONFLICT, "Your Order is Placed With cart Details");
			}

//			if (razorPayCount >= 1 && !(customerOrderReplica.getRazorPayOrderId() != null
//					&& customerOrderReplica.getRazorPayOrderId().equals(customerOrderReplicaRequest.getOrderId()))) {
//				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
//			}

			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);

			customerOrderReplica.setAttempts(customerOrderReplica.getAttempts() + 1);
			customerOrderReplica.setUpdatedTime(new Date());

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		} else {

			customerOrderReplica = new CustomerOrderReplica();
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);
			customerOrderReplica.setCartId(customerOrderReplicaRequest.getCartId());
			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());

			if (razorPayCount > 0) {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
			}

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			Schedule schedule = scheduleDao.getlatestScheduleCustomers();

			if (schedule != null) {

				try {
					customerOrderReplica.setSchedule(schedule.getsId() != null ? schedule.getsId().toString() : null);
				} catch (Exception e) {
					e.printStackTrace();
				}
			} else {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
						"Sorry We Are Not Accepting Any Order Right now");

			}

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		}

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicas(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String schedule = null;

		Map filter = request.containsKey("filters") ? (Map) request.get("filters") : null;
		if (filter != null) {
			statusType = filter.containsKey("statusType") ? ((String) filter.get("statusType")).toLowerCase() : null;
			searchQuery = filter.containsKey("searchQuery") ? ((String) filter.get("searchQuery")).toLowerCase() : null;
			schedule = filter.containsKey("schedule") ? (String.valueOf(filter.get("schedule"))) : null;

		}

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplica(searchQuery, statusType, schedule);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");

				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setStreetName(
						customers.get("streetName") != null ? (String) customers.get("streetName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicasBySchedule(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String scheduleId = null;

		Schedule schedule = scheduleDao.getlatestScheduleCustomers();

		if (schedule != null) {

			try {
				scheduleId = schedule.getsId() != null ? schedule.getsId().toString() : null;
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

		statusType = request.containsKey("statusType") ? ((String) request.get("statusType")).toLowerCase() : "Success";

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplicaBySchdeule(statusType, scheduleId);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");
				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				System.out.println("customers" + customers.get("customerName"));

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public CustomerOrderReplica getCustomerOrderReplicaByCartId(String cartId) {

		CustomerOrderReplica CustomerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(cartId,
				currentUser.getContactNumber());

		ObjectMapper objectMapper = new ObjectMapper();
		try {

			// convert JSON string to Map
			Map<String, Object> customerOrderReplicaMap = objectMapper
					.readValue(CustomerOrderReplica.getCustomerOrderDetails(), Map.class);

			Object customerOrder = customerOrderReplicaMap.get("customerOrder");
			Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

			Object quanityList = items.get("quantity");
			Map customers = customerDetailsDao.getByContactNumberAndApartment(CustomerOrderReplica.getContactNumber(),
					CustomerOrderReplica.getApartmentId());

			System.out.println("customers" + customers.get("customerName"));

			// Apartments apartments =
			// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
			CustomerOrderReplica.setApartmentName(
					customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

			CustomerOrderReplica.setCustomerDetails(customers);

			CustomerOrderReplica.setCustomerOrder(customerOrder);
			CustomerOrderReplica.setQuatityList(quanityList);

		} catch (Exception e) {
			e.printStackTrace();
		}

		return CustomerOrderReplica;

	}

	@Override
	public Map createCustomerOrderReplica(CustomerOrderReplicaRequest customerOrderReplicaRequest, String contactNumber,
			Integer aparmentId) {

		if (customerOrderReplicaRequest.getRazorPayRequest() != null) {

//			Map razorPay = consumerService.createRazorPayOrder(customerOrderReplicaRequest.getRazorPayRequest());
//			customerOrderReplicaRequest.setOrderId(razorPay.get("order") != null ? (String)((RazorPay) razorPay.get("order")).getId() : null);	
//	
//			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);
//
//			razorPay.put("cartId", customerOrderReplicaRequest.getCartId());

			Map customerOrderReplicaMap = new HashMap<>();

			Map orderId = new HashMap<>();
			String transactionId = getMerchantTransactionId();
			orderId.put("id", transactionId);

			customerOrderReplicaMap.put("order", orderId);

			customerOrderReplicaRequest.setOrderId(transactionId);
			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);

			customerOrderReplicaMap.put("cartId", customerOrderReplicaRequest.getCartId());

			try {
				customerOrderReplicaMap.put("phonePeResponse",
						phonepeServiceImpl.initiatePhonepePayment(transactionId,
								Integer.valueOf(customerOrderReplicaRequest.getRazorPayRequest().getAmount()),
								contactNumber, customerOrderReplicaRequest.getRedirectUrl(), customerOrderReplicaRequest.getCallBackUrl()));

			} catch (Exception e) {
				e.printStackTrace();
				customerOrderReplicaMap.put("phonePeResponse", new HashedMap<>());
			}

			return customerOrderReplicaMap;

		} else {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
					"paymentDetails transcation Details are mandatory");
		}

	}

	private static String getMerchantTransactionId() {

		return "OD_" + MerchantTransactionIdGenerator.getRandomString();
	}


	@Override
	public List<CustomerOrderReplica> getCustomerOrderByMoblieNo(String contactNumber,Integer aid) {
		
		Schedule latestschedule = customerOrderReplicaDoa.getlatestschedule();
		
		if (latestschedule != null && latestschedule.getCreationTimestamp()!=null) {
			
	        if (latestschedule.getStatus().equals(UserStatus.ACTIVE)) {
	        	
	        	Customers customer = customerDetailsDao.getByContactNoAndApartment(contactNumber, aid);
	        	if (customer != null) { // Ensure the customer exists
	        		List<CustomerOrder> customerOrderList = customerOrderReplicaDoa.getListCustomerOrderByCustomerId(customer.getCtid());
	        		
	                double totalOrderAmount = 0.0;
	       
                if (customerOrderList != null && !customerOrderList.isEmpty() && customerOrderList.add(customerOrder). {
                    for (CustomerOrder customerOrder : customerOrderList) {
                        Double orderAmount = customerOrder.getAmount();
                        
                        if(orderAmount>200) {
                        	
                        }
                        if (orderAmount != null) {
                            totalOrderAmount += orderAmount;
                            if(totalOrderAmount>200) {
                            	totalOrderAmount+customerOrder
                            }
                        }
                    }
                    System.out.println("Total Order Amount: " + totalOrderAmount);
                    List<CustomerOrderReplica> customerOrderReplicas = new ArrayList<>();
                    return customerOrderReplicas;
                } else {
                    return Collections.emptyList(); // or return null or an appropriate value
                }
            } else {
              
                return null; // or an appropriate value
            }
        } else {
            // Handle the case when the latest schedule is not active
            return null; // or an appropriate value
        }
    } else {
        // Handle the case when there is no latest schedule or its creation timestamp is null
        return null; // or an appropriate value
    }
	}
}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-09-21 15:05:32.769
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-09-21 15:05:32.770
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-21 15:05:34.919
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.xyram.daydrop.serviceimpl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.transaction.Transactional;

import org.apache.commons.collections4.map.HashedMap;
import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.server.ResponseStatusException;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.xyram.daydrop.admin.model.CurrentUser;
import com.xyram.daydrop.basemodel.Base64Wrapper;
import com.xyram.daydrop.basemodel.MerchantTransactionIdGenerator;
import com.xyram.daydrop.basemodel.PhonepeSerializer;
import com.xyram.daydrop.dao.ApartmentDao;
import com.xyram.daydrop.dao.CustomerDetailsDao;
import com.xyram.daydrop.dao.CustomerOrderDao;
import com.xyram.daydrop.dao.CustomerOrderReplicaDoa;
import com.xyram.daydrop.dao.SheduleDao;
import com.xyram.daydrop.enumtypes.UserStatus;
import com.xyram.daydrop.model.Apartments;
import com.xyram.daydrop.model.CustomerOrder;
import com.xyram.daydrop.model.CustomerOrderReplica;
import com.xyram.daydrop.model.Customers;
import com.xyram.daydrop.model.Schedule;
import com.xyram.daydrop.modelMapper.PaymentInstrument;
import com.xyram.daydrop.modelMapper.PhonePePayModel;
import com.xyram.daydrop.request.CustomerOrderReplicaRequest;
import com.xyram.daydrop.response.RazorPayRequest;
import com.xyram.daydrop.service.CustomerOrderPriceService;
import com.xyram.daydrop.service.CustomerOrderReplicaService;
import com.xyram.daydrop.util.HashEncoder;
import com.xyram.daydrop.util.RazorPay;
import com.xyram.daydrop.service.ConsumerService;

@Transactional
@Service
public class CustomerOrderReplicaServiceImpl implements CustomerOrderReplicaService {

	@Autowired
	CustomerOrderReplicaDoa customerOrderReplicaDoa;

	@Autowired
	ApartmentDao apartmentDao;

	@Autowired
	SheduleDao scheduleDao;

	@Autowired
	CustomerDetailsDao customerDetailsDao;

	@Autowired
	ConsumerService consumerService;

	@Autowired
	CurrentUser currentUser;

	@Autowired
	PhonepeServiceImpl phonepeServiceImpl;

	@Value("${merchant_id}")
	private String merchantId;

	@Value("${salt_key}")
	private String saltKey;

	@Value("${salt_index}")
	private String saltIndex;

	@Override
	public Map createCustomerOrderReplicaService(CustomerOrderReplicaRequest customerOrderReplicaRequest,
			String contactNumber, Integer aparmentId)

	{

		Map response = new HashedMap<>();

		response.put("message", "success");
		CustomerOrderReplica customerOrderReplica = null;

		if (customerOrderReplicaRequest.getCartId() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "cartId is mandatory ");
		}
		long razorPayCount = 0;
		if (customerOrderReplicaRequest.getOrderId() != null) {

			razorPayCount = customerOrderReplicaDoa.getRazorPayExistByCartId(customerOrderReplicaRequest.getOrderId());
		}

		if (customerOrderReplicaRequest.getCustomerDetails() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Order Details  is mandatory ");
		}

		customerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(customerOrderReplicaRequest.getCartId(),
				contactNumber);

		if (customerOrderReplica != null) {
			customerOrderReplica.setCartId(customerOrderReplica.getCartId());

			if (customerOrderReplica.isOrdered()) {
				throw new ResponseStatusException(HttpStatus.CONFLICT, "Your Order is Placed With cart Details");
			}

//			if (razorPayCount >= 1 && !(customerOrderReplica.getRazorPayOrderId() != null
//					&& customerOrderReplica.getRazorPayOrderId().equals(customerOrderReplicaRequest.getOrderId()))) {
//				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
//			}

			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);

			customerOrderReplica.setAttempts(customerOrderReplica.getAttempts() + 1);
			customerOrderReplica.setUpdatedTime(new Date());

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		} else {

			customerOrderReplica = new CustomerOrderReplica();
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);
			customerOrderReplica.setCartId(customerOrderReplicaRequest.getCartId());
			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());

			if (razorPayCount > 0) {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
			}

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			Schedule schedule = scheduleDao.getlatestScheduleCustomers();

			if (schedule != null) {

				try {
					customerOrderReplica.setSchedule(schedule.getsId() != null ? schedule.getsId().toString() : null);
				} catch (Exception e) {
					e.printStackTrace();
				}
			} else {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
						"Sorry We Are Not Accepting Any Order Right now");

			}

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		}

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicas(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String schedule = null;

		Map filter = request.containsKey("filters") ? (Map) request.get("filters") : null;
		if (filter != null) {
			statusType = filter.containsKey("statusType") ? ((String) filter.get("statusType")).toLowerCase() : null;
			searchQuery = filter.containsKey("searchQuery") ? ((String) filter.get("searchQuery")).toLowerCase() : null;
			schedule = filter.containsKey("schedule") ? (String.valueOf(filter.get("schedule"))) : null;

		}

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplica(searchQuery, statusType, schedule);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");

				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setStreetName(
						customers.get("streetName") != null ? (String) customers.get("streetName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicasBySchedule(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String scheduleId = null;

		Schedule schedule = scheduleDao.getlatestScheduleCustomers();

		if (schedule != null) {

			try {
				scheduleId = schedule.getsId() != null ? schedule.getsId().toString() : null;
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

		statusType = request.containsKey("statusType") ? ((String) request.get("statusType")).toLowerCase() : "Success";

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplicaBySchdeule(statusType, scheduleId);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");
				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				System.out.println("customers" + customers.get("customerName"));

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public CustomerOrderReplica getCustomerOrderReplicaByCartId(String cartId) {

		CustomerOrderReplica CustomerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(cartId,
				currentUser.getContactNumber());

		ObjectMapper objectMapper = new ObjectMapper();
		try {

			// convert JSON string to Map
			Map<String, Object> customerOrderReplicaMap = objectMapper
					.readValue(CustomerOrderReplica.getCustomerOrderDetails(), Map.class);

			Object customerOrder = customerOrderReplicaMap.get("customerOrder");
			Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

			Object quanityList = items.get("quantity");
			Map customers = customerDetailsDao.getByContactNumberAndApartment(CustomerOrderReplica.getContactNumber(),
					CustomerOrderReplica.getApartmentId());

			System.out.println("customers" + customers.get("customerName"));

			// Apartments apartments =
			// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
			CustomerOrderReplica.setApartmentName(
					customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

			CustomerOrderReplica.setCustomerDetails(customers);

			CustomerOrderReplica.setCustomerOrder(customerOrder);
			CustomerOrderReplica.setQuatityList(quanityList);

		} catch (Exception e) {
			e.printStackTrace();
		}

		return CustomerOrderReplica;

	}

	@Override
	public Map createCustomerOrderReplica(CustomerOrderReplicaRequest customerOrderReplicaRequest, String contactNumber,
			Integer aparmentId) {

		if (customerOrderReplicaRequest.getRazorPayRequest() != null) {

//			Map razorPay = consumerService.createRazorPayOrder(customerOrderReplicaRequest.getRazorPayRequest());
//			customerOrderReplicaRequest.setOrderId(razorPay.get("order") != null ? (String)((RazorPay) razorPay.get("order")).getId() : null);	
//	
//			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);
//
//			razorPay.put("cartId", customerOrderReplicaRequest.getCartId());

			Map customerOrderReplicaMap = new HashMap<>();

			Map orderId = new HashMap<>();
			String transactionId = getMerchantTransactionId();
			orderId.put("id", transactionId);

			customerOrderReplicaMap.put("order", orderId);

			customerOrderReplicaRequest.setOrderId(transactionId);
			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);

			customerOrderReplicaMap.put("cartId", customerOrderReplicaRequest.getCartId());

			try {
				customerOrderReplicaMap.put("phonePeResponse",
						phonepeServiceImpl.initiatePhonepePayment(transactionId,
								Integer.valueOf(customerOrderReplicaRequest.getRazorPayRequest().getAmount()),
								contactNumber, customerOrderReplicaRequest.getRedirectUrl(), customerOrderReplicaRequest.getCallBackUrl()));

			} catch (Exception e) {
				e.printStackTrace();
				customerOrderReplicaMap.put("phonePeResponse", new HashedMap<>());
			}

			return customerOrderReplicaMap;

		} else {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
					"paymentDetails transcation Details are mandatory");
		}

	}

	private static String getMerchantTransactionId() {

		return "OD_" + MerchantTransactionIdGenerator.getRandomString();
	}


	@Override
	public List<CustomerOrderReplica> getCustomerOrderByMoblieNo(String contactNumber,Integer aid) {
		
		Schedule latestschedule = customerOrderReplicaDoa.getlatestschedule();
		
		if (latestschedule != null && latestschedule.getCreationTimestamp()!=null) {
			
	        if (latestschedule.getStatus().equals(UserStatus.ACTIVE)) {
	        	
	        	Customers customer = customerDetailsDao.getByContactNoAndApartment(contactNumber, aid);
	        	if (customer != null) { // Ensure the customer exists
	        		List<CustomerOrder> customerOrderList = customerOrderReplicaDoa.getListCustomerOrderByCustomerId(customer.getCtid());
	        		
	                double totalOrderAmount = 0.0;
	       
                if (customerOrderList != null && !customerOrderList.isEmpty() && customerOrderList.add(customerOrder). {
                    for (CustomerOrder customerOrder : customerOrderList) {
                        Double orderAmount = customerOrder.getAmount();
                        
                        if(orderAmount>200) {
                        	
                        	
                        }
                        if (orderAmount != null) {
                            totalOrderAmount += orderAmount;
                            if(totalOrderAmount>200) {
                            	totalOrderAmount+customerOrder
                            }
                        }
                    }
                    System.out.println("Total Order Amount: " + totalOrderAmount);
                    List<CustomerOrderReplica> customerOrderReplicas = new ArrayList<>();
                    return customerOrderReplicas;
                } else {
                    return Collections.emptyList(); // or return null or an appropriate value
                }
            } else {
              
                return null; // or an appropriate value
            }
        } else {
            // Handle the case when the latest schedule is not active
            return null; // or an appropriate value
        }
    } else {
        // Handle the case when there is no latest schedule or its creation timestamp is null
        return null; // or an appropriate value
    }
	}
}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-09-21 15:05:34.922
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-09-21 15:05:34.925
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-21 15:05:35.015
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.xyram.daydrop.serviceimpl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.transaction.Transactional;

import org.apache.commons.collections4.map.HashedMap;
import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.server.ResponseStatusException;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.xyram.daydrop.admin.model.CurrentUser;
import com.xyram.daydrop.basemodel.Base64Wrapper;
import com.xyram.daydrop.basemodel.MerchantTransactionIdGenerator;
import com.xyram.daydrop.basemodel.PhonepeSerializer;
import com.xyram.daydrop.dao.ApartmentDao;
import com.xyram.daydrop.dao.CustomerDetailsDao;
import com.xyram.daydrop.dao.CustomerOrderDao;
import com.xyram.daydrop.dao.CustomerOrderReplicaDoa;
import com.xyram.daydrop.dao.SheduleDao;
import com.xyram.daydrop.enumtypes.UserStatus;
import com.xyram.daydrop.model.Apartments;
import com.xyram.daydrop.model.CustomerOrder;
import com.xyram.daydrop.model.CustomerOrderReplica;
import com.xyram.daydrop.model.Customers;
import com.xyram.daydrop.model.Schedule;
import com.xyram.daydrop.modelMapper.PaymentInstrument;
import com.xyram.daydrop.modelMapper.PhonePePayModel;
import com.xyram.daydrop.request.CustomerOrderReplicaRequest;
import com.xyram.daydrop.response.RazorPayRequest;
import com.xyram.daydrop.service.CustomerOrderPriceService;
import com.xyram.daydrop.service.CustomerOrderReplicaService;
import com.xyram.daydrop.util.HashEncoder;
import com.xyram.daydrop.util.RazorPay;
import com.xyram.daydrop.service.ConsumerService;

@Transactional
@Service
public class CustomerOrderReplicaServiceImpl implements CustomerOrderReplicaService {

	@Autowired
	CustomerOrderReplicaDoa customerOrderReplicaDoa;

	@Autowired
	ApartmentDao apartmentDao;

	@Autowired
	SheduleDao scheduleDao;

	@Autowired
	CustomerDetailsDao customerDetailsDao;

	@Autowired
	ConsumerService consumerService;

	@Autowired
	CurrentUser currentUser;

	@Autowired
	PhonepeServiceImpl phonepeServiceImpl;

	@Value("${merchant_id}")
	private String merchantId;

	@Value("${salt_key}")
	private String saltKey;

	@Value("${salt_index}")
	private String saltIndex;

	@Override
	public Map createCustomerOrderReplicaService(CustomerOrderReplicaRequest customerOrderReplicaRequest,
			String contactNumber, Integer aparmentId)

	{

		Map response = new HashedMap<>();

		response.put("message", "success");
		CustomerOrderReplica customerOrderReplica = null;

		if (customerOrderReplicaRequest.getCartId() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "cartId is mandatory ");
		}
		long razorPayCount = 0;
		if (customerOrderReplicaRequest.getOrderId() != null) {

			razorPayCount = customerOrderReplicaDoa.getRazorPayExistByCartId(customerOrderReplicaRequest.getOrderId());
		}

		if (customerOrderReplicaRequest.getCustomerDetails() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Order Details  is mandatory ");
		}

		customerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(customerOrderReplicaRequest.getCartId(),
				contactNumber);

		if (customerOrderReplica != null) {
			customerOrderReplica.setCartId(customerOrderReplica.getCartId());

			if (customerOrderReplica.isOrdered()) {
				throw new ResponseStatusException(HttpStatus.CONFLICT, "Your Order is Placed With cart Details");
			}

//			if (razorPayCount >= 1 && !(customerOrderReplica.getRazorPayOrderId() != null
//					&& customerOrderReplica.getRazorPayOrderId().equals(customerOrderReplicaRequest.getOrderId()))) {
//				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
//			}

			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);

			customerOrderReplica.setAttempts(customerOrderReplica.getAttempts() + 1);
			customerOrderReplica.setUpdatedTime(new Date());

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		} else {

			customerOrderReplica = new CustomerOrderReplica();
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);
			customerOrderReplica.setCartId(customerOrderReplicaRequest.getCartId());
			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());

			if (razorPayCount > 0) {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
			}

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			Schedule schedule = scheduleDao.getlatestScheduleCustomers();

			if (schedule != null) {

				try {
					customerOrderReplica.setSchedule(schedule.getsId() != null ? schedule.getsId().toString() : null);
				} catch (Exception e) {
					e.printStackTrace();
				}
			} else {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
						"Sorry We Are Not Accepting Any Order Right now");

			}

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		}

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicas(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String schedule = null;

		Map filter = request.containsKey("filters") ? (Map) request.get("filters") : null;
		if (filter != null) {
			statusType = filter.containsKey("statusType") ? ((String) filter.get("statusType")).toLowerCase() : null;
			searchQuery = filter.containsKey("searchQuery") ? ((String) filter.get("searchQuery")).toLowerCase() : null;
			schedule = filter.containsKey("schedule") ? (String.valueOf(filter.get("schedule"))) : null;

		}

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplica(searchQuery, statusType, schedule);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");

				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setStreetName(
						customers.get("streetName") != null ? (String) customers.get("streetName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicasBySchedule(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String scheduleId = null;

		Schedule schedule = scheduleDao.getlatestScheduleCustomers();

		if (schedule != null) {

			try {
				scheduleId = schedule.getsId() != null ? schedule.getsId().toString() : null;
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

		statusType = request.containsKey("statusType") ? ((String) request.get("statusType")).toLowerCase() : "Success";

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplicaBySchdeule(statusType, scheduleId);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");
				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				System.out.println("customers" + customers.get("customerName"));

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public CustomerOrderReplica getCustomerOrderReplicaByCartId(String cartId) {

		CustomerOrderReplica CustomerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(cartId,
				currentUser.getContactNumber());

		ObjectMapper objectMapper = new ObjectMapper();
		try {

			// convert JSON string to Map
			Map<String, Object> customerOrderReplicaMap = objectMapper
					.readValue(CustomerOrderReplica.getCustomerOrderDetails(), Map.class);

			Object customerOrder = customerOrderReplicaMap.get("customerOrder");
			Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

			Object quanityList = items.get("quantity");
			Map customers = customerDetailsDao.getByContactNumberAndApartment(CustomerOrderReplica.getContactNumber(),
					CustomerOrderReplica.getApartmentId());

			System.out.println("customers" + customers.get("customerName"));

			// Apartments apartments =
			// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
			CustomerOrderReplica.setApartmentName(
					customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

			CustomerOrderReplica.setCustomerDetails(customers);

			CustomerOrderReplica.setCustomerOrder(customerOrder);
			CustomerOrderReplica.setQuatityList(quanityList);

		} catch (Exception e) {
			e.printStackTrace();
		}

		return CustomerOrderReplica;

	}

	@Override
	public Map createCustomerOrderReplica(CustomerOrderReplicaRequest customerOrderReplicaRequest, String contactNumber,
			Integer aparmentId) {

		if (customerOrderReplicaRequest.getRazorPayRequest() != null) {

//			Map razorPay = consumerService.createRazorPayOrder(customerOrderReplicaRequest.getRazorPayRequest());
//			customerOrderReplicaRequest.setOrderId(razorPay.get("order") != null ? (String)((RazorPay) razorPay.get("order")).getId() : null);	
//	
//			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);
//
//			razorPay.put("cartId", customerOrderReplicaRequest.getCartId());

			Map customerOrderReplicaMap = new HashMap<>();

			Map orderId = new HashMap<>();
			String transactionId = getMerchantTransactionId();
			orderId.put("id", transactionId);

			customerOrderReplicaMap.put("order", orderId);

			customerOrderReplicaRequest.setOrderId(transactionId);
			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);

			customerOrderReplicaMap.put("cartId", customerOrderReplicaRequest.getCartId());

			try {
				customerOrderReplicaMap.put("phonePeResponse",
						phonepeServiceImpl.initiatePhonepePayment(transactionId,
								Integer.valueOf(customerOrderReplicaRequest.getRazorPayRequest().getAmount()),
								contactNumber, customerOrderReplicaRequest.getRedirectUrl(), customerOrderReplicaRequest.getCallBackUrl()));

			} catch (Exception e) {
				e.printStackTrace();
				customerOrderReplicaMap.put("phonePeResponse", new HashedMap<>());
			}

			return customerOrderReplicaMap;

		} else {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
					"paymentDetails transcation Details are mandatory");
		}

	}

	private static String getMerchantTransactionId() {

		return "OD_" + MerchantTransactionIdGenerator.getRandomString();
	}


	@Override
	public List<CustomerOrderReplica> getCustomerOrderByMoblieNo(String contactNumber,Integer aid) {
		
		Schedule latestschedule = customerOrderReplicaDoa.getlatestschedule();
		
		if (latestschedule != null && latestschedule.getCreationTimestamp()!=null) {
			
	        if (latestschedule.getStatus().equals(UserStatus.ACTIVE)) {
	        	
	        	Customers customer = customerDetailsDao.getByContactNoAndApartment(contactNumber, aid);
	        	if (customer != null) { // Ensure the customer exists
	        		List<CustomerOrder> customerOrderList = customerOrderReplicaDoa.getListCustomerOrderByCustomerId(customer.getCtid());
	        		
	                double totalOrderAmount = 0.0;
	       
                if (customerOrderList != null && !customerOrderList.isEmpty() && customerOrderList.add(customerOrder). {
                    for (CustomerOrder customerOrder : customerOrderList) {
                        Double orderAmount = customerOrder.getAmount();
                        
                        if(orderAmount>200) {
                        	
                        	
                        }
                        if (orderAmount != null) {
                            totalOrderAmount += orderAmount;
                            if(totalOrderAmount>200) {
                            	totalOrderAmount+customerOrder
                            }
                        }
                    }
                    System.out.println("Total Order Amount: " + totalOrderAmount);
                    List<CustomerOrderReplica> customerOrderReplicas = new ArrayList<>();
                    return customerOrderReplicas;
                } else {
                    return Collections.emptyList(); // or return null or an appropriate value
                }
            } else {
              
                return null; // or an appropriate value
            }
        } else {
            // Handle the case when the latest schedule is not active
            return null; // or an appropriate value
        }
    } else {
        // Handle the case when there is no latest schedule or its creation timestamp is null
        return null; // or an appropriate value
    }
	}
}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-09-21 15:05:35.018
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-09-21 15:05:35.019
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-21 15:06:50.023
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.xyram.daydrop.serviceimpl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.transaction.Transactional;

import org.apache.commons.collections4.map.HashedMap;
import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.server.ResponseStatusException;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.xyram.daydrop.admin.model.CurrentUser;
import com.xyram.daydrop.basemodel.Base64Wrapper;
import com.xyram.daydrop.basemodel.MerchantTransactionIdGenerator;
import com.xyram.daydrop.basemodel.PhonepeSerializer;
import com.xyram.daydrop.dao.ApartmentDao;
import com.xyram.daydrop.dao.CustomerDetailsDao;
import com.xyram.daydrop.dao.CustomerOrderDao;
import com.xyram.daydrop.dao.CustomerOrderReplicaDoa;
import com.xyram.daydrop.dao.SheduleDao;
import com.xyram.daydrop.enumtypes.UserStatus;
import com.xyram.daydrop.model.Apartments;
import com.xyram.daydrop.model.CustomerOrder;
import com.xyram.daydrop.model.CustomerOrderReplica;
import com.xyram.daydrop.model.Customers;
import com.xyram.daydrop.model.Schedule;
import com.xyram.daydrop.modelMapper.PaymentInstrument;
import com.xyram.daydrop.modelMapper.PhonePePayModel;
import com.xyram.daydrop.request.CustomerOrderReplicaRequest;
import com.xyram.daydrop.response.RazorPayRequest;
import com.xyram.daydrop.service.CustomerOrderPriceService;
import com.xyram.daydrop.service.CustomerOrderReplicaService;
import com.xyram.daydrop.util.HashEncoder;
import com.xyram.daydrop.util.RazorPay;
import com.xyram.daydrop.service.ConsumerService;

@Transactional
@Service
public class CustomerOrderReplicaServiceImpl implements CustomerOrderReplicaService {

	@Autowired
	CustomerOrderReplicaDoa customerOrderReplicaDoa;

	@Autowired
	ApartmentDao apartmentDao;

	@Autowired
	SheduleDao scheduleDao;

	@Autowired
	CustomerDetailsDao customerDetailsDao;

	@Autowired
	ConsumerService consumerService;

	@Autowired
	CurrentUser currentUser;

	@Autowired
	PhonepeServiceImpl phonepeServiceImpl;

	@Value("${merchant_id}")
	private String merchantId;

	@Value("${salt_key}")
	private String saltKey;

	@Value("${salt_index}")
	private String saltIndex;

	@Override
	public Map createCustomerOrderReplicaService(CustomerOrderReplicaRequest customerOrderReplicaRequest,
			String contactNumber, Integer aparmentId)

	{

		Map response = new HashedMap<>();

		response.put("message", "success");
		CustomerOrderReplica customerOrderReplica = null;

		if (customerOrderReplicaRequest.getCartId() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "cartId is mandatory ");
		}
		long razorPayCount = 0;
		if (customerOrderReplicaRequest.getOrderId() != null) {

			razorPayCount = customerOrderReplicaDoa.getRazorPayExistByCartId(customerOrderReplicaRequest.getOrderId());
		}

		if (customerOrderReplicaRequest.getCustomerDetails() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Order Details  is mandatory ");
		}

		customerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(customerOrderReplicaRequest.getCartId(),
				contactNumber);

		if (customerOrderReplica != null) {
			customerOrderReplica.setCartId(customerOrderReplica.getCartId());

			if (customerOrderReplica.isOrdered()) {
				throw new ResponseStatusException(HttpStatus.CONFLICT, "Your Order is Placed With cart Details");
			}

//			if (razorPayCount >= 1 && !(customerOrderReplica.getRazorPayOrderId() != null
//					&& customerOrderReplica.getRazorPayOrderId().equals(customerOrderReplicaRequest.getOrderId()))) {
//				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
//			}

			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);

			customerOrderReplica.setAttempts(customerOrderReplica.getAttempts() + 1);
			customerOrderReplica.setUpdatedTime(new Date());

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		} else {

			customerOrderReplica = new CustomerOrderReplica();
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);
			customerOrderReplica.setCartId(customerOrderReplicaRequest.getCartId());
			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());

			if (razorPayCount > 0) {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
			}

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			Schedule schedule = scheduleDao.getlatestScheduleCustomers();

			if (schedule != null) {

				try {
					customerOrderReplica.setSchedule(schedule.getsId() != null ? schedule.getsId().toString() : null);
				} catch (Exception e) {
					e.printStackTrace();
				}
			} else {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
						"Sorry We Are Not Accepting Any Order Right now");

			}

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		}

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicas(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String schedule = null;

		Map filter = request.containsKey("filters") ? (Map) request.get("filters") : null;
		if (filter != null) {
			statusType = filter.containsKey("statusType") ? ((String) filter.get("statusType")).toLowerCase() : null;
			searchQuery = filter.containsKey("searchQuery") ? ((String) filter.get("searchQuery")).toLowerCase() : null;
			schedule = filter.containsKey("schedule") ? (String.valueOf(filter.get("schedule"))) : null;

		}

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplica(searchQuery, statusType, schedule);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");

				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setStreetName(
						customers.get("streetName") != null ? (String) customers.get("streetName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicasBySchedule(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String scheduleId = null;

		Schedule schedule = scheduleDao.getlatestScheduleCustomers();

		if (schedule != null) {

			try {
				scheduleId = schedule.getsId() != null ? schedule.getsId().toString() : null;
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

		statusType = request.containsKey("statusType") ? ((String) request.get("statusType")).toLowerCase() : "Success";

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplicaBySchdeule(statusType, scheduleId);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");
				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				System.out.println("customers" + customers.get("customerName"));

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public CustomerOrderReplica getCustomerOrderReplicaByCartId(String cartId) {

		CustomerOrderReplica CustomerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(cartId,
				currentUser.getContactNumber());

		ObjectMapper objectMapper = new ObjectMapper();
		try {

			// convert JSON string to Map
			Map<String, Object> customerOrderReplicaMap = objectMapper
					.readValue(CustomerOrderReplica.getCustomerOrderDetails(), Map.class);

			Object customerOrder = customerOrderReplicaMap.get("customerOrder");
			Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

			Object quanityList = items.get("quantity");
			Map customers = customerDetailsDao.getByContactNumberAndApartment(CustomerOrderReplica.getContactNumber(),
					CustomerOrderReplica.getApartmentId());

			System.out.println("customers" + customers.get("customerName"));

			// Apartments apartments =
			// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
			CustomerOrderReplica.setApartmentName(
					customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

			CustomerOrderReplica.setCustomerDetails(customers);

			CustomerOrderReplica.setCustomerOrder(customerOrder);
			CustomerOrderReplica.setQuatityList(quanityList);

		} catch (Exception e) {
			e.printStackTrace();
		}

		return CustomerOrderReplica;

	}

	@Override
	public Map createCustomerOrderReplica(CustomerOrderReplicaRequest customerOrderReplicaRequest, String contactNumber,
			Integer aparmentId) {

		if (customerOrderReplicaRequest.getRazorPayRequest() != null) {

//			Map razorPay = consumerService.createRazorPayOrder(customerOrderReplicaRequest.getRazorPayRequest());
//			customerOrderReplicaRequest.setOrderId(razorPay.get("order") != null ? (String)((RazorPay) razorPay.get("order")).getId() : null);	
//	
//			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);
//
//			razorPay.put("cartId", customerOrderReplicaRequest.getCartId());

			Map customerOrderReplicaMap = new HashMap<>();

			Map orderId = new HashMap<>();
			String transactionId = getMerchantTransactionId();
			orderId.put("id", transactionId);

			customerOrderReplicaMap.put("order", orderId);

			customerOrderReplicaRequest.setOrderId(transactionId);
			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);

			customerOrderReplicaMap.put("cartId", customerOrderReplicaRequest.getCartId());

			try {
				customerOrderReplicaMap.put("phonePeResponse",
						phonepeServiceImpl.initiatePhonepePayment(transactionId,
								Integer.valueOf(customerOrderReplicaRequest.getRazorPayRequest().getAmount()),
								contactNumber, customerOrderReplicaRequest.getRedirectUrl(), customerOrderReplicaRequest.getCallBackUrl()));

			} catch (Exception e) {
				e.printStackTrace();
				customerOrderReplicaMap.put("phonePeResponse", new HashedMap<>());
			}

			return customerOrderReplicaMap;

		} else {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
					"paymentDetails transcation Details are mandatory");
		}

	}

	private static String getMerchantTransactionId() {

		return "OD_" + MerchantTransactionIdGenerator.getRandomString();
	}


	@Override
	public List<CustomerOrderReplica> getCustomerOrderByMoblieNo(String contactNumber,Integer aid) {
		
		Schedule latestschedule = customerOrderReplicaDoa.getlatestschedule();
		
		if (latestschedule != null && latestschedule.getCreationTimestamp()!=null) {
			
	        if (latestschedule.getStatus().equals(UserStatus.ACTIVE)) {
	        	
	        	Customers customer = customerDetailsDao.getByContactNoAndApartment(contactNumber, aid);
	        	if (customer != null) { // Ensure the customer exists
	        		List<CustomerOrder> customerOrderList = customerOrderReplicaDoa.getListCustomerOrderByCustomerId(customer.getCtid());
	        		
	                double totalOrderAmount = 0.0;
	       
                if (customerOrderList != null && !customerOrderList.isEmpty() && customerOrderList.add(customerOrder). {
                    for (CustomerOrder customerOrder : customerOrderList) {
                        Double orderAmount = customerOrder.getAmount()
                        if (orderAmount != null) {
                            totalOrderAmount += orderAmount;
                            if(totalOrderAmount>200) {
                            	totalOrderAmount+customerOrder
                            }
                        }
                    }
                    System.out.println("Total Order Amount: " + totalOrderAmount);
                    List<CustomerOrderReplica> customerOrderReplicas = new ArrayList<>();
                    return customerOrderReplicas;
                } else {
                    return Collections.emptyList(); // or return null or an appropriate value
                }
            } else {
              
                return null; // or an appropriate value
            }
        } else {
            // Handle the case when the latest schedule is not active
            return null; // or an appropriate value
        }
    } else {
        // Handle the case when there is no latest schedule or its creation timestamp is null
        return null; // or an appropriate value
    }
	}
}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-09-21 15:06:50.025
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-09-21 15:06:50.028
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-21 15:06:50.370
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.xyram.daydrop.serviceimpl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.transaction.Transactional;

import org.apache.commons.collections4.map.HashedMap;
import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.server.ResponseStatusException;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.xyram.daydrop.admin.model.CurrentUser;
import com.xyram.daydrop.basemodel.Base64Wrapper;
import com.xyram.daydrop.basemodel.MerchantTransactionIdGenerator;
import com.xyram.daydrop.basemodel.PhonepeSerializer;
import com.xyram.daydrop.dao.ApartmentDao;
import com.xyram.daydrop.dao.CustomerDetailsDao;
import com.xyram.daydrop.dao.CustomerOrderDao;
import com.xyram.daydrop.dao.CustomerOrderReplicaDoa;
import com.xyram.daydrop.dao.SheduleDao;
import com.xyram.daydrop.enumtypes.UserStatus;
import com.xyram.daydrop.model.Apartments;
import com.xyram.daydrop.model.CustomerOrder;
import com.xyram.daydrop.model.CustomerOrderReplica;
import com.xyram.daydrop.model.Customers;
import com.xyram.daydrop.model.Schedule;
import com.xyram.daydrop.modelMapper.PaymentInstrument;
import com.xyram.daydrop.modelMapper.PhonePePayModel;
import com.xyram.daydrop.request.CustomerOrderReplicaRequest;
import com.xyram.daydrop.response.RazorPayRequest;
import com.xyram.daydrop.service.CustomerOrderPriceService;
import com.xyram.daydrop.service.CustomerOrderReplicaService;
import com.xyram.daydrop.util.HashEncoder;
import com.xyram.daydrop.util.RazorPay;
import com.xyram.daydrop.service.ConsumerService;

@Transactional
@Service
public class CustomerOrderReplicaServiceImpl implements CustomerOrderReplicaService {

	@Autowired
	CustomerOrderReplicaDoa customerOrderReplicaDoa;

	@Autowired
	ApartmentDao apartmentDao;

	@Autowired
	SheduleDao scheduleDao;

	@Autowired
	CustomerDetailsDao customerDetailsDao;

	@Autowired
	ConsumerService consumerService;

	@Autowired
	CurrentUser currentUser;

	@Autowired
	PhonepeServiceImpl phonepeServiceImpl;

	@Value("${merchant_id}")
	private String merchantId;

	@Value("${salt_key}")
	private String saltKey;

	@Value("${salt_index}")
	private String saltIndex;

	@Override
	public Map createCustomerOrderReplicaService(CustomerOrderReplicaRequest customerOrderReplicaRequest,
			String contactNumber, Integer aparmentId)

	{

		Map response = new HashedMap<>();

		response.put("message", "success");
		CustomerOrderReplica customerOrderReplica = null;

		if (customerOrderReplicaRequest.getCartId() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "cartId is mandatory ");
		}
		long razorPayCount = 0;
		if (customerOrderReplicaRequest.getOrderId() != null) {

			razorPayCount = customerOrderReplicaDoa.getRazorPayExistByCartId(customerOrderReplicaRequest.getOrderId());
		}

		if (customerOrderReplicaRequest.getCustomerDetails() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Order Details  is mandatory ");
		}

		customerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(customerOrderReplicaRequest.getCartId(),
				contactNumber);

		if (customerOrderReplica != null) {
			customerOrderReplica.setCartId(customerOrderReplica.getCartId());

			if (customerOrderReplica.isOrdered()) {
				throw new ResponseStatusException(HttpStatus.CONFLICT, "Your Order is Placed With cart Details");
			}

//			if (razorPayCount >= 1 && !(customerOrderReplica.getRazorPayOrderId() != null
//					&& customerOrderReplica.getRazorPayOrderId().equals(customerOrderReplicaRequest.getOrderId()))) {
//				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
//			}

			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);

			customerOrderReplica.setAttempts(customerOrderReplica.getAttempts() + 1);
			customerOrderReplica.setUpdatedTime(new Date());

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		} else {

			customerOrderReplica = new CustomerOrderReplica();
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);
			customerOrderReplica.setCartId(customerOrderReplicaRequest.getCartId());
			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());

			if (razorPayCount > 0) {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
			}

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			Schedule schedule = scheduleDao.getlatestScheduleCustomers();

			if (schedule != null) {

				try {
					customerOrderReplica.setSchedule(schedule.getsId() != null ? schedule.getsId().toString() : null);
				} catch (Exception e) {
					e.printStackTrace();
				}
			} else {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
						"Sorry We Are Not Accepting Any Order Right now");

			}

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		}

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicas(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String schedule = null;

		Map filter = request.containsKey("filters") ? (Map) request.get("filters") : null;
		if (filter != null) {
			statusType = filter.containsKey("statusType") ? ((String) filter.get("statusType")).toLowerCase() : null;
			searchQuery = filter.containsKey("searchQuery") ? ((String) filter.get("searchQuery")).toLowerCase() : null;
			schedule = filter.containsKey("schedule") ? (String.valueOf(filter.get("schedule"))) : null;

		}

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplica(searchQuery, statusType, schedule);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");

				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setStreetName(
						customers.get("streetName") != null ? (String) customers.get("streetName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicasBySchedule(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String scheduleId = null;

		Schedule schedule = scheduleDao.getlatestScheduleCustomers();

		if (schedule != null) {

			try {
				scheduleId = schedule.getsId() != null ? schedule.getsId().toString() : null;
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

		statusType = request.containsKey("statusType") ? ((String) request.get("statusType")).toLowerCase() : "Success";

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplicaBySchdeule(statusType, scheduleId);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");
				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				System.out.println("customers" + customers.get("customerName"));

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public CustomerOrderReplica getCustomerOrderReplicaByCartId(String cartId) {

		CustomerOrderReplica CustomerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(cartId,
				currentUser.getContactNumber());

		ObjectMapper objectMapper = new ObjectMapper();
		try {

			// convert JSON string to Map
			Map<String, Object> customerOrderReplicaMap = objectMapper
					.readValue(CustomerOrderReplica.getCustomerOrderDetails(), Map.class);

			Object customerOrder = customerOrderReplicaMap.get("customerOrder");
			Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

			Object quanityList = items.get("quantity");
			Map customers = customerDetailsDao.getByContactNumberAndApartment(CustomerOrderReplica.getContactNumber(),
					CustomerOrderReplica.getApartmentId());

			System.out.println("customers" + customers.get("customerName"));

			// Apartments apartments =
			// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
			CustomerOrderReplica.setApartmentName(
					customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

			CustomerOrderReplica.setCustomerDetails(customers);

			CustomerOrderReplica.setCustomerOrder(customerOrder);
			CustomerOrderReplica.setQuatityList(quanityList);

		} catch (Exception e) {
			e.printStackTrace();
		}

		return CustomerOrderReplica;

	}

	@Override
	public Map createCustomerOrderReplica(CustomerOrderReplicaRequest customerOrderReplicaRequest, String contactNumber,
			Integer aparmentId) {

		if (customerOrderReplicaRequest.getRazorPayRequest() != null) {

//			Map razorPay = consumerService.createRazorPayOrder(customerOrderReplicaRequest.getRazorPayRequest());
//			customerOrderReplicaRequest.setOrderId(razorPay.get("order") != null ? (String)((RazorPay) razorPay.get("order")).getId() : null);	
//	
//			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);
//
//			razorPay.put("cartId", customerOrderReplicaRequest.getCartId());

			Map customerOrderReplicaMap = new HashMap<>();

			Map orderId = new HashMap<>();
			String transactionId = getMerchantTransactionId();
			orderId.put("id", transactionId);

			customerOrderReplicaMap.put("order", orderId);

			customerOrderReplicaRequest.setOrderId(transactionId);
			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);

			customerOrderReplicaMap.put("cartId", customerOrderReplicaRequest.getCartId());

			try {
				customerOrderReplicaMap.put("phonePeResponse",
						phonepeServiceImpl.initiatePhonepePayment(transactionId,
								Integer.valueOf(customerOrderReplicaRequest.getRazorPayRequest().getAmount()),
								contactNumber, customerOrderReplicaRequest.getRedirectUrl(), customerOrderReplicaRequest.getCallBackUrl()));

			} catch (Exception e) {
				e.printStackTrace();
				customerOrderReplicaMap.put("phonePeResponse", new HashedMap<>());
			}

			return customerOrderReplicaMap;

		} else {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
					"paymentDetails transcation Details are mandatory");
		}

	}

	private static String getMerchantTransactionId() {

		return "OD_" + MerchantTransactionIdGenerator.getRandomString();
	}


	@Override
	public List<CustomerOrderReplica> getCustomerOrderByMoblieNo(String contactNumber,Integer aid) {
		
		Schedule latestschedule = customerOrderReplicaDoa.getlatestschedule();
		
		if (latestschedule != null && latestschedule.getCreationTimestamp()!=null) {
			
	        if (latestschedule.getStatus().equals(UserStatus.ACTIVE)) {
	        	
	        	Customers customer = customerDetailsDao.getByContactNoAndApartment(contactNumber, aid);
	        	if (customer != null) { // Ensure the customer exists
	        		List<CustomerOrder> customerOrderList = customerOrderReplicaDoa.getListCustomerOrderByCustomerId(customer.getCtid());
	        		
	                double totalOrderAmount = 0.0;
	       
                if (customerOrderList != null && !customerOrderList.isEmpty() && customerOrderList.add(customerOrder). {
                    for (CustomerOrder customerOrder : customerOrderList) {
                        Double orderAmount = customerOrder.getAmount()
                        if (orderAmount != null) {
                            totalOrderAmount += orderAmount;
                            if(totalOrderAmount>200) {
                            	totalOrderAmount+customerOrder
                            }
                        }
                    }
                    System.out.println("Total Order Amount: " + totalOrderAmount);
                    List<CustomerOrderReplica> customerOrderReplicas = new ArrayList<>();
                    return customerOrderReplicas;
                } else {
                    return Collections.emptyList(); // or return null or an appropriate value
                }
            } else {
              
                return null; // or an appropriate value
            }
        } else {
            // Handle the case when the latest schedule is not active
            return null; // or an appropriate value
        }
    } else {
        // Handle the case when there is no latest schedule or its creation timestamp is null
        return null; // or an appropriate value
    }
	}
}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-09-21 15:06:50.372
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-09-21 15:06:50.374
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-21 15:06:51.115
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.xyram.daydrop.serviceimpl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.transaction.Transactional;

import org.apache.commons.collections4.map.HashedMap;
import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.server.ResponseStatusException;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.xyram.daydrop.admin.model.CurrentUser;
import com.xyram.daydrop.basemodel.Base64Wrapper;
import com.xyram.daydrop.basemodel.MerchantTransactionIdGenerator;
import com.xyram.daydrop.basemodel.PhonepeSerializer;
import com.xyram.daydrop.dao.ApartmentDao;
import com.xyram.daydrop.dao.CustomerDetailsDao;
import com.xyram.daydrop.dao.CustomerOrderDao;
import com.xyram.daydrop.dao.CustomerOrderReplicaDoa;
import com.xyram.daydrop.dao.SheduleDao;
import com.xyram.daydrop.enumtypes.UserStatus;
import com.xyram.daydrop.model.Apartments;
import com.xyram.daydrop.model.CustomerOrder;
import com.xyram.daydrop.model.CustomerOrderReplica;
import com.xyram.daydrop.model.Customers;
import com.xyram.daydrop.model.Schedule;
import com.xyram.daydrop.modelMapper.PaymentInstrument;
import com.xyram.daydrop.modelMapper.PhonePePayModel;
import com.xyram.daydrop.request.CustomerOrderReplicaRequest;
import com.xyram.daydrop.response.RazorPayRequest;
import com.xyram.daydrop.service.CustomerOrderPriceService;
import com.xyram.daydrop.service.CustomerOrderReplicaService;
import com.xyram.daydrop.util.HashEncoder;
import com.xyram.daydrop.util.RazorPay;
import com.xyram.daydrop.service.ConsumerService;

@Transactional
@Service
public class CustomerOrderReplicaServiceImpl implements CustomerOrderReplicaService {

	@Autowired
	CustomerOrderReplicaDoa customerOrderReplicaDoa;

	@Autowired
	ApartmentDao apartmentDao;

	@Autowired
	SheduleDao scheduleDao;

	@Autowired
	CustomerDetailsDao customerDetailsDao;

	@Autowired
	ConsumerService consumerService;

	@Autowired
	CurrentUser currentUser;

	@Autowired
	PhonepeServiceImpl phonepeServiceImpl;

	@Value("${merchant_id}")
	private String merchantId;

	@Value("${salt_key}")
	private String saltKey;

	@Value("${salt_index}")
	private String saltIndex;

	@Override
	public Map createCustomerOrderReplicaService(CustomerOrderReplicaRequest customerOrderReplicaRequest,
			String contactNumber, Integer aparmentId)

	{

		Map response = new HashedMap<>();

		response.put("message", "success");
		CustomerOrderReplica customerOrderReplica = null;

		if (customerOrderReplicaRequest.getCartId() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "cartId is mandatory ");
		}
		long razorPayCount = 0;
		if (customerOrderReplicaRequest.getOrderId() != null) {

			razorPayCount = customerOrderReplicaDoa.getRazorPayExistByCartId(customerOrderReplicaRequest.getOrderId());
		}

		if (customerOrderReplicaRequest.getCustomerDetails() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Order Details  is mandatory ");
		}

		customerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(customerOrderReplicaRequest.getCartId(),
				contactNumber);

		if (customerOrderReplica != null) {
			customerOrderReplica.setCartId(customerOrderReplica.getCartId());

			if (customerOrderReplica.isOrdered()) {
				throw new ResponseStatusException(HttpStatus.CONFLICT, "Your Order is Placed With cart Details");
			}

//			if (razorPayCount >= 1 && !(customerOrderReplica.getRazorPayOrderId() != null
//					&& customerOrderReplica.getRazorPayOrderId().equals(customerOrderReplicaRequest.getOrderId()))) {
//				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
//			}

			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);

			customerOrderReplica.setAttempts(customerOrderReplica.getAttempts() + 1);
			customerOrderReplica.setUpdatedTime(new Date());

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		} else {

			customerOrderReplica = new CustomerOrderReplica();
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);
			customerOrderReplica.setCartId(customerOrderReplicaRequest.getCartId());
			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());

			if (razorPayCount > 0) {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
			}

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			Schedule schedule = scheduleDao.getlatestScheduleCustomers();

			if (schedule != null) {

				try {
					customerOrderReplica.setSchedule(schedule.getsId() != null ? schedule.getsId().toString() : null);
				} catch (Exception e) {
					e.printStackTrace();
				}
			} else {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
						"Sorry We Are Not Accepting Any Order Right now");

			}

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		}

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicas(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String schedule = null;

		Map filter = request.containsKey("filters") ? (Map) request.get("filters") : null;
		if (filter != null) {
			statusType = filter.containsKey("statusType") ? ((String) filter.get("statusType")).toLowerCase() : null;
			searchQuery = filter.containsKey("searchQuery") ? ((String) filter.get("searchQuery")).toLowerCase() : null;
			schedule = filter.containsKey("schedule") ? (String.valueOf(filter.get("schedule"))) : null;

		}

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplica(searchQuery, statusType, schedule);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");

				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setStreetName(
						customers.get("streetName") != null ? (String) customers.get("streetName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicasBySchedule(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String scheduleId = null;

		Schedule schedule = scheduleDao.getlatestScheduleCustomers();

		if (schedule != null) {

			try {
				scheduleId = schedule.getsId() != null ? schedule.getsId().toString() : null;
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

		statusType = request.containsKey("statusType") ? ((String) request.get("statusType")).toLowerCase() : "Success";

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplicaBySchdeule(statusType, scheduleId);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");
				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				System.out.println("customers" + customers.get("customerName"));

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public CustomerOrderReplica getCustomerOrderReplicaByCartId(String cartId) {

		CustomerOrderReplica CustomerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(cartId,
				currentUser.getContactNumber());

		ObjectMapper objectMapper = new ObjectMapper();
		try {

			// convert JSON string to Map
			Map<String, Object> customerOrderReplicaMap = objectMapper
					.readValue(CustomerOrderReplica.getCustomerOrderDetails(), Map.class);

			Object customerOrder = customerOrderReplicaMap.get("customerOrder");
			Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

			Object quanityList = items.get("quantity");
			Map customers = customerDetailsDao.getByContactNumberAndApartment(CustomerOrderReplica.getContactNumber(),
					CustomerOrderReplica.getApartmentId());

			System.out.println("customers" + customers.get("customerName"));

			// Apartments apartments =
			// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
			CustomerOrderReplica.setApartmentName(
					customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

			CustomerOrderReplica.setCustomerDetails(customers);

			CustomerOrderReplica.setCustomerOrder(customerOrder);
			CustomerOrderReplica.setQuatityList(quanityList);

		} catch (Exception e) {
			e.printStackTrace();
		}

		return CustomerOrderReplica;

	}

	@Override
	public Map createCustomerOrderReplica(CustomerOrderReplicaRequest customerOrderReplicaRequest, String contactNumber,
			Integer aparmentId) {

		if (customerOrderReplicaRequest.getRazorPayRequest() != null) {

//			Map razorPay = consumerService.createRazorPayOrder(customerOrderReplicaRequest.getRazorPayRequest());
//			customerOrderReplicaRequest.setOrderId(razorPay.get("order") != null ? (String)((RazorPay) razorPay.get("order")).getId() : null);	
//	
//			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);
//
//			razorPay.put("cartId", customerOrderReplicaRequest.getCartId());

			Map customerOrderReplicaMap = new HashMap<>();

			Map orderId = new HashMap<>();
			String transactionId = getMerchantTransactionId();
			orderId.put("id", transactionId);

			customerOrderReplicaMap.put("order", orderId);

			customerOrderReplicaRequest.setOrderId(transactionId);
			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);

			customerOrderReplicaMap.put("cartId", customerOrderReplicaRequest.getCartId());

			try {
				customerOrderReplicaMap.put("phonePeResponse",
						phonepeServiceImpl.initiatePhonepePayment(transactionId,
								Integer.valueOf(customerOrderReplicaRequest.getRazorPayRequest().getAmount()),
								contactNumber, customerOrderReplicaRequest.getRedirectUrl(), customerOrderReplicaRequest.getCallBackUrl()));

			} catch (Exception e) {
				e.printStackTrace();
				customerOrderReplicaMap.put("phonePeResponse", new HashedMap<>());
			}

			return customerOrderReplicaMap;

		} else {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
					"paymentDetails transcation Details are mandatory");
		}

	}

	private static String getMerchantTransactionId() {

		return "OD_" + MerchantTransactionIdGenerator.getRandomString();
	}


	@Override
	public List<CustomerOrderReplica> getCustomerOrderByMoblieNo(String contactNumber,Integer aid) {
		
		Schedule latestschedule = customerOrderReplicaDoa.getlatestschedule();
		
		if (latestschedule != null && latestschedule.getCreationTimestamp()!=null) {
			
	        if (latestschedule.getStatus().equals(UserStatus.ACTIVE)) {
	        	
	        	Customers customer = customerDetailsDao.getByContactNoAndApartment(contactNumber, aid);
	        	if (customer != null) { // Ensure the customer exists
	        		List<CustomerOrder> customerOrderList = customerOrderReplicaDoa.getListCustomerOrderByCustomerId(customer.getCtid());
	        		
	                double totalOrderAmount = 0.0;
	       
                if (customerOrderList != null && !customerOrderList.isEmpty() && customerOrderList.add(customerOrder). {
                    for (CustomerOrder customerOrder : customerOrderList) {
                        Double orderAmount = customerOrder.getAmount();
                        if (orderAmount != null) {
                            totalOrderAmount += orderAmount;
                            if(totalOrderAmount>200) {
                            	totalOrderAmount+customerOrder
                            }
                        }
                    }
                    System.out.println("Total Order Amount: " + totalOrderAmount);
                    List<CustomerOrderReplica> customerOrderReplicas = new ArrayList<>();
                    return customerOrderReplicas;
                } else {
                    return Collections.emptyList(); // or return null or an appropriate value
                }
            } else {
              
                return null; // or an appropriate value
            }
        } else {
            // Handle the case when the latest schedule is not active
            return null; // or an appropriate value
        }
    } else {
        // Handle the case when there is no latest schedule or its creation timestamp is null
        return null; // or an appropriate value
    }
	}
}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-09-21 15:06:51.117
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-09-21 15:06:51.119
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-21 15:06:51.227
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.xyram.daydrop.serviceimpl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.transaction.Transactional;

import org.apache.commons.collections4.map.HashedMap;
import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.server.ResponseStatusException;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.xyram.daydrop.admin.model.CurrentUser;
import com.xyram.daydrop.basemodel.Base64Wrapper;
import com.xyram.daydrop.basemodel.MerchantTransactionIdGenerator;
import com.xyram.daydrop.basemodel.PhonepeSerializer;
import com.xyram.daydrop.dao.ApartmentDao;
import com.xyram.daydrop.dao.CustomerDetailsDao;
import com.xyram.daydrop.dao.CustomerOrderDao;
import com.xyram.daydrop.dao.CustomerOrderReplicaDoa;
import com.xyram.daydrop.dao.SheduleDao;
import com.xyram.daydrop.enumtypes.UserStatus;
import com.xyram.daydrop.model.Apartments;
import com.xyram.daydrop.model.CustomerOrder;
import com.xyram.daydrop.model.CustomerOrderReplica;
import com.xyram.daydrop.model.Customers;
import com.xyram.daydrop.model.Schedule;
import com.xyram.daydrop.modelMapper.PaymentInstrument;
import com.xyram.daydrop.modelMapper.PhonePePayModel;
import com.xyram.daydrop.request.CustomerOrderReplicaRequest;
import com.xyram.daydrop.response.RazorPayRequest;
import com.xyram.daydrop.service.CustomerOrderPriceService;
import com.xyram.daydrop.service.CustomerOrderReplicaService;
import com.xyram.daydrop.util.HashEncoder;
import com.xyram.daydrop.util.RazorPay;
import com.xyram.daydrop.service.ConsumerService;

@Transactional
@Service
public class CustomerOrderReplicaServiceImpl implements CustomerOrderReplicaService {

	@Autowired
	CustomerOrderReplicaDoa customerOrderReplicaDoa;

	@Autowired
	ApartmentDao apartmentDao;

	@Autowired
	SheduleDao scheduleDao;

	@Autowired
	CustomerDetailsDao customerDetailsDao;

	@Autowired
	ConsumerService consumerService;

	@Autowired
	CurrentUser currentUser;

	@Autowired
	PhonepeServiceImpl phonepeServiceImpl;

	@Value("${merchant_id}")
	private String merchantId;

	@Value("${salt_key}")
	private String saltKey;

	@Value("${salt_index}")
	private String saltIndex;

	@Override
	public Map createCustomerOrderReplicaService(CustomerOrderReplicaRequest customerOrderReplicaRequest,
			String contactNumber, Integer aparmentId)

	{

		Map response = new HashedMap<>();

		response.put("message", "success");
		CustomerOrderReplica customerOrderReplica = null;

		if (customerOrderReplicaRequest.getCartId() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "cartId is mandatory ");
		}
		long razorPayCount = 0;
		if (customerOrderReplicaRequest.getOrderId() != null) {

			razorPayCount = customerOrderReplicaDoa.getRazorPayExistByCartId(customerOrderReplicaRequest.getOrderId());
		}

		if (customerOrderReplicaRequest.getCustomerDetails() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Order Details  is mandatory ");
		}

		customerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(customerOrderReplicaRequest.getCartId(),
				contactNumber);

		if (customerOrderReplica != null) {
			customerOrderReplica.setCartId(customerOrderReplica.getCartId());

			if (customerOrderReplica.isOrdered()) {
				throw new ResponseStatusException(HttpStatus.CONFLICT, "Your Order is Placed With cart Details");
			}

//			if (razorPayCount >= 1 && !(customerOrderReplica.getRazorPayOrderId() != null
//					&& customerOrderReplica.getRazorPayOrderId().equals(customerOrderReplicaRequest.getOrderId()))) {
//				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
//			}

			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);

			customerOrderReplica.setAttempts(customerOrderReplica.getAttempts() + 1);
			customerOrderReplica.setUpdatedTime(new Date());

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		} else {

			customerOrderReplica = new CustomerOrderReplica();
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);
			customerOrderReplica.setCartId(customerOrderReplicaRequest.getCartId());
			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());

			if (razorPayCount > 0) {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
			}

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			Schedule schedule = scheduleDao.getlatestScheduleCustomers();

			if (schedule != null) {

				try {
					customerOrderReplica.setSchedule(schedule.getsId() != null ? schedule.getsId().toString() : null);
				} catch (Exception e) {
					e.printStackTrace();
				}
			} else {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
						"Sorry We Are Not Accepting Any Order Right now");

			}

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		}

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicas(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String schedule = null;

		Map filter = request.containsKey("filters") ? (Map) request.get("filters") : null;
		if (filter != null) {
			statusType = filter.containsKey("statusType") ? ((String) filter.get("statusType")).toLowerCase() : null;
			searchQuery = filter.containsKey("searchQuery") ? ((String) filter.get("searchQuery")).toLowerCase() : null;
			schedule = filter.containsKey("schedule") ? (String.valueOf(filter.get("schedule"))) : null;

		}

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplica(searchQuery, statusType, schedule);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");

				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setStreetName(
						customers.get("streetName") != null ? (String) customers.get("streetName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicasBySchedule(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String scheduleId = null;

		Schedule schedule = scheduleDao.getlatestScheduleCustomers();

		if (schedule != null) {

			try {
				scheduleId = schedule.getsId() != null ? schedule.getsId().toString() : null;
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

		statusType = request.containsKey("statusType") ? ((String) request.get("statusType")).toLowerCase() : "Success";

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplicaBySchdeule(statusType, scheduleId);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");
				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				System.out.println("customers" + customers.get("customerName"));

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public CustomerOrderReplica getCustomerOrderReplicaByCartId(String cartId) {

		CustomerOrderReplica CustomerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(cartId,
				currentUser.getContactNumber());

		ObjectMapper objectMapper = new ObjectMapper();
		try {

			// convert JSON string to Map
			Map<String, Object> customerOrderReplicaMap = objectMapper
					.readValue(CustomerOrderReplica.getCustomerOrderDetails(), Map.class);

			Object customerOrder = customerOrderReplicaMap.get("customerOrder");
			Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

			Object quanityList = items.get("quantity");
			Map customers = customerDetailsDao.getByContactNumberAndApartment(CustomerOrderReplica.getContactNumber(),
					CustomerOrderReplica.getApartmentId());

			System.out.println("customers" + customers.get("customerName"));

			// Apartments apartments =
			// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
			CustomerOrderReplica.setApartmentName(
					customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

			CustomerOrderReplica.setCustomerDetails(customers);

			CustomerOrderReplica.setCustomerOrder(customerOrder);
			CustomerOrderReplica.setQuatityList(quanityList);

		} catch (Exception e) {
			e.printStackTrace();
		}

		return CustomerOrderReplica;

	}

	@Override
	public Map createCustomerOrderReplica(CustomerOrderReplicaRequest customerOrderReplicaRequest, String contactNumber,
			Integer aparmentId) {

		if (customerOrderReplicaRequest.getRazorPayRequest() != null) {

//			Map razorPay = consumerService.createRazorPayOrder(customerOrderReplicaRequest.getRazorPayRequest());
//			customerOrderReplicaRequest.setOrderId(razorPay.get("order") != null ? (String)((RazorPay) razorPay.get("order")).getId() : null);	
//	
//			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);
//
//			razorPay.put("cartId", customerOrderReplicaRequest.getCartId());

			Map customerOrderReplicaMap = new HashMap<>();

			Map orderId = new HashMap<>();
			String transactionId = getMerchantTransactionId();
			orderId.put("id", transactionId);

			customerOrderReplicaMap.put("order", orderId);

			customerOrderReplicaRequest.setOrderId(transactionId);
			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);

			customerOrderReplicaMap.put("cartId", customerOrderReplicaRequest.getCartId());

			try {
				customerOrderReplicaMap.put("phonePeResponse",
						phonepeServiceImpl.initiatePhonepePayment(transactionId,
								Integer.valueOf(customerOrderReplicaRequest.getRazorPayRequest().getAmount()),
								contactNumber, customerOrderReplicaRequest.getRedirectUrl(), customerOrderReplicaRequest.getCallBackUrl()));

			} catch (Exception e) {
				e.printStackTrace();
				customerOrderReplicaMap.put("phonePeResponse", new HashedMap<>());
			}

			return customerOrderReplicaMap;

		} else {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
					"paymentDetails transcation Details are mandatory");
		}

	}

	private static String getMerchantTransactionId() {

		return "OD_" + MerchantTransactionIdGenerator.getRandomString();
	}


	@Override
	public List<CustomerOrderReplica> getCustomerOrderByMoblieNo(String contactNumber,Integer aid) {
		
		Schedule latestschedule = customerOrderReplicaDoa.getlatestschedule();
		
		if (latestschedule != null && latestschedule.getCreationTimestamp()!=null) {
			
	        if (latestschedule.getStatus().equals(UserStatus.ACTIVE)) {
	        	
	        	Customers customer = customerDetailsDao.getByContactNoAndApartment(contactNumber, aid);
	        	if (customer != null) { // Ensure the customer exists
	        		List<CustomerOrder> customerOrderList = customerOrderReplicaDoa.getListCustomerOrderByCustomerId(customer.getCtid());
	        		
	                double totalOrderAmount = 0.0;
	       
                if (customerOrderList != null && !customerOrderList.isEmpty() && customerOrderList.add(customerOrder). {
                    for (CustomerOrder customerOrder : customerOrderList) {
                        Double orderAmount = customerOrder.getAmount();
                        if (orderAmount != null) {
                            totalOrderAmount += orderAmount;
                            if(totalOrderAmount>200) {
                            	totalOrderAmount+customerOrder
                            }
                        }
                    }
                    System.out.println("Total Order Amount: " + totalOrderAmount);
                    List<CustomerOrderReplica> customerOrderReplicas = new ArrayList<>();
                    return customerOrderReplicas;
                } else {
                    return Collections.emptyList(); // or return null or an appropriate value
                }
            } else {
              
                return null; // or an appropriate value
            }
        } else {
            // Handle the case when the latest schedule is not active
            return null; // or an appropriate value
        }
    } else {
        // Handle the case when there is no latest schedule or its creation timestamp is null
        return null; // or an appropriate value
    }
	}
}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-09-21 15:06:51.230
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-09-21 15:06:51.232
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-21 15:06:52.799
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.xyram.daydrop.serviceimpl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.transaction.Transactional;

import org.apache.commons.collections4.map.HashedMap;
import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.server.ResponseStatusException;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.xyram.daydrop.admin.model.CurrentUser;
import com.xyram.daydrop.basemodel.Base64Wrapper;
import com.xyram.daydrop.basemodel.MerchantTransactionIdGenerator;
import com.xyram.daydrop.basemodel.PhonepeSerializer;
import com.xyram.daydrop.dao.ApartmentDao;
import com.xyram.daydrop.dao.CustomerDetailsDao;
import com.xyram.daydrop.dao.CustomerOrderDao;
import com.xyram.daydrop.dao.CustomerOrderReplicaDoa;
import com.xyram.daydrop.dao.SheduleDao;
import com.xyram.daydrop.enumtypes.UserStatus;
import com.xyram.daydrop.model.Apartments;
import com.xyram.daydrop.model.CustomerOrder;
import com.xyram.daydrop.model.CustomerOrderReplica;
import com.xyram.daydrop.model.Customers;
import com.xyram.daydrop.model.Schedule;
import com.xyram.daydrop.modelMapper.PaymentInstrument;
import com.xyram.daydrop.modelMapper.PhonePePayModel;
import com.xyram.daydrop.request.CustomerOrderReplicaRequest;
import com.xyram.daydrop.response.RazorPayRequest;
import com.xyram.daydrop.service.CustomerOrderPriceService;
import com.xyram.daydrop.service.CustomerOrderReplicaService;
import com.xyram.daydrop.util.HashEncoder;
import com.xyram.daydrop.util.RazorPay;
import com.xyram.daydrop.service.ConsumerService;

@Transactional
@Service
public class CustomerOrderReplicaServiceImpl implements CustomerOrderReplicaService {

	@Autowired
	CustomerOrderReplicaDoa customerOrderReplicaDoa;

	@Autowired
	ApartmentDao apartmentDao;

	@Autowired
	SheduleDao scheduleDao;

	@Autowired
	CustomerDetailsDao customerDetailsDao;

	@Autowired
	ConsumerService consumerService;

	@Autowired
	CurrentUser currentUser;

	@Autowired
	PhonepeServiceImpl phonepeServiceImpl;

	@Value("${merchant_id}")
	private String merchantId;

	@Value("${salt_key}")
	private String saltKey;

	@Value("${salt_index}")
	private String saltIndex;

	@Override
	public Map createCustomerOrderReplicaService(CustomerOrderReplicaRequest customerOrderReplicaRequest,
			String contactNumber, Integer aparmentId)

	{

		Map response = new HashedMap<>();

		response.put("message", "success");
		CustomerOrderReplica customerOrderReplica = null;

		if (customerOrderReplicaRequest.getCartId() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "cartId is mandatory ");
		}
		long razorPayCount = 0;
		if (customerOrderReplicaRequest.getOrderId() != null) {

			razorPayCount = customerOrderReplicaDoa.getRazorPayExistByCartId(customerOrderReplicaRequest.getOrderId());
		}

		if (customerOrderReplicaRequest.getCustomerDetails() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Order Details  is mandatory ");
		}

		customerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(customerOrderReplicaRequest.getCartId(),
				contactNumber);

		if (customerOrderReplica != null) {
			customerOrderReplica.setCartId(customerOrderReplica.getCartId());

			if (customerOrderReplica.isOrdered()) {
				throw new ResponseStatusException(HttpStatus.CONFLICT, "Your Order is Placed With cart Details");
			}

//			if (razorPayCount >= 1 && !(customerOrderReplica.getRazorPayOrderId() != null
//					&& customerOrderReplica.getRazorPayOrderId().equals(customerOrderReplicaRequest.getOrderId()))) {
//				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
//			}

			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);

			customerOrderReplica.setAttempts(customerOrderReplica.getAttempts() + 1);
			customerOrderReplica.setUpdatedTime(new Date());

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		} else {

			customerOrderReplica = new CustomerOrderReplica();
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);
			customerOrderReplica.setCartId(customerOrderReplicaRequest.getCartId());
			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());

			if (razorPayCount > 0) {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
			}

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			Schedule schedule = scheduleDao.getlatestScheduleCustomers();

			if (schedule != null) {

				try {
					customerOrderReplica.setSchedule(schedule.getsId() != null ? schedule.getsId().toString() : null);
				} catch (Exception e) {
					e.printStackTrace();
				}
			} else {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
						"Sorry We Are Not Accepting Any Order Right now");

			}

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		}

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicas(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String schedule = null;

		Map filter = request.containsKey("filters") ? (Map) request.get("filters") : null;
		if (filter != null) {
			statusType = filter.containsKey("statusType") ? ((String) filter.get("statusType")).toLowerCase() : null;
			searchQuery = filter.containsKey("searchQuery") ? ((String) filter.get("searchQuery")).toLowerCase() : null;
			schedule = filter.containsKey("schedule") ? (String.valueOf(filter.get("schedule"))) : null;

		}

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplica(searchQuery, statusType, schedule);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");

				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setStreetName(
						customers.get("streetName") != null ? (String) customers.get("streetName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicasBySchedule(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String scheduleId = null;

		Schedule schedule = scheduleDao.getlatestScheduleCustomers();

		if (schedule != null) {

			try {
				scheduleId = schedule.getsId() != null ? schedule.getsId().toString() : null;
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

		statusType = request.containsKey("statusType") ? ((String) request.get("statusType")).toLowerCase() : "Success";

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplicaBySchdeule(statusType, scheduleId);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");
				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				System.out.println("customers" + customers.get("customerName"));

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public CustomerOrderReplica getCustomerOrderReplicaByCartId(String cartId) {

		CustomerOrderReplica CustomerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(cartId,
				currentUser.getContactNumber());

		ObjectMapper objectMapper = new ObjectMapper();
		try {

			// convert JSON string to Map
			Map<String, Object> customerOrderReplicaMap = objectMapper
					.readValue(CustomerOrderReplica.getCustomerOrderDetails(), Map.class);

			Object customerOrder = customerOrderReplicaMap.get("customerOrder");
			Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

			Object quanityList = items.get("quantity");
			Map customers = customerDetailsDao.getByContactNumberAndApartment(CustomerOrderReplica.getContactNumber(),
					CustomerOrderReplica.getApartmentId());

			System.out.println("customers" + customers.get("customerName"));

			// Apartments apartments =
			// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
			CustomerOrderReplica.setApartmentName(
					customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

			CustomerOrderReplica.setCustomerDetails(customers);

			CustomerOrderReplica.setCustomerOrder(customerOrder);
			CustomerOrderReplica.setQuatityList(quanityList);

		} catch (Exception e) {
			e.printStackTrace();
		}

		return CustomerOrderReplica;

	}

	@Override
	public Map createCustomerOrderReplica(CustomerOrderReplicaRequest customerOrderReplicaRequest, String contactNumber,
			Integer aparmentId) {

		if (customerOrderReplicaRequest.getRazorPayRequest() != null) {

//			Map razorPay = consumerService.createRazorPayOrder(customerOrderReplicaRequest.getRazorPayRequest());
//			customerOrderReplicaRequest.setOrderId(razorPay.get("order") != null ? (String)((RazorPay) razorPay.get("order")).getId() : null);	
//	
//			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);
//
//			razorPay.put("cartId", customerOrderReplicaRequest.getCartId());

			Map customerOrderReplicaMap = new HashMap<>();

			Map orderId = new HashMap<>();
			String transactionId = getMerchantTransactionId();
			orderId.put("id", transactionId);

			customerOrderReplicaMap.put("order", orderId);

			customerOrderReplicaRequest.setOrderId(transactionId);
			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);

			customerOrderReplicaMap.put("cartId", customerOrderReplicaRequest.getCartId());

			try {
				customerOrderReplicaMap.put("phonePeResponse",
						phonepeServiceImpl.initiatePhonepePayment(transactionId,
								Integer.valueOf(customerOrderReplicaRequest.getRazorPayRequest().getAmount()),
								contactNumber, customerOrderReplicaRequest.getRedirectUrl(), customerOrderReplicaRequest.getCallBackUrl()));

			} catch (Exception e) {
				e.printStackTrace();
				customerOrderReplicaMap.put("phonePeResponse", new HashedMap<>());
			}

			return customerOrderReplicaMap;

		} else {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
					"paymentDetails transcation Details are mandatory");
		}

	}

	private static String getMerchantTransactionId() {

		return "OD_" + MerchantTransactionIdGenerator.getRandomString();
	}


	@Override
	public List<CustomerOrderReplica> getCustomerOrderByMoblieNo(String contactNumber,Integer aid) {
		
		Schedule latestschedule = customerOrderReplicaDoa.getlatestschedule();
		
		if (latestschedule != null && latestschedule.getCreationTimestamp()!=null) {
			
	        if (latestschedule.getStatus().equals(UserStatus.ACTIVE)) {
	        	
	        	Customers customer = customerDetailsDao.getByContactNoAndApartment(contactNumber, aid);
	        	if (customer != null) { // Ensure the customer exists
	        		List<CustomerOrder> customerOrderList = customerOrderReplicaDoa.getListCustomerOrderByCustomerId(customer.getCtid());
	        		
	                double totalOrderAmount = 0.0;
	       
                if (customerOrderList != null && !customerOrderList.isEmpty() && customerOrderList.add(customerOrder). {
                    for (CustomerOrder customerOrder : customerOrderList) {
                        Double orderAmount = customerOrder.getAmount();
                        if (orderAmount != null) {
                            totalOrderAmount += orderAmount;
                            if(totalOrderAmount>200) {
                            	totalOrderAmount+customerOrder
                            }
                        }
                    }
                    System.out.println("Total Order Amount: " + totalOrderAmount);
                    List<CustomerOrderReplica> customerOrderReplicas = new ArrayList<>();
                    return customerOrderReplicas;
                } else {
                    return Collections.emptyList(); // or return null or an appropriate value
                }
            } else {
              
                return null; // or an appropriate value
            }
        } else {
            // Handle the case when the latest schedule is not active
            return null; // or an appropriate value
        }
    } else {
        // Handle the case when there is no latest schedule or its creation timestamp is null
        return null; // or an appropriate value
    }
	}
}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-09-21 15:06:52.802
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-09-21 15:06:52.804
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-21 15:06:56.124
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.xyram.daydrop.serviceimpl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.transaction.Transactional;

import org.apache.commons.collections4.map.HashedMap;
import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.server.ResponseStatusException;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.xyram.daydrop.admin.model.CurrentUser;
import com.xyram.daydrop.basemodel.Base64Wrapper;
import com.xyram.daydrop.basemodel.MerchantTransactionIdGenerator;
import com.xyram.daydrop.basemodel.PhonepeSerializer;
import com.xyram.daydrop.dao.ApartmentDao;
import com.xyram.daydrop.dao.CustomerDetailsDao;
import com.xyram.daydrop.dao.CustomerOrderDao;
import com.xyram.daydrop.dao.CustomerOrderReplicaDoa;
import com.xyram.daydrop.dao.SheduleDao;
import com.xyram.daydrop.enumtypes.UserStatus;
import com.xyram.daydrop.model.Apartments;
import com.xyram.daydrop.model.CustomerOrder;
import com.xyram.daydrop.model.CustomerOrderReplica;
import com.xyram.daydrop.model.Customers;
import com.xyram.daydrop.model.Schedule;
import com.xyram.daydrop.modelMapper.PaymentInstrument;
import com.xyram.daydrop.modelMapper.PhonePePayModel;
import com.xyram.daydrop.request.CustomerOrderReplicaRequest;
import com.xyram.daydrop.response.RazorPayRequest;
import com.xyram.daydrop.service.CustomerOrderPriceService;
import com.xyram.daydrop.service.CustomerOrderReplicaService;
import com.xyram.daydrop.util.HashEncoder;
import com.xyram.daydrop.util.RazorPay;
import com.xyram.daydrop.service.ConsumerService;

@Transactional
@Service
public class CustomerOrderReplicaServiceImpl implements CustomerOrderReplicaService {

	@Autowired
	CustomerOrderReplicaDoa customerOrderReplicaDoa;

	@Autowired
	ApartmentDao apartmentDao;

	@Autowired
	SheduleDao scheduleDao;

	@Autowired
	CustomerDetailsDao customerDetailsDao;

	@Autowired
	ConsumerService consumerService;

	@Autowired
	CurrentUser currentUser;

	@Autowired
	PhonepeServiceImpl phonepeServiceImpl;

	@Value("${merchant_id}")
	private String merchantId;

	@Value("${salt_key}")
	private String saltKey;

	@Value("${salt_index}")
	private String saltIndex;

	@Override
	public Map createCustomerOrderReplicaService(CustomerOrderReplicaRequest customerOrderReplicaRequest,
			String contactNumber, Integer aparmentId)

	{

		Map response = new HashedMap<>();

		response.put("message", "success");
		CustomerOrderReplica customerOrderReplica = null;

		if (customerOrderReplicaRequest.getCartId() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "cartId is mandatory ");
		}
		long razorPayCount = 0;
		if (customerOrderReplicaRequest.getOrderId() != null) {

			razorPayCount = customerOrderReplicaDoa.getRazorPayExistByCartId(customerOrderReplicaRequest.getOrderId());
		}

		if (customerOrderReplicaRequest.getCustomerDetails() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Order Details  is mandatory ");
		}

		customerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(customerOrderReplicaRequest.getCartId(),
				contactNumber);

		if (customerOrderReplica != null) {
			customerOrderReplica.setCartId(customerOrderReplica.getCartId());

			if (customerOrderReplica.isOrdered()) {
				throw new ResponseStatusException(HttpStatus.CONFLICT, "Your Order is Placed With cart Details");
			}

//			if (razorPayCount >= 1 && !(customerOrderReplica.getRazorPayOrderId() != null
//					&& customerOrderReplica.getRazorPayOrderId().equals(customerOrderReplicaRequest.getOrderId()))) {
//				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
//			}

			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);

			customerOrderReplica.setAttempts(customerOrderReplica.getAttempts() + 1);
			customerOrderReplica.setUpdatedTime(new Date());

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		} else {

			customerOrderReplica = new CustomerOrderReplica();
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);
			customerOrderReplica.setCartId(customerOrderReplicaRequest.getCartId());
			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());

			if (razorPayCount > 0) {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
			}

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			Schedule schedule = scheduleDao.getlatestScheduleCustomers();

			if (schedule != null) {

				try {
					customerOrderReplica.setSchedule(schedule.getsId() != null ? schedule.getsId().toString() : null);
				} catch (Exception e) {
					e.printStackTrace();
				}
			} else {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
						"Sorry We Are Not Accepting Any Order Right now");

			}

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		}

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicas(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String schedule = null;

		Map filter = request.containsKey("filters") ? (Map) request.get("filters") : null;
		if (filter != null) {
			statusType = filter.containsKey("statusType") ? ((String) filter.get("statusType")).toLowerCase() : null;
			searchQuery = filter.containsKey("searchQuery") ? ((String) filter.get("searchQuery")).toLowerCase() : null;
			schedule = filter.containsKey("schedule") ? (String.valueOf(filter.get("schedule"))) : null;

		}

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplica(searchQuery, statusType, schedule);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");

				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setStreetName(
						customers.get("streetName") != null ? (String) customers.get("streetName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicasBySchedule(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String scheduleId = null;

		Schedule schedule = scheduleDao.getlatestScheduleCustomers();

		if (schedule != null) {

			try {
				scheduleId = schedule.getsId() != null ? schedule.getsId().toString() : null;
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

		statusType = request.containsKey("statusType") ? ((String) request.get("statusType")).toLowerCase() : "Success";

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplicaBySchdeule(statusType, scheduleId);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");
				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				System.out.println("customers" + customers.get("customerName"));

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public CustomerOrderReplica getCustomerOrderReplicaByCartId(String cartId) {

		CustomerOrderReplica CustomerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(cartId,
				currentUser.getContactNumber());

		ObjectMapper objectMapper = new ObjectMapper();
		try {

			// convert JSON string to Map
			Map<String, Object> customerOrderReplicaMap = objectMapper
					.readValue(CustomerOrderReplica.getCustomerOrderDetails(), Map.class);

			Object customerOrder = customerOrderReplicaMap.get("customerOrder");
			Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

			Object quanityList = items.get("quantity");
			Map customers = customerDetailsDao.getByContactNumberAndApartment(CustomerOrderReplica.getContactNumber(),
					CustomerOrderReplica.getApartmentId());

			System.out.println("customers" + customers.get("customerName"));

			// Apartments apartments =
			// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
			CustomerOrderReplica.setApartmentName(
					customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

			CustomerOrderReplica.setCustomerDetails(customers);

			CustomerOrderReplica.setCustomerOrder(customerOrder);
			CustomerOrderReplica.setQuatityList(quanityList);

		} catch (Exception e) {
			e.printStackTrace();
		}

		return CustomerOrderReplica;

	}

	@Override
	public Map createCustomerOrderReplica(CustomerOrderReplicaRequest customerOrderReplicaRequest, String contactNumber,
			Integer aparmentId) {

		if (customerOrderReplicaRequest.getRazorPayRequest() != null) {

//			Map razorPay = consumerService.createRazorPayOrder(customerOrderReplicaRequest.getRazorPayRequest());
//			customerOrderReplicaRequest.setOrderId(razorPay.get("order") != null ? (String)((RazorPay) razorPay.get("order")).getId() : null);	
//	
//			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);
//
//			razorPay.put("cartId", customerOrderReplicaRequest.getCartId());

			Map customerOrderReplicaMap = new HashMap<>();

			Map orderId = new HashMap<>();
			String transactionId = getMerchantTransactionId();
			orderId.put("id", transactionId);

			customerOrderReplicaMap.put("order", orderId);

			customerOrderReplicaRequest.setOrderId(transactionId);
			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);

			customerOrderReplicaMap.put("cartId", customerOrderReplicaRequest.getCartId());

			try {
				customerOrderReplicaMap.put("phonePeResponse",
						phonepeServiceImpl.initiatePhonepePayment(transactionId,
								Integer.valueOf(customerOrderReplicaRequest.getRazorPayRequest().getAmount()),
								contactNumber, customerOrderReplicaRequest.getRedirectUrl(), customerOrderReplicaRequest.getCallBackUrl()));

			} catch (Exception e) {
				e.printStackTrace();
				customerOrderReplicaMap.put("phonePeResponse", new HashedMap<>());
			}

			return customerOrderReplicaMap;

		} else {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
					"paymentDetails transcation Details are mandatory");
		}

	}

	private static String getMerchantTransactionId() {

		return "OD_" + MerchantTransactionIdGenerator.getRandomString();
	}


	@Override
	public List<CustomerOrderReplica> getCustomerOrderByMoblieNo(String contactNumber,Integer aid) {
		
		Schedule latestschedule = customerOrderReplicaDoa.getlatestschedule();
		
		if (latestschedule != null && latestschedule.getCreationTimestamp()!=null) {
			
	        if (latestschedule.getStatus().equals(UserStatus.ACTIVE)) {
	        	
	        	Customers customer = customerDetailsDao.getByContactNoAndApartment(contactNumber, aid);
	        	if (customer != null) { // Ensure the customer exists
	        		List<CustomerOrder> customerOrderList = customerOrderReplicaDoa.getListCustomerOrderByCustomerId(customer.getCtid());
	        		
	                double totalOrderAmount = 0.0;
	       
                if (customerOrderList != null && !customerOrderList.isEmpty() && customerOrderList.add(customerOrder). {
                    for (CustomerOrder customerOrder : customerOrderList) {
                        Double orderAmount = customerOrder.getAmount();
                        if (orderAmount != null) {
                            totalOrderAmount += orderAmount;
                            if(totalOrderAmount>200) {
                            	totalOrderAmount+customerOrder
                            }
                        }
                    }
                    System.out.println("Total Order Amount: " + totalOrderAmount);
                    List<CustomerOrderReplica> customerOrderReplicas = new ArrayList<>();
                    return customerOrderReplicas;
                } else {
                    return Collections.emptyList(); // or return null or an appropriate value
                }
            } else {
              
                return null; // or an appropriate value
            }
        } else {
            // Handle the case when the latest schedule is not active
            return null; // or an appropriate value
        }
    } else {
        // Handle the case when there is no latest schedule or its creation timestamp is null
        return null; // or an appropriate value
    }
	}
}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-09-21 15:06:56.127
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-09-21 15:06:56.129
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-21 15:06:58.830
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.xyram.daydrop.serviceimpl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.transaction.Transactional;

import org.apache.commons.collections4.map.HashedMap;
import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.server.ResponseStatusException;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.xyram.daydrop.admin.model.CurrentUser;
import com.xyram.daydrop.basemodel.Base64Wrapper;
import com.xyram.daydrop.basemodel.MerchantTransactionIdGenerator;
import com.xyram.daydrop.basemodel.PhonepeSerializer;
import com.xyram.daydrop.dao.ApartmentDao;
import com.xyram.daydrop.dao.CustomerDetailsDao;
import com.xyram.daydrop.dao.CustomerOrderDao;
import com.xyram.daydrop.dao.CustomerOrderReplicaDoa;
import com.xyram.daydrop.dao.SheduleDao;
import com.xyram.daydrop.enumtypes.UserStatus;
import com.xyram.daydrop.model.Apartments;
import com.xyram.daydrop.model.CustomerOrder;
import com.xyram.daydrop.model.CustomerOrderReplica;
import com.xyram.daydrop.model.Customers;
import com.xyram.daydrop.model.Schedule;
import com.xyram.daydrop.modelMapper.PaymentInstrument;
import com.xyram.daydrop.modelMapper.PhonePePayModel;
import com.xyram.daydrop.request.CustomerOrderReplicaRequest;
import com.xyram.daydrop.response.RazorPayRequest;
import com.xyram.daydrop.service.CustomerOrderPriceService;
import com.xyram.daydrop.service.CustomerOrderReplicaService;
import com.xyram.daydrop.util.HashEncoder;
import com.xyram.daydrop.util.RazorPay;
import com.xyram.daydrop.service.ConsumerService;

@Transactional
@Service
public class CustomerOrderReplicaServiceImpl implements CustomerOrderReplicaService {

	@Autowired
	CustomerOrderReplicaDoa customerOrderReplicaDoa;

	@Autowired
	ApartmentDao apartmentDao;

	@Autowired
	SheduleDao scheduleDao;

	@Autowired
	CustomerDetailsDao customerDetailsDao;

	@Autowired
	ConsumerService consumerService;

	@Autowired
	CurrentUser currentUser;

	@Autowired
	PhonepeServiceImpl phonepeServiceImpl;

	@Value("${merchant_id}")
	private String merchantId;

	@Value("${salt_key}")
	private String saltKey;

	@Value("${salt_index}")
	private String saltIndex;

	@Override
	public Map createCustomerOrderReplicaService(CustomerOrderReplicaRequest customerOrderReplicaRequest,
			String contactNumber, Integer aparmentId)

	{

		Map response = new HashedMap<>();

		response.put("message", "success");
		CustomerOrderReplica customerOrderReplica = null;

		if (customerOrderReplicaRequest.getCartId() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "cartId is mandatory ");
		}
		long razorPayCount = 0;
		if (customerOrderReplicaRequest.getOrderId() != null) {

			razorPayCount = customerOrderReplicaDoa.getRazorPayExistByCartId(customerOrderReplicaRequest.getOrderId());
		}

		if (customerOrderReplicaRequest.getCustomerDetails() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Order Details  is mandatory ");
		}

		customerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(customerOrderReplicaRequest.getCartId(),
				contactNumber);

		if (customerOrderReplica != null) {
			customerOrderReplica.setCartId(customerOrderReplica.getCartId());

			if (customerOrderReplica.isOrdered()) {
				throw new ResponseStatusException(HttpStatus.CONFLICT, "Your Order is Placed With cart Details");
			}

//			if (razorPayCount >= 1 && !(customerOrderReplica.getRazorPayOrderId() != null
//					&& customerOrderReplica.getRazorPayOrderId().equals(customerOrderReplicaRequest.getOrderId()))) {
//				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
//			}

			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);

			customerOrderReplica.setAttempts(customerOrderReplica.getAttempts() + 1);
			customerOrderReplica.setUpdatedTime(new Date());

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		} else {

			customerOrderReplica = new CustomerOrderReplica();
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);
			customerOrderReplica.setCartId(customerOrderReplicaRequest.getCartId());
			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());

			if (razorPayCount > 0) {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
			}

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			Schedule schedule = scheduleDao.getlatestScheduleCustomers();

			if (schedule != null) {

				try {
					customerOrderReplica.setSchedule(schedule.getsId() != null ? schedule.getsId().toString() : null);
				} catch (Exception e) {
					e.printStackTrace();
				}
			} else {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
						"Sorry We Are Not Accepting Any Order Right now");

			}

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		}

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicas(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String schedule = null;

		Map filter = request.containsKey("filters") ? (Map) request.get("filters") : null;
		if (filter != null) {
			statusType = filter.containsKey("statusType") ? ((String) filter.get("statusType")).toLowerCase() : null;
			searchQuery = filter.containsKey("searchQuery") ? ((String) filter.get("searchQuery")).toLowerCase() : null;
			schedule = filter.containsKey("schedule") ? (String.valueOf(filter.get("schedule"))) : null;

		}

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplica(searchQuery, statusType, schedule);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");

				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setStreetName(
						customers.get("streetName") != null ? (String) customers.get("streetName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicasBySchedule(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String scheduleId = null;

		Schedule schedule = scheduleDao.getlatestScheduleCustomers();

		if (schedule != null) {

			try {
				scheduleId = schedule.getsId() != null ? schedule.getsId().toString() : null;
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

		statusType = request.containsKey("statusType") ? ((String) request.get("statusType")).toLowerCase() : "Success";

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplicaBySchdeule(statusType, scheduleId);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");
				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				System.out.println("customers" + customers.get("customerName"));

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public CustomerOrderReplica getCustomerOrderReplicaByCartId(String cartId) {

		CustomerOrderReplica CustomerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(cartId,
				currentUser.getContactNumber());

		ObjectMapper objectMapper = new ObjectMapper();
		try {

			// convert JSON string to Map
			Map<String, Object> customerOrderReplicaMap = objectMapper
					.readValue(CustomerOrderReplica.getCustomerOrderDetails(), Map.class);

			Object customerOrder = customerOrderReplicaMap.get("customerOrder");
			Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

			Object quanityList = items.get("quantity");
			Map customers = customerDetailsDao.getByContactNumberAndApartment(CustomerOrderReplica.getContactNumber(),
					CustomerOrderReplica.getApartmentId());

			System.out.println("customers" + customers.get("customerName"));

			// Apartments apartments =
			// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
			CustomerOrderReplica.setApartmentName(
					customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

			CustomerOrderReplica.setCustomerDetails(customers);

			CustomerOrderReplica.setCustomerOrder(customerOrder);
			CustomerOrderReplica.setQuatityList(quanityList);

		} catch (Exception e) {
			e.printStackTrace();
		}

		return CustomerOrderReplica;

	}

	@Override
	public Map createCustomerOrderReplica(CustomerOrderReplicaRequest customerOrderReplicaRequest, String contactNumber,
			Integer aparmentId) {

		if (customerOrderReplicaRequest.getRazorPayRequest() != null) {

//			Map razorPay = consumerService.createRazorPayOrder(customerOrderReplicaRequest.getRazorPayRequest());
//			customerOrderReplicaRequest.setOrderId(razorPay.get("order") != null ? (String)((RazorPay) razorPay.get("order")).getId() : null);	
//	
//			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);
//
//			razorPay.put("cartId", customerOrderReplicaRequest.getCartId());

			Map customerOrderReplicaMap = new HashMap<>();

			Map orderId = new HashMap<>();
			String transactionId = getMerchantTransactionId();
			orderId.put("id", transactionId);

			customerOrderReplicaMap.put("order", orderId);

			customerOrderReplicaRequest.setOrderId(transactionId);
			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);

			customerOrderReplicaMap.put("cartId", customerOrderReplicaRequest.getCartId());

			try {
				customerOrderReplicaMap.put("phonePeResponse",
						phonepeServiceImpl.initiatePhonepePayment(transactionId,
								Integer.valueOf(customerOrderReplicaRequest.getRazorPayRequest().getAmount()),
								contactNumber, customerOrderReplicaRequest.getRedirectUrl(), customerOrderReplicaRequest.getCallBackUrl()));

			} catch (Exception e) {
				e.printStackTrace();
				customerOrderReplicaMap.put("phonePeResponse", new HashedMap<>());
			}

			return customerOrderReplicaMap;

		} else {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
					"paymentDetails transcation Details are mandatory");
		}

	}

	private static String getMerchantTransactionId() {

		return "OD_" + MerchantTransactionIdGenerator.getRandomString();
	}


	@Override
	public List<CustomerOrderReplica> getCustomerOrderByMoblieNo(String contactNumber,Integer aid) {
		
		Schedule latestschedule = customerOrderReplicaDoa.getlatestschedule();
		
		if (latestschedule != null && latestschedule.getCreationTimestamp()!=null) {
			
	        if (latestschedule.getStatus().equals(UserStatus.ACTIVE)) {
	        	
	        	Customers customer = customerDetailsDao.getByContactNoAndApartment(contactNumber, aid);
	        	if (customer != null) { // Ensure the customer exists
	        		List<CustomerOrder> customerOrderList = customerOrderReplicaDoa.getListCustomerOrderByCustomerId(customer.getCtid());
	        		
	                double totalOrderAmount = 0.0;
	       
                if (customerOrderList != null && !customerOrderList.isEmpty() && customerOrderList.add(customerOrder). {
                    for (CustomerOrder customerOrder : customerOrderList) {
                        Double orderAmount = customerOrder.getAmount();
                        if (orderAmount != null) {
                            totalOrderAmount += orderAmount;
                            if(totalOrderAmount>200) {
                            	totalOrderAmount+customerOrder
                            }
                        }
                    }
                    System.out.println("Total Order Amount: " + totalOrderAmount);
                    List<CustomerOrderReplica> customerOrderReplicas = new ArrayList<>();
                    return customerOrderReplicas;
                } else {
                    return Collections.emptyList(); // or return null or an appropriate value
                }
            } else {
              
                return null; // or an appropriate value
            }
        } else {
            // Handle the case when the latest schedule is not active
            return null; // or an appropriate value
        }
    } else {
        // Handle the case when there is no latest schedule or its creation timestamp is null
        return null; // or an appropriate value
    }
	}
}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-09-21 15:06:58.832
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-09-21 15:06:58.834
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-21 15:07:02.863
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.xyram.daydrop.serviceimpl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.transaction.Transactional;

import org.apache.commons.collections4.map.HashedMap;
import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.server.ResponseStatusException;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.xyram.daydrop.admin.model.CurrentUser;
import com.xyram.daydrop.basemodel.Base64Wrapper;
import com.xyram.daydrop.basemodel.MerchantTransactionIdGenerator;
import com.xyram.daydrop.basemodel.PhonepeSerializer;
import com.xyram.daydrop.dao.ApartmentDao;
import com.xyram.daydrop.dao.CustomerDetailsDao;
import com.xyram.daydrop.dao.CustomerOrderDao;
import com.xyram.daydrop.dao.CustomerOrderReplicaDoa;
import com.xyram.daydrop.dao.SheduleDao;
import com.xyram.daydrop.enumtypes.UserStatus;
import com.xyram.daydrop.model.Apartments;
import com.xyram.daydrop.model.CustomerOrder;
import com.xyram.daydrop.model.CustomerOrderReplica;
import com.xyram.daydrop.model.Customers;
import com.xyram.daydrop.model.Schedule;
import com.xyram.daydrop.modelMapper.PaymentInstrument;
import com.xyram.daydrop.modelMapper.PhonePePayModel;
import com.xyram.daydrop.request.CustomerOrderReplicaRequest;
import com.xyram.daydrop.response.RazorPayRequest;
import com.xyram.daydrop.service.CustomerOrderPriceService;
import com.xyram.daydrop.service.CustomerOrderReplicaService;
import com.xyram.daydrop.util.HashEncoder;
import com.xyram.daydrop.util.RazorPay;
import com.xyram.daydrop.service.ConsumerService;

@Transactional
@Service
public class CustomerOrderReplicaServiceImpl implements CustomerOrderReplicaService {

	@Autowired
	CustomerOrderReplicaDoa customerOrderReplicaDoa;

	@Autowired
	ApartmentDao apartmentDao;

	@Autowired
	SheduleDao scheduleDao;

	@Autowired
	CustomerDetailsDao customerDetailsDao;

	@Autowired
	ConsumerService consumerService;

	@Autowired
	CurrentUser currentUser;

	@Autowired
	PhonepeServiceImpl phonepeServiceImpl;

	@Value("${merchant_id}")
	private String merchantId;

	@Value("${salt_key}")
	private String saltKey;

	@Value("${salt_index}")
	private String saltIndex;

	@Override
	public Map createCustomerOrderReplicaService(CustomerOrderReplicaRequest customerOrderReplicaRequest,
			String contactNumber, Integer aparmentId)

	{

		Map response = new HashedMap<>();

		response.put("message", "success");
		CustomerOrderReplica customerOrderReplica = null;

		if (customerOrderReplicaRequest.getCartId() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "cartId is mandatory ");
		}
		long razorPayCount = 0;
		if (customerOrderReplicaRequest.getOrderId() != null) {

			razorPayCount = customerOrderReplicaDoa.getRazorPayExistByCartId(customerOrderReplicaRequest.getOrderId());
		}

		if (customerOrderReplicaRequest.getCustomerDetails() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Order Details  is mandatory ");
		}

		customerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(customerOrderReplicaRequest.getCartId(),
				contactNumber);

		if (customerOrderReplica != null) {
			customerOrderReplica.setCartId(customerOrderReplica.getCartId());

			if (customerOrderReplica.isOrdered()) {
				throw new ResponseStatusException(HttpStatus.CONFLICT, "Your Order is Placed With cart Details");
			}

//			if (razorPayCount >= 1 && !(customerOrderReplica.getRazorPayOrderId() != null
//					&& customerOrderReplica.getRazorPayOrderId().equals(customerOrderReplicaRequest.getOrderId()))) {
//				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
//			}

			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);

			customerOrderReplica.setAttempts(customerOrderReplica.getAttempts() + 1);
			customerOrderReplica.setUpdatedTime(new Date());

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		} else {

			customerOrderReplica = new CustomerOrderReplica();
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);
			customerOrderReplica.setCartId(customerOrderReplicaRequest.getCartId());
			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());

			if (razorPayCount > 0) {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
			}

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			Schedule schedule = scheduleDao.getlatestScheduleCustomers();

			if (schedule != null) {

				try {
					customerOrderReplica.setSchedule(schedule.getsId() != null ? schedule.getsId().toString() : null);
				} catch (Exception e) {
					e.printStackTrace();
				}
			} else {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
						"Sorry We Are Not Accepting Any Order Right now");

			}

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		}

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicas(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String schedule = null;

		Map filter = request.containsKey("filters") ? (Map) request.get("filters") : null;
		if (filter != null) {
			statusType = filter.containsKey("statusType") ? ((String) filter.get("statusType")).toLowerCase() : null;
			searchQuery = filter.containsKey("searchQuery") ? ((String) filter.get("searchQuery")).toLowerCase() : null;
			schedule = filter.containsKey("schedule") ? (String.valueOf(filter.get("schedule"))) : null;

		}

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplica(searchQuery, statusType, schedule);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");

				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setStreetName(
						customers.get("streetName") != null ? (String) customers.get("streetName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicasBySchedule(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String scheduleId = null;

		Schedule schedule = scheduleDao.getlatestScheduleCustomers();

		if (schedule != null) {

			try {
				scheduleId = schedule.getsId() != null ? schedule.getsId().toString() : null;
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

		statusType = request.containsKey("statusType") ? ((String) request.get("statusType")).toLowerCase() : "Success";

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplicaBySchdeule(statusType, scheduleId);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");
				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				System.out.println("customers" + customers.get("customerName"));

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public CustomerOrderReplica getCustomerOrderReplicaByCartId(String cartId) {

		CustomerOrderReplica CustomerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(cartId,
				currentUser.getContactNumber());

		ObjectMapper objectMapper = new ObjectMapper();
		try {

			// convert JSON string to Map
			Map<String, Object> customerOrderReplicaMap = objectMapper
					.readValue(CustomerOrderReplica.getCustomerOrderDetails(), Map.class);

			Object customerOrder = customerOrderReplicaMap.get("customerOrder");
			Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

			Object quanityList = items.get("quantity");
			Map customers = customerDetailsDao.getByContactNumberAndApartment(CustomerOrderReplica.getContactNumber(),
					CustomerOrderReplica.getApartmentId());

			System.out.println("customers" + customers.get("customerName"));

			// Apartments apartments =
			// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
			CustomerOrderReplica.setApartmentName(
					customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

			CustomerOrderReplica.setCustomerDetails(customers);

			CustomerOrderReplica.setCustomerOrder(customerOrder);
			CustomerOrderReplica.setQuatityList(quanityList);

		} catch (Exception e) {
			e.printStackTrace();
		}

		return CustomerOrderReplica;

	}

	@Override
	public Map createCustomerOrderReplica(CustomerOrderReplicaRequest customerOrderReplicaRequest, String contactNumber,
			Integer aparmentId) {

		if (customerOrderReplicaRequest.getRazorPayRequest() != null) {

//			Map razorPay = consumerService.createRazorPayOrder(customerOrderReplicaRequest.getRazorPayRequest());
//			customerOrderReplicaRequest.setOrderId(razorPay.get("order") != null ? (String)((RazorPay) razorPay.get("order")).getId() : null);	
//	
//			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);
//
//			razorPay.put("cartId", customerOrderReplicaRequest.getCartId());

			Map customerOrderReplicaMap = new HashMap<>();

			Map orderId = new HashMap<>();
			String transactionId = getMerchantTransactionId();
			orderId.put("id", transactionId);

			customerOrderReplicaMap.put("order", orderId);

			customerOrderReplicaRequest.setOrderId(transactionId);
			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);

			customerOrderReplicaMap.put("cartId", customerOrderReplicaRequest.getCartId());

			try {
				customerOrderReplicaMap.put("phonePeResponse",
						phonepeServiceImpl.initiatePhonepePayment(transactionId,
								Integer.valueOf(customerOrderReplicaRequest.getRazorPayRequest().getAmount()),
								contactNumber, customerOrderReplicaRequest.getRedirectUrl(), customerOrderReplicaRequest.getCallBackUrl()));

			} catch (Exception e) {
				e.printStackTrace();
				customerOrderReplicaMap.put("phonePeResponse", new HashedMap<>());
			}

			return customerOrderReplicaMap;

		} else {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
					"paymentDetails transcation Details are mandatory");
		}

	}

	private static String getMerchantTransactionId() {

		return "OD_" + MerchantTransactionIdGenerator.getRandomString();
	}


	@Override
	public List<CustomerOrderReplica> getCustomerOrderByMoblieNo(String contactNumber,Integer aid) {
		
		Schedule latestschedule = customerOrderReplicaDoa.getlatestschedule();
		
		if (latestschedule != null && latestschedule.getCreationTimestamp()!=null) {
			
	        if (latestschedule.getStatus().equals(UserStatus.ACTIVE)) {
	        	
	        	Customers customer = customerDetailsDao.getByContactNoAndApartment(contactNumber, aid);
	        	if (customer != null) { // Ensure the customer exists
	        		List<CustomerOrder> customerOrderList = customerOrderReplicaDoa.getListCustomerOrderByCustomerId(customer.getCtid());
	        		
	                double totalOrderAmount = 0.0;
	       
                if (customerOrderList != null && !customerOrderList.isEmpty() && customerOrderList.add(customerOrder). {
                    for (CustomerOrder customerOrder : customerOrderList) {
                        Double orderAmount = customerOrder.getAmount();
                        if (orderAmount != null) {
                            totalOrderAmount += orderAmount;
                            if(totalOrderAmount>200) {
                            	totalOrderAmount+customerOrder
                            }
                        }
                    }
                    System.out.println("Total Order Amount: " + totalOrderAmount);
                    List<CustomerOrderReplica> customerOrderReplicas = new ArrayList<>();
                    return customerOrderReplicas;
                } else {
                    return Collections.emptyList(); // or return null or an appropriate value
                }
            } else {
              
                return null; // or an appropriate value
            }
        } else {
            // Handle the case when the latest schedule is not active
            return null; // or an appropriate value
        }
    } else {
        // Handle the case when there is no latest schedule or its creation timestamp is null
        return null; // or an appropriate value
    }
	}
}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-09-21 15:07:02.865
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-09-21 15:07:02.867
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-21 15:07:04.598
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.xyram.daydrop.serviceimpl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.transaction.Transactional;

import org.apache.commons.collections4.map.HashedMap;
import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.server.ResponseStatusException;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.xyram.daydrop.admin.model.CurrentUser;
import com.xyram.daydrop.basemodel.Base64Wrapper;
import com.xyram.daydrop.basemodel.MerchantTransactionIdGenerator;
import com.xyram.daydrop.basemodel.PhonepeSerializer;
import com.xyram.daydrop.dao.ApartmentDao;
import com.xyram.daydrop.dao.CustomerDetailsDao;
import com.xyram.daydrop.dao.CustomerOrderDao;
import com.xyram.daydrop.dao.CustomerOrderReplicaDoa;
import com.xyram.daydrop.dao.SheduleDao;
import com.xyram.daydrop.enumtypes.UserStatus;
import com.xyram.daydrop.model.Apartments;
import com.xyram.daydrop.model.CustomerOrder;
import com.xyram.daydrop.model.CustomerOrderReplica;
import com.xyram.daydrop.model.Customers;
import com.xyram.daydrop.model.Schedule;
import com.xyram.daydrop.modelMapper.PaymentInstrument;
import com.xyram.daydrop.modelMapper.PhonePePayModel;
import com.xyram.daydrop.request.CustomerOrderReplicaRequest;
import com.xyram.daydrop.response.RazorPayRequest;
import com.xyram.daydrop.service.CustomerOrderPriceService;
import com.xyram.daydrop.service.CustomerOrderReplicaService;
import com.xyram.daydrop.util.HashEncoder;
import com.xyram.daydrop.util.RazorPay;
import com.xyram.daydrop.service.ConsumerService;

@Transactional
@Service
public class CustomerOrderReplicaServiceImpl implements CustomerOrderReplicaService {

	@Autowired
	CustomerOrderReplicaDoa customerOrderReplicaDoa;

	@Autowired
	ApartmentDao apartmentDao;

	@Autowired
	SheduleDao scheduleDao;

	@Autowired
	CustomerDetailsDao customerDetailsDao;

	@Autowired
	ConsumerService consumerService;

	@Autowired
	CurrentUser currentUser;

	@Autowired
	PhonepeServiceImpl phonepeServiceImpl;

	@Value("${merchant_id}")
	private String merchantId;

	@Value("${salt_key}")
	private String saltKey;

	@Value("${salt_index}")
	private String saltIndex;

	@Override
	public Map createCustomerOrderReplicaService(CustomerOrderReplicaRequest customerOrderReplicaRequest,
			String contactNumber, Integer aparmentId)

	{

		Map response = new HashedMap<>();

		response.put("message", "success");
		CustomerOrderReplica customerOrderReplica = null;

		if (customerOrderReplicaRequest.getCartId() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "cartId is mandatory ");
		}
		long razorPayCount = 0;
		if (customerOrderReplicaRequest.getOrderId() != null) {

			razorPayCount = customerOrderReplicaDoa.getRazorPayExistByCartId(customerOrderReplicaRequest.getOrderId());
		}

		if (customerOrderReplicaRequest.getCustomerDetails() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Order Details  is mandatory ");
		}

		customerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(customerOrderReplicaRequest.getCartId(),
				contactNumber);

		if (customerOrderReplica != null) {
			customerOrderReplica.setCartId(customerOrderReplica.getCartId());

			if (customerOrderReplica.isOrdered()) {
				throw new ResponseStatusException(HttpStatus.CONFLICT, "Your Order is Placed With cart Details");
			}

//			if (razorPayCount >= 1 && !(customerOrderReplica.getRazorPayOrderId() != null
//					&& customerOrderReplica.getRazorPayOrderId().equals(customerOrderReplicaRequest.getOrderId()))) {
//				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
//			}

			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);

			customerOrderReplica.setAttempts(customerOrderReplica.getAttempts() + 1);
			customerOrderReplica.setUpdatedTime(new Date());

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		} else {

			customerOrderReplica = new CustomerOrderReplica();
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);
			customerOrderReplica.setCartId(customerOrderReplicaRequest.getCartId());
			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());

			if (razorPayCount > 0) {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
			}

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			Schedule schedule = scheduleDao.getlatestScheduleCustomers();

			if (schedule != null) {

				try {
					customerOrderReplica.setSchedule(schedule.getsId() != null ? schedule.getsId().toString() : null);
				} catch (Exception e) {
					e.printStackTrace();
				}
			} else {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
						"Sorry We Are Not Accepting Any Order Right now");

			}

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		}

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicas(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String schedule = null;

		Map filter = request.containsKey("filters") ? (Map) request.get("filters") : null;
		if (filter != null) {
			statusType = filter.containsKey("statusType") ? ((String) filter.get("statusType")).toLowerCase() : null;
			searchQuery = filter.containsKey("searchQuery") ? ((String) filter.get("searchQuery")).toLowerCase() : null;
			schedule = filter.containsKey("schedule") ? (String.valueOf(filter.get("schedule"))) : null;

		}

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplica(searchQuery, statusType, schedule);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");

				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setStreetName(
						customers.get("streetName") != null ? (String) customers.get("streetName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicasBySchedule(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String scheduleId = null;

		Schedule schedule = scheduleDao.getlatestScheduleCustomers();

		if (schedule != null) {

			try {
				scheduleId = schedule.getsId() != null ? schedule.getsId().toString() : null;
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

		statusType = request.containsKey("statusType") ? ((String) request.get("statusType")).toLowerCase() : "Success";

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplicaBySchdeule(statusType, scheduleId);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");
				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				System.out.println("customers" + customers.get("customerName"));

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public CustomerOrderReplica getCustomerOrderReplicaByCartId(String cartId) {

		CustomerOrderReplica CustomerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(cartId,
				currentUser.getContactNumber());

		ObjectMapper objectMapper = new ObjectMapper();
		try {

			// convert JSON string to Map
			Map<String, Object> customerOrderReplicaMap = objectMapper
					.readValue(CustomerOrderReplica.getCustomerOrderDetails(), Map.class);

			Object customerOrder = customerOrderReplicaMap.get("customerOrder");
			Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

			Object quanityList = items.get("quantity");
			Map customers = customerDetailsDao.getByContactNumberAndApartment(CustomerOrderReplica.getContactNumber(),
					CustomerOrderReplica.getApartmentId());

			System.out.println("customers" + customers.get("customerName"));

			// Apartments apartments =
			// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
			CustomerOrderReplica.setApartmentName(
					customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

			CustomerOrderReplica.setCustomerDetails(customers);

			CustomerOrderReplica.setCustomerOrder(customerOrder);
			CustomerOrderReplica.setQuatityList(quanityList);

		} catch (Exception e) {
			e.printStackTrace();
		}

		return CustomerOrderReplica;

	}

	@Override
	public Map createCustomerOrderReplica(CustomerOrderReplicaRequest customerOrderReplicaRequest, String contactNumber,
			Integer aparmentId) {

		if (customerOrderReplicaRequest.getRazorPayRequest() != null) {

//			Map razorPay = consumerService.createRazorPayOrder(customerOrderReplicaRequest.getRazorPayRequest());
//			customerOrderReplicaRequest.setOrderId(razorPay.get("order") != null ? (String)((RazorPay) razorPay.get("order")).getId() : null);	
//	
//			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);
//
//			razorPay.put("cartId", customerOrderReplicaRequest.getCartId());

			Map customerOrderReplicaMap = new HashMap<>();

			Map orderId = new HashMap<>();
			String transactionId = getMerchantTransactionId();
			orderId.put("id", transactionId);

			customerOrderReplicaMap.put("order", orderId);

			customerOrderReplicaRequest.setOrderId(transactionId);
			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);

			customerOrderReplicaMap.put("cartId", customerOrderReplicaRequest.getCartId());

			try {
				customerOrderReplicaMap.put("phonePeResponse",
						phonepeServiceImpl.initiatePhonepePayment(transactionId,
								Integer.valueOf(customerOrderReplicaRequest.getRazorPayRequest().getAmount()),
								contactNumber, customerOrderReplicaRequest.getRedirectUrl(), customerOrderReplicaRequest.getCallBackUrl()));

			} catch (Exception e) {
				e.printStackTrace();
				customerOrderReplicaMap.put("phonePeResponse", new HashedMap<>());
			}

			return customerOrderReplicaMap;

		} else {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
					"paymentDetails transcation Details are mandatory");
		}

	}

	private static String getMerchantTransactionId() {

		return "OD_" + MerchantTransactionIdGenerator.getRandomString();
	}


	@Override
	public List<CustomerOrderReplica> getCustomerOrderByMoblieNo(String contactNumber,Integer aid) {
		
		Schedule latestschedule = customerOrderReplicaDoa.getlatestschedule();
		
		if (latestschedule != null && latestschedule.getCreationTimestamp()!=null) {
			
	        if (latestschedule.getStatus().equals(UserStatus.ACTIVE)) {
	        	
	        	Customers customer = customerDetailsDao.getByContactNoAndApartment(contactNumber, aid);
	        	if (customer != null) { // Ensure the customer exists
	        		List<CustomerOrder> customerOrderList = customerOrderReplicaDoa.getListCustomerOrderByCustomerId(customer.getCtid());
	        		
	                double totalOrderAmount = 0.0;
	       
                if (customerOrderList != null && !customerOrderList.isEmpty() && customerOrderList.add(customerOrder). {
                    for (CustomerOrder customerOrder : customerOrderList) {
                        Double orderAmount = customerOrder.getAmount();
                        if (orderAmount != null) {
                            totalOrderAmount += orderAmount;
                            if(totalOrderAmount>200) {
                            	totalOrderAmount+customerOrder
                            }
                        }
                    }
                    System.out.println("Total Order Amount: " + totalOrderAmount);
                    List<CustomerOrderReplica> customerOrderReplicas = new ArrayList<>();
                    return customerOrderReplicas;
                } else {
                    return Collections.emptyList(); // or return null or an appropriate value
                }
            } else {
              
                return null; // or an appropriate value
            }
        } else {
            // Handle the case when the latest schedule is not active
            return null; // or an appropriate value
        }
    } else {
        // Handle the case when there is no latest schedule or its creation timestamp is null
        return null; // or an appropriate value
    }
	}
}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-09-21 15:07:04.600
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-09-21 15:07:04.601
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-21 15:07:05.521
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.xyram.daydrop.serviceimpl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.transaction.Transactional;

import org.apache.commons.collections4.map.HashedMap;
import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.server.ResponseStatusException;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.xyram.daydrop.admin.model.CurrentUser;
import com.xyram.daydrop.basemodel.Base64Wrapper;
import com.xyram.daydrop.basemodel.MerchantTransactionIdGenerator;
import com.xyram.daydrop.basemodel.PhonepeSerializer;
import com.xyram.daydrop.dao.ApartmentDao;
import com.xyram.daydrop.dao.CustomerDetailsDao;
import com.xyram.daydrop.dao.CustomerOrderDao;
import com.xyram.daydrop.dao.CustomerOrderReplicaDoa;
import com.xyram.daydrop.dao.SheduleDao;
import com.xyram.daydrop.enumtypes.UserStatus;
import com.xyram.daydrop.model.Apartments;
import com.xyram.daydrop.model.CustomerOrder;
import com.xyram.daydrop.model.CustomerOrderReplica;
import com.xyram.daydrop.model.Customers;
import com.xyram.daydrop.model.Schedule;
import com.xyram.daydrop.modelMapper.PaymentInstrument;
import com.xyram.daydrop.modelMapper.PhonePePayModel;
import com.xyram.daydrop.request.CustomerOrderReplicaRequest;
import com.xyram.daydrop.response.RazorPayRequest;
import com.xyram.daydrop.service.CustomerOrderPriceService;
import com.xyram.daydrop.service.CustomerOrderReplicaService;
import com.xyram.daydrop.util.HashEncoder;
import com.xyram.daydrop.util.RazorPay;
import com.xyram.daydrop.service.ConsumerService;

@Transactional
@Service
public class CustomerOrderReplicaServiceImpl implements CustomerOrderReplicaService {

	@Autowired
	CustomerOrderReplicaDoa customerOrderReplicaDoa;

	@Autowired
	ApartmentDao apartmentDao;

	@Autowired
	SheduleDao scheduleDao;

	@Autowired
	CustomerDetailsDao customerDetailsDao;

	@Autowired
	ConsumerService consumerService;

	@Autowired
	CurrentUser currentUser;

	@Autowired
	PhonepeServiceImpl phonepeServiceImpl;

	@Value("${merchant_id}")
	private String merchantId;

	@Value("${salt_key}")
	private String saltKey;

	@Value("${salt_index}")
	private String saltIndex;

	@Override
	public Map createCustomerOrderReplicaService(CustomerOrderReplicaRequest customerOrderReplicaRequest,
			String contactNumber, Integer aparmentId)

	{

		Map response = new HashedMap<>();

		response.put("message", "success");
		CustomerOrderReplica customerOrderReplica = null;

		if (customerOrderReplicaRequest.getCartId() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "cartId is mandatory ");
		}
		long razorPayCount = 0;
		if (customerOrderReplicaRequest.getOrderId() != null) {

			razorPayCount = customerOrderReplicaDoa.getRazorPayExistByCartId(customerOrderReplicaRequest.getOrderId());
		}

		if (customerOrderReplicaRequest.getCustomerDetails() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Order Details  is mandatory ");
		}

		customerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(customerOrderReplicaRequest.getCartId(),
				contactNumber);

		if (customerOrderReplica != null) {
			customerOrderReplica.setCartId(customerOrderReplica.getCartId());

			if (customerOrderReplica.isOrdered()) {
				throw new ResponseStatusException(HttpStatus.CONFLICT, "Your Order is Placed With cart Details");
			}

//			if (razorPayCount >= 1 && !(customerOrderReplica.getRazorPayOrderId() != null
//					&& customerOrderReplica.getRazorPayOrderId().equals(customerOrderReplicaRequest.getOrderId()))) {
//				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
//			}

			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);

			customerOrderReplica.setAttempts(customerOrderReplica.getAttempts() + 1);
			customerOrderReplica.setUpdatedTime(new Date());

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		} else {

			customerOrderReplica = new CustomerOrderReplica();
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);
			customerOrderReplica.setCartId(customerOrderReplicaRequest.getCartId());
			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());

			if (razorPayCount > 0) {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
			}

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			Schedule schedule = scheduleDao.getlatestScheduleCustomers();

			if (schedule != null) {

				try {
					customerOrderReplica.setSchedule(schedule.getsId() != null ? schedule.getsId().toString() : null);
				} catch (Exception e) {
					e.printStackTrace();
				}
			} else {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
						"Sorry We Are Not Accepting Any Order Right now");

			}

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		}

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicas(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String schedule = null;

		Map filter = request.containsKey("filters") ? (Map) request.get("filters") : null;
		if (filter != null) {
			statusType = filter.containsKey("statusType") ? ((String) filter.get("statusType")).toLowerCase() : null;
			searchQuery = filter.containsKey("searchQuery") ? ((String) filter.get("searchQuery")).toLowerCase() : null;
			schedule = filter.containsKey("schedule") ? (String.valueOf(filter.get("schedule"))) : null;

		}

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplica(searchQuery, statusType, schedule);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");

				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setStreetName(
						customers.get("streetName") != null ? (String) customers.get("streetName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicasBySchedule(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String scheduleId = null;

		Schedule schedule = scheduleDao.getlatestScheduleCustomers();

		if (schedule != null) {

			try {
				scheduleId = schedule.getsId() != null ? schedule.getsId().toString() : null;
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

		statusType = request.containsKey("statusType") ? ((String) request.get("statusType")).toLowerCase() : "Success";

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplicaBySchdeule(statusType, scheduleId);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");
				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				System.out.println("customers" + customers.get("customerName"));

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public CustomerOrderReplica getCustomerOrderReplicaByCartId(String cartId) {

		CustomerOrderReplica CustomerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(cartId,
				currentUser.getContactNumber());

		ObjectMapper objectMapper = new ObjectMapper();
		try {

			// convert JSON string to Map
			Map<String, Object> customerOrderReplicaMap = objectMapper
					.readValue(CustomerOrderReplica.getCustomerOrderDetails(), Map.class);

			Object customerOrder = customerOrderReplicaMap.get("customerOrder");
			Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

			Object quanityList = items.get("quantity");
			Map customers = customerDetailsDao.getByContactNumberAndApartment(CustomerOrderReplica.getContactNumber(),
					CustomerOrderReplica.getApartmentId());

			System.out.println("customers" + customers.get("customerName"));

			// Apartments apartments =
			// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
			CustomerOrderReplica.setApartmentName(
					customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

			CustomerOrderReplica.setCustomerDetails(customers);

			CustomerOrderReplica.setCustomerOrder(customerOrder);
			CustomerOrderReplica.setQuatityList(quanityList);

		} catch (Exception e) {
			e.printStackTrace();
		}

		return CustomerOrderReplica;

	}

	@Override
	public Map createCustomerOrderReplica(CustomerOrderReplicaRequest customerOrderReplicaRequest, String contactNumber,
			Integer aparmentId) {

		if (customerOrderReplicaRequest.getRazorPayRequest() != null) {

//			Map razorPay = consumerService.createRazorPayOrder(customerOrderReplicaRequest.getRazorPayRequest());
//			customerOrderReplicaRequest.setOrderId(razorPay.get("order") != null ? (String)((RazorPay) razorPay.get("order")).getId() : null);	
//	
//			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);
//
//			razorPay.put("cartId", customerOrderReplicaRequest.getCartId());

			Map customerOrderReplicaMap = new HashMap<>();

			Map orderId = new HashMap<>();
			String transactionId = getMerchantTransactionId();
			orderId.put("id", transactionId);

			customerOrderReplicaMap.put("order", orderId);

			customerOrderReplicaRequest.setOrderId(transactionId);
			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);

			customerOrderReplicaMap.put("cartId", customerOrderReplicaRequest.getCartId());

			try {
				customerOrderReplicaMap.put("phonePeResponse",
						phonepeServiceImpl.initiatePhonepePayment(transactionId,
								Integer.valueOf(customerOrderReplicaRequest.getRazorPayRequest().getAmount()),
								contactNumber, customerOrderReplicaRequest.getRedirectUrl(), customerOrderReplicaRequest.getCallBackUrl()));

			} catch (Exception e) {
				e.printStackTrace();
				customerOrderReplicaMap.put("phonePeResponse", new HashedMap<>());
			}

			return customerOrderReplicaMap;

		} else {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
					"paymentDetails transcation Details are mandatory");
		}

	}

	private static String getMerchantTransactionId() {

		return "OD_" + MerchantTransactionIdGenerator.getRandomString();
	}


	@Override
	public List<CustomerOrderReplica> getCustomerOrderByMoblieNo(String contactNumber,Integer aid) {
		
		Schedule latestschedule = customerOrderReplicaDoa.getlatestschedule();
		
		if (latestschedule != null && latestschedule.getCreationTimestamp()!=null) {
			
	        if (latestschedule.getStatus().equals(UserStatus.ACTIVE)) {
	        	
	        	Customers customer = customerDetailsDao.getByContactNoAndApartment(contactNumber, aid);
	        	if (customer != null) { // Ensure the customer exists
	        		List<CustomerOrder> customerOrderList = customerOrderReplicaDoa.getListCustomerOrderByCustomerId(customer.getCtid());
	        		
	                double totalOrderAmount = 0.0;
	       
                if (customerOrderList != null && !customerOrderList.isEmpty() && customerOrderList.add(customerOrder). {
                    for (CustomerOrder customerOrder : customerOrderList) {
                        Double orderAmount = customerOrder.getAmount();
                        if (orderAmount != null) {
                            totalOrderAmount += orderAmount;
                            if(totalOrderAmount>200) {
                            	totalOrderAmount+customerOrder
                            }
                        }
                    }
                    System.out.println("Total Order Amount: " + totalOrderAmount);
                    List<CustomerOrderReplica> customerOrderReplicas = new ArrayList<>();
                    return customerOrderReplicas;
                } else {
                    return Collections.emptyList(); // or return null or an appropriate value
                }
            } else {
              
                return null; // or an appropriate value
            }
        } else {
            // Handle the case when the latest schedule is not active
            return null; // or an appropriate value
        }
    } else {
        // Handle the case when there is no latest schedule or its creation timestamp is null
        return null; // or an appropriate value
    }
	}
}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-09-21 15:07:05.524
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-09-21 15:07:05.526
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-21 15:07:05.637
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.xyram.daydrop.serviceimpl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.transaction.Transactional;

import org.apache.commons.collections4.map.HashedMap;
import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.server.ResponseStatusException;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.xyram.daydrop.admin.model.CurrentUser;
import com.xyram.daydrop.basemodel.Base64Wrapper;
import com.xyram.daydrop.basemodel.MerchantTransactionIdGenerator;
import com.xyram.daydrop.basemodel.PhonepeSerializer;
import com.xyram.daydrop.dao.ApartmentDao;
import com.xyram.daydrop.dao.CustomerDetailsDao;
import com.xyram.daydrop.dao.CustomerOrderDao;
import com.xyram.daydrop.dao.CustomerOrderReplicaDoa;
import com.xyram.daydrop.dao.SheduleDao;
import com.xyram.daydrop.enumtypes.UserStatus;
import com.xyram.daydrop.model.Apartments;
import com.xyram.daydrop.model.CustomerOrder;
import com.xyram.daydrop.model.CustomerOrderReplica;
import com.xyram.daydrop.model.Customers;
import com.xyram.daydrop.model.Schedule;
import com.xyram.daydrop.modelMapper.PaymentInstrument;
import com.xyram.daydrop.modelMapper.PhonePePayModel;
import com.xyram.daydrop.request.CustomerOrderReplicaRequest;
import com.xyram.daydrop.response.RazorPayRequest;
import com.xyram.daydrop.service.CustomerOrderPriceService;
import com.xyram.daydrop.service.CustomerOrderReplicaService;
import com.xyram.daydrop.util.HashEncoder;
import com.xyram.daydrop.util.RazorPay;
import com.xyram.daydrop.service.ConsumerService;

@Transactional
@Service
public class CustomerOrderReplicaServiceImpl implements CustomerOrderReplicaService {

	@Autowired
	CustomerOrderReplicaDoa customerOrderReplicaDoa;

	@Autowired
	ApartmentDao apartmentDao;

	@Autowired
	SheduleDao scheduleDao;

	@Autowired
	CustomerDetailsDao customerDetailsDao;

	@Autowired
	ConsumerService consumerService;

	@Autowired
	CurrentUser currentUser;

	@Autowired
	PhonepeServiceImpl phonepeServiceImpl;

	@Value("${merchant_id}")
	private String merchantId;

	@Value("${salt_key}")
	private String saltKey;

	@Value("${salt_index}")
	private String saltIndex;

	@Override
	public Map createCustomerOrderReplicaService(CustomerOrderReplicaRequest customerOrderReplicaRequest,
			String contactNumber, Integer aparmentId)

	{

		Map response = new HashedMap<>();

		response.put("message", "success");
		CustomerOrderReplica customerOrderReplica = null;

		if (customerOrderReplicaRequest.getCartId() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "cartId is mandatory ");
		}
		long razorPayCount = 0;
		if (customerOrderReplicaRequest.getOrderId() != null) {

			razorPayCount = customerOrderReplicaDoa.getRazorPayExistByCartId(customerOrderReplicaRequest.getOrderId());
		}

		if (customerOrderReplicaRequest.getCustomerDetails() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Order Details  is mandatory ");
		}

		customerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(customerOrderReplicaRequest.getCartId(),
				contactNumber);

		if (customerOrderReplica != null) {
			customerOrderReplica.setCartId(customerOrderReplica.getCartId());

			if (customerOrderReplica.isOrdered()) {
				throw new ResponseStatusException(HttpStatus.CONFLICT, "Your Order is Placed With cart Details");
			}

//			if (razorPayCount >= 1 && !(customerOrderReplica.getRazorPayOrderId() != null
//					&& customerOrderReplica.getRazorPayOrderId().equals(customerOrderReplicaRequest.getOrderId()))) {
//				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
//			}

			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);

			customerOrderReplica.setAttempts(customerOrderReplica.getAttempts() + 1);
			customerOrderReplica.setUpdatedTime(new Date());

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		} else {

			customerOrderReplica = new CustomerOrderReplica();
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);
			customerOrderReplica.setCartId(customerOrderReplicaRequest.getCartId());
			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());

			if (razorPayCount > 0) {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
			}

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			Schedule schedule = scheduleDao.getlatestScheduleCustomers();

			if (schedule != null) {

				try {
					customerOrderReplica.setSchedule(schedule.getsId() != null ? schedule.getsId().toString() : null);
				} catch (Exception e) {
					e.printStackTrace();
				}
			} else {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
						"Sorry We Are Not Accepting Any Order Right now");

			}

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		}

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicas(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String schedule = null;

		Map filter = request.containsKey("filters") ? (Map) request.get("filters") : null;
		if (filter != null) {
			statusType = filter.containsKey("statusType") ? ((String) filter.get("statusType")).toLowerCase() : null;
			searchQuery = filter.containsKey("searchQuery") ? ((String) filter.get("searchQuery")).toLowerCase() : null;
			schedule = filter.containsKey("schedule") ? (String.valueOf(filter.get("schedule"))) : null;

		}

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplica(searchQuery, statusType, schedule);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");

				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setStreetName(
						customers.get("streetName") != null ? (String) customers.get("streetName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicasBySchedule(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String scheduleId = null;

		Schedule schedule = scheduleDao.getlatestScheduleCustomers();

		if (schedule != null) {

			try {
				scheduleId = schedule.getsId() != null ? schedule.getsId().toString() : null;
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

		statusType = request.containsKey("statusType") ? ((String) request.get("statusType")).toLowerCase() : "Success";

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplicaBySchdeule(statusType, scheduleId);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");
				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				System.out.println("customers" + customers.get("customerName"));

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public CustomerOrderReplica getCustomerOrderReplicaByCartId(String cartId) {

		CustomerOrderReplica CustomerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(cartId,
				currentUser.getContactNumber());

		ObjectMapper objectMapper = new ObjectMapper();
		try {

			// convert JSON string to Map
			Map<String, Object> customerOrderReplicaMap = objectMapper
					.readValue(CustomerOrderReplica.getCustomerOrderDetails(), Map.class);

			Object customerOrder = customerOrderReplicaMap.get("customerOrder");
			Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

			Object quanityList = items.get("quantity");
			Map customers = customerDetailsDao.getByContactNumberAndApartment(CustomerOrderReplica.getContactNumber(),
					CustomerOrderReplica.getApartmentId());

			System.out.println("customers" + customers.get("customerName"));

			// Apartments apartments =
			// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
			CustomerOrderReplica.setApartmentName(
					customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

			CustomerOrderReplica.setCustomerDetails(customers);

			CustomerOrderReplica.setCustomerOrder(customerOrder);
			CustomerOrderReplica.setQuatityList(quanityList);

		} catch (Exception e) {
			e.printStackTrace();
		}

		return CustomerOrderReplica;

	}

	@Override
	public Map createCustomerOrderReplica(CustomerOrderReplicaRequest customerOrderReplicaRequest, String contactNumber,
			Integer aparmentId) {

		if (customerOrderReplicaRequest.getRazorPayRequest() != null) {

//			Map razorPay = consumerService.createRazorPayOrder(customerOrderReplicaRequest.getRazorPayRequest());
//			customerOrderReplicaRequest.setOrderId(razorPay.get("order") != null ? (String)((RazorPay) razorPay.get("order")).getId() : null);	
//	
//			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);
//
//			razorPay.put("cartId", customerOrderReplicaRequest.getCartId());

			Map customerOrderReplicaMap = new HashMap<>();

			Map orderId = new HashMap<>();
			String transactionId = getMerchantTransactionId();
			orderId.put("id", transactionId);

			customerOrderReplicaMap.put("order", orderId);

			customerOrderReplicaRequest.setOrderId(transactionId);
			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);

			customerOrderReplicaMap.put("cartId", customerOrderReplicaRequest.getCartId());

			try {
				customerOrderReplicaMap.put("phonePeResponse",
						phonepeServiceImpl.initiatePhonepePayment(transactionId,
								Integer.valueOf(customerOrderReplicaRequest.getRazorPayRequest().getAmount()),
								contactNumber, customerOrderReplicaRequest.getRedirectUrl(), customerOrderReplicaRequest.getCallBackUrl()));

			} catch (Exception e) {
				e.printStackTrace();
				customerOrderReplicaMap.put("phonePeResponse", new HashedMap<>());
			}

			return customerOrderReplicaMap;

		} else {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
					"paymentDetails transcation Details are mandatory");
		}

	}

	private static String getMerchantTransactionId() {

		return "OD_" + MerchantTransactionIdGenerator.getRandomString();
	}


	@Override
	public List<CustomerOrderReplica> getCustomerOrderByMoblieNo(String contactNumber,Integer aid) {
		
		Schedule latestschedule = customerOrderReplicaDoa.getlatestschedule();
		
		if (latestschedule != null && latestschedule.getCreationTimestamp()!=null) {
			
	        if (latestschedule.getStatus().equals(UserStatus.ACTIVE)) {
	        	
	        	Customers customer = customerDetailsDao.getByContactNoAndApartment(contactNumber, aid);
	        	if (customer != null) { // Ensure the customer exists
	        		List<CustomerOrder> customerOrderList = customerOrderReplicaDoa.getListCustomerOrderByCustomerId(customer.getCtid());
	        		
	                double totalOrderAmount = 0.0;
	       
                if (customerOrderList != null && !customerOrderList.isEmpty() && customerOrderList.add(customerOrder). {
                    for (CustomerOrder customerOrder : customerOrderList) {
                        Double orderAmount = customerOrder.getAmount();
                        if (orderAmount != null) {
                            totalOrderAmount += orderAmount;
                            if(totalOrderAmount>200) {
                            	totalOrderAmount+customerOrder
                            }
                        }
                    }
                    System.out.println("Total Order Amount: " + totalOrderAmount);
                    List<CustomerOrderReplica> customerOrderReplicas = new ArrayList<>();
                    return customerOrderReplicas;
                } else {
                    return Collections.emptyList(); // or return null or an appropriate value
                }
            } else {
              
                return null; // or an appropriate value
            }
        } else {
            // Handle the case when the latest schedule is not active
            return null; // or an appropriate value
        }
    } else {
        // Handle the case when there is no latest schedule or its creation timestamp is null
        return null; // or an appropriate value
    }
	}
}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1003)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:799)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:743)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:666)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:658)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.lambda$0(LSJavaHoverProvider.java:68)
	at java.base/java.util.concurrent.CompletableFuture$AsyncRun.run(CompletableFuture.java:1804)
	at java.base/java.util.concurrent.CompletableFuture$AsyncRun.exec(CompletableFuture.java:1796)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:373)
	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1182)
	at java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1655)
	at java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1622)
	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:165)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-09-21 15:07:05.639
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1003)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:799)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:743)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:666)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:658)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.lambda$0(LSJavaHoverProvider.java:68)
	at java.base/java.util.concurrent.CompletableFuture$AsyncRun.run(CompletableFuture.java:1804)
	at java.base/java.util.concurrent.CompletableFuture$AsyncRun.exec(CompletableFuture.java:1796)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:373)
	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1182)
	at java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1655)
	at java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1622)
	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:165)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-09-21 15:07:05.642
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1003)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:799)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:743)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:666)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:658)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.lambda$0(LSJavaHoverProvider.java:68)
	at java.base/java.util.concurrent.CompletableFuture$AsyncRun.run(CompletableFuture.java:1804)
	at java.base/java.util.concurrent.CompletableFuture$AsyncRun.exec(CompletableFuture.java:1796)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:373)
	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1182)
	at java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1655)
	at java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1622)
	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:165)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-21 15:07:05.719
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.xyram.daydrop.serviceimpl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.transaction.Transactional;

import org.apache.commons.collections4.map.HashedMap;
import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.server.ResponseStatusException;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.xyram.daydrop.admin.model.CurrentUser;
import com.xyram.daydrop.basemodel.Base64Wrapper;
import com.xyram.daydrop.basemodel.MerchantTransactionIdGenerator;
import com.xyram.daydrop.basemodel.PhonepeSerializer;
import com.xyram.daydrop.dao.ApartmentDao;
import com.xyram.daydrop.dao.CustomerDetailsDao;
import com.xyram.daydrop.dao.CustomerOrderDao;
import com.xyram.daydrop.dao.CustomerOrderReplicaDoa;
import com.xyram.daydrop.dao.SheduleDao;
import com.xyram.daydrop.enumtypes.UserStatus;
import com.xyram.daydrop.model.Apartments;
import com.xyram.daydrop.model.CustomerOrder;
import com.xyram.daydrop.model.CustomerOrderReplica;
import com.xyram.daydrop.model.Customers;
import com.xyram.daydrop.model.Schedule;
import com.xyram.daydrop.modelMapper.PaymentInstrument;
import com.xyram.daydrop.modelMapper.PhonePePayModel;
import com.xyram.daydrop.request.CustomerOrderReplicaRequest;
import com.xyram.daydrop.response.RazorPayRequest;
import com.xyram.daydrop.service.CustomerOrderPriceService;
import com.xyram.daydrop.service.CustomerOrderReplicaService;
import com.xyram.daydrop.util.HashEncoder;
import com.xyram.daydrop.util.RazorPay;
import com.xyram.daydrop.service.ConsumerService;

@Transactional
@Service
public class CustomerOrderReplicaServiceImpl implements CustomerOrderReplicaService {

	@Autowired
	CustomerOrderReplicaDoa customerOrderReplicaDoa;

	@Autowired
	ApartmentDao apartmentDao;

	@Autowired
	SheduleDao scheduleDao;

	@Autowired
	CustomerDetailsDao customerDetailsDao;

	@Autowired
	ConsumerService consumerService;

	@Autowired
	CurrentUser currentUser;

	@Autowired
	PhonepeServiceImpl phonepeServiceImpl;

	@Value("${merchant_id}")
	private String merchantId;

	@Value("${salt_key}")
	private String saltKey;

	@Value("${salt_index}")
	private String saltIndex;

	@Override
	public Map createCustomerOrderReplicaService(CustomerOrderReplicaRequest customerOrderReplicaRequest,
			String contactNumber, Integer aparmentId)

	{

		Map response = new HashedMap<>();

		response.put("message", "success");
		CustomerOrderReplica customerOrderReplica = null;

		if (customerOrderReplicaRequest.getCartId() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "cartId is mandatory ");
		}
		long razorPayCount = 0;
		if (customerOrderReplicaRequest.getOrderId() != null) {

			razorPayCount = customerOrderReplicaDoa.getRazorPayExistByCartId(customerOrderReplicaRequest.getOrderId());
		}

		if (customerOrderReplicaRequest.getCustomerDetails() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Order Details  is mandatory ");
		}

		customerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(customerOrderReplicaRequest.getCartId(),
				contactNumber);

		if (customerOrderReplica != null) {
			customerOrderReplica.setCartId(customerOrderReplica.getCartId());

			if (customerOrderReplica.isOrdered()) {
				throw new ResponseStatusException(HttpStatus.CONFLICT, "Your Order is Placed With cart Details");
			}

//			if (razorPayCount >= 1 && !(customerOrderReplica.getRazorPayOrderId() != null
//					&& customerOrderReplica.getRazorPayOrderId().equals(customerOrderReplicaRequest.getOrderId()))) {
//				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
//			}

			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);

			customerOrderReplica.setAttempts(customerOrderReplica.getAttempts() + 1);
			customerOrderReplica.setUpdatedTime(new Date());

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		} else {

			customerOrderReplica = new CustomerOrderReplica();
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);
			customerOrderReplica.setCartId(customerOrderReplicaRequest.getCartId());
			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());

			if (razorPayCount > 0) {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
			}

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			Schedule schedule = scheduleDao.getlatestScheduleCustomers();

			if (schedule != null) {

				try {
					customerOrderReplica.setSchedule(schedule.getsId() != null ? schedule.getsId().toString() : null);
				} catch (Exception e) {
					e.printStackTrace();
				}
			} else {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
						"Sorry We Are Not Accepting Any Order Right now");

			}

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		}

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicas(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String schedule = null;

		Map filter = request.containsKey("filters") ? (Map) request.get("filters") : null;
		if (filter != null) {
			statusType = filter.containsKey("statusType") ? ((String) filter.get("statusType")).toLowerCase() : null;
			searchQuery = filter.containsKey("searchQuery") ? ((String) filter.get("searchQuery")).toLowerCase() : null;
			schedule = filter.containsKey("schedule") ? (String.valueOf(filter.get("schedule"))) : null;

		}

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplica(searchQuery, statusType, schedule);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");

				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setStreetName(
						customers.get("streetName") != null ? (String) customers.get("streetName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicasBySchedule(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String scheduleId = null;

		Schedule schedule = scheduleDao.getlatestScheduleCustomers();

		if (schedule != null) {

			try {
				scheduleId = schedule.getsId() != null ? schedule.getsId().toString() : null;
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

		statusType = request.containsKey("statusType") ? ((String) request.get("statusType")).toLowerCase() : "Success";

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplicaBySchdeule(statusType, scheduleId);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");
				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				System.out.println("customers" + customers.get("customerName"));

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public CustomerOrderReplica getCustomerOrderReplicaByCartId(String cartId) {

		CustomerOrderReplica CustomerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(cartId,
				currentUser.getContactNumber());

		ObjectMapper objectMapper = new ObjectMapper();
		try {

			// convert JSON string to Map
			Map<String, Object> customerOrderReplicaMap = objectMapper
					.readValue(CustomerOrderReplica.getCustomerOrderDetails(), Map.class);

			Object customerOrder = customerOrderReplicaMap.get("customerOrder");
			Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

			Object quanityList = items.get("quantity");
			Map customers = customerDetailsDao.getByContactNumberAndApartment(CustomerOrderReplica.getContactNumber(),
					CustomerOrderReplica.getApartmentId());

			System.out.println("customers" + customers.get("customerName"));

			// Apartments apartments =
			// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
			CustomerOrderReplica.setApartmentName(
					customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

			CustomerOrderReplica.setCustomerDetails(customers);

			CustomerOrderReplica.setCustomerOrder(customerOrder);
			CustomerOrderReplica.setQuatityList(quanityList);

		} catch (Exception e) {
			e.printStackTrace();
		}

		return CustomerOrderReplica;

	}

	@Override
	public Map createCustomerOrderReplica(CustomerOrderReplicaRequest customerOrderReplicaRequest, String contactNumber,
			Integer aparmentId) {

		if (customerOrderReplicaRequest.getRazorPayRequest() != null) {

//			Map razorPay = consumerService.createRazorPayOrder(customerOrderReplicaRequest.getRazorPayRequest());
//			customerOrderReplicaRequest.setOrderId(razorPay.get("order") != null ? (String)((RazorPay) razorPay.get("order")).getId() : null);	
//	
//			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);
//
//			razorPay.put("cartId", customerOrderReplicaRequest.getCartId());

			Map customerOrderReplicaMap = new HashMap<>();

			Map orderId = new HashMap<>();
			String transactionId = getMerchantTransactionId();
			orderId.put("id", transactionId);

			customerOrderReplicaMap.put("order", orderId);

			customerOrderReplicaRequest.setOrderId(transactionId);
			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);

			customerOrderReplicaMap.put("cartId", customerOrderReplicaRequest.getCartId());

			try {
				customerOrderReplicaMap.put("phonePeResponse",
						phonepeServiceImpl.initiatePhonepePayment(transactionId,
								Integer.valueOf(customerOrderReplicaRequest.getRazorPayRequest().getAmount()),
								contactNumber, customerOrderReplicaRequest.getRedirectUrl(), customerOrderReplicaRequest.getCallBackUrl()));

			} catch (Exception e) {
				e.printStackTrace();
				customerOrderReplicaMap.put("phonePeResponse", new HashedMap<>());
			}

			return customerOrderReplicaMap;

		} else {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
					"paymentDetails transcation Details are mandatory");
		}

	}

	private static String getMerchantTransactionId() {

		return "OD_" + MerchantTransactionIdGenerator.getRandomString();
	}


	@Override
	public List<CustomerOrderReplica> getCustomerOrderByMoblieNo(String contactNumber,Integer aid) {
		
		Schedule latestschedule = customerOrderReplicaDoa.getlatestschedule();
		
		if (latestschedule != null && latestschedule.getCreationTimestamp()!=null) {
			
	        if (latestschedule.getStatus().equals(UserStatus.ACTIVE)) {
	        	
	        	Customers customer = customerDetailsDao.getByContactNoAndApartment(contactNumber, aid);
	        	if (customer != null) { // Ensure the customer exists
	        		List<CustomerOrder> customerOrderList = customerOrderReplicaDoa.getListCustomerOrderByCustomerId(customer.getCtid());
	        		
	                double totalOrderAmount = 0.0;
	       
                if (customerOrderList != null && !customerOrderList.isEmpty() && customerOrderList.add(customerOrder). {
                    for (CustomerOrder customerOrder : customerOrderList) {
                        Double orderAmount = customerOrder.getAmount();
                        if (orderAmount != null) {
                            totalOrderAmount += orderAmount;
                            if(totalOrderAmount>200) {
                            	totalOrderAmount+customerOrder
                            }
                        }
                    }
                    System.out.println("Total Order Amount: " + totalOrderAmount);
                    List<CustomerOrderReplica> customerOrderReplicas = new ArrayList<>();
                    return customerOrderReplicas;
                } else {
                    return Collections.emptyList(); // or return null or an appropriate value
                }
            } else {
              
                return null; // or an appropriate value
            }
        } else {
            // Handle the case when the latest schedule is not active
            return null; // or an appropriate value
        }
    } else {
        // Handle the case when there is no latest schedule or its creation timestamp is null
        return null; // or an appropriate value
    }
	}
}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-09-21 15:07:05.721
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-09-21 15:07:05.722
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-21 15:07:05.781
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.xyram.daydrop.serviceimpl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.transaction.Transactional;

import org.apache.commons.collections4.map.HashedMap;
import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.server.ResponseStatusException;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.xyram.daydrop.admin.model.CurrentUser;
import com.xyram.daydrop.basemodel.Base64Wrapper;
import com.xyram.daydrop.basemodel.MerchantTransactionIdGenerator;
import com.xyram.daydrop.basemodel.PhonepeSerializer;
import com.xyram.daydrop.dao.ApartmentDao;
import com.xyram.daydrop.dao.CustomerDetailsDao;
import com.xyram.daydrop.dao.CustomerOrderDao;
import com.xyram.daydrop.dao.CustomerOrderReplicaDoa;
import com.xyram.daydrop.dao.SheduleDao;
import com.xyram.daydrop.enumtypes.UserStatus;
import com.xyram.daydrop.model.Apartments;
import com.xyram.daydrop.model.CustomerOrder;
import com.xyram.daydrop.model.CustomerOrderReplica;
import com.xyram.daydrop.model.Customers;
import com.xyram.daydrop.model.Schedule;
import com.xyram.daydrop.modelMapper.PaymentInstrument;
import com.xyram.daydrop.modelMapper.PhonePePayModel;
import com.xyram.daydrop.request.CustomerOrderReplicaRequest;
import com.xyram.daydrop.response.RazorPayRequest;
import com.xyram.daydrop.service.CustomerOrderPriceService;
import com.xyram.daydrop.service.CustomerOrderReplicaService;
import com.xyram.daydrop.util.HashEncoder;
import com.xyram.daydrop.util.RazorPay;
import com.xyram.daydrop.service.ConsumerService;

@Transactional
@Service
public class CustomerOrderReplicaServiceImpl implements CustomerOrderReplicaService {

	@Autowired
	CustomerOrderReplicaDoa customerOrderReplicaDoa;

	@Autowired
	ApartmentDao apartmentDao;

	@Autowired
	SheduleDao scheduleDao;

	@Autowired
	CustomerDetailsDao customerDetailsDao;

	@Autowired
	ConsumerService consumerService;

	@Autowired
	CurrentUser currentUser;

	@Autowired
	PhonepeServiceImpl phonepeServiceImpl;

	@Value("${merchant_id}")
	private String merchantId;

	@Value("${salt_key}")
	private String saltKey;

	@Value("${salt_index}")
	private String saltIndex;

	@Override
	public Map createCustomerOrderReplicaService(CustomerOrderReplicaRequest customerOrderReplicaRequest,
			String contactNumber, Integer aparmentId)

	{

		Map response = new HashedMap<>();

		response.put("message", "success");
		CustomerOrderReplica customerOrderReplica = null;

		if (customerOrderReplicaRequest.getCartId() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "cartId is mandatory ");
		}
		long razorPayCount = 0;
		if (customerOrderReplicaRequest.getOrderId() != null) {

			razorPayCount = customerOrderReplicaDoa.getRazorPayExistByCartId(customerOrderReplicaRequest.getOrderId());
		}

		if (customerOrderReplicaRequest.getCustomerDetails() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Order Details  is mandatory ");
		}

		customerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(customerOrderReplicaRequest.getCartId(),
				contactNumber);

		if (customerOrderReplica != null) {
			customerOrderReplica.setCartId(customerOrderReplica.getCartId());

			if (customerOrderReplica.isOrdered()) {
				throw new ResponseStatusException(HttpStatus.CONFLICT, "Your Order is Placed With cart Details");
			}

//			if (razorPayCount >= 1 && !(customerOrderReplica.getRazorPayOrderId() != null
//					&& customerOrderReplica.getRazorPayOrderId().equals(customerOrderReplicaRequest.getOrderId()))) {
//				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
//			}

			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);

			customerOrderReplica.setAttempts(customerOrderReplica.getAttempts() + 1);
			customerOrderReplica.setUpdatedTime(new Date());

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		} else {

			customerOrderReplica = new CustomerOrderReplica();
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);
			customerOrderReplica.setCartId(customerOrderReplicaRequest.getCartId());
			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());

			if (razorPayCount > 0) {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
			}

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			Schedule schedule = scheduleDao.getlatestScheduleCustomers();

			if (schedule != null) {

				try {
					customerOrderReplica.setSchedule(schedule.getsId() != null ? schedule.getsId().toString() : null);
				} catch (Exception e) {
					e.printStackTrace();
				}
			} else {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
						"Sorry We Are Not Accepting Any Order Right now");

			}

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		}

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicas(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String schedule = null;

		Map filter = request.containsKey("filters") ? (Map) request.get("filters") : null;
		if (filter != null) {
			statusType = filter.containsKey("statusType") ? ((String) filter.get("statusType")).toLowerCase() : null;
			searchQuery = filter.containsKey("searchQuery") ? ((String) filter.get("searchQuery")).toLowerCase() : null;
			schedule = filter.containsKey("schedule") ? (String.valueOf(filter.get("schedule"))) : null;

		}

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplica(searchQuery, statusType, schedule);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");

				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setStreetName(
						customers.get("streetName") != null ? (String) customers.get("streetName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicasBySchedule(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String scheduleId = null;

		Schedule schedule = scheduleDao.getlatestScheduleCustomers();

		if (schedule != null) {

			try {
				scheduleId = schedule.getsId() != null ? schedule.getsId().toString() : null;
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

		statusType = request.containsKey("statusType") ? ((String) request.get("statusType")).toLowerCase() : "Success";

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplicaBySchdeule(statusType, scheduleId);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");
				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				System.out.println("customers" + customers.get("customerName"));

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public CustomerOrderReplica getCustomerOrderReplicaByCartId(String cartId) {

		CustomerOrderReplica CustomerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(cartId,
				currentUser.getContactNumber());

		ObjectMapper objectMapper = new ObjectMapper();
		try {

			// convert JSON string to Map
			Map<String, Object> customerOrderReplicaMap = objectMapper
					.readValue(CustomerOrderReplica.getCustomerOrderDetails(), Map.class);

			Object customerOrder = customerOrderReplicaMap.get("customerOrder");
			Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

			Object quanityList = items.get("quantity");
			Map customers = customerDetailsDao.getByContactNumberAndApartment(CustomerOrderReplica.getContactNumber(),
					CustomerOrderReplica.getApartmentId());

			System.out.println("customers" + customers.get("customerName"));

			// Apartments apartments =
			// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
			CustomerOrderReplica.setApartmentName(
					customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

			CustomerOrderReplica.setCustomerDetails(customers);

			CustomerOrderReplica.setCustomerOrder(customerOrder);
			CustomerOrderReplica.setQuatityList(quanityList);

		} catch (Exception e) {
			e.printStackTrace();
		}

		return CustomerOrderReplica;

	}

	@Override
	public Map createCustomerOrderReplica(CustomerOrderReplicaRequest customerOrderReplicaRequest, String contactNumber,
			Integer aparmentId) {

		if (customerOrderReplicaRequest.getRazorPayRequest() != null) {

//			Map razorPay = consumerService.createRazorPayOrder(customerOrderReplicaRequest.getRazorPayRequest());
//			customerOrderReplicaRequest.setOrderId(razorPay.get("order") != null ? (String)((RazorPay) razorPay.get("order")).getId() : null);	
//	
//			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);
//
//			razorPay.put("cartId", customerOrderReplicaRequest.getCartId());

			Map customerOrderReplicaMap = new HashMap<>();

			Map orderId = new HashMap<>();
			String transactionId = getMerchantTransactionId();
			orderId.put("id", transactionId);

			customerOrderReplicaMap.put("order", orderId);

			customerOrderReplicaRequest.setOrderId(transactionId);
			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);

			customerOrderReplicaMap.put("cartId", customerOrderReplicaRequest.getCartId());

			try {
				customerOrderReplicaMap.put("phonePeResponse",
						phonepeServiceImpl.initiatePhonepePayment(transactionId,
								Integer.valueOf(customerOrderReplicaRequest.getRazorPayRequest().getAmount()),
								contactNumber, customerOrderReplicaRequest.getRedirectUrl(), customerOrderReplicaRequest.getCallBackUrl()));

			} catch (Exception e) {
				e.printStackTrace();
				customerOrderReplicaMap.put("phonePeResponse", new HashedMap<>());
			}

			return customerOrderReplicaMap;

		} else {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
					"paymentDetails transcation Details are mandatory");
		}

	}

	private static String getMerchantTransactionId() {

		return "OD_" + MerchantTransactionIdGenerator.getRandomString();
	}


	@Override
	public List<CustomerOrderReplica> getCustomerOrderByMoblieNo(String contactNumber,Integer aid) {
		
		Schedule latestschedule = customerOrderReplicaDoa.getlatestschedule();
		
		if (latestschedule != null && latestschedule.getCreationTimestamp()!=null) {
			
	        if (latestschedule.getStatus().equals(UserStatus.ACTIVE)) {
	        	
	        	Customers customer = customerDetailsDao.getByContactNoAndApartment(contactNumber, aid);
	        	if (customer != null) { // Ensure the customer exists
	        		List<CustomerOrder> customerOrderList = customerOrderReplicaDoa.getListCustomerOrderByCustomerId(customer.getCtid());
	        		
	                double totalOrderAmount = 0.0;
	       
                if (customerOrderList != null && !customerOrderList.isEmpty() && customerOrderList.add(customerOrder). {
                    for (CustomerOrder customerOrder : customerOrderList) {
                        Double orderAmount = customerOrder.getAmount();
                        if (orderAmount != null) {
                            totalOrderAmount += orderAmount;
                            if(totalOrderAmount>200) {
                            	totalOrderAmount+customerOrder
                            }
                        }
                    }
                    System.out.println("Total Order Amount: " + totalOrderAmount);
                    List<CustomerOrderReplica> customerOrderReplicas = new ArrayList<>();
                    return customerOrderReplicas;
                } else {
                    return Collections.emptyList(); // or return null or an appropriate value
                }
            } else {
              
                return null; // or an appropriate value
            }
        } else {
            // Handle the case when the latest schedule is not active
            return null; // or an appropriate value
        }
    } else {
        // Handle the case when there is no latest schedule or its creation timestamp is null
        return null; // or an appropriate value
    }
	}
}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1003)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:799)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:743)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:666)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:658)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-09-21 15:07:05.783
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1003)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:799)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:743)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:666)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:658)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-09-21 15:07:05.784
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1003)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:799)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:743)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:666)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:658)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-21 15:07:09.694
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.xyram.daydrop.serviceimpl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.transaction.Transactional;

import org.apache.commons.collections4.map.HashedMap;
import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.server.ResponseStatusException;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.xyram.daydrop.admin.model.CurrentUser;
import com.xyram.daydrop.basemodel.Base64Wrapper;
import com.xyram.daydrop.basemodel.MerchantTransactionIdGenerator;
import com.xyram.daydrop.basemodel.PhonepeSerializer;
import com.xyram.daydrop.dao.ApartmentDao;
import com.xyram.daydrop.dao.CustomerDetailsDao;
import com.xyram.daydrop.dao.CustomerOrderDao;
import com.xyram.daydrop.dao.CustomerOrderReplicaDoa;
import com.xyram.daydrop.dao.SheduleDao;
import com.xyram.daydrop.enumtypes.UserStatus;
import com.xyram.daydrop.model.Apartments;
import com.xyram.daydrop.model.CustomerOrder;
import com.xyram.daydrop.model.CustomerOrderReplica;
import com.xyram.daydrop.model.Customers;
import com.xyram.daydrop.model.Schedule;
import com.xyram.daydrop.modelMapper.PaymentInstrument;
import com.xyram.daydrop.modelMapper.PhonePePayModel;
import com.xyram.daydrop.request.CustomerOrderReplicaRequest;
import com.xyram.daydrop.response.RazorPayRequest;
import com.xyram.daydrop.service.CustomerOrderPriceService;
import com.xyram.daydrop.service.CustomerOrderReplicaService;
import com.xyram.daydrop.util.HashEncoder;
import com.xyram.daydrop.util.RazorPay;
import com.xyram.daydrop.service.ConsumerService;

@Transactional
@Service
public class CustomerOrderReplicaServiceImpl implements CustomerOrderReplicaService {

	@Autowired
	CustomerOrderReplicaDoa customerOrderReplicaDoa;

	@Autowired
	ApartmentDao apartmentDao;

	@Autowired
	SheduleDao scheduleDao;

	@Autowired
	CustomerDetailsDao customerDetailsDao;

	@Autowired
	ConsumerService consumerService;

	@Autowired
	CurrentUser currentUser;

	@Autowired
	PhonepeServiceImpl phonepeServiceImpl;

	@Value("${merchant_id}")
	private String merchantId;

	@Value("${salt_key}")
	private String saltKey;

	@Value("${salt_index}")
	private String saltIndex;

	@Override
	public Map createCustomerOrderReplicaService(CustomerOrderReplicaRequest customerOrderReplicaRequest,
			String contactNumber, Integer aparmentId)

	{

		Map response = new HashedMap<>();

		response.put("message", "success");
		CustomerOrderReplica customerOrderReplica = null;

		if (customerOrderReplicaRequest.getCartId() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "cartId is mandatory ");
		}
		long razorPayCount = 0;
		if (customerOrderReplicaRequest.getOrderId() != null) {

			razorPayCount = customerOrderReplicaDoa.getRazorPayExistByCartId(customerOrderReplicaRequest.getOrderId());
		}

		if (customerOrderReplicaRequest.getCustomerDetails() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Order Details  is mandatory ");
		}

		customerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(customerOrderReplicaRequest.getCartId(),
				contactNumber);

		if (customerOrderReplica != null) {
			customerOrderReplica.setCartId(customerOrderReplica.getCartId());

			if (customerOrderReplica.isOrdered()) {
				throw new ResponseStatusException(HttpStatus.CONFLICT, "Your Order is Placed With cart Details");
			}

//			if (razorPayCount >= 1 && !(customerOrderReplica.getRazorPayOrderId() != null
//					&& customerOrderReplica.getRazorPayOrderId().equals(customerOrderReplicaRequest.getOrderId()))) {
//				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
//			}

			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);

			customerOrderReplica.setAttempts(customerOrderReplica.getAttempts() + 1);
			customerOrderReplica.setUpdatedTime(new Date());

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		} else {

			customerOrderReplica = new CustomerOrderReplica();
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);
			customerOrderReplica.setCartId(customerOrderReplicaRequest.getCartId());
			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());

			if (razorPayCount > 0) {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
			}

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			Schedule schedule = scheduleDao.getlatestScheduleCustomers();

			if (schedule != null) {

				try {
					customerOrderReplica.setSchedule(schedule.getsId() != null ? schedule.getsId().toString() : null);
				} catch (Exception e) {
					e.printStackTrace();
				}
			} else {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
						"Sorry We Are Not Accepting Any Order Right now");

			}

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		}

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicas(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String schedule = null;

		Map filter = request.containsKey("filters") ? (Map) request.get("filters") : null;
		if (filter != null) {
			statusType = filter.containsKey("statusType") ? ((String) filter.get("statusType")).toLowerCase() : null;
			searchQuery = filter.containsKey("searchQuery") ? ((String) filter.get("searchQuery")).toLowerCase() : null;
			schedule = filter.containsKey("schedule") ? (String.valueOf(filter.get("schedule"))) : null;

		}

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplica(searchQuery, statusType, schedule);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");

				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setStreetName(
						customers.get("streetName") != null ? (String) customers.get("streetName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicasBySchedule(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String scheduleId = null;

		Schedule schedule = scheduleDao.getlatestScheduleCustomers();

		if (schedule != null) {

			try {
				scheduleId = schedule.getsId() != null ? schedule.getsId().toString() : null;
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

		statusType = request.containsKey("statusType") ? ((String) request.get("statusType")).toLowerCase() : "Success";

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplicaBySchdeule(statusType, scheduleId);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");
				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				System.out.println("customers" + customers.get("customerName"));

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public CustomerOrderReplica getCustomerOrderReplicaByCartId(String cartId) {

		CustomerOrderReplica CustomerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(cartId,
				currentUser.getContactNumber());

		ObjectMapper objectMapper = new ObjectMapper();
		try {

			// convert JSON string to Map
			Map<String, Object> customerOrderReplicaMap = objectMapper
					.readValue(CustomerOrderReplica.getCustomerOrderDetails(), Map.class);

			Object customerOrder = customerOrderReplicaMap.get("customerOrder");
			Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

			Object quanityList = items.get("quantity");
			Map customers = customerDetailsDao.getByContactNumberAndApartment(CustomerOrderReplica.getContactNumber(),
					CustomerOrderReplica.getApartmentId());

			System.out.println("customers" + customers.get("customerName"));

			// Apartments apartments =
			// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
			CustomerOrderReplica.setApartmentName(
					customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

			CustomerOrderReplica.setCustomerDetails(customers);

			CustomerOrderReplica.setCustomerOrder(customerOrder);
			CustomerOrderReplica.setQuatityList(quanityList);

		} catch (Exception e) {
			e.printStackTrace();
		}

		return CustomerOrderReplica;

	}

	@Override
	public Map createCustomerOrderReplica(CustomerOrderReplicaRequest customerOrderReplicaRequest, String contactNumber,
			Integer aparmentId) {

		if (customerOrderReplicaRequest.getRazorPayRequest() != null) {

//			Map razorPay = consumerService.createRazorPayOrder(customerOrderReplicaRequest.getRazorPayRequest());
//			customerOrderReplicaRequest.setOrderId(razorPay.get("order") != null ? (String)((RazorPay) razorPay.get("order")).getId() : null);	
//	
//			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);
//
//			razorPay.put("cartId", customerOrderReplicaRequest.getCartId());

			Map customerOrderReplicaMap = new HashMap<>();

			Map orderId = new HashMap<>();
			String transactionId = getMerchantTransactionId();
			orderId.put("id", transactionId);

			customerOrderReplicaMap.put("order", orderId);

			customerOrderReplicaRequest.setOrderId(transactionId);
			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);

			customerOrderReplicaMap.put("cartId", customerOrderReplicaRequest.getCartId());

			try {
				customerOrderReplicaMap.put("phonePeResponse",
						phonepeServiceImpl.initiatePhonepePayment(transactionId,
								Integer.valueOf(customerOrderReplicaRequest.getRazorPayRequest().getAmount()),
								contactNumber, customerOrderReplicaRequest.getRedirectUrl(), customerOrderReplicaRequest.getCallBackUrl()));

			} catch (Exception e) {
				e.printStackTrace();
				customerOrderReplicaMap.put("phonePeResponse", new HashedMap<>());
			}

			return customerOrderReplicaMap;

		} else {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
					"paymentDetails transcation Details are mandatory");
		}

	}

	private static String getMerchantTransactionId() {

		return "OD_" + MerchantTransactionIdGenerator.getRandomString();
	}


	@Override
	public List<CustomerOrderReplica> getCustomerOrderByMoblieNo(String contactNumber,Integer aid) {
		
		Schedule latestschedule = customerOrderReplicaDoa.getlatestschedule();
		
		if (latestschedule != null && latestschedule.getCreationTimestamp()!=null) {
			
	        if (latestschedule.getStatus().equals(UserStatus.ACTIVE)) {
	        	
	        	Customers customer = customerDetailsDao.getByContactNoAndApartment(contactNumber, aid);
	        	if (customer != null) { // Ensure the customer exists
	        		List<CustomerOrder> customerOrderList = customerOrderReplicaDoa.getListCustomerOrderByCustomerId(customer.getCtid());
	        		
	                double totalOrderAmount = 0.0;
	       
                if (customerOrderList != null && !customerOrderList.isEmpty() && customerOrderList.add(customerOrder). {
                    for (CustomerOrder customerOrder : customerOrderList) {
                        Double orderAmount = customerOrder.getAmount();
                        if (orderAmount != null) {
                            totalOrderAmount += orderAmount;
                            if(totalOrderAmount>200) {
                            	totalOrderAmount+customerOrder
                            }
                        }
                    }
                    System.out.println("Total Order Amount: " + totalOrderAmount);
                    List<CustomerOrderReplica> customerOrderReplicas = new ArrayList<>();
                    return customerOrderReplicas;
                } else {
                    return Collections.emptyList(); // or return null or an appropriate value
                }
            } else {
              
                return null; // or an appropriate value
            }
        } else {
            // Handle the case when the latest schedule is not active
            return null; // or an appropriate value
        }
    } else {
        // Handle the case when there is no latest schedule or its creation timestamp is null
        return null; // or an appropriate value
    }
	}
}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-09-21 15:07:09.697
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-09-21 15:07:09.700
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-21 15:07:09.834
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.xyram.daydrop.serviceimpl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.transaction.Transactional;

import org.apache.commons.collections4.map.HashedMap;
import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.server.ResponseStatusException;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.xyram.daydrop.admin.model.CurrentUser;
import com.xyram.daydrop.basemodel.Base64Wrapper;
import com.xyram.daydrop.basemodel.MerchantTransactionIdGenerator;
import com.xyram.daydrop.basemodel.PhonepeSerializer;
import com.xyram.daydrop.dao.ApartmentDao;
import com.xyram.daydrop.dao.CustomerDetailsDao;
import com.xyram.daydrop.dao.CustomerOrderDao;
import com.xyram.daydrop.dao.CustomerOrderReplicaDoa;
import com.xyram.daydrop.dao.SheduleDao;
import com.xyram.daydrop.enumtypes.UserStatus;
import com.xyram.daydrop.model.Apartments;
import com.xyram.daydrop.model.CustomerOrder;
import com.xyram.daydrop.model.CustomerOrderReplica;
import com.xyram.daydrop.model.Customers;
import com.xyram.daydrop.model.Schedule;
import com.xyram.daydrop.modelMapper.PaymentInstrument;
import com.xyram.daydrop.modelMapper.PhonePePayModel;
import com.xyram.daydrop.request.CustomerOrderReplicaRequest;
import com.xyram.daydrop.response.RazorPayRequest;
import com.xyram.daydrop.service.CustomerOrderPriceService;
import com.xyram.daydrop.service.CustomerOrderReplicaService;
import com.xyram.daydrop.util.HashEncoder;
import com.xyram.daydrop.util.RazorPay;
import com.xyram.daydrop.service.ConsumerService;

@Transactional
@Service
public class CustomerOrderReplicaServiceImpl implements CustomerOrderReplicaService {

	@Autowired
	CustomerOrderReplicaDoa customerOrderReplicaDoa;

	@Autowired
	ApartmentDao apartmentDao;

	@Autowired
	SheduleDao scheduleDao;

	@Autowired
	CustomerDetailsDao customerDetailsDao;

	@Autowired
	ConsumerService consumerService;

	@Autowired
	CurrentUser currentUser;

	@Autowired
	PhonepeServiceImpl phonepeServiceImpl;

	@Value("${merchant_id}")
	private String merchantId;

	@Value("${salt_key}")
	private String saltKey;

	@Value("${salt_index}")
	private String saltIndex;

	@Override
	public Map createCustomerOrderReplicaService(CustomerOrderReplicaRequest customerOrderReplicaRequest,
			String contactNumber, Integer aparmentId)

	{

		Map response = new HashedMap<>();

		response.put("message", "success");
		CustomerOrderReplica customerOrderReplica = null;

		if (customerOrderReplicaRequest.getCartId() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "cartId is mandatory ");
		}
		long razorPayCount = 0;
		if (customerOrderReplicaRequest.getOrderId() != null) {

			razorPayCount = customerOrderReplicaDoa.getRazorPayExistByCartId(customerOrderReplicaRequest.getOrderId());
		}

		if (customerOrderReplicaRequest.getCustomerDetails() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Order Details  is mandatory ");
		}

		customerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(customerOrderReplicaRequest.getCartId(),
				contactNumber);

		if (customerOrderReplica != null) {
			customerOrderReplica.setCartId(customerOrderReplica.getCartId());

			if (customerOrderReplica.isOrdered()) {
				throw new ResponseStatusException(HttpStatus.CONFLICT, "Your Order is Placed With cart Details");
			}

//			if (razorPayCount >= 1 && !(customerOrderReplica.getRazorPayOrderId() != null
//					&& customerOrderReplica.getRazorPayOrderId().equals(customerOrderReplicaRequest.getOrderId()))) {
//				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
//			}

			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);

			customerOrderReplica.setAttempts(customerOrderReplica.getAttempts() + 1);
			customerOrderReplica.setUpdatedTime(new Date());

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		} else {

			customerOrderReplica = new CustomerOrderReplica();
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);
			customerOrderReplica.setCartId(customerOrderReplicaRequest.getCartId());
			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());

			if (razorPayCount > 0) {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
			}

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			Schedule schedule = scheduleDao.getlatestScheduleCustomers();

			if (schedule != null) {

				try {
					customerOrderReplica.setSchedule(schedule.getsId() != null ? schedule.getsId().toString() : null);
				} catch (Exception e) {
					e.printStackTrace();
				}
			} else {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
						"Sorry We Are Not Accepting Any Order Right now");

			}

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		}

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicas(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String schedule = null;

		Map filter = request.containsKey("filters") ? (Map) request.get("filters") : null;
		if (filter != null) {
			statusType = filter.containsKey("statusType") ? ((String) filter.get("statusType")).toLowerCase() : null;
			searchQuery = filter.containsKey("searchQuery") ? ((String) filter.get("searchQuery")).toLowerCase() : null;
			schedule = filter.containsKey("schedule") ? (String.valueOf(filter.get("schedule"))) : null;

		}

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplica(searchQuery, statusType, schedule);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");

				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setStreetName(
						customers.get("streetName") != null ? (String) customers.get("streetName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicasBySchedule(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String scheduleId = null;

		Schedule schedule = scheduleDao.getlatestScheduleCustomers();

		if (schedule != null) {

			try {
				scheduleId = schedule.getsId() != null ? schedule.getsId().toString() : null;
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

		statusType = request.containsKey("statusType") ? ((String) request.get("statusType")).toLowerCase() : "Success";

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplicaBySchdeule(statusType, scheduleId);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");
				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				System.out.println("customers" + customers.get("customerName"));

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public CustomerOrderReplica getCustomerOrderReplicaByCartId(String cartId) {

		CustomerOrderReplica CustomerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(cartId,
				currentUser.getContactNumber());

		ObjectMapper objectMapper = new ObjectMapper();
		try {

			// convert JSON string to Map
			Map<String, Object> customerOrderReplicaMap = objectMapper
					.readValue(CustomerOrderReplica.getCustomerOrderDetails(), Map.class);

			Object customerOrder = customerOrderReplicaMap.get("customerOrder");
			Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

			Object quanityList = items.get("quantity");
			Map customers = customerDetailsDao.getByContactNumberAndApartment(CustomerOrderReplica.getContactNumber(),
					CustomerOrderReplica.getApartmentId());

			System.out.println("customers" + customers.get("customerName"));

			// Apartments apartments =
			// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
			CustomerOrderReplica.setApartmentName(
					customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

			CustomerOrderReplica.setCustomerDetails(customers);

			CustomerOrderReplica.setCustomerOrder(customerOrder);
			CustomerOrderReplica.setQuatityList(quanityList);

		} catch (Exception e) {
			e.printStackTrace();
		}

		return CustomerOrderReplica;

	}

	@Override
	public Map createCustomerOrderReplica(CustomerOrderReplicaRequest customerOrderReplicaRequest, String contactNumber,
			Integer aparmentId) {

		if (customerOrderReplicaRequest.getRazorPayRequest() != null) {

//			Map razorPay = consumerService.createRazorPayOrder(customerOrderReplicaRequest.getRazorPayRequest());
//			customerOrderReplicaRequest.setOrderId(razorPay.get("order") != null ? (String)((RazorPay) razorPay.get("order")).getId() : null);	
//	
//			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);
//
//			razorPay.put("cartId", customerOrderReplicaRequest.getCartId());

			Map customerOrderReplicaMap = new HashMap<>();

			Map orderId = new HashMap<>();
			String transactionId = getMerchantTransactionId();
			orderId.put("id", transactionId);

			customerOrderReplicaMap.put("order", orderId);

			customerOrderReplicaRequest.setOrderId(transactionId);
			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);

			customerOrderReplicaMap.put("cartId", customerOrderReplicaRequest.getCartId());

			try {
				customerOrderReplicaMap.put("phonePeResponse",
						phonepeServiceImpl.initiatePhonepePayment(transactionId,
								Integer.valueOf(customerOrderReplicaRequest.getRazorPayRequest().getAmount()),
								contactNumber, customerOrderReplicaRequest.getRedirectUrl(), customerOrderReplicaRequest.getCallBackUrl()));

			} catch (Exception e) {
				e.printStackTrace();
				customerOrderReplicaMap.put("phonePeResponse", new HashedMap<>());
			}

			return customerOrderReplicaMap;

		} else {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
					"paymentDetails transcation Details are mandatory");
		}

	}

	private static String getMerchantTransactionId() {

		return "OD_" + MerchantTransactionIdGenerator.getRandomString();
	}


	@Override
	public List<CustomerOrderReplica> getCustomerOrderByMoblieNo(String contactNumber,Integer aid) {
		
		Schedule latestschedule = customerOrderReplicaDoa.getlatestschedule();
		
		if (latestschedule != null && latestschedule.getCreationTimestamp()!=null) {
			
	        if (latestschedule.getStatus().equals(UserStatus.ACTIVE)) {
	        	
	        	Customers customer = customerDetailsDao.getByContactNoAndApartment(contactNumber, aid);
	        	if (customer != null) { // Ensure the customer exists
	        		List<CustomerOrder> customerOrderList = customerOrderReplicaDoa.getListCustomerOrderByCustomerId(customer.getCtid());
	        		
	                double totalOrderAmount = 0.0;
	       
                if (customerOrderList != null && !customerOrderList.isEmpty() && customerOrderList.add(customerOrder). {
                    for (CustomerOrder customerOrder : customerOrderList) {
                        Double orderAmount = customerOrder.getAmount();
                        if (orderAmount != null) {
                            totalOrderAmount += orderAmount;
                            if(totalOrderAmount>200) {
                            	totalOrderAmount+customerOrder
                            }
                        }
                    }
                    System.out.println("Total Order Amount: " + totalOrderAmount);
                    List<CustomerOrderReplica> customerOrderReplicas = new ArrayList<>();
                    return customerOrderReplicas;
                } else {
                    return Collections.emptyList(); // or return null or an appropriate value
                }
            } else {
              
                return null; // or an appropriate value
            }
        } else {
            // Handle the case when the latest schedule is not active
            return null; // or an appropriate value
        }
    } else {
        // Handle the case when there is no latest schedule or its creation timestamp is null
        return null; // or an appropriate value
    }
	}
}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1003)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:799)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:743)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:666)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:658)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.lambda$0(LSJavaHoverProvider.java:68)
	at java.base/java.util.concurrent.CompletableFuture$AsyncRun.run(CompletableFuture.java:1804)
	at java.base/java.util.concurrent.CompletableFuture$AsyncRun.exec(CompletableFuture.java:1796)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:373)
	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1182)
	at java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1655)
	at java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1622)
	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:165)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-09-21 15:07:09.836
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1003)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:799)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:743)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:666)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:658)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.lambda$0(LSJavaHoverProvider.java:68)
	at java.base/java.util.concurrent.CompletableFuture$AsyncRun.run(CompletableFuture.java:1804)
	at java.base/java.util.concurrent.CompletableFuture$AsyncRun.exec(CompletableFuture.java:1796)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:373)
	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1182)
	at java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1655)
	at java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1622)
	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:165)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-09-21 15:07:09.838
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1003)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:799)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:743)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:666)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:658)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.lambda$0(LSJavaHoverProvider.java:68)
	at java.base/java.util.concurrent.CompletableFuture$AsyncRun.run(CompletableFuture.java:1804)
	at java.base/java.util.concurrent.CompletableFuture$AsyncRun.exec(CompletableFuture.java:1796)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:373)
	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1182)
	at java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1655)
	at java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1622)
	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:165)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-21 15:07:09.922
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.xyram.daydrop.serviceimpl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.transaction.Transactional;

import org.apache.commons.collections4.map.HashedMap;
import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.server.ResponseStatusException;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.xyram.daydrop.admin.model.CurrentUser;
import com.xyram.daydrop.basemodel.Base64Wrapper;
import com.xyram.daydrop.basemodel.MerchantTransactionIdGenerator;
import com.xyram.daydrop.basemodel.PhonepeSerializer;
import com.xyram.daydrop.dao.ApartmentDao;
import com.xyram.daydrop.dao.CustomerDetailsDao;
import com.xyram.daydrop.dao.CustomerOrderDao;
import com.xyram.daydrop.dao.CustomerOrderReplicaDoa;
import com.xyram.daydrop.dao.SheduleDao;
import com.xyram.daydrop.enumtypes.UserStatus;
import com.xyram.daydrop.model.Apartments;
import com.xyram.daydrop.model.CustomerOrder;
import com.xyram.daydrop.model.CustomerOrderReplica;
import com.xyram.daydrop.model.Customers;
import com.xyram.daydrop.model.Schedule;
import com.xyram.daydrop.modelMapper.PaymentInstrument;
import com.xyram.daydrop.modelMapper.PhonePePayModel;
import com.xyram.daydrop.request.CustomerOrderReplicaRequest;
import com.xyram.daydrop.response.RazorPayRequest;
import com.xyram.daydrop.service.CustomerOrderPriceService;
import com.xyram.daydrop.service.CustomerOrderReplicaService;
import com.xyram.daydrop.util.HashEncoder;
import com.xyram.daydrop.util.RazorPay;
import com.xyram.daydrop.service.ConsumerService;

@Transactional
@Service
public class CustomerOrderReplicaServiceImpl implements CustomerOrderReplicaService {

	@Autowired
	CustomerOrderReplicaDoa customerOrderReplicaDoa;

	@Autowired
	ApartmentDao apartmentDao;

	@Autowired
	SheduleDao scheduleDao;

	@Autowired
	CustomerDetailsDao customerDetailsDao;

	@Autowired
	ConsumerService consumerService;

	@Autowired
	CurrentUser currentUser;

	@Autowired
	PhonepeServiceImpl phonepeServiceImpl;

	@Value("${merchant_id}")
	private String merchantId;

	@Value("${salt_key}")
	private String saltKey;

	@Value("${salt_index}")
	private String saltIndex;

	@Override
	public Map createCustomerOrderReplicaService(CustomerOrderReplicaRequest customerOrderReplicaRequest,
			String contactNumber, Integer aparmentId)

	{

		Map response = new HashedMap<>();

		response.put("message", "success");
		CustomerOrderReplica customerOrderReplica = null;

		if (customerOrderReplicaRequest.getCartId() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "cartId is mandatory ");
		}
		long razorPayCount = 0;
		if (customerOrderReplicaRequest.getOrderId() != null) {

			razorPayCount = customerOrderReplicaDoa.getRazorPayExistByCartId(customerOrderReplicaRequest.getOrderId());
		}

		if (customerOrderReplicaRequest.getCustomerDetails() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Order Details  is mandatory ");
		}

		customerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(customerOrderReplicaRequest.getCartId(),
				contactNumber);

		if (customerOrderReplica != null) {
			customerOrderReplica.setCartId(customerOrderReplica.getCartId());

			if (customerOrderReplica.isOrdered()) {
				throw new ResponseStatusException(HttpStatus.CONFLICT, "Your Order is Placed With cart Details");
			}

//			if (razorPayCount >= 1 && !(customerOrderReplica.getRazorPayOrderId() != null
//					&& customerOrderReplica.getRazorPayOrderId().equals(customerOrderReplicaRequest.getOrderId()))) {
//				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
//			}

			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);

			customerOrderReplica.setAttempts(customerOrderReplica.getAttempts() + 1);
			customerOrderReplica.setUpdatedTime(new Date());

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		} else {

			customerOrderReplica = new CustomerOrderReplica();
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);
			customerOrderReplica.setCartId(customerOrderReplicaRequest.getCartId());
			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());

			if (razorPayCount > 0) {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
			}

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			Schedule schedule = scheduleDao.getlatestScheduleCustomers();

			if (schedule != null) {

				try {
					customerOrderReplica.setSchedule(schedule.getsId() != null ? schedule.getsId().toString() : null);
				} catch (Exception e) {
					e.printStackTrace();
				}
			} else {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
						"Sorry We Are Not Accepting Any Order Right now");

			}

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		}

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicas(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String schedule = null;

		Map filter = request.containsKey("filters") ? (Map) request.get("filters") : null;
		if (filter != null) {
			statusType = filter.containsKey("statusType") ? ((String) filter.get("statusType")).toLowerCase() : null;
			searchQuery = filter.containsKey("searchQuery") ? ((String) filter.get("searchQuery")).toLowerCase() : null;
			schedule = filter.containsKey("schedule") ? (String.valueOf(filter.get("schedule"))) : null;

		}

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplica(searchQuery, statusType, schedule);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");

				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setStreetName(
						customers.get("streetName") != null ? (String) customers.get("streetName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicasBySchedule(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String scheduleId = null;

		Schedule schedule = scheduleDao.getlatestScheduleCustomers();

		if (schedule != null) {

			try {
				scheduleId = schedule.getsId() != null ? schedule.getsId().toString() : null;
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

		statusType = request.containsKey("statusType") ? ((String) request.get("statusType")).toLowerCase() : "Success";

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplicaBySchdeule(statusType, scheduleId);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");
				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				System.out.println("customers" + customers.get("customerName"));

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public CustomerOrderReplica getCustomerOrderReplicaByCartId(String cartId) {

		CustomerOrderReplica CustomerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(cartId,
				currentUser.getContactNumber());

		ObjectMapper objectMapper = new ObjectMapper();
		try {

			// convert JSON string to Map
			Map<String, Object> customerOrderReplicaMap = objectMapper
					.readValue(CustomerOrderReplica.getCustomerOrderDetails(), Map.class);

			Object customerOrder = customerOrderReplicaMap.get("customerOrder");
			Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

			Object quanityList = items.get("quantity");
			Map customers = customerDetailsDao.getByContactNumberAndApartment(CustomerOrderReplica.getContactNumber(),
					CustomerOrderReplica.getApartmentId());

			System.out.println("customers" + customers.get("customerName"));

			// Apartments apartments =
			// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
			CustomerOrderReplica.setApartmentName(
					customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

			CustomerOrderReplica.setCustomerDetails(customers);

			CustomerOrderReplica.setCustomerOrder(customerOrder);
			CustomerOrderReplica.setQuatityList(quanityList);

		} catch (Exception e) {
			e.printStackTrace();
		}

		return CustomerOrderReplica;

	}

	@Override
	public Map createCustomerOrderReplica(CustomerOrderReplicaRequest customerOrderReplicaRequest, String contactNumber,
			Integer aparmentId) {

		if (customerOrderReplicaRequest.getRazorPayRequest() != null) {

//			Map razorPay = consumerService.createRazorPayOrder(customerOrderReplicaRequest.getRazorPayRequest());
//			customerOrderReplicaRequest.setOrderId(razorPay.get("order") != null ? (String)((RazorPay) razorPay.get("order")).getId() : null);	
//	
//			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);
//
//			razorPay.put("cartId", customerOrderReplicaRequest.getCartId());

			Map customerOrderReplicaMap = new HashMap<>();

			Map orderId = new HashMap<>();
			String transactionId = getMerchantTransactionId();
			orderId.put("id", transactionId);

			customerOrderReplicaMap.put("order", orderId);

			customerOrderReplicaRequest.setOrderId(transactionId);
			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);

			customerOrderReplicaMap.put("cartId", customerOrderReplicaRequest.getCartId());

			try {
				customerOrderReplicaMap.put("phonePeResponse",
						phonepeServiceImpl.initiatePhonepePayment(transactionId,
								Integer.valueOf(customerOrderReplicaRequest.getRazorPayRequest().getAmount()),
								contactNumber, customerOrderReplicaRequest.getRedirectUrl(), customerOrderReplicaRequest.getCallBackUrl()));

			} catch (Exception e) {
				e.printStackTrace();
				customerOrderReplicaMap.put("phonePeResponse", new HashedMap<>());
			}

			return customerOrderReplicaMap;

		} else {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
					"paymentDetails transcation Details are mandatory");
		}

	}

	private static String getMerchantTransactionId() {

		return "OD_" + MerchantTransactionIdGenerator.getRandomString();
	}


	@Override
	public List<CustomerOrderReplica> getCustomerOrderByMoblieNo(String contactNumber,Integer aid) {
		
		Schedule latestschedule = customerOrderReplicaDoa.getlatestschedule();
		
		if (latestschedule != null && latestschedule.getCreationTimestamp()!=null) {
			
	        if (latestschedule.getStatus().equals(UserStatus.ACTIVE)) {
	        	
	        	Customers customer = customerDetailsDao.getByContactNoAndApartment(contactNumber, aid);
	        	if (customer != null) { // Ensure the customer exists
	        		List<CustomerOrder> customerOrderList = customerOrderReplicaDoa.getListCustomerOrderByCustomerId(customer.getCtid());
	        		
	                double totalOrderAmount = 0.0;
	       
                if (customerOrderList != null && !customerOrderList.isEmpty() && customerOrderList.add(customerOrder). {
                    for (CustomerOrder customerOrder : customerOrderList) {
                        Double orderAmount = customerOrder.getAmount();
                        if (orderAmount != null) {
                            totalOrderAmount += orderAmount;
                            if(totalOrderAmount>200) {
                            	totalOrderAmount+customerOrder
                            }
                        }
                    }
                    System.out.println("Total Order Amount: " + totalOrderAmount);
                    List<CustomerOrderReplica> customerOrderReplicas = new ArrayList<>();
                    return customerOrderReplicas;
                } else {
                    return Collections.emptyList(); // or return null or an appropriate value
                }
            } else {
              
                return null; // or an appropriate value
            }
        } else {
            // Handle the case when the latest schedule is not active
            return null; // or an appropriate value
        }
    } else {
        // Handle the case when there is no latest schedule or its creation timestamp is null
        return null; // or an appropriate value
    }
	}
}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-09-21 15:07:09.924
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-09-21 15:07:09.926
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-21 15:07:10.016
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.xyram.daydrop.serviceimpl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.transaction.Transactional;

import org.apache.commons.collections4.map.HashedMap;
import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.server.ResponseStatusException;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.xyram.daydrop.admin.model.CurrentUser;
import com.xyram.daydrop.basemodel.Base64Wrapper;
import com.xyram.daydrop.basemodel.MerchantTransactionIdGenerator;
import com.xyram.daydrop.basemodel.PhonepeSerializer;
import com.xyram.daydrop.dao.ApartmentDao;
import com.xyram.daydrop.dao.CustomerDetailsDao;
import com.xyram.daydrop.dao.CustomerOrderDao;
import com.xyram.daydrop.dao.CustomerOrderReplicaDoa;
import com.xyram.daydrop.dao.SheduleDao;
import com.xyram.daydrop.enumtypes.UserStatus;
import com.xyram.daydrop.model.Apartments;
import com.xyram.daydrop.model.CustomerOrder;
import com.xyram.daydrop.model.CustomerOrderReplica;
import com.xyram.daydrop.model.Customers;
import com.xyram.daydrop.model.Schedule;
import com.xyram.daydrop.modelMapper.PaymentInstrument;
import com.xyram.daydrop.modelMapper.PhonePePayModel;
import com.xyram.daydrop.request.CustomerOrderReplicaRequest;
import com.xyram.daydrop.response.RazorPayRequest;
import com.xyram.daydrop.service.CustomerOrderPriceService;
import com.xyram.daydrop.service.CustomerOrderReplicaService;
import com.xyram.daydrop.util.HashEncoder;
import com.xyram.daydrop.util.RazorPay;
import com.xyram.daydrop.service.ConsumerService;

@Transactional
@Service
public class CustomerOrderReplicaServiceImpl implements CustomerOrderReplicaService {

	@Autowired
	CustomerOrderReplicaDoa customerOrderReplicaDoa;

	@Autowired
	ApartmentDao apartmentDao;

	@Autowired
	SheduleDao scheduleDao;

	@Autowired
	CustomerDetailsDao customerDetailsDao;

	@Autowired
	ConsumerService consumerService;

	@Autowired
	CurrentUser currentUser;

	@Autowired
	PhonepeServiceImpl phonepeServiceImpl;

	@Value("${merchant_id}")
	private String merchantId;

	@Value("${salt_key}")
	private String saltKey;

	@Value("${salt_index}")
	private String saltIndex;

	@Override
	public Map createCustomerOrderReplicaService(CustomerOrderReplicaRequest customerOrderReplicaRequest,
			String contactNumber, Integer aparmentId)

	{

		Map response = new HashedMap<>();

		response.put("message", "success");
		CustomerOrderReplica customerOrderReplica = null;

		if (customerOrderReplicaRequest.getCartId() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "cartId is mandatory ");
		}
		long razorPayCount = 0;
		if (customerOrderReplicaRequest.getOrderId() != null) {

			razorPayCount = customerOrderReplicaDoa.getRazorPayExistByCartId(customerOrderReplicaRequest.getOrderId());
		}

		if (customerOrderReplicaRequest.getCustomerDetails() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Order Details  is mandatory ");
		}

		customerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(customerOrderReplicaRequest.getCartId(),
				contactNumber);

		if (customerOrderReplica != null) {
			customerOrderReplica.setCartId(customerOrderReplica.getCartId());

			if (customerOrderReplica.isOrdered()) {
				throw new ResponseStatusException(HttpStatus.CONFLICT, "Your Order is Placed With cart Details");
			}

//			if (razorPayCount >= 1 && !(customerOrderReplica.getRazorPayOrderId() != null
//					&& customerOrderReplica.getRazorPayOrderId().equals(customerOrderReplicaRequest.getOrderId()))) {
//				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
//			}

			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);

			customerOrderReplica.setAttempts(customerOrderReplica.getAttempts() + 1);
			customerOrderReplica.setUpdatedTime(new Date());

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		} else {

			customerOrderReplica = new CustomerOrderReplica();
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);
			customerOrderReplica.setCartId(customerOrderReplicaRequest.getCartId());
			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());

			if (razorPayCount > 0) {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
			}

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			Schedule schedule = scheduleDao.getlatestScheduleCustomers();

			if (schedule != null) {

				try {
					customerOrderReplica.setSchedule(schedule.getsId() != null ? schedule.getsId().toString() : null);
				} catch (Exception e) {
					e.printStackTrace();
				}
			} else {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
						"Sorry We Are Not Accepting Any Order Right now");

			}

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		}

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicas(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String schedule = null;

		Map filter = request.containsKey("filters") ? (Map) request.get("filters") : null;
		if (filter != null) {
			statusType = filter.containsKey("statusType") ? ((String) filter.get("statusType")).toLowerCase() : null;
			searchQuery = filter.containsKey("searchQuery") ? ((String) filter.get("searchQuery")).toLowerCase() : null;
			schedule = filter.containsKey("schedule") ? (String.valueOf(filter.get("schedule"))) : null;

		}

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplica(searchQuery, statusType, schedule);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");

				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setStreetName(
						customers.get("streetName") != null ? (String) customers.get("streetName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicasBySchedule(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String scheduleId = null;

		Schedule schedule = scheduleDao.getlatestScheduleCustomers();

		if (schedule != null) {

			try {
				scheduleId = schedule.getsId() != null ? schedule.getsId().toString() : null;
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

		statusType = request.containsKey("statusType") ? ((String) request.get("statusType")).toLowerCase() : "Success";

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplicaBySchdeule(statusType, scheduleId);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");
				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				System.out.println("customers" + customers.get("customerName"));

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public CustomerOrderReplica getCustomerOrderReplicaByCartId(String cartId) {

		CustomerOrderReplica CustomerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(cartId,
				currentUser.getContactNumber());

		ObjectMapper objectMapper = new ObjectMapper();
		try {

			// convert JSON string to Map
			Map<String, Object> customerOrderReplicaMap = objectMapper
					.readValue(CustomerOrderReplica.getCustomerOrderDetails(), Map.class);

			Object customerOrder = customerOrderReplicaMap.get("customerOrder");
			Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

			Object quanityList = items.get("quantity");
			Map customers = customerDetailsDao.getByContactNumberAndApartment(CustomerOrderReplica.getContactNumber(),
					CustomerOrderReplica.getApartmentId());

			System.out.println("customers" + customers.get("customerName"));

			// Apartments apartments =
			// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
			CustomerOrderReplica.setApartmentName(
					customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

			CustomerOrderReplica.setCustomerDetails(customers);

			CustomerOrderReplica.setCustomerOrder(customerOrder);
			CustomerOrderReplica.setQuatityList(quanityList);

		} catch (Exception e) {
			e.printStackTrace();
		}

		return CustomerOrderReplica;

	}

	@Override
	public Map createCustomerOrderReplica(CustomerOrderReplicaRequest customerOrderReplicaRequest, String contactNumber,
			Integer aparmentId) {

		if (customerOrderReplicaRequest.getRazorPayRequest() != null) {

//			Map razorPay = consumerService.createRazorPayOrder(customerOrderReplicaRequest.getRazorPayRequest());
//			customerOrderReplicaRequest.setOrderId(razorPay.get("order") != null ? (String)((RazorPay) razorPay.get("order")).getId() : null);	
//	
//			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);
//
//			razorPay.put("cartId", customerOrderReplicaRequest.getCartId());

			Map customerOrderReplicaMap = new HashMap<>();

			Map orderId = new HashMap<>();
			String transactionId = getMerchantTransactionId();
			orderId.put("id", transactionId);

			customerOrderReplicaMap.put("order", orderId);

			customerOrderReplicaRequest.setOrderId(transactionId);
			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);

			customerOrderReplicaMap.put("cartId", customerOrderReplicaRequest.getCartId());

			try {
				customerOrderReplicaMap.put("phonePeResponse",
						phonepeServiceImpl.initiatePhonepePayment(transactionId,
								Integer.valueOf(customerOrderReplicaRequest.getRazorPayRequest().getAmount()),
								contactNumber, customerOrderReplicaRequest.getRedirectUrl(), customerOrderReplicaRequest.getCallBackUrl()));

			} catch (Exception e) {
				e.printStackTrace();
				customerOrderReplicaMap.put("phonePeResponse", new HashedMap<>());
			}

			return customerOrderReplicaMap;

		} else {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
					"paymentDetails transcation Details are mandatory");
		}

	}

	private static String getMerchantTransactionId() {

		return "OD_" + MerchantTransactionIdGenerator.getRandomString();
	}


	@Override
	public List<CustomerOrderReplica> getCustomerOrderByMoblieNo(String contactNumber,Integer aid) {
		
		Schedule latestschedule = customerOrderReplicaDoa.getlatestschedule();
		
		if (latestschedule != null && latestschedule.getCreationTimestamp()!=null) {
			
	        if (latestschedule.getStatus().equals(UserStatus.ACTIVE)) {
	        	
	        	Customers customer = customerDetailsDao.getByContactNoAndApartment(contactNumber, aid);
	        	if (customer != null) { // Ensure the customer exists
	        		List<CustomerOrder> customerOrderList = customerOrderReplicaDoa.getListCustomerOrderByCustomerId(customer.getCtid());
	        		
	                double totalOrderAmount = 0.0;
	       
                if (customerOrderList != null && !customerOrderList.isEmpty() && customerOrderList.add(customerOrder). {
                    for (CustomerOrder customerOrder : customerOrderList) {
                        Double orderAmount = customerOrder.getAmount();
                        if (orderAmount != null) {
                            totalOrderAmount += orderAmount;
                            if(totalOrderAmount>200) {
                            	totalOrderAmount+customerOrder
                            }
                        }
                    }
                    System.out.println("Total Order Amount: " + totalOrderAmount);
                    List<CustomerOrderReplica> customerOrderReplicas = new ArrayList<>();
                    return customerOrderReplicas;
                } else {
                    return Collections.emptyList(); // or return null or an appropriate value
                }
            } else {
              
                return null; // or an appropriate value
            }
        } else {
            // Handle the case when the latest schedule is not active
            return null; // or an appropriate value
        }
    } else {
        // Handle the case when there is no latest schedule or its creation timestamp is null
        return null; // or an appropriate value
    }
	}
}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1003)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:799)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:743)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:666)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:658)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-09-21 15:07:10.019
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1003)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:799)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:743)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:666)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:658)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-09-21 15:07:10.021
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1003)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:799)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:743)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:666)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:658)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-21 15:07:33.209
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.xyram.daydrop.serviceimpl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.transaction.Transactional;

import org.apache.commons.collections4.map.HashedMap;
import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.server.ResponseStatusException;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.xyram.daydrop.admin.model.CurrentUser;
import com.xyram.daydrop.basemodel.Base64Wrapper;
import com.xyram.daydrop.basemodel.MerchantTransactionIdGenerator;
import com.xyram.daydrop.basemodel.PhonepeSerializer;
import com.xyram.daydrop.dao.ApartmentDao;
import com.xyram.daydrop.dao.CustomerDetailsDao;
import com.xyram.daydrop.dao.CustomerOrderDao;
import com.xyram.daydrop.dao.CustomerOrderReplicaDoa;
import com.xyram.daydrop.dao.SheduleDao;
import com.xyram.daydrop.enumtypes.UserStatus;
import com.xyram.daydrop.model.Apartments;
import com.xyram.daydrop.model.CustomerOrder;
import com.xyram.daydrop.model.CustomerOrderReplica;
import com.xyram.daydrop.model.Customers;
import com.xyram.daydrop.model.Schedule;
import com.xyram.daydrop.modelMapper.PaymentInstrument;
import com.xyram.daydrop.modelMapper.PhonePePayModel;
import com.xyram.daydrop.request.CustomerOrderReplicaRequest;
import com.xyram.daydrop.response.RazorPayRequest;
import com.xyram.daydrop.service.CustomerOrderPriceService;
import com.xyram.daydrop.service.CustomerOrderReplicaService;
import com.xyram.daydrop.util.HashEncoder;
import com.xyram.daydrop.util.RazorPay;
import com.xyram.daydrop.service.ConsumerService;

@Transactional
@Service
public class CustomerOrderReplicaServiceImpl implements CustomerOrderReplicaService {

	@Autowired
	CustomerOrderReplicaDoa customerOrderReplicaDoa;

	@Autowired
	ApartmentDao apartmentDao;

	@Autowired
	SheduleDao scheduleDao;

	@Autowired
	CustomerDetailsDao customerDetailsDao;

	@Autowired
	ConsumerService consumerService;

	@Autowired
	CurrentUser currentUser;

	@Autowired
	PhonepeServiceImpl phonepeServiceImpl;

	@Value("${merchant_id}")
	private String merchantId;

	@Value("${salt_key}")
	private String saltKey;

	@Value("${salt_index}")
	private String saltIndex;

	@Override
	public Map createCustomerOrderReplicaService(CustomerOrderReplicaRequest customerOrderReplicaRequest,
			String contactNumber, Integer aparmentId)

	{

		Map response = new HashedMap<>();

		response.put("message", "success");
		CustomerOrderReplica customerOrderReplica = null;

		if (customerOrderReplicaRequest.getCartId() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "cartId is mandatory ");
		}
		long razorPayCount = 0;
		if (customerOrderReplicaRequest.getOrderId() != null) {

			razorPayCount = customerOrderReplicaDoa.getRazorPayExistByCartId(customerOrderReplicaRequest.getOrderId());
		}

		if (customerOrderReplicaRequest.getCustomerDetails() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Order Details  is mandatory ");
		}

		customerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(customerOrderReplicaRequest.getCartId(),
				contactNumber);

		if (customerOrderReplica != null) {
			customerOrderReplica.setCartId(customerOrderReplica.getCartId());

			if (customerOrderReplica.isOrdered()) {
				throw new ResponseStatusException(HttpStatus.CONFLICT, "Your Order is Placed With cart Details");
			}

//			if (razorPayCount >= 1 && !(customerOrderReplica.getRazorPayOrderId() != null
//					&& customerOrderReplica.getRazorPayOrderId().equals(customerOrderReplicaRequest.getOrderId()))) {
//				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
//			}

			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);

			customerOrderReplica.setAttempts(customerOrderReplica.getAttempts() + 1);
			customerOrderReplica.setUpdatedTime(new Date());

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		} else {

			customerOrderReplica = new CustomerOrderReplica();
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);
			customerOrderReplica.setCartId(customerOrderReplicaRequest.getCartId());
			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());

			if (razorPayCount > 0) {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
			}

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			Schedule schedule = scheduleDao.getlatestScheduleCustomers();

			if (schedule != null) {

				try {
					customerOrderReplica.setSchedule(schedule.getsId() != null ? schedule.getsId().toString() : null);
				} catch (Exception e) {
					e.printStackTrace();
				}
			} else {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
						"Sorry We Are Not Accepting Any Order Right now");

			}

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		}

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicas(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String schedule = null;

		Map filter = request.containsKey("filters") ? (Map) request.get("filters") : null;
		if (filter != null) {
			statusType = filter.containsKey("statusType") ? ((String) filter.get("statusType")).toLowerCase() : null;
			searchQuery = filter.containsKey("searchQuery") ? ((String) filter.get("searchQuery")).toLowerCase() : null;
			schedule = filter.containsKey("schedule") ? (String.valueOf(filter.get("schedule"))) : null;

		}

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplica(searchQuery, statusType, schedule);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");

				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setStreetName(
						customers.get("streetName") != null ? (String) customers.get("streetName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicasBySchedule(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String scheduleId = null;

		Schedule schedule = scheduleDao.getlatestScheduleCustomers();

		if (schedule != null) {

			try {
				scheduleId = schedule.getsId() != null ? schedule.getsId().toString() : null;
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

		statusType = request.containsKey("statusType") ? ((String) request.get("statusType")).toLowerCase() : "Success";

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplicaBySchdeule(statusType, scheduleId);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");
				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				System.out.println("customers" + customers.get("customerName"));

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public CustomerOrderReplica getCustomerOrderReplicaByCartId(String cartId) {

		CustomerOrderReplica CustomerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(cartId,
				currentUser.getContactNumber());

		ObjectMapper objectMapper = new ObjectMapper();
		try {

			// convert JSON string to Map
			Map<String, Object> customerOrderReplicaMap = objectMapper
					.readValue(CustomerOrderReplica.getCustomerOrderDetails(), Map.class);

			Object customerOrder = customerOrderReplicaMap.get("customerOrder");
			Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

			Object quanityList = items.get("quantity");
			Map customers = customerDetailsDao.getByContactNumberAndApartment(CustomerOrderReplica.getContactNumber(),
					CustomerOrderReplica.getApartmentId());

			System.out.println("customers" + customers.get("customerName"));

			// Apartments apartments =
			// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
			CustomerOrderReplica.setApartmentName(
					customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

			CustomerOrderReplica.setCustomerDetails(customers);

			CustomerOrderReplica.setCustomerOrder(customerOrder);
			CustomerOrderReplica.setQuatityList(quanityList);

		} catch (Exception e) {
			e.printStackTrace();
		}

		return CustomerOrderReplica;

	}

	@Override
	public Map createCustomerOrderReplica(CustomerOrderReplicaRequest customerOrderReplicaRequest, String contactNumber,
			Integer aparmentId) {

		if (customerOrderReplicaRequest.getRazorPayRequest() != null) {

//			Map razorPay = consumerService.createRazorPayOrder(customerOrderReplicaRequest.getRazorPayRequest());
//			customerOrderReplicaRequest.setOrderId(razorPay.get("order") != null ? (String)((RazorPay) razorPay.get("order")).getId() : null);	
//	
//			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);
//
//			razorPay.put("cartId", customerOrderReplicaRequest.getCartId());

			Map customerOrderReplicaMap = new HashMap<>();

			Map orderId = new HashMap<>();
			String transactionId = getMerchantTransactionId();
			orderId.put("id", transactionId);

			customerOrderReplicaMap.put("order", orderId);

			customerOrderReplicaRequest.setOrderId(transactionId);
			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);

			customerOrderReplicaMap.put("cartId", customerOrderReplicaRequest.getCartId());

			try {
				customerOrderReplicaMap.put("phonePeResponse",
						phonepeServiceImpl.initiatePhonepePayment(transactionId,
								Integer.valueOf(customerOrderReplicaRequest.getRazorPayRequest().getAmount()),
								contactNumber, customerOrderReplicaRequest.getRedirectUrl(), customerOrderReplicaRequest.getCallBackUrl()));

			} catch (Exception e) {
				e.printStackTrace();
				customerOrderReplicaMap.put("phonePeResponse", new HashedMap<>());
			}

			return customerOrderReplicaMap;

		} else {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
					"paymentDetails transcation Details are mandatory");
		}

	}

	private static String getMerchantTransactionId() {

		return "OD_" + MerchantTransactionIdGenerator.getRandomString();
	}


	@Override
	public List<CustomerOrderReplica> getCustomerOrderByMoblieNo(String contactNumber,Integer aid) {
		
		Schedule latestschedule = customerOrderReplicaDoa.getlatestschedule();
		
		if (latestschedule != null && latestschedule.getCreationTimestamp()!=null) {
			
	        if (latestschedule.getStatus().equals(UserStatus.ACTIVE)) {
	        	
	        	Customers customer = customerDetailsDao.getByContactNoAndApartment(contactNumber, aid);
	        	if (customer != null) { // Ensure the customer exists
	        		List<CustomerOrder> customerOrderList = customerOrderReplicaDoa.getListCustomerOrderByCustomerId(customer.getCtid());
	        		
	                double totalOrderAmount = 0.0;
	       
                if (customerOrderList != null && !customerOrderList.isEmpty() && customerOrderList.add(customerOrder). {
                    for (CustomerOrder customerOrder : customerOrderList) {
                        Double orderAmount = customerOrder.getAmount();
                        if (orderAmount != null) {
                            totalOrderAmount += orderAmount;
                            if(totalOrderAmount>200) {
                            	totalOrderAmount+customerOrder
                            }
                        }
                    }
                    System.out.println("Total Order Amount: " + totalOrderAmount);
                    List<CustomerOrderReplica> customerOrderReplicas = new ArrayList<>();
                    return customerOrderReplicas;
                } else {
                    return Collections.emptyList(); // or return null or an appropriate value
                }
            } else {
              
                return null; // or an appropriate value
            }
        } else {
            // Handle the case when the latest schedule is not active
            return null; // or an appropriate value
        }
    } else {
        // Handle the case when there is no latest schedule or its creation timestamp is null
        return null; // or an appropriate value
    }
	}
}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-09-21 15:07:33.212
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-09-21 15:07:33.215
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-21 15:07:33.920
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.xyram.daydrop.serviceimpl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.transaction.Transactional;

import org.apache.commons.collections4.map.HashedMap;
import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.server.ResponseStatusException;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.xyram.daydrop.admin.model.CurrentUser;
import com.xyram.daydrop.basemodel.Base64Wrapper;
import com.xyram.daydrop.basemodel.MerchantTransactionIdGenerator;
import com.xyram.daydrop.basemodel.PhonepeSerializer;
import com.xyram.daydrop.dao.ApartmentDao;
import com.xyram.daydrop.dao.CustomerDetailsDao;
import com.xyram.daydrop.dao.CustomerOrderDao;
import com.xyram.daydrop.dao.CustomerOrderReplicaDoa;
import com.xyram.daydrop.dao.SheduleDao;
import com.xyram.daydrop.enumtypes.UserStatus;
import com.xyram.daydrop.model.Apartments;
import com.xyram.daydrop.model.CustomerOrder;
import com.xyram.daydrop.model.CustomerOrderReplica;
import com.xyram.daydrop.model.Customers;
import com.xyram.daydrop.model.Schedule;
import com.xyram.daydrop.modelMapper.PaymentInstrument;
import com.xyram.daydrop.modelMapper.PhonePePayModel;
import com.xyram.daydrop.request.CustomerOrderReplicaRequest;
import com.xyram.daydrop.response.RazorPayRequest;
import com.xyram.daydrop.service.CustomerOrderPriceService;
import com.xyram.daydrop.service.CustomerOrderReplicaService;
import com.xyram.daydrop.util.HashEncoder;
import com.xyram.daydrop.util.RazorPay;
import com.xyram.daydrop.service.ConsumerService;

@Transactional
@Service
public class CustomerOrderReplicaServiceImpl implements CustomerOrderReplicaService {

	@Autowired
	CustomerOrderReplicaDoa customerOrderReplicaDoa;

	@Autowired
	ApartmentDao apartmentDao;

	@Autowired
	SheduleDao scheduleDao;

	@Autowired
	CustomerDetailsDao customerDetailsDao;

	@Autowired
	ConsumerService consumerService;

	@Autowired
	CurrentUser currentUser;

	@Autowired
	PhonepeServiceImpl phonepeServiceImpl;

	@Value("${merchant_id}")
	private String merchantId;

	@Value("${salt_key}")
	private String saltKey;

	@Value("${salt_index}")
	private String saltIndex;

	@Override
	public Map createCustomerOrderReplicaService(CustomerOrderReplicaRequest customerOrderReplicaRequest,
			String contactNumber, Integer aparmentId)

	{

		Map response = new HashedMap<>();

		response.put("message", "success");
		CustomerOrderReplica customerOrderReplica = null;

		if (customerOrderReplicaRequest.getCartId() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "cartId is mandatory ");
		}
		long razorPayCount = 0;
		if (customerOrderReplicaRequest.getOrderId() != null) {

			razorPayCount = customerOrderReplicaDoa.getRazorPayExistByCartId(customerOrderReplicaRequest.getOrderId());
		}

		if (customerOrderReplicaRequest.getCustomerDetails() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Order Details  is mandatory ");
		}

		customerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(customerOrderReplicaRequest.getCartId(),
				contactNumber);

		if (customerOrderReplica != null) {
			customerOrderReplica.setCartId(customerOrderReplica.getCartId());

			if (customerOrderReplica.isOrdered()) {
				throw new ResponseStatusException(HttpStatus.CONFLICT, "Your Order is Placed With cart Details");
			}

//			if (razorPayCount >= 1 && !(customerOrderReplica.getRazorPayOrderId() != null
//					&& customerOrderReplica.getRazorPayOrderId().equals(customerOrderReplicaRequest.getOrderId()))) {
//				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
//			}

			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);

			customerOrderReplica.setAttempts(customerOrderReplica.getAttempts() + 1);
			customerOrderReplica.setUpdatedTime(new Date());

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		} else {

			customerOrderReplica = new CustomerOrderReplica();
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);
			customerOrderReplica.setCartId(customerOrderReplicaRequest.getCartId());
			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());

			if (razorPayCount > 0) {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
			}

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			Schedule schedule = scheduleDao.getlatestScheduleCustomers();

			if (schedule != null) {

				try {
					customerOrderReplica.setSchedule(schedule.getsId() != null ? schedule.getsId().toString() : null);
				} catch (Exception e) {
					e.printStackTrace();
				}
			} else {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
						"Sorry We Are Not Accepting Any Order Right now");

			}

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		}

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicas(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String schedule = null;

		Map filter = request.containsKey("filters") ? (Map) request.get("filters") : null;
		if (filter != null) {
			statusType = filter.containsKey("statusType") ? ((String) filter.get("statusType")).toLowerCase() : null;
			searchQuery = filter.containsKey("searchQuery") ? ((String) filter.get("searchQuery")).toLowerCase() : null;
			schedule = filter.containsKey("schedule") ? (String.valueOf(filter.get("schedule"))) : null;

		}

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplica(searchQuery, statusType, schedule);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");

				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setStreetName(
						customers.get("streetName") != null ? (String) customers.get("streetName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicasBySchedule(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String scheduleId = null;

		Schedule schedule = scheduleDao.getlatestScheduleCustomers();

		if (schedule != null) {

			try {
				scheduleId = schedule.getsId() != null ? schedule.getsId().toString() : null;
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

		statusType = request.containsKey("statusType") ? ((String) request.get("statusType")).toLowerCase() : "Success";

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplicaBySchdeule(statusType, scheduleId);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");
				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				System.out.println("customers" + customers.get("customerName"));

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public CustomerOrderReplica getCustomerOrderReplicaByCartId(String cartId) {

		CustomerOrderReplica CustomerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(cartId,
				currentUser.getContactNumber());

		ObjectMapper objectMapper = new ObjectMapper();
		try {

			// convert JSON string to Map
			Map<String, Object> customerOrderReplicaMap = objectMapper
					.readValue(CustomerOrderReplica.getCustomerOrderDetails(), Map.class);

			Object customerOrder = customerOrderReplicaMap.get("customerOrder");
			Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

			Object quanityList = items.get("quantity");
			Map customers = customerDetailsDao.getByContactNumberAndApartment(CustomerOrderReplica.getContactNumber(),
					CustomerOrderReplica.getApartmentId());

			System.out.println("customers" + customers.get("customerName"));

			// Apartments apartments =
			// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
			CustomerOrderReplica.setApartmentName(
					customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

			CustomerOrderReplica.setCustomerDetails(customers);

			CustomerOrderReplica.setCustomerOrder(customerOrder);
			CustomerOrderReplica.setQuatityList(quanityList);

		} catch (Exception e) {
			e.printStackTrace();
		}

		return CustomerOrderReplica;

	}

	@Override
	public Map createCustomerOrderReplica(CustomerOrderReplicaRequest customerOrderReplicaRequest, String contactNumber,
			Integer aparmentId) {

		if (customerOrderReplicaRequest.getRazorPayRequest() != null) {

//			Map razorPay = consumerService.createRazorPayOrder(customerOrderReplicaRequest.getRazorPayRequest());
//			customerOrderReplicaRequest.setOrderId(razorPay.get("order") != null ? (String)((RazorPay) razorPay.get("order")).getId() : null);	
//	
//			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);
//
//			razorPay.put("cartId", customerOrderReplicaRequest.getCartId());

			Map customerOrderReplicaMap = new HashMap<>();

			Map orderId = new HashMap<>();
			String transactionId = getMerchantTransactionId();
			orderId.put("id", transactionId);

			customerOrderReplicaMap.put("order", orderId);

			customerOrderReplicaRequest.setOrderId(transactionId);
			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);

			customerOrderReplicaMap.put("cartId", customerOrderReplicaRequest.getCartId());

			try {
				customerOrderReplicaMap.put("phonePeResponse",
						phonepeServiceImpl.initiatePhonepePayment(transactionId,
								Integer.valueOf(customerOrderReplicaRequest.getRazorPayRequest().getAmount()),
								contactNumber, customerOrderReplicaRequest.getRedirectUrl(), customerOrderReplicaRequest.getCallBackUrl()));

			} catch (Exception e) {
				e.printStackTrace();
				customerOrderReplicaMap.put("phonePeResponse", new HashedMap<>());
			}

			return customerOrderReplicaMap;

		} else {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
					"paymentDetails transcation Details are mandatory");
		}

	}

	private static String getMerchantTransactionId() {

		return "OD_" + MerchantTransactionIdGenerator.getRandomString();
	}


	@Override
	public List<CustomerOrderReplica> getCustomerOrderByMoblieNo(String contactNumber,Integer aid) {
		
		Schedule latestschedule = customerOrderReplicaDoa.getlatestschedule();
		
		if (latestschedule != null && latestschedule.getCreationTimestamp()!=null) {
			
	        if (latestschedule.getStatus().equals(UserStatus.ACTIVE)) {
	        	
	        	Customers customer = customerDetailsDao.getByContactNoAndApartment(contactNumber, aid);
	        	if (customer != null) { // Ensure the customer exists
	        		List<CustomerOrder> customerOrderList = customerOrderReplicaDoa.getListCustomerOrderByCustomerId(customer.getCtid());
	        		
	                double totalOrderAmount = 0.0;
	       
                if (customerOrderList != null && !customerOrderList.isEmpty() && customerOrderList.add(customerOrder). {
                    for (CustomerOrder customerOrder : customerOrderList) {
                        Double orderAmount = customerOrder.getAmount();
                        if (orderAmount != null) {
                            totalOrderAmount += orderAmount;
                            if(totalOrderAmount>200) {
                            	totalOrderAmount+customerOrder
                            }
                        }
                    }
                    System.out.println("Total Order Amount: " + totalOrderAmount);
                    List<CustomerOrderReplica> customerOrderReplicas = new ArrayList<>();
                    return customerOrderReplicas;
                } else {
                    return Collections.emptyList(); // or return null or an appropriate value
                }
            } else {
              
                return null; // or an appropriate value
            }
        } else {
            // Handle the case when the latest schedule is not active
            return null; // or an appropriate value
        }
    } else {
        // Handle the case when there is no latest schedule or its creation timestamp is null
        return null; // or an appropriate value
    }
	}
}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-09-21 15:07:33.921
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-09-21 15:07:33.923
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-21 15:07:35.773
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.xyram.daydrop.serviceimpl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.transaction.Transactional;

import org.apache.commons.collections4.map.HashedMap;
import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.server.ResponseStatusException;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.xyram.daydrop.admin.model.CurrentUser;
import com.xyram.daydrop.basemodel.Base64Wrapper;
import com.xyram.daydrop.basemodel.MerchantTransactionIdGenerator;
import com.xyram.daydrop.basemodel.PhonepeSerializer;
import com.xyram.daydrop.dao.ApartmentDao;
import com.xyram.daydrop.dao.CustomerDetailsDao;
import com.xyram.daydrop.dao.CustomerOrderDao;
import com.xyram.daydrop.dao.CustomerOrderReplicaDoa;
import com.xyram.daydrop.dao.SheduleDao;
import com.xyram.daydrop.enumtypes.UserStatus;
import com.xyram.daydrop.model.Apartments;
import com.xyram.daydrop.model.CustomerOrder;
import com.xyram.daydrop.model.CustomerOrderReplica;
import com.xyram.daydrop.model.Customers;
import com.xyram.daydrop.model.Schedule;
import com.xyram.daydrop.modelMapper.PaymentInstrument;
import com.xyram.daydrop.modelMapper.PhonePePayModel;
import com.xyram.daydrop.request.CustomerOrderReplicaRequest;
import com.xyram.daydrop.response.RazorPayRequest;
import com.xyram.daydrop.service.CustomerOrderPriceService;
import com.xyram.daydrop.service.CustomerOrderReplicaService;
import com.xyram.daydrop.util.HashEncoder;
import com.xyram.daydrop.util.RazorPay;
import com.xyram.daydrop.service.ConsumerService;

@Transactional
@Service
public class CustomerOrderReplicaServiceImpl implements CustomerOrderReplicaService {

	@Autowired
	CustomerOrderReplicaDoa customerOrderReplicaDoa;

	@Autowired
	ApartmentDao apartmentDao;

	@Autowired
	SheduleDao scheduleDao;

	@Autowired
	CustomerDetailsDao customerDetailsDao;

	@Autowired
	ConsumerService consumerService;

	@Autowired
	CurrentUser currentUser;

	@Autowired
	PhonepeServiceImpl phonepeServiceImpl;

	@Value("${merchant_id}")
	private String merchantId;

	@Value("${salt_key}")
	private String saltKey;

	@Value("${salt_index}")
	private String saltIndex;

	@Override
	public Map createCustomerOrderReplicaService(CustomerOrderReplicaRequest customerOrderReplicaRequest,
			String contactNumber, Integer aparmentId)

	{

		Map response = new HashedMap<>();

		response.put("message", "success");
		CustomerOrderReplica customerOrderReplica = null;

		if (customerOrderReplicaRequest.getCartId() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "cartId is mandatory ");
		}
		long razorPayCount = 0;
		if (customerOrderReplicaRequest.getOrderId() != null) {

			razorPayCount = customerOrderReplicaDoa.getRazorPayExistByCartId(customerOrderReplicaRequest.getOrderId());
		}

		if (customerOrderReplicaRequest.getCustomerDetails() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Order Details  is mandatory ");
		}

		customerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(customerOrderReplicaRequest.getCartId(),
				contactNumber);

		if (customerOrderReplica != null) {
			customerOrderReplica.setCartId(customerOrderReplica.getCartId());

			if (customerOrderReplica.isOrdered()) {
				throw new ResponseStatusException(HttpStatus.CONFLICT, "Your Order is Placed With cart Details");
			}

//			if (razorPayCount >= 1 && !(customerOrderReplica.getRazorPayOrderId() != null
//					&& customerOrderReplica.getRazorPayOrderId().equals(customerOrderReplicaRequest.getOrderId()))) {
//				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
//			}

			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);

			customerOrderReplica.setAttempts(customerOrderReplica.getAttempts() + 1);
			customerOrderReplica.setUpdatedTime(new Date());

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		} else {

			customerOrderReplica = new CustomerOrderReplica();
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);
			customerOrderReplica.setCartId(customerOrderReplicaRequest.getCartId());
			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());

			if (razorPayCount > 0) {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
			}

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			Schedule schedule = scheduleDao.getlatestScheduleCustomers();

			if (schedule != null) {

				try {
					customerOrderReplica.setSchedule(schedule.getsId() != null ? schedule.getsId().toString() : null);
				} catch (Exception e) {
					e.printStackTrace();
				}
			} else {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
						"Sorry We Are Not Accepting Any Order Right now");

			}

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		}

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicas(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String schedule = null;

		Map filter = request.containsKey("filters") ? (Map) request.get("filters") : null;
		if (filter != null) {
			statusType = filter.containsKey("statusType") ? ((String) filter.get("statusType")).toLowerCase() : null;
			searchQuery = filter.containsKey("searchQuery") ? ((String) filter.get("searchQuery")).toLowerCase() : null;
			schedule = filter.containsKey("schedule") ? (String.valueOf(filter.get("schedule"))) : null;

		}

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplica(searchQuery, statusType, schedule);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");

				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setStreetName(
						customers.get("streetName") != null ? (String) customers.get("streetName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicasBySchedule(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String scheduleId = null;

		Schedule schedule = scheduleDao.getlatestScheduleCustomers();

		if (schedule != null) {

			try {
				scheduleId = schedule.getsId() != null ? schedule.getsId().toString() : null;
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

		statusType = request.containsKey("statusType") ? ((String) request.get("statusType")).toLowerCase() : "Success";

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplicaBySchdeule(statusType, scheduleId);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");
				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				System.out.println("customers" + customers.get("customerName"));

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public CustomerOrderReplica getCustomerOrderReplicaByCartId(String cartId) {

		CustomerOrderReplica CustomerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(cartId,
				currentUser.getContactNumber());

		ObjectMapper objectMapper = new ObjectMapper();
		try {

			// convert JSON string to Map
			Map<String, Object> customerOrderReplicaMap = objectMapper
					.readValue(CustomerOrderReplica.getCustomerOrderDetails(), Map.class);

			Object customerOrder = customerOrderReplicaMap.get("customerOrder");
			Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

			Object quanityList = items.get("quantity");
			Map customers = customerDetailsDao.getByContactNumberAndApartment(CustomerOrderReplica.getContactNumber(),
					CustomerOrderReplica.getApartmentId());

			System.out.println("customers" + customers.get("customerName"));

			// Apartments apartments =
			// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
			CustomerOrderReplica.setApartmentName(
					customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

			CustomerOrderReplica.setCustomerDetails(customers);

			CustomerOrderReplica.setCustomerOrder(customerOrder);
			CustomerOrderReplica.setQuatityList(quanityList);

		} catch (Exception e) {
			e.printStackTrace();
		}

		return CustomerOrderReplica;

	}

	@Override
	public Map createCustomerOrderReplica(CustomerOrderReplicaRequest customerOrderReplicaRequest, String contactNumber,
			Integer aparmentId) {

		if (customerOrderReplicaRequest.getRazorPayRequest() != null) {

//			Map razorPay = consumerService.createRazorPayOrder(customerOrderReplicaRequest.getRazorPayRequest());
//			customerOrderReplicaRequest.setOrderId(razorPay.get("order") != null ? (String)((RazorPay) razorPay.get("order")).getId() : null);	
//	
//			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);
//
//			razorPay.put("cartId", customerOrderReplicaRequest.getCartId());

			Map customerOrderReplicaMap = new HashMap<>();

			Map orderId = new HashMap<>();
			String transactionId = getMerchantTransactionId();
			orderId.put("id", transactionId);

			customerOrderReplicaMap.put("order", orderId);

			customerOrderReplicaRequest.setOrderId(transactionId);
			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);

			customerOrderReplicaMap.put("cartId", customerOrderReplicaRequest.getCartId());

			try {
				customerOrderReplicaMap.put("phonePeResponse",
						phonepeServiceImpl.initiatePhonepePayment(transactionId,
								Integer.valueOf(customerOrderReplicaRequest.getRazorPayRequest().getAmount()),
								contactNumber, customerOrderReplicaRequest.getRedirectUrl(), customerOrderReplicaRequest.getCallBackUrl()));

			} catch (Exception e) {
				e.printStackTrace();
				customerOrderReplicaMap.put("phonePeResponse", new HashedMap<>());
			}

			return customerOrderReplicaMap;

		} else {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
					"paymentDetails transcation Details are mandatory");
		}

	}

	private static String getMerchantTransactionId() {

		return "OD_" + MerchantTransactionIdGenerator.getRandomString();
	}


	@Override
	public List<CustomerOrderReplica> getCustomerOrderByMoblieNo(String contactNumber,Integer aid) {
		
		Schedule latestschedule = customerOrderReplicaDoa.getlatestschedule();
		
		if (latestschedule != null && latestschedule.getCreationTimestamp()!=null) {
			
	        if (latestschedule.getStatus().equals(UserStatus.ACTIVE)) {
	        	
	        	Customers customer = customerDetailsDao.getByContactNoAndApartment(contactNumber, aid);
	        	if (customer != null) { // Ensure the customer exists
	        		List<CustomerOrder> customerOrderList = customerOrderReplicaDoa.getListCustomerOrderByCustomerId(customer.getCtid());
	        		
	                double totalOrderAmount = 0.0;
	       
                if (customerOrderList != null && !customerOrderList.isEmpty() && customerOrderList.add(customerOrder). {
                    for (CustomerOrder customerOrder : customerOrderList) {
                        Double orderAmount = customerOrder.getAmount();
                        if (orderAmount != null) {
                            totalOrderAmount += orderAmount;
                            if(totalOrderAmount>200) {
                            	totalOrderAmount+customerOrder
                            }
                        }
                    }
                    System.out.println("Total Order Amount: " + totalOrderAmount);
                    List<CustomerOrderReplica> customerOrderReplicas = new ArrayList<>();
                    return customerOrderReplicas;
                } else {
                    return Collections.emptyList(); // or return null or an appropriate value
                }
            } else {
              
                return null; // or an appropriate value
            }
        } else {
            // Handle the case when the latest schedule is not active
            return null; // or an appropriate value
        }
    } else {
        // Handle the case when there is no latest schedule or its creation timestamp is null
        return null; // or an appropriate value
    }
	}
}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-09-21 15:07:35.775
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-09-21 15:07:35.777
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-21 15:07:37.681
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.xyram.daydrop.serviceimpl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import javax.transaction.Transactional;

import org.apache.commons.collections4.map.HashedMap;
import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.server.ResponseStatusException;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.xyram.daydrop.admin.model.CurrentUser;
import com.xyram.daydrop.basemodel.Base64Wrapper;
import com.xyram.daydrop.basemodel.MerchantTransactionIdGenerator;
import com.xyram.daydrop.basemodel.PhonepeSerializer;
import com.xyram.daydrop.dao.ApartmentDao;
import com.xyram.daydrop.dao.CustomerDetailsDao;
import com.xyram.daydrop.dao.CustomerOrderDao;
import com.xyram.daydrop.dao.CustomerOrderReplicaDoa;
import com.xyram.daydrop.dao.SheduleDao;
import com.xyram.daydrop.enumtypes.UserStatus;
import com.xyram.daydrop.model.Apartments;
import com.xyram.daydrop.model.CustomerOrder;
import com.xyram.daydrop.model.CustomerOrderReplica;
import com.xyram.daydrop.model.Customers;
import com.xyram.daydrop.model.Schedule;
import com.xyram.daydrop.modelMapper.PaymentInstrument;
import com.xyram.daydrop.modelMapper.PhonePePayModel;
import com.xyram.daydrop.request.CustomerOrderReplicaRequest;
import com.xyram.daydrop.response.RazorPayRequest;
import com.xyram.daydrop.service.CustomerOrderPriceService;
import com.xyram.daydrop.service.CustomerOrderReplicaService;
import com.xyram.daydrop.util.HashEncoder;
import com.xyram.daydrop.util.RazorPay;
import com.xyram.daydrop.service.ConsumerService;

@Transactional
@Service
public class CustomerOrderReplicaServiceImpl implements CustomerOrderReplicaService {

	@Autowired
	CustomerOrderReplicaDoa customerOrderReplicaDoa;

	@Autowired
	ApartmentDao apartmentDao;

	@Autowired
	SheduleDao scheduleDao;

	@Autowired
	CustomerDetailsDao customerDetailsDao;

	@Autowired
	ConsumerService consumerService;

	@Autowired
	CurrentUser currentUser;

	@Autowired
	PhonepeServiceImpl phonepeServiceImpl;

	@Value("${merchant_id}")
	private String merchantId;

	@Value("${salt_key}")
	private String saltKey;

	@Value("${salt_index}")
	private String saltIndex;

	@Override
	public Map createCustomerOrderReplicaService(CustomerOrderReplicaRequest customerOrderReplicaRequest,
			String contactNumber, Integer aparmentId)

	{

		Map response = new HashedMap<>();

		response.put("message", "success");
		CustomerOrderReplica customerOrderReplica = null;

		if (customerOrderReplicaRequest.getCartId() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "cartId is mandatory ");
		}
		long razorPayCount = 0;
		if (customerOrderReplicaRequest.getOrderId() != null) {

			razorPayCount = customerOrderReplicaDoa.getRazorPayExistByCartId(customerOrderReplicaRequest.getOrderId());
		}

		if (customerOrderReplicaRequest.getCustomerDetails() == null) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Order Details  is mandatory ");
		}

		customerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(customerOrderReplicaRequest.getCartId(),
				contactNumber);

		if (customerOrderReplica != null) {
			customerOrderReplica.setCartId(customerOrderReplica.getCartId());

			if (customerOrderReplica.isOrdered()) {
				throw new ResponseStatusException(HttpStatus.CONFLICT, "Your Order is Placed With cart Details");
			}

//			if (razorPayCount >= 1 && !(customerOrderReplica.getRazorPayOrderId() != null
//					&& customerOrderReplica.getRazorPayOrderId().equals(customerOrderReplicaRequest.getOrderId()))) {
//				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
//			}

			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);

			customerOrderReplica.setAttempts(customerOrderReplica.getAttempts() + 1);
			customerOrderReplica.setUpdatedTime(new Date());

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		} else {

			customerOrderReplica = new CustomerOrderReplica();
			customerOrderReplica.setContactNumber(contactNumber);
			customerOrderReplica.setApartmentId(aparmentId);
			customerOrderReplica.setCartId(customerOrderReplicaRequest.getCartId());
			customerOrderReplica.setStatusType(customerOrderReplicaRequest.getStatusType());

			if (razorPayCount > 0) {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Razor Pay Id Are already Exist ");
			}

			customerOrderReplica.setRazorPayOrderId(customerOrderReplicaRequest.getOrderId());

			Schedule schedule = scheduleDao.getlatestScheduleCustomers();

			if (schedule != null) {

				try {
					customerOrderReplica.setSchedule(schedule.getsId() != null ? schedule.getsId().toString() : null);
				} catch (Exception e) {
					e.printStackTrace();
				}
			} else {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
						"Sorry We Are Not Accepting Any Order Right now");

			}

			try {

				JSONObject obj = new JSONObject(customerOrderReplicaRequest.getCustomerDetails());

				customerOrderReplica.setCustomerOrderDetails(obj != null ? obj.toString() : null);

				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;

			} catch (Exception e) {
				customerOrderReplica.setCustomerOrderDetails(customerOrderReplicaRequest.getCustomerDetails() != null
						? customerOrderReplicaRequest.getCustomerDetails().toString()
						: null);
				customerOrderReplicaDoa.updateCustomer(customerOrderReplica);
				return response;
			}

		}

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicas(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String schedule = null;

		Map filter = request.containsKey("filters") ? (Map) request.get("filters") : null;
		if (filter != null) {
			statusType = filter.containsKey("statusType") ? ((String) filter.get("statusType")).toLowerCase() : null;
			searchQuery = filter.containsKey("searchQuery") ? ((String) filter.get("searchQuery")).toLowerCase() : null;
			schedule = filter.containsKey("schedule") ? (String.valueOf(filter.get("schedule"))) : null;

		}

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplica(searchQuery, statusType, schedule);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");

				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setStreetName(
						customers.get("streetName") != null ? (String) customers.get("streetName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public List<CustomerOrderReplica> getAllCustomerOrderReplicasBySchedule(Map<String, Object> request) {

		String statusType = null;
		String searchQuery = null;

		String scheduleId = null;

		Schedule schedule = scheduleDao.getlatestScheduleCustomers();

		if (schedule != null) {

			try {
				scheduleId = schedule.getsId() != null ? schedule.getsId().toString() : null;
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

		statusType = request.containsKey("statusType") ? ((String) request.get("statusType")).toLowerCase() : "Success";

		List<CustomerOrderReplica> CustomerOrderReplica = customerOrderReplicaDoa
				.getAllcustomerOrderReplicaBySchdeule(statusType, scheduleId);

		ObjectMapper objectMapper = new ObjectMapper();
		CustomerOrderReplica.forEach(customerOrderReplica -> {
			try {

				// convert JSON string to Map
				Map<String, Object> customerOrderReplicaMap = objectMapper
						.readValue(customerOrderReplica.getCustomerOrderDetails(), Map.class);

				Object customerOrder = customerOrderReplicaMap.get("customerOrder");
				Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

				Object quanityList = items.get("quantity");
				Map customers = customerDetailsDao.getByContactNumberAndApartment(
						customerOrderReplica.getContactNumber(), customerOrderReplica.getApartmentId());

				System.out.println("customers" + customers.get("customerName"));

				// Apartments apartments =
				// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
				customerOrderReplica.setApartmentName(
						customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

				customerOrderReplica.setCustomerDetails(customers);

				customerOrderReplica.setCustomerOrder(customerOrder);
				customerOrderReplica.setQuatityList(quanityList);

			} catch (Exception e) {
				e.printStackTrace();
			}

		});

		return CustomerOrderReplica;

	}

	@Override
	public CustomerOrderReplica getCustomerOrderReplicaByCartId(String cartId) {

		CustomerOrderReplica CustomerOrderReplica = customerOrderReplicaDoa.getCustomerOrderByCartId(cartId,
				currentUser.getContactNumber());

		ObjectMapper objectMapper = new ObjectMapper();
		try {

			// convert JSON string to Map
			Map<String, Object> customerOrderReplicaMap = objectMapper
					.readValue(CustomerOrderReplica.getCustomerOrderDetails(), Map.class);

			Object customerOrder = customerOrderReplicaMap.get("customerOrder");
			Map<String, Object> items = (Map<String, Object>) customerOrderReplicaMap.get("items");

			Object quanityList = items.get("quantity");
			Map customers = customerDetailsDao.getByContactNumberAndApartment(CustomerOrderReplica.getContactNumber(),
					CustomerOrderReplica.getApartmentId());

			System.out.println("customers" + customers.get("customerName"));

			// Apartments apartments =
			// apartmentDao.getApartmentById(customerOrderReplica.getApartmentId());
			CustomerOrderReplica.setApartmentName(
					customers.get("apartmentName") != null ? (String) customers.get("apartmentName") : null);

			CustomerOrderReplica.setCustomerDetails(customers);

			CustomerOrderReplica.setCustomerOrder(customerOrder);
			CustomerOrderReplica.setQuatityList(quanityList);

		} catch (Exception e) {
			e.printStackTrace();
		}

		return CustomerOrderReplica;

	}

	@Override
	public Map createCustomerOrderReplica(CustomerOrderReplicaRequest customerOrderReplicaRequest, String contactNumber,
			Integer aparmentId) {

		if (customerOrderReplicaRequest.getRazorPayRequest() != null) {

//			Map razorPay = consumerService.createRazorPayOrder(customerOrderReplicaRequest.getRazorPayRequest());
//			customerOrderReplicaRequest.setOrderId(razorPay.get("order") != null ? (String)((RazorPay) razorPay.get("order")).getId() : null);	
//	
//			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);
//
//			razorPay.put("cartId", customerOrderReplicaRequest.getCartId());

			Map customerOrderReplicaMap = new HashMap<>();

			Map orderId = new HashMap<>();
			String transactionId = getMerchantTransactionId();
			orderId.put("id", transactionId);

			customerOrderReplicaMap.put("order", orderId);

			customerOrderReplicaRequest.setOrderId(transactionId);
			createCustomerOrderReplicaService(customerOrderReplicaRequest, contactNumber, aparmentId);

			customerOrderReplicaMap.put("cartId", customerOrderReplicaRequest.getCartId());

			try {
				customerOrderReplicaMap.put("phonePeResponse",
						phonepeServiceImpl.initiatePhonepePayment(transactionId,
								Integer.valueOf(customerOrderReplicaRequest.getRazorPayRequest().getAmount()),
								contactNumber, customerOrderReplicaRequest.getRedirectUrl(), customerOrderReplicaRequest.getCallBackUrl()));

			} catch (Exception e) {
				e.printStackTrace();
				customerOrderReplicaMap.put("phonePeResponse", new HashedMap<>());
			}

			return customerOrderReplicaMap;

		} else {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
					"paymentDetails transcation Details are mandatory");
		}

	}

	private static String getMerchantTransactionId() {

		return "OD_" + MerchantTransactionIdGenerator.getRandomString();
	}


	@Override
	public List<CustomerOrderReplica> getCustomerOrderByMoblieNo(String contactNumber,Integer aid) {
		
		Schedule latestschedule = customerOrderReplicaDoa.getlatestschedule();
		
		if (latestschedule != null && latestschedule.getCreationTimestamp()!=null) {
			
	        if (latestschedule.getStatus().equals(UserStatus.ACTIVE)) {
	        	
	        	Customers customer = customerDetailsDao.getByContactNoAndApartment(contactNumber, aid);
	        	if (customer != null) { // Ensure the customer exists
	        		List<CustomerOrder> customerOrderList = customerOrderReplicaDoa.getListCustomerOrderByCustomerId(customer.getCtid());
	        		
	                double totalOrderAmount = 0.0;
	       
                if (customerOrderList != null && !customerOrderList.isEmpty() && customerOrderList.add(customerOrder). {
                    for (CustomerOrder customerOrder : customerOrderList) {
                        Double orderAmount = customerOrder.getAmount();
                        if (orderAmount != null) {
                            totalOrderAmount += orderAmount;
                            if(totalOrderAmount>200) {
                            	totalOrderAmount+customerOrder
                            }
                        }
                    }
                    System.out.println("Total Order Amount: " + totalOrderAmount);
                    List<CustomerOrderReplica> customerOrderReplicas = new ArrayList<>();
                    return customerOrderReplicas;
                } else {
                    return Collections.emptyList(); // or return null or an appropriate value
                }
            } else {
              
                return null; // or an appropriate value
            }
        } else {
            // Handle the case when the latest schedule is not active
            return null; // or an appropriate value
        }
    } else {
        // Handle the case when there is no latest schedule or its creation timestamp is null
        return null; // or an appropriate value
    }
	}
}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2168)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3003)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3013)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2243)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3037)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
